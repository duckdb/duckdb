# name: test/sql/cte/test_recursive_cte_recurring.test
# description: Recursive CTEs with access to the UNION table
# group: [cte]

statement ok
PRAGMA enable_verification;

query II
WITH RECURSIVE deduction AS (
	-- P, (not P or Q), (not Q)
	SELECT clause FROM (VALUES ([1]), ([-1, 2]), ([-2])) AS kb(clause)
		UNION
	SELECT
	-- Create new clause by merging and removing resolved literals
	list_distinct(
		list_concat(
			list_filter(p_new.clause, lambda x: x <> lit),
				list_filter(p_old.clause, lambda x: x <> -lit)
			)
		) AS new_clause
	FROM deduction p_new -- Newly added clauses
	CROSS JOIN UNNEST(p_new.clause) AS t_lit(lit)
	-- We join with the UNION table to find the negation of that literal
	JOIN recurring.deduction p_old ON list_contains(p_old.clause, -lit)
	WHERE
		-- A resolution step is only useful if it doesn't create a tautology (like [P, not P]).
		NOT EXISTS (
			SELECT 1 FROM (
				-- Check all literals in the potential new clause
				SELECT UNNEST(list_concat(
					list_filter(p_new.clause, lambda x: x <> lit),
						list_filter(p_old.clause, lambda x: x <> -lit)
				)) AS l
			)
			GROUP BY abs(l)
			HAVING count(distinct l) > 1 -- Found both X and -X
		)
)
-- If we deduced an empty clause [], it means the input was contradictory.
SELECT CASE WHEN EXISTS (SELECT 1 FROM deduction WHERE len(clause) = 0)
            THEN 'CONTRADICTION FOUND'
            ELSE 'LOGICALLY CONSISTENT'
       END AS result,
       (SELECT list(clause ORDER BY clause) FROM deduction) AS all_deduced_clauses;
----
CONTRADICTION FOUND	[[], [-2], [-1], [-1, 2], [1], [2]]
