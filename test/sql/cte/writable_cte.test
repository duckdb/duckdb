# name: test/sql/cte/writable_cte.test
# description: Test writable CTEs (data-modifying statements in CTEs)
# group: [cte]

# Note: Verification is not enabled because StatementNode wraps DML statements
# (INSERT/UPDATE/DELETE) which don't have serialization support yet.
# This can be added in a follow-up PR that implements SQLStatement serialization.

# =============================================================================
# Basic INSERT with RETURNING in CTE
# =============================================================================

statement ok
CREATE TABLE t1 (id INTEGER, val TEXT);

query II
WITH inserted AS (INSERT INTO t1 VALUES (1, 'a'), (2, 'b') RETURNING *)
SELECT * FROM inserted ORDER BY id;
----
1	a
2	b

query II
SELECT * FROM t1 ORDER BY id;
----
1	a
2	b

# =============================================================================
# Basic UPDATE with RETURNING in CTE
# =============================================================================

query II
WITH updated AS (UPDATE t1 SET val = 'updated_' || val WHERE id = 1 RETURNING *)
SELECT * FROM updated;
----
1	updated_a

query II
SELECT * FROM t1 ORDER BY id;
----
1	updated_a
2	b

# =============================================================================
# Basic DELETE with RETURNING in CTE
# =============================================================================

query II
WITH deleted AS (DELETE FROM t1 WHERE id = 2 RETURNING *)
SELECT * FROM deleted;
----
2	b

query II
SELECT * FROM t1;
----
1	updated_a

# =============================================================================
# Chained DML CTEs (INSERT result feeds another INSERT)
# =============================================================================

statement ok
CREATE TABLE t2 (id INTEGER, val TEXT);

statement ok
CREATE TABLE t3 (id INTEGER, val TEXT);

query II
WITH ins1 AS (INSERT INTO t2 VALUES (10, 'x'), (20, 'y') RETURNING *),
     ins2 AS (INSERT INTO t3 SELECT * FROM ins1 RETURNING *)
SELECT * FROM ins2 ORDER BY id;
----
10	x
20	y

query II
SELECT * FROM t2 ORDER BY id;
----
10	x
20	y

query II
SELECT * FROM t3 ORDER BY id;
----
10	x
20	y

# =============================================================================
# Multiple references to DML CTE (should execute only once)
# =============================================================================

statement ok
TRUNCATE t2;

query IIII
WITH ins AS (INSERT INTO t2 VALUES (100, 'test') RETURNING *)
SELECT a.id, a.val, b.id, b.val FROM ins a, ins b;
----
100	test	100	test

# Verify only one row was inserted (DML executed once)
query II
SELECT * FROM t2;
----
100	test

# =============================================================================
# Unreferenced DML CTE (should still execute - PostgreSQL behavior)
# =============================================================================

statement ok
TRUNCATE t2;

# The DML CTE is defined but not referenced in the main query
query I
WITH ins AS (INSERT INTO t2 VALUES (200, 'unreferenced') RETURNING id)
SELECT 1;
----
1

# Verify the insert still happened
query II
SELECT * FROM t2;
----
200	unreferenced

# =============================================================================
# Unreferenced INSERT ... ON CONFLICT CTE (MERGE INTO - should still execute)
# =============================================================================

statement ok
CREATE TABLE t_conflict (id INTEGER PRIMARY KEY, val TEXT);

statement ok
INSERT INTO t_conflict VALUES (1, 'original');

# Unreferenced CTE with INSERT ... ON CONFLICT DO UPDATE (uses LOGICAL_MERGE_INTO)
query I
WITH upsert AS (
    INSERT INTO t_conflict VALUES (1, 'conflict'), (2, 'new')
    ON CONFLICT (id) DO UPDATE SET val = 'updated'
    RETURNING id
)
SELECT 42;
----
42

# Verify the upsert still happened even though the CTE was not referenced
query IT
SELECT * FROM t_conflict ORDER BY id;
----
1	updated
2	new

# Test unreferenced INSERT ... ON CONFLICT DO NOTHING
statement ok
TRUNCATE t_conflict;

statement ok
INSERT INTO t_conflict VALUES (1, 'keep');

query I
WITH upsert AS (
    INSERT INTO t_conflict VALUES (1, 'ignored'), (3, 'inserted')
    ON CONFLICT (id) DO NOTHING
    RETURNING id
)
SELECT 99;
----
99

# Verify the operation executed
query IT
SELECT * FROM t_conflict ORDER BY id;
----
1	keep
3	inserted

statement ok
DROP TABLE t_conflict;

# =============================================================================
# Error cases
# =============================================================================

# Error: Recursive CTE with DML
statement error
WITH RECURSIVE cte AS (INSERT INTO t1 VALUES (999, 'error') RETURNING *)
SELECT * FROM cte;
----
Recursive CTEs cannot contain data-modifying statements

# Error: DML without RETURNING clause
statement error
WITH cte AS (INSERT INTO t1 VALUES (999, 'error'))
SELECT * FROM cte;
----
INSERT in a CTE must have a RETURNING clause

statement error
WITH cte AS (UPDATE t1 SET val = 'error')
SELECT * FROM cte;
----
UPDATE in a CTE must have a RETURNING clause

statement error
WITH cte AS (DELETE FROM t1 WHERE id = 999)
SELECT * FROM cte;
----
DELETE in a CTE must have a RETURNING clause

# Error: Cannot create view with writable CTE
statement error
CREATE VIEW v AS WITH cte AS (INSERT INTO t1 VALUES (999, 'view_test') RETURNING *) SELECT * FROM cte;
----
Views cannot contain data-modifying statements in CTEs

statement error
CREATE VIEW v AS WITH cte AS (UPDATE t1 SET val = 'x' RETURNING *) SELECT * FROM cte;
----
Views cannot contain data-modifying statements in CTEs

statement error
CREATE VIEW v AS WITH cte AS (DELETE FROM t1 RETURNING *) SELECT * FROM cte;
----
Views cannot contain data-modifying statements in CTEs

# =============================================================================
# Complex queries with DML CTEs
# =============================================================================

statement ok
CREATE TABLE audit_log (action TEXT, old_id INTEGER, old_val TEXT);

# Use DELETE RETURNING to feed an INSERT
statement ok
INSERT INTO t1 VALUES (5, 'to_delete');

query II
WITH deleted AS (DELETE FROM t1 WHERE id = 5 RETURNING *)
INSERT INTO audit_log SELECT 'deleted', id, val FROM deleted RETURNING action, old_id;
----
deleted	5

query III
SELECT * FROM audit_log;
----
deleted	5	to_delete

# Verify the row was deleted from t1
query II
SELECT * FROM t1;
----
1	updated_a

# =============================================================================
# RETURNING specific columns (not just *)
# =============================================================================

statement ok
CREATE TABLE t4 (id INTEGER, name TEXT, value DECIMAL(10,2), created_at DATE);

query I
WITH ins AS (INSERT INTO t4 VALUES (1, 'item1', 99.99, '2024-01-15') RETURNING id)
SELECT * FROM ins;
----
1

query T
WITH ins AS (INSERT INTO t4 VALUES (2, 'item2', 149.99, '2024-01-16') RETURNING name)
SELECT * FROM ins;
----
item2

query II
WITH ins AS (INSERT INTO t4 VALUES (3, 'item3', 199.99, '2024-01-17') RETURNING id, name)
SELECT * FROM ins;
----
3	item3

# =============================================================================
# RETURNING with expressions
# =============================================================================

query I
WITH ins AS (INSERT INTO t4 VALUES (4, 'item4', 50.00, '2024-01-18') RETURNING id * 10 AS scaled_id)
SELECT * FROM ins;
----
40

query T
WITH ins AS (INSERT INTO t4 VALUES (5, 'item5', 75.00, '2024-01-19') RETURNING 'inserted: ' || name AS msg)
SELECT * FROM ins;
----
inserted: item5

query R
WITH ins AS (INSERT INTO t4 VALUES (6, 'item6', 100.00, '2024-01-20') RETURNING value * 1.1 AS with_tax)
SELECT * FROM ins;
----
110.00

# =============================================================================
# UPDATE with FROM clause (DML with JOINs)
# =============================================================================

statement ok
CREATE TABLE prices (item_id INTEGER, new_price DECIMAL(10,2));

statement ok
INSERT INTO prices VALUES (1, 89.99), (2, 129.99), (3, 179.99);

query IR
WITH upd AS (
    UPDATE t4 SET value = prices.new_price
    FROM prices
    WHERE t4.id = prices.item_id
    RETURNING t4.id, t4.value
)
SELECT * FROM upd ORDER BY id;
----
1	89.99
2	129.99
3	179.99

# Verify the update happened
query IR
SELECT id, value FROM t4 WHERE id <= 3 ORDER BY id;
----
1	89.99
2	129.99
3	179.99

# =============================================================================
# DELETE with complex WHERE clause using subquery
# =============================================================================

statement ok
CREATE TABLE to_delete_ids (id INTEGER);

statement ok
INSERT INTO to_delete_ids VALUES (4), (5);

query IT
WITH del AS (
    DELETE FROM t4
    WHERE id IN (SELECT id FROM to_delete_ids)
    RETURNING id, name
)
SELECT * FROM del ORDER BY id;
----
4	item4
5	item5

# Verify deletions
query I
SELECT COUNT(*) FROM t4 WHERE id IN (4, 5);
----
0

# =============================================================================
# Multiple DML CTEs in sequence
# =============================================================================

statement ok
CREATE TABLE inventory (product_id INTEGER, quantity INTEGER);

statement ok
CREATE TABLE orders (order_id INTEGER, product_id INTEGER, qty INTEGER);

statement ok
CREATE TABLE shipments (shipment_id INTEGER, order_id INTEGER);

statement ok
INSERT INTO inventory VALUES (100, 50), (200, 30);

# Chain: INSERT order -> UPDATE inventory -> INSERT shipment
query III
WITH new_order AS (
    INSERT INTO orders VALUES (1, 100, 5) RETURNING *
),
inv_update AS (
    UPDATE inventory SET quantity = quantity - (SELECT qty FROM new_order)
    WHERE product_id = (SELECT product_id FROM new_order)
    RETURNING product_id, quantity
),
new_shipment AS (
    INSERT INTO shipments SELECT 1000, order_id FROM new_order RETURNING *
)
SELECT
    (SELECT order_id FROM new_order),
    (SELECT quantity FROM inv_update),
    (SELECT shipment_id FROM new_shipment);
----
1	45	1000

# Verify all changes
query III
SELECT * FROM orders;
----
1	100	5

query II
SELECT * FROM inventory WHERE product_id = 100;
----
100	45

query II
SELECT * FROM shipments;
----
1000	1

# =============================================================================
# DML CTE with aggregation on results
# =============================================================================

statement ok
TRUNCATE orders;

query IR
WITH ins AS (
    INSERT INTO orders VALUES (10, 100, 2), (11, 100, 3), (12, 200, 5) RETURNING *
)
SELECT product_id, SUM(qty) as total_qty FROM ins GROUP BY product_id ORDER BY product_id;
----
100	5
200	5

# =============================================================================
# DML CTE with window functions
# =============================================================================

query III
WITH ins AS (
    INSERT INTO orders VALUES (20, 100, 1), (21, 100, 2), (22, 200, 3) RETURNING *
)
SELECT order_id, qty, SUM(qty) OVER (PARTITION BY product_id ORDER BY order_id) as running_total
FROM ins ORDER BY order_id;
----
20	1	1
21	2	3
22	3	3

# =============================================================================
# INSERT ... SELECT from another DML CTE
# =============================================================================

statement ok
CREATE TABLE archive (archived_id INTEGER, archived_name TEXT, archived_at TIMESTAMP);

query II
WITH to_archive AS (
    DELETE FROM t4 WHERE id = 6 RETURNING id, name
),
archived AS (
    INSERT INTO archive SELECT id, name, CURRENT_TIMESTAMP FROM to_archive RETURNING archived_id, archived_name
)
SELECT * FROM archived;
----
6	item6

query I
SELECT COUNT(*) FROM archive WHERE archived_id = 6;
----
1

# =============================================================================
# Nested subqueries within DML CTE
# =============================================================================

statement ok
TRUNCATE t2;

query II
WITH ins AS (
    INSERT INTO t2
    SELECT id, name FROM (
        SELECT id, name FROM t4 WHERE value > 100 ORDER BY id LIMIT 2
    ) sub
    RETURNING *
)
SELECT * FROM ins ORDER BY id;
----
2	item2
3	item3

# =============================================================================
# DML CTE with CASE expression in RETURNING
# =============================================================================

statement ok
CREATE TABLE status_log (id INTEGER, status TEXT);

statement ok
INSERT INTO status_log VALUES (1, 'active'), (2, 'pending'), (3, 'inactive');

query IT
WITH upd AS (
    UPDATE status_log SET status = 'processed' WHERE status = 'pending'
    RETURNING id, CASE WHEN id % 2 = 0 THEN 'even' ELSE 'odd' END as id_type
)
SELECT * FROM upd;
----
2	even

# =============================================================================
# Nested CTEs inside DML CTE (WITH before DML - standard PostgreSQL syntax)
# =============================================================================

statement ok
CREATE TABLE t_nested_cte (id INTEGER);

# This is the standard PostgreSQL syntax: WITH clause before the DML statement
query I
WITH dml_cte AS (
  WITH inner_cte AS (SELECT 1 AS id)
  INSERT INTO t_nested_cte
  SELECT id FROM inner_cte
  RETURNING id
)
SELECT * FROM dml_cte;
----
1

# Verify data was inserted
query I
SELECT * FROM t_nested_cte;
----
1

# Test UPDATE with nested CTE (WITH before UPDATE)
statement ok
TRUNCATE t_nested_cte;

statement ok
INSERT INTO t_nested_cte VALUES (1);

query I
WITH dml_cte AS (
  WITH multiplier AS (SELECT 10 AS mult)
  UPDATE t_nested_cte SET id = id * (SELECT mult FROM multiplier)
  RETURNING id
)
SELECT * FROM dml_cte;
----
10

# Test DELETE with nested CTE (WITH before DELETE)
query I
WITH dml_cte AS (
  WITH threshold AS (SELECT 5 AS val)
  DELETE FROM t_nested_cte WHERE id > (SELECT val FROM threshold)
  RETURNING id
)
SELECT * FROM dml_cte;
----
10

# Verify table is now empty
query I
SELECT COUNT(*) FROM t_nested_cte;
----
0

statement ok
DROP TABLE t_nested_cte;

# =============================================================================
# Clean up
# =============================================================================

statement ok
DROP TABLE t1;

statement ok
DROP TABLE t2;

statement ok
DROP TABLE t3;

statement ok
DROP TABLE t4;

statement ok
DROP TABLE audit_log;

statement ok
DROP TABLE prices;

statement ok
DROP TABLE to_delete_ids;

statement ok
DROP TABLE inventory;

statement ok
DROP TABLE orders;

statement ok
DROP TABLE shipments;

statement ok
DROP TABLE archive;

statement ok
DROP TABLE status_log;
