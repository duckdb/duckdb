# name: test/sql/storage/concurrent_wal/concurrent_checkpoint_abort.test
# description: Test recovery when doing concurrent appends with a failing checkpoint
# group: [concurrent_wal]

foreach wal_abort_mode before_wal_finish before_header

statement ok
ATTACH '__TEST_DIR__/concurrent_abort_${wal_abort_mode}.db' AS main_db

statement ok
SET checkpoint_threshold='1TB'

statement ok
PRAGMA disable_checkpoint_on_shutdown

statement ok
PRAGMA debug_checkpoint_abort='${wal_abort_mode}'

statement ok
CREATE TABLE main_db.integers(i INTEGER)

statement ok
ATTACH '__TEST_DIR__/concurrent_other_db_${wal_abort_mode}.db' AS other_db

statement ok
CREATE TABLE other_db.ranges(begin_range INT, end_range INT)

concurrentloop threadid 0 20

loop x 0 10

# we write to two databases - the main database (that is being checkpointed) and a back-up database "concurrent_other_db"
# we write to the database "concurrent_other_db" after a commit to the main database has succeeded
# so anything that ends up there has to also be in the main database
# otherwise we have lost data
onlyif threadid<>10
statement maybe
INSERT INTO main_db.integers SELECT * FROM range(${x} * 2000 + ${threadid} * 100, ${x} * 2000 + (${threadid} + 1) * 100);
----
database has been invalidated because of a previous fatal error

onlyif threadid<>10
statement maybe
INSERT INTO other_db.ranges VALUES (${x} * 2000 + ${threadid} * 100, ${x} * 2000 + (${threadid} + 1) * 100);
----
database has been invalidated because of a previous fatal error

endloop

onlyif threadid=10
statement error
CHECKPOINT main_db
----
Checkpoint aborted

endloop

restart

statement ok
ATTACH '__TEST_DIR__/concurrent_abort_${wal_abort_mode}.db' AS main_db

statement ok
ATTACH '__TEST_DIR__/concurrent_other_db_${wal_abort_mode}.db' AS other_db

#
query I
SELECT CASE WHEN max_i + 1 >= max_end THEN NULL ELSE CONCAT('Found min ', min_i, ', max ', max_i, ' which does not fall within range ', begin_range, ' - ', max_end, ' (all ranges: ', (SELECT LIST(r ORDER BY begin_range) FROM other_db.ranges r)::VARCHAR, ')') END
FROM (SELECT MIN(i) min_i, MAX(i) max_i FROM main_db.integers), (SELECT MIN(begin_range) begin_range, MAX(end_range) max_end FROM other_db.ranges)
----
NULL

restart

endloop
