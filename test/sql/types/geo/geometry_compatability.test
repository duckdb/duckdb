# name: test/sql/types/geo/geometry_compatability.test
# group: [geo]

# This test opens a database created with DuckDB v1.4.3 using the spatial extension, which had a different internal
# geometry representation than what we use in core. Once geometry was added to core in v1.5.0 we made the storage layer
# automatically convert between old and new (and vice-versa) so that there is no percievable difference to both users
# and the execution engine. This test ensures that we can deal with the old geometry format without any issues.

# Make a copy of the testing database so we can make modifications
statement ok
copy (select content from read_blob('{DATA_DIR}/storage/spatial_geo.db')) to '__TEST_DIR__/geo.db' (format BLOB);

statement ok
ATTACH '__TEST_DIR__/geo.db'

statement ok
USE geo;

# Check that this is indeed an old format database, and that the storage version is correct.
query I
select tags.storage_version from duckdb_databases() where database_name = 'geo';
----
v1.0.0+

# Check that we can read (and cast to VARCHAR) the old geometries correctly.
query II
select * from t_all_types order by id;
----
1	POINT (1 2)
2	POINT Z (1 2 3)
3	POINT M (1 2 4)
4	POINT ZM (1 2 3 4)
5	LINESTRING (1 2, 3 4)
6	LINESTRING Z (1 2 3, 4 5 6)
7	LINESTRING M (1 2 4, 4 5 7)
8	LINESTRING ZM (1 2 3 4, 4 5 6 7)
9	POLYGON ((1 2, 3 4, 5 6, 1 2))
10	POLYGON Z ((1 2 3, 3 4 5, 5 6 7, 1 2 3))
11	POLYGON M ((1 2 4, 3 4 6, 5 6 8, 1 2 4))
12	POLYGON ZM ((1 2 3 4, 3 4 5 6, 5 6 7 8, 1 2 3 4))
13	MULTIPOINT (1 2, 3 4, 5 6)
14	MULTIPOINT Z (1 2 3, 3 4 5, 5 6 7)
15	MULTIPOINT M (1 2 4, 3 4 6, 5 6 8)
16	MULTIPOINT ZM (1 2 3 4, 3 4 5 6, 5 6 7 8)
17	MULTILINESTRING ((1 2, 3 4), (5 6, 7 8))
18	MULTILINESTRING Z ((1 2 3, 3 4 5), (5 6 7, 7 8 9))
19	MULTILINESTRING M ((1 2 4, 3 4 6), (5 6 8, 7 8 10))
20	MULTILINESTRING ZM ((1 2 3 4, 3 4 5 6), (5 6 7 8, 7 8 9 10))
21	MULTIPOLYGON (((1 2, 3 4, 5 6, 1 2)), ((7 8, 9 10, 11 12, 7 8)))
22	MULTIPOLYGON Z (((1 2 3, 3 4 5, 5 6 7, 1 2 3)), ((7 8 9, 9 10 11, 11 12 13, 7 8 9)))
23	MULTIPOLYGON M (((1 2 4, 3 4 6, 5 6 8, 1 2 4)), ((7 8 10, 9 10 12, 11 12 14, 7 8 10)))
24	MULTIPOLYGON ZM (((1 2 3 4, 3 4 5 6, 5 6 7 8, 1 2 3 4)), ((7 8 9 10, 9 10 11 12, 11 12 13 14, 7 8 9 10)))
25	GEOMETRYCOLLECTION (POINT (1 2), LINESTRING (3 4, 5 6))
26	GEOMETRYCOLLECTION Z (POINT Z (1 2 3), LINESTRING Z (3 4 5, 5 6 7))
27	GEOMETRYCOLLECTION M (POINT M (1 2 4), LINESTRING M (3 4 6, 5 6 8))
28	GEOMETRYCOLLECTION ZM (POINT ZM (1 2 3 4), LINESTRING ZM (3 4 5 6, 5 6 7 8))

# Stats should be "Unknown" as the old format does not have geometry stats, but string stats (that we ignore)
query I
select stats(g) from t_all_types limit 1
----
[Extent: [X: [-inf, inf], Y: [-inf, inf], Z: [-inf, inf], M: [-inf, inf]], Types: [unknown, point, linestring, polygon, multipoint, multilinestring, multipolygon, geometrycollection, unknown_z, point_z, linestring_z, polygon_z, multipoint_z, multilinestring_z, multipolygon_z, geometrycollection_z, unknown_m, point_m, linestring_m, polygon_m, multipoint_m, multilinestring_m, multipolygon_m, geometrycollection_m, unknown_zm, point_zm, linestring_zm, polygon_zm, multipoint_zm, multilinestring_zm, multipolygon_zm, geometrycollection_zm], Flags: [Has Empty Geom: true, Has No Empty Geom: true, Has Empty Part: true, Has No Empty Part: true]][Has Null: false, Has No Null: true][Approx Unique: 28]

# Additionally, there is an ART index on the geometry, so make sure we can use it and get the same results as a sequential scan.
# (ART indexing geometries make little sense, but nevertheless its important that new geometries are converted to the same byte representation
# as the old ones when scanning/inserting).

# Check that we still get the index scan
query II
EXPLAIN ANALYZE SELECT id from t_all_types where g = 'MULTIPOINT Z (1 2 3, 3 4 5, 5 6 7)';
----
analyzed_plan	<REGEX>:.*Type: Index Scan.*

# Check that we get the correct result when doing ART lookups on the geometry column.
query I
SELECT id from t_all_types where g = 'MULTIPOINT Z (1 2 3, 3 4 5, 5 6 7)';
----
14

# Also constraint violations
statement error
INSERT INTO t_all_types VALUES (29, 'POINT (1 2)');
----
TransactionContext Error: Failed to commit: PRIMARY KEY or UNIQUE constraint violation: duplicate key "POINT (1 2)"

# But we can do other inserts
statement ok
INSERT INTO t_all_types VALUES (29, 'POINT (2 3)');

query II
select id, g from t_all_types where id = 29;
----
29	POINT (2 3)

statement ok
CHECKPOINT;

# Lets see if we attach with a newer storage version
statement ok
USE memory

statement ok
DETACH geo;

statement ok
ATTACH '__TEST_DIR__/geo.db' (STORAGE_VERSION 'v1.5.0');

statement ok
USE geo;

query I
select tags.storage_version from duckdb_databases() where database_name = 'geo';
----
v1.5.0+

query I
select stats(g) from t_all_types limit 1
----
[Extent: [X: [-inf, inf], Y: [-inf, inf], Z: [-inf, inf], M: [-inf, inf]], Types: [unknown, point, linestring, polygon, multipoint, multilinestring, multipolygon, geometrycollection, unknown_z, point_z, linestring_z, polygon_z, multipoint_z, multilinestring_z, multipolygon_z, geometrycollection_z, unknown_m, point_m, linestring_m, polygon_m, multipoint_m, multilinestring_m, multipolygon_m, geometrycollection_m, unknown_zm, point_zm, linestring_zm, polygon_zm, multipoint_zm, multilinestring_zm, multipolygon_zm, geometrycollection_zm], Flags: [Has Empty Geom: true, Has No Empty Geom: true, Has Empty Part: true, Has No Empty Part: true]][Has Null: false, Has No Null: true][Approx Unique: 29]

# We should still ensure the index converts properly, an detects the duplicate key
statement error
INSERT INTO t_all_types VALUES (29, 'POINT (1 2)');
----
TransactionContext Error: Failed to commit: PRIMARY KEY or UNIQUE constraint violation: duplicate key "POINT (1 2)"

# Now that we have a new storage version, once we checkpoint we will get a new geometry format written,
# and stats should be properly populated!

statement ok
INSERT INTO t_all_types VALUES (30, 'POINT (4 4)');

statement ok
checkpoint;

query I
select stats(g) from t_all_types limit 1
----
[Extent: [X: [1.000000, 11.000000], Y: [2.000000, 12.000000], Z: [3.000000, 13.000000], M: [4.000000, 14.000000]], Types: [point, linestring, polygon, multipoint, multilinestring, multipolygon, geometrycollection, point_z, linestring_z, polygon_z, multipoint_z, multilinestring_z, multipolygon_z, geometrycollection_z, point_m, linestring_m, polygon_m, multipoint_m, multilinestring_m, multipolygon_m, geometrycollection_m, point_zm, linestring_zm, polygon_zm, multipoint_zm, multilinestring_zm, multipolygon_zm, geometrycollection_zm], Flags: [Has Empty Geom: false, Has No Empty Geom: true, Has Empty Part: false, Has No Empty Part: true]][Has Null: false, Has No Null: true][Approx Unique: 30]
