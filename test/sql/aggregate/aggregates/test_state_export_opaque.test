# name: test/sql/aggregate/aggregates/test_state_export_opaque.test
# description: Test the state export functionality, in the legacy opaque AGGREGATE_STATE format (orginally taken from https://github.com/duckdb/duckdb/blob/02ec08120314f0bf6e2f4d0eaa36512c5c275b2d/test/sql/aggregate/aggregates/test_state_export.test
# group: [aggregates]

statement ok
create table dummy as select range % 10 g, range d from range(100);

# ungrouped aggr

query IIIIII nosort res0
SELECT count(*), count(d) FROM dummy;
----

query IIIIII nosort res0
SELECT finalize(count(*) EXPORT_STATE), finalize(count(d) EXPORT_STATE) FROM dummy;
----

# grouped aggr
query IIIIIII nosort res1
SELECT g, count(*), count(d) FROM dummy GROUP BY g ORDER BY g;
----

query IIIIIII nosort res1
SELECT g, finalize(count(*) EXPORT_STATE), finalize(count(d) EXPORT_STATE)  FROM dummy GROUP BY g ORDER BY g;
----

# we can persist this
statement ok
CREATE TABLE state AS SELECT g, count(*) EXPORT_STATE count_star_state, count(d) EXPORT_STATE count_state FROM dummy GROUP BY g ORDER BY g;

query IIIIIII nosort res1
SELECT g, finalize(count_star_state),finalize(count_state) FROM state ORDER BY g;
----

query II nosort res2
SELECT count(d) * 2 FROM dummy;
----

query II nosort res2
SELECT FINALIZE(COMBINE(count(d) EXPORT_STATE, count(d) EXPORT_STATE)) FROM dummy;
----


query II nosort res3
SELECT g, count(d) * 2 combined_count FROM dummy GROUP BY g ORDER BY g;
----

query II nosort res3
select g, finalize(combine(count(d) EXPORT_STATE, count_state)) combined_count from dummy join state using (g) group by g, count_state ORDER BY g;
----

# combine aggregate state in UNION
statement ok
CREATE TABLE state2 AS SELECT g, count(d) EXPORT_STATE count_state FROM dummy WHERE g < 5 GROUP BY g ORDER BY g;

query II rowsort res3
select g, finalize(count_state) * 2 combined_count from (select g, count(d) EXPORT_STATE count_state from dummy where g >= 5 GROUP BY g union all SELECT * FROM state2) ORDER BY g;
----

# combine aggregate states in JOINs with NULLs
query II rowsort res3
with groups as (select distinct g from dummy)
select g, FINALIZE(COMBINE(count_state, count_state2)) * 2 from groups left join state2 using(g) left join (select g, count(d) EXPORT_STATE count_state2 from dummy where g >= 5 GROUP BY g) using (g)
----

query IIII
with groups as (select distinct g from dummy)
select g, FINALIZE(count_state), FINALIZE(count_state2), FINALIZE(COMBINE(count_state, count_state2))  from groups left join state2 using(g) left join (select g, count(d) EXPORT_STATE count_state2 from dummy where g >= 3 GROUP BY g) using (g) order by g
----
0	10	NULL	10
1	10	NULL	10
2	10	NULL	10
3	10	10	20
4	10	10	20
5	NULL	10	10
6	NULL	10	10
7	NULL	10	10
8	NULL	10	10
9	NULL	10	10

# empty groups
query IIIIII nosort res4
SELECT count(*), count(d) FROM dummy WHERE FALSE;
----

query IIIIII nosort res4
SELECT finalize(count(*) EXPORT_STATE), finalize(count(d) EXPORT_STATE) FROM dummy WHERE FALSE;
----

# only null scanned
query IIIIII nosort res5
SELECT count(*), count(d) FROM (SELECT NULL::integer d);
----

query IIIIII nosort res5
SELECT finalize(count(*) EXPORT_STATE), finalize(count(d) EXPORT_STATE) FROM (SELECT NULL::integer d);
----

# only null scanned, but grouped
query IIIIII nosort res6
SELECT count(*), count(d) FROM (SELECT NULL::integer d, g FROM dummy);
----

query IIIIII nosort res6
SELECT finalize(count(*) EXPORT_STATE), finalize(count(d) EXPORT_STATE) FROM (SELECT NULL::integer d, g FROM dummy);
----

# more aggregates

query IIIIIII nosort res8
SELECT g, first(d), last(d), product(d), bit_xor(d), bool_and(d > 5) FROM dummy GROUP BY g ORDER BY g;
----

query IIIIIII nosort res8
SELECT g, FINALIZE(first(d) EXPORT_STATE), FINALIZE(last(d) EXPORT_STATE), FINALIZE(product(d) EXPORT_STATE), FINALIZE(bit_xor(d) EXPORT_STATE), FINALIZE(bool_and(d > 5) EXPORT_STATE) FROM dummy GROUP BY g ORDER BY g;
----

query II nosort res9
SELECT corr(d, d+1), covar_pop(d, d+1)FROM dummy;
----


query II nosort res9
SELECT FINALIZE(corr(d, d+1) EXPORT_STATE), FINALIZE(covar_pop(d, d+1) EXPORT_STATE) from dummy;
----


# you're holding it wrong:

statement error
SELECT list(d) EXPORT_STATE from dummy;
----

statement error
SELECT string_agg(d, ',') EXPORT_STATE from dummy;
----

statement error
SELECT string_agg(d) EXPORT_STATE from dummy;
----

statement error
SELECT FINALIZE(COMBINE(covar_pop(d, d) EXPORT_STATE)) FROM dummy;
----

statement error
SELECT combine(NULL, NULL);
----

statement error
SELECT combine(42, 42);
----

statement error
SELECT finalize(NULL);
----

statement error
SELECT finalize(42);
----

statement error
SELECT finalize(corr(d, 5)) from dummy;
----

statement error
SELECT finalize(corr(d, 5)) from dummy group by g;
----

# can't finalize twice
statement error
SELECT finalize(finalize(corr(d, 5) EXPORT_STATE)) from dummy;
----

statement error
select corr(42, 10) EXPORT_STATE over ();
----


# tests with ze persistence
# The storage version will be latest, so both opted-in to new AGGREGATE_STATE as struct an non-opted in will work
load __TEST_DIR__/test_state_export.db readwrite latest

statement ok
create table dummy as select range % 10 g, range d from range(100);

# we can persist this
statement ok
CREATE TABLE state AS SELECT g, count(*) EXPORT_STATE count_star_state, count(d) EXPORT_STATE count_state FROM dummy GROUP BY g ORDER BY g;

statement ok
CREATE VIEW state_view AS SELECT g, count(*) EXPORT_STATE count_star_state, count(d) EXPORT_STATE count_state FROM dummy GROUP BY g ORDER BY g;

restart

query IIIIIII nosort res10
SELECT g, count(*), count(d) FROM dummy GROUP BY g ORDER BY g;
----

query IIIIIII nosort res10
SELECT g, finalize(count_star_state),finalize(count_state) FROM state ORDER BY g;
----

query IIIIIII nosort res10
SELECT g, finalize(count_star_state),finalize(count_state) FROM state_view ORDER BY g;
----

# BLOB casting back and forth
statement ok
SELECT (covar_pop(42, 42) EXPORT_STATE)::BLOB;

query I
SELECT FINALIZE(COMBINE(covar_pop(42, 42) EXPORT_STATE, (covar_pop(20, 20) EXPORT_STATE)::BLOB));
----
121.0

statement error
SELECT (covar_pop(42, 42) EXPORT_STATE)::INTEGER;
----

statement error
SELECT COMBINE(covar_pop(42, 42) EXPORT_STATE, 42);
----

statement error
SELECT COMBINE(covar_pop(42, 42) EXPORT_STATE, 'ASDF'::BLOB);
----

statement error
SELECT COMBINE((covar_pop(42, 42) EXPORT_STATE)::BLOB, covar_pop(42, 42) EXPORT_STATE);
----

# simulate round tripping
require parquet

# TODO - we should support the new aggregate state in parquet files
statement ok
COPY (SELECT g, (covar_pop(d, d) EXPORT_STATE)::BLOB s1 FROM dummy GROUP BY g) TO '__TEST_DIR__/state.parquet' (FORMAT PARQUET);

query II
SELECT g, FINALIZE(COMBINE(s2, s1)) FROM (SELECT g, covar_pop(d, d) EXPORT_STATE s2 FROM dummy GROUP BY g) q1 JOIN '__TEST_DIR__/state.parquet' USING(g) ORDER BY g;
----
0	825.0
1	825.0
2	825.0
3	825.0
4	825.0
5	825.0
6	825.0
7	825.0
8	825.0
9	825.0
