# name: test/sql/aggregate/aggregates/test_sum.test
# description: Test sum aggregate
# group: [aggregates]

statement ok
CREATE TABLE integers(i INTEGER);

statement ok
INSERT INTO integers SELECT * FROM range(0, 1000, 1);

# positive numbers
query I
SELECT SUM(i) FROM integers;
----
499500

# negative numbers
statement ok
INSERT INTO integers SELECT * FROM range(0, -1000, -1);

query I
SELECT SUM(i) FROM integers;
----
0

# more negative numbers
statement ok
INSERT INTO integers SELECT * FROM range(0, -1000, -1);

query I
SELECT SUM(i) FROM integers;
----
-499500

# now perform sum of a constant
query I
SELECT SUM(1) FROM integers;
----
3000

# negative constant
query I
SELECT SUM(-1) FROM integers;
----
-3000

# negative constant with a low amount of values
query I
SELECT SUM(-1) FROM integers WHERE i=-1;
----
-2

# no values
query I
SELECT SUM(-1) FROM integers WHERE i>10000;
----
NULL

# bigint sum
statement ok
CREATE TABLE bigints(b BIGINT);

# a bunch of huge values
statement ok
INSERT INTO bigints SELECT * FROM range(4611686018427387904, 4611686018427388904, 1);

# sum them up
query I
SELECT SUM(b) FROM bigints
----
4611686018427388403500

# this is too big for a bigint
statement error
SELECT SUM(b)::BIGINT FROM bigints
----
Conversion Error: Type INT128 with value 4611686018427388403500

# struct-based aggregate state
# When the return type's physical type matches the state type, the value type in the struct should use the return type

# SUM(INTEGER): state is hugeint_t, return is HUGEINT -> match -> value type is HUGEINT
query T
SELECT typeof(sum(1::INTEGER) EXPORT_STATE) = 'AGGREGATE_STATE<sum(INTEGER)::HUGEINT, STRUCT(isset BOOLEAN, "value" HUGEINT)>';
----
true

# SUM(BIGINT): state is hugeint_t, return is HUGEINT -> match -> value type is HUGEINT
query T
SELECT typeof(sum(1::BIGINT) EXPORT_STATE) = 'AGGREGATE_STATE<sum(BIGINT)::HUGEINT, STRUCT(isset BOOLEAN, "value" HUGEINT)>';
----
true

# SUM(DOUBLE): state is double, return is DOUBLE -> match -> value type is DOUBLE
query T
SELECT typeof(sum(1.0::DOUBLE) EXPORT_STATE) = 'AGGREGATE_STATE<sum(DOUBLE)::DOUBLE, STRUCT(isset BOOLEAN, "value" DOUBLE)>';
----
true

# SUM(DECIMAL): state is hugeint_t (INT128), return is DECIMAL(38,3) (INT128) -> match -> value type is DECIMAL(38,3)
query T
SELECT typeof(sum(1.12::DECIMAL) EXPORT_STATE) = 'AGGREGATE_STATE<sum(DECIMAL(18,3))::DECIMAL(38,3), STRUCT(isset BOOLEAN, "value" DECIMAL(38,3))>';
----
true

# When the return type's physical type does NOT match the state type, the value type falls back to the state's physical logical type

# SUM(BOOL): state is int64_t (INT64), return is HUGEINT (INT128) -> no match -> value type is BIGINT
query T
SELECT typeof(sum(true) EXPORT_STATE) = 'AGGREGATE_STATE<sum(BOOLEAN)::HUGEINT, STRUCT(isset BOOLEAN, "value" BIGINT)>';
----
true

# SUM(SMALLINT): state is int64_t (INT64), return is HUGEINT (INT128) -> no match -> value type is BIGINT
query T
SELECT typeof(sum(1::SMALLINT) EXPORT_STATE) = 'AGGREGATE_STATE<sum(SMALLINT)::HUGEINT, STRUCT(isset BOOLEAN, "value" BIGINT)>';
----
true

# SUM(DECIMAL(4,2)): state is int64_t (INT64), return is DECIMAL(38,2) (INT128) -> no match -> value type is BIGINT
query T
SELECT typeof(sum(1.00::DECIMAL(4,2)) EXPORT_STATE) = 'AGGREGATE_STATE<sum(DECIMAL(4,2))::DECIMAL(38,2), STRUCT(isset BOOLEAN, "value" BIGINT)>';
----
true

#
# Order by
#
statement ok
CREATE TABLE doubles(n DOUBLE);

statement ok
INSERT INTO doubles (n) VALUES ('9007199254740992'::DOUBLE), (1::DOUBLE), (1::DOUBLE), (0::DOUBLE);

# Correct result when ordered by size
query I
SELECT sum(n ORDER BY ABS(n))::BIGINT FROM doubles;
----
9007199254740994

# Error as an ordered aggregate
statement error
SELECT (sum(n) WITHIN GROUP(ORDER BY ABS(n)))::BIGINT FROM doubles;
----
Parser Error: Unknown ordered aggregate "sum"
