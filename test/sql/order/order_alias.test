# name: test/sql/order/order_alias.test
# description: Test LIMIT with a parameter (issue 1866)
# group: [order]

statement ok
PRAGMA enable_verification

query I
SELECT foo AS bar FROM (SELECT 1 AS foo) t ORDER BY foo + 1;
----
1

query I
SELECT foo AS bar FROM (SELECT 1 AS foo) t ORDER BY bar;
----
1

query I
SELECT foo AS bar FROM (SELECT 1 AS foo) t ORDER BY bar + 1;
----
1

query I
SELECT bar+bar AS bar FROM (SELECT 1 AS bar) t ORDER BY bar;
----
2

query I
SELECT foo AS bar FROM (SELECT i%2 foo FROM generate_series(0, 3, 1) t(i)) t ORDER BY bar + 1;
----
0
0
1
1

query I
SELECT foo AS bar FROM (SELECT i%2 foo FROM generate_series(0, 3, 1) t(i)) t ORDER BY 1 - bar;
----
1
1
0
0

query I
SELECT foo AS bar FROM (SELECT i%2 foo FROM generate_series(0, 3, 1) t(i)) t ORDER BY 1 - bar + bar + bar;
----
0
0
1
1

query I
SELECT 1-i AS i FROM (SELECT i%2 foo FROM generate_series(0, 3, 1) t(i)) t(i) ORDER BY i;
----
0
0
1
1

# CONTROVERSIAL: sqlite reverses the order here
# it seems that there is a different code path in SQLite
# for binding the alias as root of the order by vs binding the alias as part of an expression
query I
SELECT 1-i AS i FROM (SELECT i%2 foo FROM generate_series(0, 3, 1) t(i)) t(i) ORDER BY i+1;
----
0
0
1
1

# duplicate alias
# we match SQLite's behavior here and use the first
# CONTROVERSIAL: Postgres reports an error
query II
SELECT foo AS bar, 1-foo AS bar FROM (SELECT i%2 foo FROM generate_series(0, 3, 1) t(i)) t ORDER BY bar + 1;
----
0	1
0	1
1	0
1	0

query II
SELECT foo AS bar, 1-foo AS bar FROM (SELECT i%2 foo FROM generate_series(0, 3, 1) t(i)) t ORDER BY bar;
----
0	1
0	1
1	0
1	0

# DISTINCT ON binds in the same manner as ORDER BY
query I
SELECT DISTINCT ON(bar) foo AS bar FROM (SELECT 1 AS foo) t;
----
1

query I
SELECT DISTINCT ON(bar + 1) foo AS bar FROM (SELECT 1 AS foo) t;
----
1
