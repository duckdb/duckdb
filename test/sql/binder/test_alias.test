# name: test/sql/binder/test_alias.test
# description: Test that aliases work properly in renaming columns
# group: [binder]

statement ok
SET default_null_order='nulls_first';

statement ok
PRAGMA enable_verification

statement ok
CREATE TABLE integers(i INTEGER);

statement ok
INSERT INTO integers VALUES (1), (2), (3), (NULL)

query IR
SELECT i % 2 AS p, SUM(i) AS sum_i FROM integers GROUP BY p ORDER BY 1
----
NULL	NULL
0	2.000000
1	4.000000

query TT
SELECT alias(i % 2) AS p, alias(SUM(i)) AS sum_i FROM integers GROUP BY p ORDER BY 1
----
p	sum_i

query II
SELECT i + 1 + 1 + 1 AS k, abs(i) AS l FROM integers WHERE i=1 ORDER BY 1
----
4	1

query TT
SELECT alias(i + 1 + 1 + 1) AS k, alias(abs(i)) AS l FROM integers WHERE i=1 ORDER BY 1
----
k	l

query TTTT
SELECT alias(i) AS k, alias(i IN (1)) AS l, alias(i >= 10) AS m, alias(1=0) AS n FROM integers WHERE i=1 ORDER BY 1
----
k	l	m	n

query TT
SELECT alias(CASE WHEN i=1 THEN 19 ELSE 0 END) AS k, alias(i::VARCHAR) AS l FROM integers WHERE i=1 ORDER BY 1
----
k	l

statement ok
CREATE TABLE test (a INTEGER, b INTEGER)

statement ok
INSERT INTO test VALUES (42, 10), (43, 100);

# check column names for simple projections and aliases
query IIII
SELECT a, b, a * 2 AS c, b * (a * 2) AS d FROM test ORDER BY a
----
42	10	84	840
43	100	86	8600

query TTTT
SELECT alias(a), alias(b), alias(a * 2) AS c, alias(b * (a * 2)) AS d FROM test ORDER BY a
----
a	b	c	d
a	b	c	d


# test nested alias in where clause
query IIII
select i as b, b as c, c as d, d as e from integers where e = 3;
----
3	3	3	3


# Test function chain in QUALIFY
query II
SELECT c1, row_number() over(partition BY c1 order by c2) as rk FROM VALUES ('a', 1), ('b', 2), ('b', 3), ('c', 4) AS t(c1, c2) qualify rk.add(1) > 2
----
b	2


query I
FROM VALUES ('CS', 'Bachelor'), ('CS', 'Bachelor'), ('CS', 'PhD'), ('Math', 'Masters') AS t(c1, c2)
SELECT list(c2) over(partition BY c1) AS "c3"
QUALIFY "c3".len() = 1;
----
[Masters]

query II
SELECT c1, sum(c2) as c3 FROM VALUES ('a', 1), ('b', 2), ('b', 3), ('c', 4), ('d', null) AS t(c1, c2) group by c1 having c3.add(1) > 2 order by c1;
----
b	5
c	4

query II
FROM VALUES ('CS', 'Bachelor'), ('CS', 'Bachelor'), ('CS', 'PhD'), ('Math', 'Masters') AS t(c1, c2)
SELECT c1, STRING_AGG(c2, ',' order by c2) as c3
GROUP BY c1
HAVING len(c3) > 7
----
CS	Bachelor,Bachelor,PhD


query II
FROM VALUES ('CS', 'Bachelor'), ('CS', 'Bachelor'), ('CS', 'PhD'), ('Math', 'Masters') AS t(c1, c2)
SELECT c1, STRING_AGG(c2, ',' order by c2) as c3
GROUP BY c1
HAVING c3.len() > 7
----
CS	Bachelor,Bachelor,PhD
