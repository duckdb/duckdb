# name: test/sql/copy/parquet/parquet_union_by_name.test
# description: Test parquet files UNION_BY_NAME reading
# group: [parquet]

statement ok
SET default_null_order='nulls_first';

require parquet

statement ok
PRAGMA enable_verification

# we run this twice, once with multi threading and once without
loop i 0 2

statement ok
CREATE OR REPLACE TABLE ubn1(a BIGINT);

statement ok
CREATE OR REPLACE TABLE ubn2(a INTEGER, b INTEGER);

statement ok
CREATE OR REPLACE TABLE ubn3(a INTEGER, c INTEGER);

statement ok
INSERT INTO ubn1 VALUES (1), (2), (9223372036854775807);

statement ok
INSERT INTO ubn2 VALUES (3,4), (5, 6);

statement ok
INSERT INTO ubn3 VALUES (100,101), (102, 103);

statement ok
COPY ubn1 TO '{TEMP_DIR}/ubn1.parquet' WITH (FORMAT PARQUET);

statement ok
COPY ubn2 TO '{TEMP_DIR}/ubn2.parquet' WITH (FORMAT PARQUET);

statement ok
COPY ubn3 TO '{TEMP_DIR}/ubn3.parquet' WITH (FORMAT PARQUET);

# If use SELECT * some filesystem may surprisingly success
statement error
SELECT a,b,c FROM parquet_scan('{TEMP_DIR}/ubn*.parquet')
----

query III
SELECT a,b,c 
FROM parquet_scan('{TEMP_DIR}/ubn*.parquet', UNION_BY_NAME=TRUE) 
ORDER BY a;
----
1	NULL	NULL
2	NULL	NULL
3	4	NULL
5	6	NULL
100	NULL	101
102	NULL	103
9223372036854775807	NULL	NULL


# without union by name, parquet reader will use the first parquet files's type
statement error
SELECT a 
FROM parquet_scan(['{TEMP_DIR}/ubn2.parquet', '{TEMP_DIR}/ubn1.parquet', '{TEMP_DIR}/ubn3.parquet']) 
ORDER BY a;
----

# with union by name, parquet readers will use max logical type
query I
SELECT a 
FROM parquet_scan('{TEMP_DIR}/ubn*.parquet', UNION_BY_NAME=TRUE) 
ORDER BY a;
----
1
2
3
5
100
102
9223372036854775807


statement error
SELECT b
FROM parquet_scan('{TEMP_DIR}/ubn*.parquet') 
ORDER BY b;
----

query I
SELECT b
FROM parquet_scan('{TEMP_DIR}/ubn*.parquet', UNION_BY_NAME=TRUE) 
ORDER BY b;
----
NULL
NULL
NULL
NULL
NULL
4
6

query TTT
SELECT typeof(a), typeof(b), typeof(c)
FROM parquet_scan('{TEMP_DIR}/ubn*.parquet', UNION_BY_NAME=TRUE)
LIMIT 1;
----
BIGINT	INTEGER	INTEGER

statement ok
COPY (SELECT [42::INT] a, [43::INT] b) TO '{TEMP_DIR}/listubn1.parquet' (FORMAT PARQUET)

statement ok
COPY (SELECT [44::BIGINT] b, [45::INT] c) TO '{TEMP_DIR}/listubn2.parquet' (FORMAT PARQUET)

query III
SELECT a,b,c 
FROM parquet_scan('{TEMP_DIR}/listubn[12].parquet', union_by_name=true)
ORDER BY a;
----
NULL	[44]	[45]
[42]	[43]	NULL


query TTT
SELECT typeof(a),typeof(b),typeof(c)
FROM parquet_scan('{TEMP_DIR}/listubn[12].parquet', union_by_name=true)
LIMIT 1;
----
INTEGER[]	BIGINT[]	INTEGER[]

statement ok
PRAGMA threads=1

endloop
