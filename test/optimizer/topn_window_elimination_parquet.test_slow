# name: test/optimizer/topn_window_elimination_parquet.test_slow
# description: Test Top-N Window Elimination Rule
# group: [optimizer]

require parquet

statement ok
PRAGMA enable_verification

statement ok
PRAGMA explain_output = OPTIMIZED_ONLY;

statement ok
COPY (SELECT * FROM VALUES (0, {'x': 0}, 0), (0, {'x': 1}, 1), (1, {'x': 2}, 2), (null, {'x': 3}, 3), (null, {'x': 4}, 4), t(grp, a, b)) TO '__TEST_DIR__/tbl.parquet'

statement ok
COPY (SELECT * FROM VALUES (0, [0], null), (0, [1], 1), (1, [2], null), (null, [3], 3), (null, [4], 4), t(grp, a, b)) TO '__TEST_DIR__/tbl_with_null.parquet'

statement ok
COPY (SELECT * FROM VALUES (0, 'a'), (1, 'b'), (null, 'c'), t(x, y)) TO '__TEST_DIR__/tbl2.parquet'

# test min_max
foreach sort_order ASC DESC

# test topn sizes
loop topn 1 3

# min/max
query II
EXPLAIN SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp FROM read_parquet('__TEST_DIR__/tbl.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL
----
logical_opt	<!REGEX>:.*FILTER.*WINDOW.*

statement ok
SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp FROM read_parquet('__TEST_DIR__/tbl.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL

# arg_min/max, no struct_pack
query II
EXPLAIN SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a FROM read_parquet('__TEST_DIR__/tbl.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL
----
logical_opt	<!REGEX>:.*FILTER.*WINDOW.*

statement ok
SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a FROM read_parquet('__TEST_DIR__/tbl.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL

# arg_min/max with struct_pack
query II
EXPLAIN SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a, b FROM read_parquet('__TEST_DIR__/tbl.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL
----
logical_opt	<!REGEX>:.*FILTER.*WINDOW.*

statement ok
SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a, b FROM read_parquet('__TEST_DIR__/tbl.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL

# min/max and nulls
query II
EXPLAIN SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp FROM read_parquet('__TEST_DIR__/tbl_with_null.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL
----
logical_opt	<!REGEX>:.*FILTER.*WINDOW.*

statement ok
SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp FROM read_parquet('__TEST_DIR__/tbl_with_null.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL

# arg_min/max, no struct_pack and nulls
query II
EXPLAIN SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a FROM read_parquet('__TEST_DIR__/tbl_with_null.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL
----
logical_opt	<!REGEX>:.*FILTER.*WINDOW.*

statement ok
SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a FROM read_parquet('__TEST_DIR__/tbl_with_null.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL


# arg_min/max with struct_pack and nulls
query II
EXPLAIN SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a, b FROM read_parquet('__TEST_DIR__/tbl_with_null.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL
----
logical_opt	<!REGEX>:.*FILTER.*WINDOW.*

statement ok
SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a, b FROM read_parquet('__TEST_DIR__/tbl_with_null.parquet') QUALIFY rn <= ${topn}) ORDER BY ALL

# window function with join and one-sided projections
query II
EXPLAIN SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a, b FROM read_parquet('__TEST_DIR__/tbl.parquet') JOIN read_parquet('__TEST_DIR__/tbl2.parquet') ON grp = x QUALIFY rn <= ${topn}) ORDER BY ALL
----
logical_opt	<!REGEX>:.*FILTER.*WINDOW.*

statement ok
SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a, b FROM read_parquet('__TEST_DIR__/tbl.parquet') JOIN read_parquet('__TEST_DIR__/tbl2.parquet') ON grp = x QUALIFY rn <= ${topn}) ORDER BY ALL

# window function with join and one-sided projections + join column
# expect no late materialization as struct size is not smaller than 2
query II
EXPLAIN SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a, b, x FROM read_parquet('__TEST_DIR__/tbl.parquet') JOIN read_parquet('__TEST_DIR__/tbl2.parquet') ON grp = x QUALIFY rn <= ${topn}) ORDER BY ALL
----
logical_opt	<!REGEX>:.*COMPARISON_JOIN.*rowid = rowid.*AGGREGATE.*

statement ok
SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a, b, x FROM read_parquet('__TEST_DIR__/tbl.parquet') JOIN read_parquet('__TEST_DIR__/tbl2.parquet') ON grp = x QUALIFY rn <= ${topn}) ORDER BY ALL

# window function with join and two-sided projections
query II
EXPLAIN SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a, b, y FROM read_parquet('__TEST_DIR__/tbl.parquet') JOIN read_parquet('__TEST_DIR__/tbl2.parquet') ON grp = x QUALIFY rn <= ${topn}) ORDER BY ALL
----
logical_opt	<!REGEX>:.*COMPARISON_JOIN.*rowid = rowid.*AGGREGATE.*

statement ok
SELECT * FROM (SELECT row_number() OVER (PARTITION BY grp ORDER BY b ${sort_order}) as rn, grp, a, b, y FROM read_parquet('__TEST_DIR__/tbl.parquet') JOIN read_parquet('__TEST_DIR__/tbl2.parquet') ON grp = x QUALIFY rn <= ${topn}) ORDER BY ALL

# test lateral join
query II
EXPLAIN SELECT t1.* FROM read_parquet('__TEST_DIR__/tbl.parquet') t1 INNER JOIN LATERAL (SELECT * FROM read_parquet('__TEST_DIR__/tbl.parquet') t2 WHERE t1.grp = t2.grp ORDER BY b ${sort_order} LIMIT ${topn}) ON true
----
logical_opt	<!REGEX>:.*FILTER.*WINDOW.*

statement ok
SELECT t1.* FROM read_parquet('__TEST_DIR__/tbl.parquet') t1 INNER JOIN LATERAL (SELECT * FROM read_parquet('__TEST_DIR__/tbl.parquet') t2 WHERE t1.grp = t2.grp ORDER BY b ${sort_order} LIMIT ${topn}) ON true

endloop

endloop
