/* THIS FILE WAS AUTOMATICALLY GENERATED BY inline_grammar.py */

namespace duckdb {

const char INLINED_PEG_GRAMMAR[] = {
	"PivotStatement <- PivotKeyword TableRef PivotOn? PivotUsing? GroupByClause?\n"
	"PivotOn <- 'ON' PivotColumnList\n"
	"PivotUsing <- 'USING' TargetList\n"
	"PivotColumnList <- List(Expression)\n"
	"PivotKeyword <- 'PIVOT'i / 'PIVOT_WIDER'i\n"
	"UnpivotKeyword <- 'UNPIVOT'i / 'PIVOT_LONGER'i\n"
	"UnpivotStatement <- UnpivotKeyword TableRef 'ON' TargetList IntoNameValues?\n"
	"IntoNameValues <- 'INTO' 'NAME' Identifier ValueOrValues List(Identifier)\n"
	"ValueOrValues <- 'VALUE' / 'VALUES'\n"
	"IncludeExcludeNulls <- ('INCLUDE' / 'EXCLUDE') 'NULLS'\n"
	"UnpivotHeader <- Identifier / Parens(List(Identifier))\n"
	"ColumnReference <- CatalogQualification? SchemaQualification? TableQualification? ColumnName\n"
	"FunctionExpression <- FunctionIdentifier Parens(DistinctOrAll? List(FunctionArgument)? OrderByClause?) WithinGroupClause? FilterClause? ExportClause? OverClause?\n"
	"FunctionIdentifier <- CatalogQualification? SchemaQualification? FunctionName\n"
	"DistinctOrAll <- 'DISTINCT'i / 'ALL'i\n"
	"ExportClause <- 'EXPORT_STATE'i\n"
	"WithinGroupClause <- 'WITHIN'i 'GROUP'i Parens(OrderByClause)\n"
	"FilterClause <- 'FILTER' Parens('WHERE'i? Expression)\n"
	"ParenthesisExpression <- Parens(List(Expression))\n"
	"LiteralExpression <- StringLiteral / NumberLiteral / 'NULL'i / 'TRUE'i / 'FALSE'i\n"
	"CastExpression <- CastOrTryCast Parens(Expression 'AS'i Type)\n"
	"CastOrTryCast <- 'CAST'i / 'TRY_CAST'i\n"
	"StarExpression <- (Identifier '.')* '*'i ExcludeList? ReplaceList? RenameList?\n"
	"ExcludeList <- 'EXCLUDE'i (Parens(List(ColumnReference)) / ColumnReference)\n"
	"ReplaceList <- 'REPLACE'i (Parens(List(ReplaceEntry)) / ReplaceEntry)\n"
	"ReplaceEntry <- Expression 'AS'i ColumnReference\n"
	"RenameList <- 'RENAME'i (Parens(List(RenameEntry)) / RenameEntry)\n"
	"RenameEntry <- ColumnReference 'AS'i Identifier\n"
	"SubqueryExpression <- 'NOT'i? 'EXISTS'i? SubqueryReference\n"
	"CaseExpression <- 'CASE'i ColumnReference? CaseWhenThen CaseWhenThen* CaseElse? 'END'i\n"
	"CaseWhenThen <- 'WHEN'i Expression 'THEN'i Expression\n"
	"CaseElse <- 'ELSE'i Expression\n"
	"TypeLiteral <- Identifier StringLiteral\n"
	"IntervalLiteral <- 'INTERVAL'i IntervalParameter IntervalUnit?\n"
	"IntervalParameter <- StringLiteral / NumberLiteral / Parens(Expression)\n"
	"IntervalUnit <- Identifier\n"
	"FrameClause <- Framing FrameExtent WindowExcludeClause?\n"
	"Framing <- 'ROWS'i / 'RANGE'i / 'GROUPS'i\n"
	"FrameExtent <- FrameBound / ('BETWEEN'i FrameBound 'AND'i FrameBound)\n"
	"FrameBound <- ('UNBOUNDED'i 'PRECEDING'i) / ('UNBOUNDED'i 'FOLLOWING'i) / ('CURRENT'i 'ROW'i) / (Expression 'PRECEDING'i) / (Expression 'FOLLOWING'i)\n"
	"WindowExcludeClause <- 'EXCLUDE'i WindowExcludeElement\n"
	"WindowExcludeElement <- ('CURRENT'i 'ROW'i) / 'GROUP'i / 'TIES'i / ('NO'i 'OTHERS'i)\n"
	"OverClause <- 'OVER'i WindowFrame\n"
	"WindowFrame <- WindowFrameDefinition / Identifier / Parens(Identifier)\n"
	"WindowFrameDefinition <- Parens(WindowFrameContents)\n"
	"WindowFrameContents <- WindowPartition? OrderByClause? FrameClause?\n"
	"WindowPartition <- 'PARTITION'i 'BY'i List(Expression)\n"
	"PrefixExpression <- PrefixOperator Expression\n"
	"PrefixOperator <- 'NOT'i / '-' / '+'\n"
	"ListExpression <- 'ARRAY'i? '[' List(Expression)? ']'\n"
	"StructExpression <- '{' List(StructField) '}'\n"
	"StructField <- Expression ':'i Expression\n"
	"MapExpression <- 'MAP'i StructExpression\n"
	"GroupingExpression <- GroupingOrGroupingId Parens(List(Expression))\n"
	"GroupingOrGroupingId <- 'GROUPING'i / 'GROUPING_ID'i\n"
	"Parameter <- '?' / NumberedParameter\n"
	"NumberedParameter <- '$' NumberLiteral\n"
	"PositionalExpression <- '#' NumberLiteral\n"
	"DefaultExpression <- 'DEFAULT'i\n"
	"ListComprehensionExpression <- '['i Expression 'FOR'i List(Expression) ListComprehensionFilter? ']'\n"
	"ListComprehensionFilter <- 'IF'i Expression\n"
	"SingleExpression <-\n"
	"	Parameter /\n"
	"    SubqueryExpression /\n"
	"    SpecialFunctionExpression /\n"
	"    ParenthesisExpression /\n"
	"    IntervalLiteral /\n"
	"    TypeLiteral /\n"
	"    CaseExpression /\n"
	"    StarExpression /\n"
	"    CastExpression /\n"
	"    GroupingExpression /\n"
	"    FunctionExpression /\n"
	"    ColumnReference /\n"
	"    LiteralExpression /\n"
	"    PrefixExpression /\n"
	"    ListComprehensionExpression /\n"
	"    ListExpression /\n"
	"    StructExpression /\n"
	"    MapExpression /\n"
	"    PositionalExpression /\n"
	"    DefaultExpression\n"
	"OperatorLiteral <- <[\\+\\-\\*\\/\\%\\^\\<\\>\\=\\~\\!\\@\\&\\|\\`]+>\n"
	"LikeOperator <- 'NOT'i? LikeOrSimilarTo\n"
	"LikeOrSimilarTo <- 'LIKE'i / 'ILIKE'i / 'GLOB'i / ('SIMILAR'i 'TO'i)\n"
	"InOperator <- 'NOT'i? 'IN'i\n"
	"IsOperator <- 'IS'i 'NOT'i? DistinctFrom?\n"
	"DistinctFrom <- 'DISTINCT'i 'FROM'i\n"
	"ConjunctionOperator <- 'OR'i / 'AND'i\n"
	"ComparisonOperator <-  '=' / '<=' / '>=' / '<' / '>' / '<>' / '!=' / '=='\n"
	"BetweenOperator <- 'NOT'i? 'BETWEEN'i\n"
	"CollateOperator <- 'COLLATE'i\n"
	"LambdaOperator <- '->'\n"
	"EscapeOperator <- 'ESCAPE'i\n"
	"AtTimeZoneOperator <- 'AT'i 'TIME'i 'ZONE'i\n"
	"PostfixOperator <- '!'\n"
	"AnyAllOperator <- ComparisonOperator AnyOrAll\n"
	"AnyOrAll <- 'ANY' / 'ALL'\n"
	"Operator <-\n"
	"	AnyAllOperator /\n"
	"    ConjunctionOperator /\n"
	"    LikeOperator /\n"
	"    InOperator /\n"
	"    IsOperator /\n"
	"    BetweenOperator /\n"
	"    CollateOperator /\n"
	"    LambdaOperator /\n"
	"    EscapeOperator /\n"
	"    AtTimeZoneOperator /\n"
	"    OperatorLiteral\n"
	"CastOperator <- '::' Type\n"
	"DotOperator <- '.' (FunctionExpression / Identifier)\n"
	"NotNull <- 'NOT'i 'NULL'i\n"
	"Indirection <- CastOperator / DotOperator / SliceExpression / NotNull / PostfixOperator\n"
	"BaseExpression <- SingleExpression Indirection*\n"
	"Expression <- BaseExpression RecursiveExpression*\n"
	"RecursiveExpression <- (Operator Expression)\n"
	"SliceExpression <- '[' SliceBound ']'\n"
	"SliceBound <- Expression? (':' Expression?)? (':' Expression?)?\n"
	"SpecialFunctionExpression <- CoalesceExpression / ColumnsExpression / ExtractExpression / NullIfExpression / PositionExpression / RowExpression / SubstringExpression / TrimExpression\n"
	"CoalesceExpression <- 'COALESCE'i Parens(List(Expression))\n"
	"ColumnsExpression <- '*'? 'COLUMNS'i Parens(Expression)\n"
	"ExtractExpression <- 'EXTRACT'i Parens(Expression 'FROM'i Expression)\n"
	"NullIfExpression <- 'NULLIF'i Parens(Expression ',' Expression)\n"
	"PositionExpression <- 'POSITION'i Parens(Expression)\n"
	"RowExpression <- 'ROW'i Parens(List(Expression))\n"
	"SubstringExpression <- 'SUBSTRING'i Parens(SubstringParameters / List(Expression))\n"
	"SubstringParameters <- Expression 'FROM'i NumberLiteral 'FOR'i NumberLiteral\n"
	"TrimExpression <- 'TRIM'i Parens(TrimDirection? TrimSource? List(Expression))\n"
	"TrimDirection <- 'BOTH'i / 'LEADING'i / 'TRAILING'i\n"
	"TrimSource <- Expression? 'FROM'i\n"
	"ExecuteStatement <- 'EXECUTE'i Identifier TableFunctionArguments?\n"
	"CreateSecretStmt <- 'SECRET'i IfNotExists? SecretName? SecretStorageSpecifier? Parens(GenericCopyOptionList)\n"
	"SecretStorageSpecifier <- 'IN'i Identifier\n"
	"CreateViewStmt <- 'VIEW'i IfNotExists? QualifiedName InsertColumnList? 'AS'i SelectStatement\n"
	"DescribeStatement <- ShowSelect / ShowAllTables / ShowQualifiedName\n"
	"ShowSelect <- ShowOrDescribeOrSummarize SelectStatement\n"
	"ShowAllTables <- ShowOrDescribe 'ALL'i 'TABLES'\n"
	"ShowQualifiedName <- ShowOrDescribeOrSummarize (QualifiedName / StringLiteral)?\n"
	"ShowOrDescribeOrSummarize <- ShowOrDescribe / 'SUMMARIZE'i\n"
	"ShowOrDescribe <- 'SHOW'i / 'DESCRIBE'i / 'DESC'i\n"
	"VacuumStatement <- 'VACUUM'i 'FULL'i? QualifiedName?\n"
	"PragmaStatement <- 'PRAGMA'i (PragmaAssign / PragmaFunction)\n"
	"PragmaAssign <- SettingName '=' VariableList\n"
	"PragmaFunction <- PragmaName PragmaParameters?\n"
	"PragmaParameters <- List(Expression)\n"
	"DeallocateStatement <- 'DEALLOCATE'i 'PREPARE'i? Identifier\n"
	"PrepareStatement <- 'PREPARE'i Identifier TypeList? 'AS'i Statement\n"
	"TypeList <- Parens(List(Type))\n"
	"CreateStatement <- 'CREATE'i OrReplace? Temporary? (CreateTableStmt / CreateMacroStmt / CreateSequenceStmt / CreateTypeStmt / CreateSchemaStmt / CreateViewStmt / CreateIndexStmt / CreateSecretStmt)\n"
	"OrReplace <- 'OR'i 'REPLACE'i\n"
	"Temporary <- 'TEMP'i / 'TEMPORARY'i / 'PERSISTENT'i\n"
	"CreateTableStmt <- 'TABLE'i IfNotExists? QualifiedName (CreateColumnList / CreateTableAs) CommitAction?\n"
	"CreateTableAs <- IdentifierList? 'AS'i SelectStatement\n"
	"IdentifierList <- Parens(List(Identifier))\n"
	"CreateColumnList <- Parens(CreateTableColumnList)\n"
	"IfNotExists <- 'IF'i 'NOT'i 'EXISTS'i\n"
	"QualifiedName <- CatalogQualification? SchemaQualification? Identifier\n"
	"CatalogQualification <- CatalogName '.'\n"
	"SchemaQualification <- SchemaName '.'\n"
	"TableQualification <- TableName '.'\n"
	"CreateTableColumnList <- List(CreateTableColumnElement)\n"
	"CreateTableColumnElement <- ColumnDefinition / TopLevelConstraint\n"
	"ColumnDefinition <- Identifier TypeOrGenerated ColumnConstraint*\n"
	"TypeOrGenerated <- Type? GeneratedColumn?\n"
	"ColumnConstraint <- NotNullConstraint / UniqueConstraint / PrimaryKeyConstraint / DefaultValue / CheckConstraint / ForeignKeyConstraint / ColumnCollation / ColumnCompression\n"
	"NotNullConstraint <- 'NOT'i 'NULL'i\n"
	"UniqueConstraint <- 'UNIQUE'i\n"
	"PrimaryKeyConstraint <- 'PRIMARY'i 'KEY'i\n"
	"DefaultValue <- 'DEFAULT'i Expression\n"
	"CheckConstraint <- 'CHECK'i Parens(Expression)\n"
	"ForeignKeyConstraint <- 'REFERENCES'i BaseTableName Parens(ColumnList)? KeyActions?\n"
	"ColumnCollation <- 'COLLATE'i Expression\n"
	"ColumnCompression <- 'USING'i 'COMPRESSION'i Identifier\n"
	"KeyActions <- UpdateAction? DeleteAction?\n"
	"UpdateAction <- 'ON' 'UPDATE' KeyAction\n"
	"DeleteAction <- 'ON' 'DELETE' KeyAction\n"
	"KeyAction <- ('NO'i 'ACTION'i) / 'RESTRICT'i / 'CASCADE'i / ('SET'i 'NULL'i) / ('SET'i 'DEFAULT'i)\n"
	"TopLevelConstraint <- ConstraintNameClause? TopLevelConstraintList\n"
	"TopLevelConstraintList <- TopPrimaryKeyConstraint / CheckConstraint / TopUniqueConstraint / TopForeignKeyConstraint\n"
	"ConstraintNameClause <- 'CONSTRAINT'i Identifier\n"
	"TopPrimaryKeyConstraint <- 'PRIMARY'i 'KEY'i ColumnIdList\n"
	"TopUniqueConstraint <- 'UNIQUE'i ColumnIdList\n"
	"TopForeignKeyConstraint <- 'FOREIGN'i 'KEY'i ColumnIdList ForeignKeyConstraint\n"
	"ColumnIdList <- Parens(List(Identifier))\n"
	"PlainIdentifier <-  !ReservedKeyword <[a-z_]i[a-z0-9_]i*>\n"
	"QuotedIdentifier <- '\"' [^\"]* '\"'\n"
	"Identifier <- QuotedIdentifier / PlainIdentifier\n"
	"GeneratedColumn <- Generated? 'AS'i Parens(Expression) GeneratedColumnType?\n"
	"Generated <- 'GENERATED'i AlwaysOrByDefault?\n"
	"AlwaysOrByDefault <- 'ALWAYS'i / ('BY'i 'DEFAULT'i)\n"
	"GeneratedColumnType <- 'VIRTUAL'i / 'STORED'i\n"
	"CommitAction <- 'ON'i 'COMMIT'i 'PRESERVE'i 'ROWS'i\n"
	"CreateIndexStmt <- Unique? 'INDEX'i IfNotExists? IndexName? 'ON'i BaseTableName IndexType? Parens(List(IndexElement))\n"
	"IndexElement <- Expression DescOrAsc? NullsFirstOrLast?\n"
	"Unique <- 'UNIQUE'i\n"
	"IndexType <- 'USING'i Identifier\n"
	"DropStatement <- 'DROP'i DropEntries DropBehavior?\n"
	"DropEntries <-\n"
	"	DropTable /\n"
	"	DropTableFunction /\n"
	"	DropFunction /\n"
	"	DropSchema /\n"
	"	DropIndex /\n"
	"	DropSequence /\n"
	"	DropCollation /\n"
	"	DropType /\n"
	"	DropSecret\n"
	"DropTable <- TableOrView IfExists? List(BaseTableName)\n"
	"DropTableFunction <- 'MACRO'i 'TABLE'i IfExists? List(TableFunctionName)\n"
	"DropFunction <- FunctionType IfExists? List(FunctionIdentifier)\n"
	"DropSchema <- 'SCHEMA'i IfExists? List(QualifiedSchemaName)\n"
	"DropIndex <- 'INDEX'i IfExists? List(IndexName)\n"
	"DropSequence <- 'SEQUENCE'i IfExists? List(QualifiedSequenceName)\n"
	"DropCollation <- 'COLLATION'i IfExists? List(CollationName)\n"
	"DropType <- 'TYPE'i IfExists? List(QualifiedTypeName)\n"
	"DropSecret <- Temporary? 'SECRET'i IfExists? SecretName DropSecretStorage?\n"
	"TableOrView <- 'TABLE'i / 'VIEW'i / ('MATERIALIZED'i 'VIEW'i)\n"
	"FunctionType <- 'MACRO'i / 'FUNCTION'i\n"
	"DropBehavior <- 'CASCADE'i / 'RESTRICT'i\n"
	"IfExists <- 'IF'i 'EXISTS'i\n"
	"QualifiedSchemaName <- CatalogQualification? SchemaName\n"
	"DropSecretStorage <- 'FROM'i Identifier\n"
	"UpdateStatement <- WithClause? 'UPDATE'i UpdateTarget 'SET'i UpdateSetClause FromClause? WhereClause? ReturningClause?\n"
	"UpdateTarget <- BaseTableName UpdateAlias?\n"
	"UpdateAlias <- 'AS'i Identifier\n"
	"UpdateSetClause <- List(UpdateSetElement)\n"
	"UpdateSetElement <- ColumnName '=' Expression\n"
	"InsertStatement <- WithClause? 'INSERT'i OrAction? 'INTO'i InsertTarget ByNameOrPosition? InsertColumnList? InsertValues OnConflictClause? ReturningClause?\n"
	"OrAction <- 'OR'i 'REPLACE'i / 'IGNORE'i\n"
	"ByNameOrPosition <- 'BY'i 'NAME'i / 'POSITION'i\n"
	"InsertTarget <- BaseTableName InsertAlias?\n"
	"InsertAlias <- 'AS'i Identifier\n"
	"ColumnList <- List(Identifier)\n"
	"InsertColumnList <- Parens(ColumnList)\n"
	"InsertValues <- SelectStatement / DefaultValues\n"
	"DefaultValues <- 'DEFAULT'i 'VALUES'i\n"
	"OnConflictClause <- 'ON'i 'CONFLICT'i OnConflictTarget? OnConflictAction\n"
	"OnConflictTarget <- OnConflictExpressionTarget / OnConflictIndexTarget\n"
	"OnConflictExpressionTarget <- Parens(List(Identifier)) WhereClause?\n"
	"OnConflictIndexTarget <- 'ON'i 'CONSTRAINT'i ConstraintName\n"
	"OnConflictAction <- OnConflictUpdate / OnConflictNothing\n"
	"OnConflictUpdate <- 'DO'i 'UPDATE'i UpdateSetClause WhereClause?\n"
	"OnConflictNothing <- 'DO'i 'NOTHING'i\n"
	"ReturningClause <- 'RETURNING'i TargetList\n"
	"CreateSchemaStmt <- 'SCHEMA'i IfNotExists? QualifiedName\n"
	"SelectStatement <- SelectOrParens (SetopClause SelectStatement)* ResultModifiers\n"
	"SetopClause <- ('UNION'i / 'EXCEPT'i / 'INTERSECT'i) DistinctOrAll? ByName?\n"
	"ByName <- 'BY'i 'NAME'i\n"
	"SelectOrParens <- BaseSelect / Parens(SelectStatement)\n"
	"BaseSelect <- WithClause? (SimpleSelect / ValuesClause / DescribeStatement / TableStatement / PivotStatement / UnpivotStatement) ResultModifiers\n"
	"ResultModifiers <- OrderByClause? LimitClause? OffsetClause?\n"
	"TableStatement <- 'TABLE' BaseTableName\n"
	"SimpleSelect <- SelectFrom WhereClause? GroupByClause? HavingClause? WindowClause? QualifyClause? SampleClause?\n"
	"SelectFrom <- (SelectClause FromClause?) / (FromClause SelectClause?)\n"
	"WithStatement <- Identifier InsertColumnList? 'AS'i Materialized? SubqueryReference\n"
	"Materialized <- 'NOT'i? 'MATERIALIZED'i\n"
	"WithClause <- 'WITH'i Recursive? List(WithStatement)\n"
	"Recursive <- 'RECURSIVE'i\n"
	"SelectClause <- 'SELECT'i DistinctClause? TargetList\n"
	"TargetList <- List(AliasedExpression)\n"
	"ColumnAliases <- Parens(List(Identifier))\n"
	"DistinctClause <- ('DISTINCT'i DistinctOn?) / 'ALL'i\n"
	"DistinctOn <- 'ON'i Parens(List(Expression))\n"
	"InnerTableRef <- ValuesRef / TableFunction / TableSubquery / BaseTableRef / ParensTableRef\n"
	"TableRef <- InnerTableRef JoinOrPivot*\n"
	"TableSubquery <- Lateral? SubqueryReference TableAlias?\n"
	"BaseTableRef <- BaseTableName TableAlias?\n"
	"ValuesRef <- ValuesClause TableAlias?\n"
	"ParensTableRef <- Parens(TableRef)\n"
	"JoinOrPivot <- JoinClause / TablePivotClause / TableUnpivotClause\n"
	"TablePivotClause <- 'PIVOT' Parens(TargetList 'FOR' PivotValueLists GroupByClause?) TableAlias?\n"
	"TableUnpivotClause <- 'UNPIVOT' IncludeExcludeNulls? Parens(UnpivotHeader 'FOR' PivotValueLists) TableAlias?\n"
	"PivotHeader <- BaseExpression\n"
	"PivotValueLists <- PivotValueList PivotValueList*\n"
	"PivotValueList <- PivotHeader 'IN' PivotTargetList\n"
	"PivotTargetList <- Identifier / Parens(TargetList)\n"
	"Lateral <- 'LATERAL'i\n"
	"BaseTableName <- CatalogQualification? SchemaQualification? TableName\n"
	"TableFunction <- Lateral? QualifiedTableFunction TableFunctionArguments TableAlias?\n"
	"QualifiedTableFunction <- CatalogQualification? SchemaQualification? TableFunctionName\n"
	"TableFunctionArguments <- Parens(List(FunctionArgument)?)\n"
	"FunctionArgument <- NamedParameter / Expression\n"
	"NamedParameter <- Identifier NamedParameterAssignment Expression\n"
	"NamedParameterAssignment <- ':=' / '=>'\n"
	"TableAlias <- 'AS'i? Identifier ColumnAliases?\n"
	"JoinClause <- RegularJoinClause / JoinWithoutOnClause\n"
	"RegularJoinClause <- 'ASOF'i? JoinType? 'JOIN'i InnerTableRef JoinQualifier\n"
	"JoinWithoutOnClause <- JoinPrefix 'JOIN'i InnerTableRef\n"
	"JoinQualifier <- OnClause / UsingClause\n"
	"OnClause <- 'ON'i Expression\n"
	"UsingClause <- 'USING'i Parens(List(ColumnName))\n"
	"OuterJoinType <- 'FULL'i / 'LEFT'i / 'RIGHT'i\n"
	"JoinType <- (OuterJoinType 'OUTER'i?) / 'SEMI'i / 'ANTI'i / 'INNER'i\n"
	"JoinPrefix <- 'CROSS'i / ('NATURAL'i JoinType?) / 'POSITIONAL'i\n"
	"FromClause <- 'FROM'i List(TableRef)\n"
	"WhereClause <- 'WHERE'i Expression\n"
	"GroupByClause <- 'GROUP'i 'BY'i GroupByExpressions\n"
	"HavingClause <- 'HAVING'i Expression\n"
	"QualifyClause <- 'QUALIFY'i Expression\n"
	"SampleClause <- 'USING'i 'SAMPLE'i SampleEntry\n"
	"WindowClause <- 'WINDOW'i List(WindowDefinition)\n"
	"WindowDefinition <- Identifier 'AS'i WindowFrameDefinition\n"
	"SampleEntry <- SampleEntryCount / SampleEntryFunction RepeatableSample?\n"
	"SampleEntryCount <- SampleCount Parens(SampleProperties)?\n"
	"SampleEntryFunction <- SampleFunction? Parens(SampleCount)\n"
	"SampleFunction <- Identifier\n"
	"SampleProperties <- Identifier (',' NumberLiteral)\n"
	"RepeatableSample <- 'REPEATABLE' Parens(NumberLiteral)\n"
	"SampleCount <- Expression SampleUnit?\n"
	"SampleUnit <- '%' / 'PERCENT'i / 'ROWS'i\n"
	"GroupByExpressions <- GroupByList / 'ALL'i\n"
	"GroupByList <- List(GroupByExpression)\n"
	"GroupByExpression <- EmptyGroupingItem / CubeOrRollupClause / GroupingSetsClause / Expression\n"
	"EmptyGroupingItem <- '(' ')'\n"
	"CubeOrRollupClause <- CubeOrRollup Parens(List(Expression))\n"
	"CubeOrRollup <- 'CUBE'i / 'ROLLUP'i\n"
	"GroupingSetsClause <- 'GROUPING'i 'SETS'i Parens(GroupByList)\n"
	"SubqueryReference <- Parens(SelectStatement)\n"
	"OrderByExpression <- Expression DescOrAsc? NullsFirstOrLast?\n"
	"DescOrAsc <- 'DESC'i / 'DESCENDING'i / 'ASC'i / 'ASCENDING'i\n"
	"NullsFirstOrLast <- 'NULLS'i 'FIRST'i / 'LAST'i\n"
	"OrderByClause <- 'ORDER'i 'BY'i OrderByExpressions\n"
	"OrderByExpressions <- List(OrderByExpression) / OrderByAll\n"
	"OrderByAll <- 'ALL'i DescOrAsc? NullsFirstOrLast?\n"
	"LimitClause <- 'LIMIT'i LimitValue\n"
	"OffsetClause <- 'OFFSET'i LimitValue\n"
	"LimitValue <- 'ALL'i / (NumberLiteral 'PERCENT'i) / (Expression '%'?)\n"
	"AliasedExpression <- Expression ('AS'i? Identifier)?\n"
	"ValuesClause <- 'VALUES'i List(ValuesExpressions)\n"
	"ValuesExpressions <- Parens(List(Expression))\n"
	"TransactionStatement <- BeginTransaction / RollbackTransaction / CommitTransaction\n"
	"BeginTransaction <- StartOrBegin Transaction? ReadOrWrite?\n"
	"RollbackTransaction <- AbortOrRollback Transaction?\n"
	"CommitTransaction <- CommitOrEnd Transaction?\n"
	"StartOrBegin <- 'START'i / 'BEGIN'i\n"
	"Transaction <- 'WORK'i / 'TRANSACTION'i\n"
	"ReadOrWrite <- 'READ'i ('ONLY'i / 'WRITE'i)\n"
	"AbortOrRollback <- 'ABORT'i / 'ROLLBACK'i\n"
	"CommitOrEnd <- 'COMMIT'i / 'END'i\n"
	"DeleteStatement <- WithClause? 'DELETE'i 'FROM'i InsertTarget DeleteUsingClause? WhereClause? ReturningClause?\n"
	"TruncateStatement <- 'TRUNCATE'i 'TABLE'i? BaseTableName\n"
	"DeleteUsingClause <- 'USING'i List(TableRef)\n"
	"CreateTypeStmt <- 'TYPE'i IfNotExists? QualifiedName 'AS'i Type\n"
	"SetStatement <- 'SET'i (StandardAssignment / SetTimeZone)\n"
	"StandardAssignment <- (SetVariable / SetSetting) SetAssignment\n"
	"SetTimeZone <- 'TIME'i 'ZONE'i Expression\n"
	"SetSetting <- SettingScope? SettingName\n"
	"SetVariable <- 'VARIABLE'i Identifier\n"
	"SettingScope <- 'LOCAL'i / 'SESSION'i / 'GLOBAL'i\n"
	"SetAssignment <- VariableAssign VariableList\n"
	"VariableAssign <- '=' / 'TO'\n"
	"VariableList <- List(Expression)\n"
	"ResetStatement <- 'RESET'i (SetSetting / SetVariable)\n"
	"ExportStatement <- 'EXPORT'i 'DATABASE'i ExportSource? StringLiteral Parens(GenericCopyOptionList)?\n"
	"ExportSource <- CatalogName 'TO'i\n"
	"ImportStatement <- 'IMPORT'i 'DATABASE'i StringLiteral\n"
	"CheckpointStatement <- 'FORCE'i? 'CHECKPOINT'i CatalogName?\n"
	"CopyStatement <- 'COPY'i (CopyTable / CopySelect / CopyFromDatabase)\n"
	"CopyTable <- BaseTableName InsertColumnList? FromOrTo CopyFileName CopyOptions?\n"
	"FromOrTo <- 'FROM'i / 'TO'i\n"
	"CopySelect <- Parens(SelectStatement) 'TO'i CopyFileName CopyOptions?\n"
	"CopyFileName <- StringLiteral / Identifier\n"
	"CopyOptions <- 'WITH'i? (Parens(GenericCopyOptionList) / (SpecializedOptions*))\n"
	"SpecializedOptions <-\n"
	"	'BINARY'i / 'FREEZE'i / 'OIDS'i / 'CSV'i / 'HEADER'i /\n"
	"	SpecializedStringOption /\n"
	"	('ENCODING'i StringLiteral) /\n"
	"	('FORCE'i 'QUOTE'i StarOrColumnList) /\n"
	"	('PARTITION'i 'BY'i StarOrColumnList) /\n"
	"	('FORCE'i 'NOT'i? 'NULL'i ColumnList)\n"
	"SpecializedStringOption <- ('DELIMITER'i / 'NULL'i / 'QUOTE'i / 'ESCAPE'i) 'AS'i? StringLiteral\n"
	"StarOrColumnList <- '*' / ColumnList\n"
	"GenericCopyOptionList <- List(GenericCopyOption)\n"
	"GenericCopyOption <- GenericCopyOptionName Expression?\n"
	"# FIXME: should not need to hard-code options here\n"
	"GenericCopyOptionName <- 'ARRAY'i / 'NULL'i / 'ANALYZE'i / CopyOptionName\n"
	"CopyFromDatabase <- 'FROM'i 'DATABASE'i Identifier 'TO'i Identifier CopyDatabaseFlag?\n"
	"CopyDatabaseFlag <- Parens(SchemaOrData)\n"
	"SchemaOrData <- 'SCHEMA'i / 'DATA'i\n"
	"AlterStatement <- 'ALTER'i AlterOptions\n"
	"AlterOptions <- AlterTableStmt / AlterViewStmt / AlterSequenceStmt\n"
	"AlterTableStmt <- 'TABLE'i IfExists? BaseTableName AlterTableOptions\n"
	"AlterTableOptions <- AddColumn / DropColumn / AlterColumn / AddConstraint / ChangeNullability / RenameColumn / RenameAlter\n"
	"AddConstraint <- 'ADD'i TopLevelConstraint\n"
	"AddColumn <- 'ADD'i 'COLUMN'i? IfNotExists? ColumnDefinition\n"
	"DropColumn <- 'DROP'i 'COLUMN'i? IfExists? ColumnName DropBehavior?\n"
	"AlterColumn <- 'ALTER'i 'COLUMN'i? Identifier AlterColumnEntry\n"
	"RenameColumn <- 'RENAME'i 'COLUMN'i? ColumnName 'TO'i Identifier\n"
	"RenameAlter <- 'RENAME'i 'TO'i Identifier\n"
	"AlterColumnEntry <- AddOrDropDefault / ChangeNullability / AlterType\n"
	"AddOrDropDefault <- AddDefault / DropDefault\n"
	"AddDefault <- 'SET'i 'DEFAULT'i Expression\n"
	"DropDefault <- 'DROP'i 'DEFAULT'i\n"
	"ChangeNullability <- ('DROP'i / 'SET'i) 'NOT'i 'NULL'i\n"
	"AlterType <- SetData? 'TYPE'i Type? UsingExpression?\n"
	"SetData <- 'SET'i 'DATA'i?\n"
	"UsingExpression <- 'USING'i Expression\n"
	"AlterViewStmt <- 'VIEW'i IfExists? BaseTableName RenameAlter\n"
	"AlterSequenceStmt <- 'SEQUENCE'i IfExists? QualifiedSequenceName AlterSequenceOptions\n"
	"QualifiedSequenceName <- CatalogQualification? SchemaQualification? SequenceName\n"
	"AlterSequenceOptions <- RenameAlter / SetSequenceOption\n"
	"SetSequenceOption <- List(SequenceOption)\n"
	"CreateSequenceStmt <- 'SEQUENCE'i IfNotExists? QualifiedName SequenceOption*\n"
	"SequenceOption <-\n"
	"	SeqSetCycle /\n"
	"	SeqSetIncrement /\n"
	"	SeqSetMinMax /\n"
	"	SeqNoMinMax /\n"
	"	SeqStartWith /\n"
	"	SeqOwnedBy\n"
	"SeqSetCycle <- 'NO'i? 'CYCLE'i\n"
	"SeqSetIncrement <- 'INCREMENT'i 'BY'i? Expression\n"
	"SeqSetMinMax <- SeqMinOrMax Expression\n"
	"SeqNoMinMax <- 'NO'i SeqMinOrMax\n"
	"SeqStartWith <- 'START'i 'WITH'i? Expression\n"
	"SeqOwnedBy <- 'OWNED'i 'BY'i QualifiedName\n"
	"SeqMinOrMax <- 'MINVALUE'i / 'MAXVALUE'i\n"
	"Statement <-\n"
	"	CreateStatement /\n"
	"	SelectStatement /\n"
	"	SetStatement /\n"
	"	PragmaStatement /\n"
	"	CallStatement /\n"
	"	InsertStatement /\n"
	"	DropStatement /\n"
	"	CopyStatement /\n"
	"	ExplainStatement /\n"
	"	UpdateStatement /\n"
	"	PrepareStatement /\n"
	"	ExecuteStatement /\n"
	"	AlterStatement /\n"
	"	TransactionStatement /\n"
	"	DeleteStatement /\n"
	"	AttachStatement /\n"
	"	UseStatement /\n"
	"	DetachStatement /\n"
	"	CheckpointStatement /\n"
	"	VacuumStatement /\n"
	"	ResetStatement /\n"
	"	ExportStatement /\n"
	"	ImportStatement /\n"
	"	CommentStatement /\n"
	"	DeallocateStatement /\n"
	"	TruncateStatement\n"
	"TypeName <- Identifier\n"
	"CatalogName <- Identifier\n"
	"SchemaName <- Identifier\n"
	"TableName <- Identifier\n"
	"ColumnName <- Identifier\n"
	"IndexName <- Identifier\n"
	"FunctionName <- Identifier\n"
	"SettingName <- Identifier\n"
	"PragmaName <- Identifier\n"
	"TableFunctionName <- Identifier\n"
	"ConstraintName <- Identifier\n"
	"SequenceName <- Identifier\n"
	"CollationName <- Identifier\n"
	"CopyOptionName <- Identifier\n"
	"SecretName <- Identifier\n"
	"NumberLiteral <- < [+-]?[0-9]*([.][0-9]*)? >\n"
	"StringLiteral <- '\\'' [^\\']* '\\''\n"
	"Type <- (TimeType / RowType / MapType / UnionType / DoubleType / SimpleType) ArrayBounds*\n"
	"SimpleType <- QualifiedTypeName TypeModifiers?\n"
	"DoubleType <- 'DOUBLE'i 'PRECISION'\n"
	"QualifiedTypeName <- CatalogQualification? SchemaQualification? TypeName\n"
	"TypeModifiers <- Parens(List(Expression))\n"
	"RowType <- RowOrStruct Parens(List(IdentifierType))\n"
	"UnionType <- 'UNION'i Parens(List(IdentifierType))\n"
	"MapType <- 'MAP'i Parens(List(Type))\n"
	"IdentifierType <- Identifier Type\n"
	"ArrayBounds <- ('[' NumberLiteral? ']') / 'ARRAY'\n"
	"TimeType <- TimeOrTimestamp TypeModifiers? TimeZone?\n"
	"TimeOrTimestamp <- 'TIME'i / 'TIMESTAMP'i\n"
	"TimeZone <- WithOrWithout 'TIME'i 'ZONE'i\n"
	"WithOrWithout <- 'WITH'i / 'WITHOUT'i\n"
	"RowOrStruct <- 'ROW'i / 'STRUCT'i\n"
	"# keywords\n"
	"ReservedKeyword <- 'ALL'i /\n"
	"'ANALYSE'i /\n"
	"'ANALYZE'i /\n"
	"'AND'i /\n"
	"'ANY'i /\n"
	"'ARRAY'i /\n"
	"'AS'i /\n"
	"'ASC_P'i /\n"
	"'ASYMMETRIC'i /\n"
	"'BOTH'i /\n"
	"'CASE'i /\n"
	"'CAST'i /\n"
	"'CHECK_P'i /\n"
	"'COLLATE'i /\n"
	"'COLUMN'i /\n"
	"'CONSTRAINT'i /\n"
	"'CREATE_P'i /\n"
	"'DEFAULT'i /\n"
	"'DEFERRABLE'i /\n"
	"'DESC_P'i /\n"
	"'DESCRIBE'i /\n"
	"'DISTINCT'i /\n"
	"'DO'i /\n"
	"'ELSE'i /\n"
	"'END_P'i /\n"
	"'EXCEPT'i /\n"
	"'FALSE_P'i /\n"
	"'FETCH'i /\n"
	"'FOR'i /\n"
	"'FOREIGN'i /\n"
	"'FROM'i /\n"
	"'GRANT'i /\n"
	"'GROUP_P'i /\n"
	"'HAVING'i /\n"
	"'QUALIFY'i /\n"
	"'IN_P'i /\n"
	"'INITIALLY'i /\n"
	"'INTERSECT'i /\n"
	"'INTO'i /\n"
	"'LATERAL_P'i /\n"
	"'LEADING'i /\n"
	"'LIMIT'i /\n"
	"'NOT'i /\n"
	"'NULL_P'i /\n"
	"'OFFSET'i /\n"
	"'ON'i /\n"
	"'ONLY'i /\n"
	"'OR'i /\n"
	"'ORDER'i /\n"
	"'PIVOT'i /\n"
	"'PIVOT_WIDER'i /\n"
	"'PIVOT_LONGER'i /\n"
	"'PLACING'i /\n"
	"'PRIMARY'i /\n"
	"'REFERENCES'i /\n"
	"'RETURNING'i /\n"
	"'SELECT'i /\n"
	"'SHOW'i /\n"
	"'SOME'i /\n"
	"'SUMMARIZE'i /\n"
	"'SYMMETRIC'i /\n"
	"'TABLE'i /\n"
	"'THEN'i /\n"
	"'TO'i /\n"
	"'TRAILING'i /\n"
	"'TRUE_P'i /\n"
	"'UNION'i /\n"
	"'UNIQUE'i /\n"
	"'UNPIVOT'i /\n"
	"'USING'i /\n"
	"'VARIADIC'i /\n"
	"'WHEN'i /\n"
	"'WHERE'i /\n"
	"'WINDOW'i /\n"
	"'WITH'i\n"
	"# internal definitions\n"
	"%whitespace <- [ \\t\\n\\r]*\n"
	"List(D) <- D (',' D)* ','?\n"
	"Parens(D) <- '(' D ')'\n"
	"ExplainStatement <- 'EXPLAIN'i 'ANALYZE'i? ExplainOptions? Statement\n"
	"ExplainOptions <- Parens(GenericCopyOptionList)\n"
	"CreateMacroStmt <- MacroOrFunction IfNotExists? QualifiedName List(MacroDefinition)\n"
	"MacroOrFunction <- 'MACRO'i / 'FUNCTION'i\n"
	"MacroDefinition <- Parens(MacroParameters?) 'AS'i (ScalarMacroDefinition / TableMacroDefinition)\n"
	"MacroParameters <- List(MacroParameter)\n"
	"MacroParameter <- NamedParameter / Identifier\n"
	"ScalarMacroDefinition <- Expression\n"
	"TableMacroDefinition <- 'TABLE'i SelectStatement\n"
	"CommentStatement <- 'COMMENT'i 'ON'i CommentOnType ColumnReference 'IS'i CommentValue\n"
	"CommentOnType <- 'TABLE'i / 'SEQUENCE'i / 'FUNCTION'i / ('MACRO'i 'TABLE'i?) / 'VIEW'i / 'DATABASE'i / 'INDEX'i / 'SCHEMA'i / 'TYPE'i / 'COLUMN'i\n"
	"CommentValue <- 'NULL'i / StringLiteral\n"
	"AttachStatement <- 'ATTACH'i IfNotExists? Database? DatabasePath AttachAlias? AttachOptions?\n"
	"Database <- 'DATABASE'i\n"
	"DatabasePath <- StringLiteral\n"
	"AttachAlias <- 'AS'i Identifier\n"
	"AttachOptions <- Parens(GenericCopyOptionList)\n"
	"DetachStatement <- 'DETACH'i Database? IfExists? CatalogName\n"
	"UseStatement <- 'USE'i UseTarget\n"
	"UseTarget <- (CatalogName '.' SchemaName) / SchemaName / CatalogName\n"
	"CallStatement <- 'CALL'i TableFunctionName TableFunctionArguments\n"

};

} // namespace duckdb
