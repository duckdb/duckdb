/* THIS FILE WAS AUTOMATICALLY GENERATED BY inline_grammar.py */
#pragma once

namespace duckdb {

const char INLINED_PEG_GRAMMAR[] = {
	"UnreservedKeyword <- 'ABORT' /\n"
	"'ABSOLUTE' /\n"
	"'ACCESS' /\n"
	"'ACTION' /\n"
	"'ADD' /\n"
	"'ADMIN' /\n"
	"'AFTER' /\n"
	"'AGGREGATE' /\n"
	"'ALSO' /\n"
	"'ALTER' /\n"
	"'ALWAYS' /\n"
	"'ASSERTION' /\n"
	"'ASSIGNMENT' /\n"
	"'ATTACH' /\n"
	"'ATTRIBUTE' /\n"
	"'BACKWARD' /\n"
	"'BEFORE' /\n"
	"'BEGIN' /\n"
	"'CACHE' /\n"
	"'CALL' /\n"
	"'CALLED' /\n"
	"'CASCADE' /\n"
	"'CASCADED' /\n"
	"'CATALOG' /\n"
	"'CENTURY' /\n"
	"'CENTURIES' /\n"
	"'CHAIN' /\n"
	"'CHARACTERISTICS' /\n"
	"'CHECKPOINT' /\n"
	"'CLASS' /\n"
	"'CLOSE' /\n"
	"'CLUSTER' /\n"
	"'COMMENT' /\n"
	"'COMMENTS' /\n"
	"'COMMIT' /\n"
	"'COMMITTED' /\n"
	"'COMPRESSION' /\n"
	"'CONFIGURATION' /\n"
	"'CONFLICT' /\n"
	"'CONNECTION' /\n"
	"'CONSTRAINTS' /\n"
	"'CONTENT' /\n"
	"'CONTINUE' /\n"
	"'CONVERSION' /\n"
	"'COPY' /\n"
	"'COST' /\n"
	"'CSV' /\n"
	"'CUBE' /\n"
	"'CURRENT' /\n"
	"'CURSOR' /\n"
	"'CYCLE' /\n"
	"'DATA' /\n"
	"'DATABASE' /\n"
	"'DAY' /\n"
	"'DAYS' /\n"
	"'DEALLOCATE' /\n"
	"'DECADE' /\n"
	"'DECADES' /\n"
	"'DECLARE' /\n"
	"'DEFAULTS' /\n"
	"'DEFERRED' /\n"
	"'DEFINER' /\n"
	"'DELETE' /\n"
	"'DELIMITER' /\n"
	"'DELIMITERS' /\n"
	"'DEPENDS' /\n"
	"'DETACH' /\n"
	"'DICTIONARY' /\n"
	"'DISABLE' /\n"
	"'DISCARD' /\n"
	"'DOCUMENT' /\n"
	"'DOMAIN' /\n"
	"'DOUBLE' /\n"
	"'DROP' /\n"
	"'EACH' /\n"
	"'ENABLE' /\n"
	"'ENCODING' /\n"
	"'ENCRYPTED' /\n"
	"'ENUM' /\n"
	"'ERROR' /\n"
	"'ESCAPE' /\n"
	"'EVENT' /\n"
	"'EXCLUDE' /\n"
	"'EXCLUDING' /\n"
	"'EXCLUSIVE' /\n"
	"'EXECUTE' /\n"
	"'EXPLAIN' /\n"
	"'EXPORT' /\n"
	"'EXPORT_STATE' /\n"
	"'EXTENSION' /\n"
	"'EXTENSIONS' /\n"
	"'EXTERNAL' /\n"
	"'FAMILY' /\n"
	"'FILTER' /\n"
	"'FIRST' /\n"
	"'FOLLOWING' /\n"
	"'FORCE' /\n"
	"'FORWARD' /\n"
	"'FUNCTION' /\n"
	"'FUNCTIONS' /\n"
	"'GLOBAL' /\n"
	"'GRANT' /\n"
	"'GRANTED' /\n"
	"'GROUPS' /\n"
	"'HANDLER' /\n"
	"'HEADER' /\n"
	"'HOLD' /\n"
	"'HOUR' /\n"
	"'HOURS' /\n"
	"'IDENTITY' /\n"
	"'IF' /\n"
	"'IGNORE' /\n"
	"'IMMEDIATE' /\n"
	"'IMMUTABLE' /\n"
	"'IMPLICIT' /\n"
	"'IMPORT' /\n"
	"'INCLUDE' /\n"
	"'INCLUDING' /\n"
	"'INCREMENT' /\n"
	"'INDEX' /\n"
	"'INDEXES' /\n"
	"'INHERIT' /\n"
	"'INHERITS' /\n"
	"'INLINE' /\n"
	"'INPUT' /\n"
	"'INSENSITIVE' /\n"
	"'INSERT' /\n"
	"'INSTALL' /\n"
	"'INSTEAD' /\n"
	"'INVOKER' /\n"
	"'JSON' /\n"
	"'ISOLATION' /\n"
	"'KEY' /\n"
	"'LABEL' /\n"
	"'LANGUAGE' /\n"
	"'LARGE' /\n"
	"'LAST' /\n"
	"'LEAKPROOF' /\n"
	"'LEVEL' /\n"
	"'LISTEN' /\n"
	"'LOAD' /\n"
	"'LOCAL' /\n"
	"'LOCATION' /\n"
	"'LOCK' /\n"
	"'LOCKED' /\n"
	"'LOGGED' /\n"
	"'MACRO' /\n"
	"'MAPPING' /\n"
	"'MATCH' /\n"
	"'MATCHED' /\n"
	"'MATERIALIZED' /\n"
	"'MAXVALUE' /\n"
	"'MERGE' /\n"
	"'METHOD' /\n"
	"'MICROSECOND' /\n"
	"'MICROSECONDS' /\n"
	"'MILLENNIUM' /\n"
	"'MILLENNIA' /\n"
	"'MILLISECOND' /\n"
	"'MILLISECONDS' /\n"
	"'MINUTE' /\n"
	"'MINUTES' /\n"
	"'MINVALUE' /\n"
	"'MODE' /\n"
	"'MONTH' /\n"
	"'MONTHS' /\n"
	"'MOVE' /\n"
	"'NAME' /\n"
	"'NAMES' /\n"
	"'NEW' /\n"
	"'NEXT' /\n"
	"'NO' /\n"
	"'NOTHING' /\n"
	"'NOTIFY' /\n"
	"'NOWAIT' /\n"
	"'NULLS' /\n"
	"'OBJECT' /\n"
	"'OF' /\n"
	"'OFF' /\n"
	"'OIDS' /\n"
	"'OLD' /\n"
	"'OPERATOR' /\n"
	"'OPTION' /\n"
	"'OPTIONS' /\n"
	"'ORDINALITY' /\n"
	"'OTHERS' /\n"
	"'OVER' /\n"
	"'OVERRIDING' /\n"
	"'OWNED' /\n"
	"'OWNER' /\n"
	"'PARALLEL' /\n"
	"'PARSER' /\n"
	"'PARTIAL' /\n"
	"'PARTITION' /\n"
	"'PARTITIONED' /\n"
	"'PASSING' /\n"
	"'PASSWORD' /\n"
	"'PERCENT' /\n"
	"'PERSISTENT' /\n"
	"'PLANS' /\n"
	"'POLICY' /\n"
	"'PRAGMA' /\n"
	"'PRECEDING' /\n"
	"'PREPARE' /\n"
	"'PREPARED' /\n"
	"'PRESERVE' /\n"
	"'PRIOR' /\n"
	"'PRIVILEGES' /\n"
	"'PROCEDURAL' /\n"
	"'PROCEDURE' /\n"
	"'PROGRAM' /\n"
	"'PUBLICATION' /\n"
	"'QUARTER' /\n"
	"'QUARTERS' /\n"
	"'QUOTE' /\n"
	"'RANGE' /\n"
	"'READ' /\n"
	"'REASSIGN' /\n"
	"'RECHECK' /\n"
	"'RECURSIVE' /\n"
	"'REF' /\n"
	"'REFERENCING' /\n"
	"'REFRESH' /\n"
	"'REINDEX' /\n"
	"'RELATIVE' /\n"
	"'RELEASE' /\n"
	"'RENAME' /\n"
	"'REPEATABLE' /\n"
	"'REPLACE' /\n"
	"'REPLICA' /\n"
	"'RESET' /\n"
	"'RESPECT' /\n"
	"'RESTART' /\n"
	"'RESTRICT' /\n"
	"'RETURNS' /\n"
	"'REVOKE' /\n"
	"'ROLE' /\n"
	"'ROLLBACK' /\n"
	"'ROLLUP' /\n"
	"'ROWS' /\n"
	"'RULE' /\n"
	"'SAMPLE' /\n"
	"'SAVEPOINT' /\n"
	"'SCHEMA' /\n"
	"'SCHEMAS' /\n"
	"'SCOPE' /\n"
	"'SCROLL' /\n"
	"'SEARCH' /\n"
	"'SECRET' /\n"
	"'SECOND' /\n"
	"'SECONDS' /\n"
	"'SECURITY' /\n"
	"'SEQUENCE' /\n"
	"'SEQUENCES' /\n"
	"'SERIALIZABLE' /\n"
	"'SERVER' /\n"
	"'SESSION' /\n"
	"'SET' /\n"
	"'SETS' /\n"
	"'SHARE' /\n"
	"'SIMPLE' /\n"
	"'SKIP' /\n"
	"'SNAPSHOT' /\n"
	"'SORTED' /\n"
	"'SOURCE' /\n"
	"'SQL' /\n"
	"'STABLE' /\n"
	"'STANDALONE' /\n"
	"'START' /\n"
	"'STATEMENT' /\n"
	"'STATISTICS' /\n"
	"'STDIN' /\n"
	"'STDOUT' /\n"
	"'STORAGE' /\n"
	"'STORED' /\n"
	"'STRICT' /\n"
	"'STRIP' /\n"
	"'SUBSCRIPTION' /\n"
	"'SYSID' /\n"
	"'SYSTEM' /\n"
	"'TABLES' /\n"
	"'TABLESPACE' /\n"
	"'TARGET' /\n"
	"'TEMP' /\n"
	"'TEMPLATE' /\n"
	"'TEMPORARY' /\n"
	"'TEXT' /\n"
	"'TIES' /\n"
	"'TRANSACTION' /\n"
	"'TRANSFORM' /\n"
	"'TRIGGER' /\n"
	"'TRUNCATE' /\n"
	"'TRUSTED' /\n"
	"'TYPE' /\n"
	"'TYPES' /\n"
	"'UNBOUNDED' /\n"
	"'UNCOMMITTED' /\n"
	"'UNENCRYPTED' /\n"
	"'UNKNOWN' /\n"
	"'UNLISTEN' /\n"
	"'UNLOGGED' /\n"
	"'UNTIL' /\n"
	"'UPDATE' /\n"
	"'USE' /\n"
	"'USER' /\n"
	"'VACUUM' /\n"
	"'VALID' /\n"
	"'VALIDATE' /\n"
	"'VALIDATOR' /\n"
	"'VALUE' /\n"
	"'VARIABLE' /\n"
	"'VARYING' /\n"
	"'VERSION' /\n"
	"'VIEW' /\n"
	"'VIEWS' /\n"
	"'VIRTUAL' /\n"
	"'VOLATILE' /\n"
	"'WEEK' /\n"
	"'WEEKS' /\n"
	"'WHITESPACE' /\n"
	"'WITHIN' /\n"
	"'WITHOUT' /\n"
	"'WORK' /\n"
	"'WRAPPER' /\n"
	"'WRITE' /\n"
	"'XML' /\n"
	"'YEAR' /\n"
	"'YEARS' /\n"
	"'YES' /\n"
	"'ZONE'\n"
	"ReservedKeyword <- 'ALL' /\n"
	"'ANALYSE' /\n"
	"'ANALYZE' /\n"
	"'AND' /\n"
	"'ANY' /\n"
	"'ARRAY' /\n"
	"'AS' /\n"
	"'ASC' /\n"
	"'ASYMMETRIC' /\n"
	"'BOTH' /\n"
	"'CASE' /\n"
	"'CAST' /\n"
	"'CHECK' /\n"
	"'COLLATE' /\n"
	"'COLUMN' /\n"
	"'CONSTRAINT' /\n"
	"'CREATE' /\n"
	"'DEFAULT' /\n"
	"'DEFERRABLE' /\n"
	"'DESC' /\n"
	"'DESCRIBE' /\n"
	"'DISTINCT' /\n"
	"'DO' /\n"
	"'ELSE' /\n"
	"'END' /\n"
	"'EXCEPT' /\n"
	"'FALSE' /\n"
	"'FETCH' /\n"
	"'FOR' /\n"
	"'FOREIGN' /\n"
	"'FROM' /\n"
	"'GROUP' /\n"
	"'HAVING' /\n"
	"'QUALIFY' /\n"
	"'IN' /\n"
	"'INITIALLY' /\n"
	"'INTERSECT' /\n"
	"'INTO' /\n"
	"'LAMBDA' /\n"
	"'LATERAL' /\n"
	"'LEADING' /\n"
	"'LIMIT' /\n"
	"'NOT' /\n"
	"'NULL' /\n"
	"'OFFSET' /\n"
	"'ON' /\n"
	"'ONLY' /\n"
	"'OR' /\n"
	"'ORDER' /\n"
	"'PIVOT' /\n"
	"'PIVOT_WIDER' /\n"
	"'PIVOT_LONGER' /\n"
	"'PLACING' /\n"
	"'PRIMARY' /\n"
	"'REFERENCES' /\n"
	"'RETURNING' /\n"
	"'SELECT' /\n"
	"'SHOW' /\n"
	"'SOME' /\n"
	"'SUMMARIZE' /\n"
	"'SYMMETRIC' /\n"
	"'TABLE' /\n"
	"'THEN' /\n"
	"'TO' /\n"
	"'TRAILING' /\n"
	"'TRUE' /\n"
	"'UNION' /\n"
	"'UNIQUE' /\n"
	"'UNPIVOT' /\n"
	"'USING' /\n"
	"'VARIADIC' /\n"
	"'WHEN' /\n"
	"'WHERE' /\n"
	"'WINDOW' /\n"
	"'WITH'\n"
	"ColumnNameKeyword <- 'BETWEEN' /\n"
	"'BIGINT' /\n"
	"'BIT' /\n"
	"'BOOLEAN' /\n"
	"'CHAR' /\n"
	"'CHARACTER' /\n"
	"'COALESCE' /\n"
	"'COLUMNS' /\n"
	"'DEC' /\n"
	"'DECIMAL' /\n"
	"'EXISTS' /\n"
	"'EXTRACT' /\n"
	"'FLOAT' /\n"
	"'GENERATED' /\n"
	"'GROUPING' /\n"
	"'GROUPING_ID' /\n"
	"'INOUT' /\n"
	"'INT' /\n"
	"'INTEGER' /\n"
	"'INTERVAL' /\n"
	"'MAP' /\n"
	"'NATIONAL' /\n"
	"'NCHAR' /\n"
	"'NONE' /\n"
	"'NULLIF' /\n"
	"'NUMERIC' /\n"
	"'OUT' /\n"
	"'OVERLAY' /\n"
	"'POSITION' /\n"
	"'PRECISION' /\n"
	"'REAL' /\n"
	"'ROW' /\n"
	"'SETOF' /\n"
	"'SMALLINT' /\n"
	"'SUBSTRING' /\n"
	"'STRUCT' /\n"
	"'TIME' /\n"
	"'TIMESTAMP' /\n"
	"'TREAT' /\n"
	"'TRIM' /\n"
	"'TRY_CAST' /\n"
	"'VALUES' /\n"
	"'VARCHAR' /\n"
	"'XMLATTRIBUTES' /\n"
	"'XMLCONCAT' /\n"
	"'XMLELEMENT' /\n"
	"'XMLEXISTS' /\n"
	"'XMLFOREST' /\n"
	"'XMLNAMESPACES' /\n"
	"'XMLPARSE' /\n"
	"'XMLPI' /\n"
	"'XMLROOT' /\n"
	"'XMLSERIALIZE' /\n"
	"'XMLTABLE'\n"
	"FuncNameKeyword <- 'ASOF' /\n"
	"'AT' /\n"
	"'AUTHORIZATION' /\n"
	"'BINARY' /\n"
	"'COLLATION' /\n"
	"'CONCURRENTLY' /\n"
	"'CROSS' /\n"
	"'FREEZE' /\n"
	"'FULL' /\n"
	"'GENERATED' /\n"
	"'GLOB' /\n"
	"'ILIKE' /\n"
	"'INNER' /\n"
	"'IS' /\n"
	"'ISNULL' /\n"
	"'JOIN' /\n"
	"'LEFT' /\n"
	"'LIKE' /\n"
	"'MAP' /\n"
	"'NATURAL' /\n"
	"'NOTNULL' /\n"
	"'OUTER' /\n"
	"'OVERLAPS' /\n"
	"'POSITIONAL' /\n"
	"'RIGHT' /\n"
	"'SIMILAR' /\n"
	"'STRUCT' /\n"
	"'TABLESAMPLE' /\n"
	"'VERBOSE'\n"
	"TypeNameKeyword <- 'ASOF' /\n"
	"'AT' /\n"
	"'AUTHORIZATION' /\n"
	"'BINARY' /\n"
	"'BY' /\n"
	"'COLLATION' /\n"
	"'COLUMNS' /\n"
	"'CONCURRENTLY' /\n"
	"'CROSS' /\n"
	"'FREEZE' /\n"
	"'FULL' /\n"
	"'GLOB' /\n"
	"'ILIKE' /\n"
	"'INNER' /\n"
	"'IS' /\n"
	"'ISNULL' /\n"
	"'JOIN' /\n"
	"'LEFT' /\n"
	"'LIKE' /\n"
	"'NATURAL' /\n"
	"'NOTNULL' /\n"
	"'OUTER' /\n"
	"'OVERLAPS' /\n"
	"'POSITIONAL' /\n"
	"'RIGHT' /\n"
	"'UNPACK' /\n"
	"'SIMILAR' /\n"
	"'TABLESAMPLE' /\n"
	"'TRY_CAST' /\n"
	"'VERBOSE' /\n"
	"'SEMI' /\n"
	"'ANTI'\n"
	"PivotStatement <- PivotKeyword TableRef PivotOn? PivotUsing? GroupByClause?\n"
	"PivotOn <- 'ON' PivotColumnList\n"
	"PivotUsing <- 'USING' TargetList\n"
	"PivotColumnList <- List(Expression)\n"
	"PivotKeyword <- 'PIVOT' / 'PIVOT_WIDER'\n"
	"UnpivotKeyword <- 'UNPIVOT' / 'PIVOT_LONGER'\n"
	"UnpivotStatement <- UnpivotKeyword TableRef 'ON' TargetList IntoNameValues?\n"
	"IntoNameValues <- 'INTO' 'NAME' ColIdOrString ValueOrValues List(Identifier)\n"
	"ValueOrValues <- 'VALUE' / 'VALUES'\n"
	"IncludeExcludeNulls <- ('INCLUDE' / 'EXCLUDE') 'NULLS'\n"
	"UnpivotHeader <- ColIdOrString / Parens(List(ColIdOrString))\n"
	"ColumnReference <- CatalogReservedSchemaTableColumnName / SchemaReservedTableColumnName / TableReservedColumnName / ColumnName\n"
	"CatalogReservedSchemaTableColumnName <- CatalogQualification ReservedSchemaQualification ReservedTableQualification ReservedColumnName\n"
	"SchemaReservedTableColumnName <- SchemaQualification ReservedTableQualification ReservedColumnName\n"
	"TableReservedColumnName <- TableQualification ReservedColumnName\n"
	"FunctionExpression <- FunctionIdentifier Parens(DistinctOrAll? List(FunctionArgument)? OrderByClause? IgnoreNulls?) WithinGroupClause? FilterClause? ExportClause? OverClause?\n"
	"FunctionIdentifier <- CatalogReservedSchemaFunctionName / SchemaReservedFunctionName / FunctionName\n"
	"CatalogReservedSchemaFunctionName <- CatalogQualification ReservedSchemaQualification? ReservedFunctionName\n"
	"SchemaReservedFunctionName <- SchemaQualification ReservedFunctionName\n"
	"DistinctOrAll <- 'DISTINCT' / 'ALL'\n"
	"ExportClause <- 'EXPORT_STATE'\n"
	"WithinGroupClause <- 'WITHIN' 'GROUP' Parens(OrderByClause)\n"
	"FilterClause <- 'FILTER' Parens('WHERE'? Expression)\n"
	"IgnoreNulls <- ('IGNORE' 'NULLS') / ('RESPECT' 'NULLS')\n"
	"ParenthesisExpression <- Parens(List(Expression))\n"
	"LiteralExpression <- StringLiteral / NumberLiteral / 'NULL' / 'TRUE' / 'FALSE'\n"
	"CastExpression <- CastOrTryCast Parens(Expression 'AS' Type)\n"
	"CastOrTryCast <- 'CAST' / 'TRY_CAST'\n"
	"StarExpression <- (ColId '.')* '*' ExcludeList? ReplaceList? RenameList?\n"
	"ExcludeList <- 'EXCLUDE' (Parens(List(ExcludeName)) / ExcludeName)\n"
	"ExcludeName <- DottedIdentifier / ColIdOrString\n"
	"ReplaceList <- 'REPLACE' (Parens(List(ReplaceEntry)) / ReplaceEntry)\n"
	"ReplaceEntry <- Expression 'AS' ColumnReference\n"
	"RenameList <- 'RENAME' (Parens(List(RenameEntry)) / RenameEntry)\n"
	"RenameEntry <- ColumnReference 'AS' Identifier\n"
	"SubqueryExpression <- 'NOT'? 'EXISTS'? SubqueryReference\n"
	"CaseExpression <- 'CASE' Expression? CaseWhenThen CaseWhenThen* CaseElse? 'END'\n"
	"CaseWhenThen <- 'WHEN' Expression 'THEN' Expression\n"
	"CaseElse <- 'ELSE' Expression\n"
	"TypeLiteral <- ColId StringLiteral\n"
	"IntervalLiteral <- 'INTERVAL' IntervalParameter IntervalUnit?\n"
	"IntervalParameter <- StringLiteral / NumberLiteral / Parens(Expression)\n"
	"IntervalUnit <- ColId\n"
	"FrameClause <- Framing FrameExtent WindowExcludeClause?\n"
	"Framing <- 'ROWS' / 'RANGE' / 'GROUPS'\n"
	"FrameExtent <- ('BETWEEN' FrameBound 'AND' FrameBound) / FrameBound\n"
	"FrameBound <- ('UNBOUNDED' 'PRECEDING') / ('UNBOUNDED' 'FOLLOWING') / ('CURRENT' 'ROW') / (Expression 'PRECEDING') / (Expression 'FOLLOWING')\n"
	"WindowExcludeClause <- 'EXCLUDE' WindowExcludeElement\n"
	"WindowExcludeElement <- ('CURRENT' 'ROW') / 'GROUP' / 'TIES' / ('NO' 'OTHERS')\n"
	"OverClause <- 'OVER' WindowFrame\n"
	"WindowFrame <- WindowFrameDefinition / Identifier / Parens(Identifier)\n"
	"WindowFrameDefinition <- Parens(BaseWindowName? WindowFrameContents) / Parens(WindowFrameContents)\n"
	"WindowFrameContents <- WindowPartition? OrderByClause? FrameClause?\n"
	"BaseWindowName <- Identifier\n"
	"WindowPartition <- 'PARTITION' 'BY' List(Expression)\n"
	"PrefixExpression <- PrefixOperator Expression\n"
	"PrefixOperator <- 'NOT' / '-' / '+' / '~'\n"
	"ListExpression <- 'ARRAY'? (BoundedListExpression / SelectStatement)\n"
	"BoundedListExpression <- '[' List(Expression)? ']'\n"
	"StructExpression <- '{' List(StructField)? '}'\n"
	"StructField <- Expression ':' Expression\n"
	"MapExpression <- 'MAP' StructExpression\n"
	"GroupingExpression <- GroupingOrGroupingId Parens(List(Expression))\n"
	"GroupingOrGroupingId <- 'GROUPING' / 'GROUPING_ID'\n"
	"Parameter <- '?' / NumberedParameter / ColLabelParameter\n"
	"NumberedParameter <- '$' NumberLiteral\n"
	"ColLabelParameter <- '$' ColLabel\n"
	"PositionalExpression <- '#' NumberLiteral\n"
	"DefaultExpression <- 'DEFAULT'\n"
	"ListComprehensionExpression <- '[' Expression 'FOR' List(Expression) ListComprehensionFilter? ']'\n"
	"ListComprehensionFilter <- 'IF' Expression\n"
	"SingleExpression <-\n"
	"	LiteralExpression /\n"
	"	Parameter /\n"
	"    SubqueryExpression /\n"
	"    SpecialFunctionExpression /\n"
	"    ParenthesisExpression /\n"
	"    IntervalLiteral /\n"
	"    TypeLiteral /\n"
	"    CaseExpression /\n"
	"    StarExpression /\n"
	"    CastExpression /\n"
	"    GroupingExpression /\n"
	"    MapExpression /\n"
	"    FunctionExpression /\n"
	"    ColumnReference /\n"
	"    PrefixExpression /\n"
	"    ListComprehensionExpression /\n"
	"    ListExpression /\n"
	"    StructExpression /\n"
	"    PositionalExpression /\n"
	"    DefaultExpression\n"
	"OperatorLiteral <- <[\\+\\-\\*\\/\\%\\^\\<\\>\\=\\~\\!\\@\\&\\|\\`]+>\n"
	"LikeOperator <- 'NOT'? LikeOrSimilarTo\n"
	"LikeOrSimilarTo <- 'LIKE' / 'ILIKE' / 'GLOB' / ('SIMILAR' 'TO')\n"
	"InOperator <- 'NOT'? 'IN'\n"
	"IsOperator <- 'IS' 'NOT'? DistinctFrom?\n"
	"DistinctFrom <- 'DISTINCT' 'FROM'\n"
	"ConjunctionOperator <- 'OR' / 'AND'\n"
	"ComparisonOperator <- '=' / '<=' / '>=' / '<' / '>' / '<>' / '!=' / '=='\n"
	"BetweenOperator <- 'NOT'? 'BETWEEN'\n"
	"CollateOperator <- 'COLLATE'\n"
	"LambdaOperator <- '->'\n"
	"EscapeOperator <- 'ESCAPE'\n"
	"AtTimeZoneOperator <- 'AT' 'TIME' 'ZONE'\n"
	"PostfixOperator <- '!'\n"
	"AnyAllOperator <- ComparisonOperator AnyOrAll\n"
	"AnyOrAll <- 'ANY' / 'ALL'\n"
	"Operator <-\n"
	"	AnyAllOperator /\n"
	"    ConjunctionOperator /\n"
	"    LikeOperator /\n"
	"    InOperator /\n"
	"    IsOperator /\n"
	"    BetweenOperator /\n"
	"    CollateOperator /\n"
	"    LambdaOperator /\n"
	"    EscapeOperator /\n"
	"    AtTimeZoneOperator /\n"
	"    OperatorLiteral\n"
	"CastOperator <- '::' Type\n"
	"DotOperator <- '.' (FunctionExpression / ColLabel)\n"
	"NotNull <- 'NOT' 'NULL'\n"
	"Indirection <- CastOperator / DotOperator / SliceExpression / NotNull / PostfixOperator\n"
	"BaseExpression <- SingleExpression Indirection*\n"
	"Expression <- BaseExpression RecursiveExpression*\n"
	"RecursiveExpression <- (Operator Expression)\n"
	"SliceExpression <- '[' SliceBound ']'\n"
	"SliceBound <- Expression? (':' (Expression / '-')?)? (':' Expression?)?\n"
	"SpecialFunctionExpression <- CoalesceExpression / UnpackExpression / ColumnsExpression / ExtractExpression / LambdaExpression / NullIfExpression / PositionExpression / RowExpression / SubstringExpression / TrimExpression\n"
	"CoalesceExpression <- 'COALESCE' Parens(List(Expression))\n"
	"UnpackExpression <- 'UNPACK' Parens(Expression)\n"
	"ColumnsExpression <- '*'? 'COLUMNS' Parens(Expression)\n"
	"ExtractExpression <- 'EXTRACT' Parens(Expression 'FROM' Expression)\n"
	"LambdaExpression <- 'LAMBDA' List(ColIdOrString) ':' Expression\n"
	"NullIfExpression <- 'NULLIF' Parens(Expression ',' Expression)\n"
	"PositionExpression <- 'POSITION' Parens(Expression)\n"
	"RowExpression <- 'ROW' Parens(List(Expression))\n"
	"SubstringExpression <- 'SUBSTRING' Parens(SubstringParameters / List(Expression))\n"
	"SubstringParameters <- Expression 'FROM' NumberLiteral 'FOR' NumberLiteral\n"
	"TrimExpression <- 'TRIM' Parens(TrimDirection? TrimSource? List(Expression))\n"
	"TrimDirection <- 'BOTH' / 'LEADING' / 'TRAILING'\n"
	"TrimSource <- Expression? 'FROM'\n"
	"ExecuteStatement <- 'EXECUTE' Identifier TableFunctionArguments?\n"
	"CreateSecretStmt <- 'SECRET' IfNotExists? SecretName? SecretStorageSpecifier? Parens(GenericCopyOptionList)\n"
	"SecretStorageSpecifier <- 'IN' Identifier\n"
	"CreateViewStmt <- 'RECURSIVE'? 'VIEW' IfNotExists? QualifiedName InsertColumnList? 'AS' SelectStatement\n"
	"DescribeStatement <- ShowTables / ShowSelect / ShowAllTables / ShowQualifiedName\n"
	"ShowSelect <- ShowOrDescribeOrSummarize SelectStatement\n"
	"ShowAllTables <- ShowOrDescribe 'ALL' 'TABLES'\n"
	"ShowQualifiedName <- ShowOrDescribeOrSummarize (BaseTableName / StringLiteral)?\n"
	"ShowTables <- ShowOrDescribe 'TABLES' 'FROM' QualifiedName\n"
	"ShowOrDescribeOrSummarize <- ShowOrDescribe / 'SUMMARIZE'\n"
	"ShowOrDescribe <- 'SHOW' / 'DESCRIBE' / 'DESC'\n"
	"VacuumStatement <- 'VACUUM' (VacuumLegacyOptions AnalyzeStatement / VacuumLegacyOptions QualifiedTarget / VacuumLegacyOptions / VacuumParensOptions QualifiedTarget?)?\n"
	"VacuumLegacyOptions <- OptFull OptFreeze OptVerbose\n"
	"VacuumParensOptions <- Parens(List(VacuumOption))\n"
	"VacuumOption <- 'ANALYZE' / 'VERBOSE' / 'FREEZE' / 'FULL' / Identifier\n"
	"OptFull <- 'FULL'?\n"
	"OptFreeze <- 'FREEZE'?\n"
	"OptVerbose <- 'VERBOSE'?\n"
	"QualifiedTarget <- QualifiedName OptNameList\n"
	"OptNameList <- Parens(List(Name))?\n"
	"MergeIntoStatement <- WithClause? 'MERGE' 'INTO' TargetOptAlias MergeIntoUsingClause MergeMatch* ReturningClause?\n"
	"MergeIntoUsingClause <- 'USING' TableRef JoinQualifier\n"
	"MergeMatch <- MatchedClause / NotMatchedClause\n"
	"MatchedClause <- 'WHEN' 'MATCHED' AndExpression? 'THEN' MatchedClauseAction\n"
	"MatchedClauseAction <- UpdateMatchClause / DeleteMatchClause / InsertMatchClause / DoNothingMatchClause / ErrorMatchClause\n"
	"UpdateMatchClause <- 'UPDATE' (UpdateMatchSetClause / ByNameOrPosition?)\n"
	"DeleteMatchClause <- 'DELETE'\n"
	"InsertMatchClause <- 'INSERT' (InsertValuesList / DefaultValues / InsertByNameOrPosition)?\n"
	"InsertByNameOrPosition <- ByNameOrPosition? '*'?\n"
	"InsertValuesList <- InsertColumnList? 'VALUES' Parens(List(Expression))\n"
	"DoNothingMatchClause <- 'DO' 'NOTHING'\n"
	"ErrorMatchClause <- 'ERROR' Expression?\n"
	"UpdateMatchSetClause <- 'SET' (UpdateSetClause / '*')\n"
	"AndExpression <- 'AND' Expression\n"
	"NotMatchedClause <- 'WHEN' 'NOT' 'MATCHED' BySourceOrTarget? AndExpression? 'THEN' MatchedClauseAction\n"
	"BySourceOrTarget <- 'BY' ('SOURCE' / 'TARGET')\n"
	"PragmaStatement <- 'PRAGMA' (PragmaAssign / PragmaFunction)\n"
	"PragmaAssign <- SettingName '=' VariableList\n"
	"PragmaFunction <- PragmaName PragmaParameters?\n"
	"PragmaParameters <- List(Expression)\n"
	"DeallocateStatement <- 'DEALLOCATE' 'PREPARE'? Identifier\n"
	"PrepareStatement <- 'PREPARE' Identifier TypeList? 'AS' Statement\n"
	"TypeList <- Parens(List(Type))\n"
	"CreateStatement <- 'CREATE' OrReplace? Temporary? (CreateTableStmt / CreateMacroStmt / CreateSequenceStmt / CreateTypeStmt / CreateSchemaStmt / CreateViewStmt / CreateIndexStmt / CreateSecretStmt)\n"
	"OrReplace <- 'OR' 'REPLACE'\n"
	"Temporary <- 'TEMP' / 'TEMPORARY' / 'PERSISTENT'\n"
	"CreateTableStmt <- 'TABLE' IfNotExists? QualifiedName (CreateTableAs / CreateColumnList) CommitAction?\n"
	"CreateTableAs <- IdentifierList? 'AS' SelectStatement WithData?\n"
	"WithData <- 'WITH' 'NO'? 'DATA'\n"
	"IdentifierList <- Parens(List(Identifier))\n"
	"CreateColumnList <- Parens(CreateTableColumnList)\n"
	"IfNotExists <- 'IF' 'NOT' 'EXISTS'\n"
	"QualifiedName <- CatalogReservedSchemaIdentifier / SchemaReservedIdentifierOrStringLiteral / IdentifierOrStringLiteral\n"
	"SchemaReservedIdentifierOrStringLiteral <- SchemaQualification ReservedIdentifierOrStringLiteral\n"
	"CatalogReservedSchemaIdentifier <- CatalogQualification ReservedSchemaQualification ReservedIdentifierOrStringLiteral\n"
	"IdentifierOrStringLiteral <- Identifier / StringLiteral\n"
	"ReservedIdentifierOrStringLiteral <- ReservedIdentifier / StringLiteral\n"
	"CatalogQualification <- CatalogName '.'\n"
	"SchemaQualification <- SchemaName '.'\n"
	"ReservedSchemaQualification <- ReservedSchemaName '.'\n"
	"TableQualification <- TableName '.'\n"
	"ReservedTableQualification <- ReservedTableName '.'\n"
	"CreateTableColumnList <- List(CreateTableColumnElement)\n"
	"CreateTableColumnElement <- ColumnDefinition / TopLevelConstraint\n"
	"ColumnDefinition <- DottedIdentifier TypeOrGenerated ColumnConstraint*\n"
	"TypeOrGenerated <- Type? GeneratedColumn?\n"
	"ColumnConstraint <- NotNullConstraint / UniqueConstraint / PrimaryKeyConstraint / DefaultValue / CheckConstraint / ForeignKeyConstraint / ColumnCollation / ColumnCompression\n"
	"NotNullConstraint <- 'NOT'? 'NULL'\n"
	"UniqueConstraint <- 'UNIQUE'\n"
	"PrimaryKeyConstraint <- 'PRIMARY' 'KEY'\n"
	"DefaultValue <- 'DEFAULT' Expression\n"
	"CheckConstraint <- 'CHECK' Parens(Expression)\n"
	"ForeignKeyConstraint <- 'REFERENCES' BaseTableName Parens(ColumnList)? KeyActions?\n"
	"ColumnCollation <- 'COLLATE' Expression\n"
	"ColumnCompression <- 'USING' 'COMPRESSION' ColIdOrString\n"
	"KeyActions <- UpdateAction? DeleteAction?\n"
	"UpdateAction <- 'ON' 'UPDATE' KeyAction\n"
	"DeleteAction <- 'ON' 'DELETE' KeyAction\n"
	"KeyAction <- ('NO' 'ACTION') / 'RESTRICT' / 'CASCADE' / ('SET' 'NULL') / ('SET' 'DEFAULT')\n"
	"TopLevelConstraint <- ConstraintNameClause? TopLevelConstraintList\n"
	"TopLevelConstraintList <- TopPrimaryKeyConstraint / CheckConstraint / TopUniqueConstraint / TopForeignKeyConstraint\n"
	"ConstraintNameClause <- 'CONSTRAINT' Identifier\n"
	"TopPrimaryKeyConstraint <- 'PRIMARY' 'KEY' ColumnIdList\n"
	"TopUniqueConstraint <- 'UNIQUE' ColumnIdList\n"
	"TopForeignKeyConstraint <- 'FOREIGN' 'KEY' ColumnIdList ForeignKeyConstraint\n"
	"ColumnIdList <- Parens(List(ColId))\n"
	"PlainIdentifier <- !ReservedKeyword <[a-z_]i[a-z0-9_]i*>\n"
	"QuotedIdentifier <- '\"' [^\"]* '\"'\n"
	"DottedIdentifier <- Identifier ('.' Identifier)*\n"
	"Identifier <- QuotedIdentifier / PlainIdentifier\n"
	"ColId <- UnreservedKeyword / ColumnNameKeyword / Identifier\n"
	"ColIdOrString <- ColId / StringLiteral\n"
	"FuncName <- UnreservedKeyword / FuncNameKeyword / Identifier\n"
	"TypeFuncName <- UnreservedKeyword / TypeNameKeyword / FuncNameKeyword / Identifier\n"
	"TypeName <- UnreservedKeyword / TypeNameKeyword / Identifier\n"
	"ColLabel <- ReservedKeyword / UnreservedKeyword / ColumnNameKeyword / FuncNameKeyword / TypeNameKeyword / Identifier\n"
	"ColLabelOrString <- ColLabel / StringLiteral\n"
	"GeneratedColumn <- Generated? 'AS' Parens(Expression) GeneratedColumnType?\n"
	"Generated <- 'GENERATED' AlwaysOrByDefault?\n"
	"AlwaysOrByDefault <- 'ALWAYS' / ('BY' 'DEFAULT')\n"
	"GeneratedColumnType <- 'VIRTUAL' / 'STORED'\n"
	"CommitAction <- 'ON' 'COMMIT' PreserveOrDelete\n"
	"PreserveOrDelete <- ('PRESERVE' / 'DELETE') 'ROWS'\n"
	"CreateIndexStmt <- Unique? 'INDEX' IfNotExists? IndexName? 'ON' BaseTableName IndexType? Parens(List(IndexElement)) WithList? WhereClause?\n"
	"WithList <- 'WITH' Parens(List(RelOption)) / Oids\n"
	"Oids <- ('WITH' / 'WITHOUT') 'OIDS'\n"
	"IndexElement <- Expression DescOrAsc? NullsFirstOrLast?\n"
	"Unique <- 'UNIQUE'\n"
	"IndexType <- 'USING' Identifier\n"
	"RelOption <- ColLabel ('.' ColLabel)* ('=' DefArg)?\n"
	"DefArg <- FuncType / ReservedKeyword / StringLiteral / NumberLiteral / 'NONE'\n"
	"FuncType <- Type / ('SETOF'? TypeFuncName '%' 'TYPE')\n"
	"LoadStatement <- 'LOAD' ColIdOrString\n"
	"InstallStatement <- 'FORCE'? 'INSTALL' Identifier FromSource? VersionNumber?\n"
	"FromSource <- 'FROM' (Identifier / StringLiteral)\n"
	"VersionNumber <- Identifier\n"
	"DropStatement <- 'DROP' DropEntries DropBehavior?\n"
	"DropEntries <-\n"
	"	DropTable /\n"
	"	DropTableFunction /\n"
	"	DropFunction /\n"
	"	DropSchema /\n"
	"	DropIndex /\n"
	"	DropSequence /\n"
	"	DropCollation /\n"
	"	DropType /\n"
	"	DropSecret\n"
	"DropTable <- TableOrView IfExists? List(BaseTableName)\n"
	"DropTableFunction <- 'MACRO' 'TABLE' IfExists? List(TableFunctionName)\n"
	"DropFunction <- FunctionType IfExists? List(FunctionIdentifier)\n"
	"DropSchema <- 'SCHEMA' IfExists? List(QualifiedSchemaName)\n"
	"DropIndex <- 'INDEX' IfExists? List(QualifiedIndexName)\n"
	"QualifiedIndexName <- CatalogQualification? SchemaQualification? IndexName\n"
	"DropSequence <- 'SEQUENCE' IfExists? List(QualifiedSequenceName)\n"
	"DropCollation <- 'COLLATION' IfExists? List(CollationName)\n"
	"DropType <- 'TYPE' IfExists? List(QualifiedTypeName)\n"
	"DropSecret <- Temporary? 'SECRET' IfExists? SecretName DropSecretStorage?\n"
	"TableOrView <- 'TABLE' / 'VIEW' / ('MATERIALIZED' 'VIEW')\n"
	"FunctionType <- 'MACRO' / 'FUNCTION'\n"
	"DropBehavior <- 'CASCADE' / 'RESTRICT'\n"
	"IfExists <- 'IF' 'EXISTS'\n"
	"QualifiedSchemaName <- CatalogQualification? SchemaName\n"
	"DropSecretStorage <- 'FROM' Identifier\n"
	"UpdateStatement <- WithClause? 'UPDATE' UpdateTarget UpdateSetClause FromClause? WhereClause? ReturningClause?\n"
	"UpdateTarget <- (BaseTableName 'SET') / (BaseTableName UpdateAlias? 'SET')\n"
	"UpdateAlias <- 'AS'? ColId\n"
	"UpdateSetClause <- List(UpdateSetElement) / (Parens(List(ColumnName)) '=' Expression)\n"
	"UpdateSetElement <- ColumnName '=' Expression\n"
	"InsertStatement <- WithClause? 'INSERT' OrAction? 'INTO' InsertTarget ByNameOrPosition? InsertColumnList? InsertValues OnConflictClause? ReturningClause?\n"
	"OrAction <- 'OR' 'REPLACE' / 'IGNORE'\n"
	"ByNameOrPosition <- 'BY' 'NAME' / 'POSITION'\n"
	"InsertTarget <- BaseTableName InsertAlias?\n"
	"InsertAlias <- 'AS' Identifier\n"
	"ColumnList <- List(ColId)\n"
	"InsertColumnList <- Parens(ColumnList)\n"
	"InsertValues <- SelectStatement / DefaultValues\n"
	"DefaultValues <- 'DEFAULT' 'VALUES'\n"
	"OnConflictClause <- 'ON' 'CONFLICT' OnConflictTarget? OnConflictAction\n"
	"OnConflictTarget <- OnConflictExpressionTarget / OnConflictIndexTarget\n"
	"OnConflictExpressionTarget <- Parens(List(ColId)) WhereClause?\n"
	"OnConflictIndexTarget <- 'ON' 'CONSTRAINT' ConstraintName\n"
	"OnConflictAction <- OnConflictUpdate / OnConflictNothing\n"
	"OnConflictUpdate <- 'DO' 'UPDATE' 'SET' UpdateSetClause WhereClause?\n"
	"OnConflictNothing <- 'DO' 'NOTHING'\n"
	"ReturningClause <- 'RETURNING' TargetList\n"
	"CreateSchemaStmt <- 'SCHEMA' IfNotExists? QualifiedName\n"
	"SelectStatement <- SelectOrParens (SetopClause SelectStatement)* ResultModifiers\n"
	"SetopClause <- ('UNION' / 'EXCEPT' / 'INTERSECT') DistinctOrAll? ByName?\n"
	"ByName <- 'BY' 'NAME'\n"
	"SelectOrParens <- BaseSelect / Parens(SelectStatement)\n"
	"BaseSelect <- WithClause? (OptionalParensSimpleSelect / ValuesClause / DescribeStatement / TableStatement / PivotStatement / UnpivotStatement) ResultModifiers\n"
	"ResultModifiers <- OrderByClause? LimitClause? OffsetClause?\n"
	"TableStatement <- 'TABLE' BaseTableName\n"
	"OptionalParensSimpleSelect <- Parens(SimpleSelect) / SimpleSelect\n"
	"SimpleSelect <- SelectFrom WhereClause? GroupByClause? HavingClause? WindowClause? QualifyClause? SampleClause?\n"
	"SelectFrom <- (SelectClause FromClause?) / (FromClause SelectClause?)\n"
	"WithStatement <- ColIdOrString InsertColumnList? UsingKey? 'AS' Materialized? SubqueryReference\n"
	"UsingKey <- 'USING' 'KEY' Parens(List(ColId))\n"
	"Materialized <- 'NOT'? 'MATERIALIZED'\n"
	"WithClause <- 'WITH' Recursive? List(WithStatement)\n"
	"Recursive <- 'RECURSIVE'\n"
	"SelectClause <- 'SELECT' DistinctClause? TargetList\n"
	"TargetList <- List(AliasedExpression)\n"
	"ColumnAliases <- Parens(List(ColIdOrString))\n"
	"DistinctClause <- ('DISTINCT' DistinctOn?) / 'ALL'\n"
	"DistinctOn <- 'ON' Parens(List(Expression))\n"
	"InnerTableRef <- ValuesRef / TableFunction / TableSubquery / BaseTableRef / ParensTableRef\n"
	"TableRef <- InnerTableRef JoinOrPivot* TableAlias?\n"
	"TableSubquery <- Lateral? SubqueryReference TableAlias?\n"
	"BaseTableRef <- TableAliasColon? BaseTableName TableAlias? AtClause?\n"
	"TableAliasColon <- ColIdOrString ':'\n"
	"ValuesRef <- ValuesClause TableAlias?\n"
	"ParensTableRef <- TableAliasColon? Parens(TableRef)\n"
	"JoinOrPivot <- JoinClause / TablePivotClause / TableUnpivotClause\n"
	"TablePivotClause <- 'PIVOT' Parens(TargetList 'FOR' PivotValueLists GroupByClause?) TableAlias?\n"
	"TableUnpivotClause <- 'UNPIVOT' IncludeExcludeNulls? Parens(UnpivotHeader 'FOR' PivotValueLists) TableAlias?\n"
	"PivotHeader <- BaseExpression\n"
	"PivotValueLists <- PivotValueList PivotValueList*\n"
	"PivotValueList <- PivotHeader 'IN' PivotTargetList\n"
	"PivotTargetList <- Identifier / Parens(TargetList)\n"
	"Lateral <- 'LATERAL'\n"
	"BaseTableName <- CatalogReservedSchemaTable / SchemaReservedTable / TableName\n"
	"SchemaReservedTable <- SchemaQualification ReservedTableName\n"
	"CatalogReservedSchemaTable <- CatalogQualification ReservedSchemaQualification ReservedTableName\n"
	"TableFunction <- TableFunctionLateralOpt / TableFunctionAliasColon\n"
	"TableFunctionLateralOpt <- Lateral? QualifiedTableFunction TableFunctionArguments WithOrdinality? TableAlias?\n"
	"TableFunctionAliasColon <- TableAliasColon QualifiedTableFunction TableFunctionArguments WithOrdinality?\n"
	"WithOrdinality <- 'WITH' 'ORDINALITY'\n"
	"QualifiedTableFunction <- CatalogQualification? SchemaQualification? TableFunctionName\n"
	"TableFunctionArguments <- Parens(List(FunctionArgument)?)\n"
	"FunctionArgument <- NamedParameter / Expression\n"
	"NamedParameter <- TypeName Type? NamedParameterAssignment Expression\n"
	"NamedParameterAssignment <- ':=' / '=>'\n"
	"TableAlias <- 'AS'? (Identifier / StringLiteral) ColumnAliases?\n"
	"AtClause <- 'AT' Parens(AtSpecifier)\n"
	"AtSpecifier <- AtUnit '=>' Expression\n"
	"AtUnit <- 'VERSION' / 'TIMESTAMP'\n"
	"JoinClause <- RegularJoinClause / JoinWithoutOnClause\n"
	"RegularJoinClause <- 'ASOF'? JoinType? 'JOIN' TableRef JoinQualifier\n"
	"JoinWithoutOnClause <- JoinPrefix 'JOIN' TableRef\n"
	"JoinQualifier <- OnClause / UsingClause\n"
	"OnClause <- 'ON' Expression\n"
	"UsingClause <- 'USING' Parens(List(ColumnName))\n"
	"OuterJoinType <- 'FULL' / 'LEFT' / 'RIGHT'\n"
	"JoinType <- (OuterJoinType 'OUTER'?) / 'SEMI' / 'ANTI' / 'INNER'\n"
	"JoinPrefix <- 'CROSS' / ('NATURAL' JoinType?) / 'POSITIONAL'\n"
	"FromClause <- 'FROM' List(TableRef)\n"
	"WhereClause <- 'WHERE' Expression\n"
	"GroupByClause <- 'GROUP' 'BY' GroupByExpressions\n"
	"HavingClause <- 'HAVING' Expression\n"
	"QualifyClause <- 'QUALIFY' Expression\n"
	"SampleClause <- (TableSample / UsingSample) SampleEntry\n"
	"UsingSample <- 'USING' 'SAMPLE'\n"
	"TableSample <- 'TABLESAMPLE'\n"
	"WindowClause <- 'WINDOW' List(WindowDefinition)\n"
	"WindowDefinition <- Identifier 'AS' WindowFrameDefinition\n"
	"SampleEntry <- SampleEntryFunction / SampleEntryCount\n"
	"SampleEntryCount <- SampleCount Parens(SampleProperties)?\n"
	"SampleEntryFunction <- SampleFunction? Parens(SampleCount) RepeatableSample?\n"
	"SampleFunction <- ColId\n"
	"SampleProperties <- ColId (',' NumberLiteral)?\n"
	"RepeatableSample <- 'REPEATABLE' Parens(NumberLiteral)\n"
	"SampleCount <- Expression SampleUnit?\n"
	"SampleUnit <- '%' / 'PERCENT' / 'ROWS'\n"
	"GroupByExpressions <- GroupByList / 'ALL'\n"
	"GroupByList <- List(GroupByExpression)\n"
	"GroupByExpression <- EmptyGroupingItem / CubeOrRollupClause / GroupingSetsClause / Expression\n"
	"EmptyGroupingItem <- '(' ')'\n"
	"CubeOrRollupClause <- CubeOrRollup Parens(List(Expression))\n"
	"CubeOrRollup <- 'CUBE' / 'ROLLUP'\n"
	"GroupingSetsClause <- 'GROUPING' 'SETS' Parens(GroupByList)\n"
	"SubqueryReference <- Parens(SelectStatement)\n"
	"OrderByExpression <- Expression DescOrAsc? NullsFirstOrLast?\n"
	"DescOrAsc <- 'DESC' / 'DESCENDING' / 'ASC' / 'ASCENDING'\n"
	"NullsFirstOrLast <- 'NULLS' 'FIRST' / 'LAST'\n"
	"OrderByClause <- 'ORDER' 'BY' OrderByExpressions\n"
	"OrderByExpressions <- List(OrderByExpression) / OrderByAll\n"
	"OrderByAll <- 'ALL' DescOrAsc? NullsFirstOrLast?\n"
	"LimitClause <- 'LIMIT' LimitValue\n"
	"OffsetClause <- 'OFFSET' OffsetValue\n"
	"LimitValue <- 'ALL' / (NumberLiteral 'PERCENT') / (Expression '%'?)\n"
	"OffsetValue <- Expression RowOrRows?\n"
	"RowOrRows <- 'ROW' / 'ROWS'\n"
	"AliasedExpression <- (ColId ':' Expression) / (Expression 'AS' ColLabelOrString) / (Expression Identifier?)\n"
	"ValuesClause <- 'VALUES' List(ValuesExpressions)\n"
	"ValuesExpressions <- Parens(List(Expression))\n"
	"TransactionStatement <- BeginTransaction / RollbackTransaction / CommitTransaction\n"
	"BeginTransaction <- StartOrBegin Transaction? ReadOrWrite?\n"
	"RollbackTransaction <- AbortOrRollback Transaction?\n"
	"CommitTransaction <- CommitOrEnd Transaction?\n"
	"StartOrBegin <- 'START' / 'BEGIN'\n"
	"Transaction <- 'WORK' / 'TRANSACTION'\n"
	"ReadOrWrite <- 'READ' ('ONLY' / 'WRITE')\n"
	"AbortOrRollback <- 'ABORT' / 'ROLLBACK'\n"
	"CommitOrEnd <- 'COMMIT' / 'END'\n"
	"DeleteStatement <- WithClause? 'DELETE' 'FROM' TargetOptAlias DeleteUsingClause? WhereClause? ReturningClause?\n"
	"TruncateStatement <- 'TRUNCATE' 'TABLE'? BaseTableName\n"
	"TargetOptAlias <- BaseTableName 'AS'? ColId?\n"
	"DeleteUsingClause <- 'USING' List(TableRef)\n"
	"CreateTypeStmt <- 'TYPE' IfNotExists? QualifiedName 'AS' CreateType\n"
	"CreateType <- ('ENUM' Parens(SelectStatement)) /\n"
	"              ('ENUM' Parens(List(StringLiteral))) /\n"
	"              Type\n"
	"SetStatement <- 'SET' (StandardAssignment / SetTimeZone)\n"
	"StandardAssignment <- (SetVariable / SetSetting) SetAssignment\n"
	"SetTimeZone <- 'TIME' 'ZONE' Expression\n"
	"SetSetting <- SettingScope? SettingName\n"
	"SetVariable <- 'VARIABLE' Identifier\n"
	"SettingScope <- 'LOCAL' / 'SESSION' / 'GLOBAL'\n"
	"SetAssignment <- VariableAssign VariableList\n"
	"VariableAssign <- '=' / 'TO'\n"
	"VariableList <- List(Expression)\n"
	"ResetStatement <- 'RESET' (SetVariable / SetSetting)\n"
	"ExportStatement <- 'EXPORT' 'DATABASE' ExportSource? StringLiteral Parens(GenericCopyOptionList)?\n"
	"ExportSource <- CatalogName 'TO'\n"
	"ImportStatement <- 'IMPORT' 'DATABASE' StringLiteral\n"
	"CheckpointStatement <- 'FORCE'? 'CHECKPOINT' CatalogName?\n"
	"CopyStatement <- 'COPY' (CopyTable / CopySelect / CopyFromDatabase)\n"
	"CopyTable <- BaseTableName InsertColumnList? FromOrTo CopyFileName CopyOptions?\n"
	"FromOrTo <- 'FROM' / 'TO'\n"
	"CopySelect <- Parens(SelectStatement) 'TO' CopyFileName CopyOptions?\n"
	"CopyFileName <- Expression / StringLiteral / Identifier / (Identifier '.' ColId)\n"
	"CopyOptions <- 'WITH'? (Parens(GenericCopyOptionList) / (SpecializedOptions*))\n"
	"SpecializedOptions <-\n"
	"	'BINARY' / 'FREEZE' / 'OIDS' / 'CSV' / 'HEADER' /\n"
	"	SpecializedStringOption /\n"
	"	('ENCODING' StringLiteral) /\n"
	"	('FORCE' 'QUOTE' StarOrColumnList) /\n"
	"	('PARTITION' 'BY' StarOrColumnList) /\n"
	"	('FORCE' 'NOT'? 'NULL' ColumnList)\n"
	"SpecializedStringOption <- ('DELIMITER' / 'NULL' / 'QUOTE' / 'ESCAPE') 'AS'? StringLiteral\n"
	"StarOrColumnList <- '*' / ColumnList\n"
	"GenericCopyOptionList <- List(GenericCopyOption)\n"
	"GenericCopyOption <- GenericCopyOptionName Expression?\n"
	"# FIXME: should not need to hard-code options here\n"
	"GenericCopyOptionName <- 'ARRAY' / 'NULL' / 'ANALYZE' / CopyOptionName\n"
	"CopyFromDatabase <- 'FROM' 'DATABASE' ColId 'TO' ColId CopyDatabaseFlag?\n"
	"CopyDatabaseFlag <- Parens(SchemaOrData)\n"
	"SchemaOrData <- 'SCHEMA' / 'DATA'\n"
	"AlterStatement <- 'ALTER' AlterOptions\n"
	"AlterOptions <- AlterTableStmt / AlterViewStmt / AlterSequenceStmt / AlterDatabaseStmt / AlterSchemaStmt\n"
	"AlterTableStmt <- 'TABLE' IfExists? BaseTableName AlterTableOptions\n"
	"AlterSchemaStmt <- 'SCHEMA' IfExists? QualifiedName RenameAlter\n"
	"AlterTableOptions <- AddColumn / DropColumn / AlterColumn / AddConstraint / ChangeNullability / RenameColumn / RenameAlter / SetPartitionedBy / ResetPartitionedBy / SetSortedBy / ResetSortedBy\n"
	"AddConstraint <- 'ADD' TopLevelConstraint\n"
	"AddColumn <- 'ADD' 'COLUMN'? IfNotExists? ColumnDefinition\n"
	"DropColumn <- 'DROP' 'COLUMN'? IfExists? NestedColumnName DropBehavior?\n"
	"AlterColumn <- 'ALTER' 'COLUMN'? NestedColumnName AlterColumnEntry\n"
	"RenameColumn <- 'RENAME' 'COLUMN'? NestedColumnName 'TO' Identifier\n"
	"NestedColumnName <- (Identifier '.')* ColumnName\n"
	"RenameAlter <- 'RENAME' 'TO' Identifier\n"
	"SetPartitionedBy <- 'SET' 'PARTITIONED' 'BY' Parens(List(Expression))\n"
	"ResetPartitionedBy <- 'RESET' 'PARTITIONED' 'BY'\n"
	"SetSortedBy <- 'SET' 'SORTED' 'BY' Parens(OrderByExpressions)\n"
	"ResetSortedBy <- 'RESET' 'SORTED' 'BY'\n"
	"AlterColumnEntry <- AddOrDropDefault / ChangeNullability / AlterType\n"
	"AddOrDropDefault <- AddDefault / DropDefault\n"
	"AddDefault <- 'SET' 'DEFAULT' Expression\n"
	"DropDefault <- 'DROP' 'DEFAULT'\n"
	"ChangeNullability <- ('DROP' / 'SET') 'NOT' 'NULL'\n"
	"AlterType <- SetData? 'TYPE' Type? UsingExpression?\n"
	"SetData <- 'SET' 'DATA'?\n"
	"UsingExpression <- 'USING' Expression\n"
	"AlterViewStmt <- 'VIEW' IfExists? BaseTableName RenameAlter\n"
	"AlterSequenceStmt <- 'SEQUENCE' IfExists? QualifiedSequenceName AlterSequenceOptions\n"
	"QualifiedSequenceName <- CatalogQualification? SchemaQualification? SequenceName\n"
	"AlterSequenceOptions <- RenameAlter / SetSequenceOption\n"
	"SetSequenceOption <- List(SequenceOption)\n"
	"AlterDatabaseStmt <- 'DATABASE' IfExists? Identifier RenameDatabaseAlter\n"
	"RenameDatabaseAlter <- 'RENAME' 'TO' Identifier\n"
	"CreateSequenceStmt <- 'SEQUENCE' IfNotExists? QualifiedName SequenceOption*\n"
	"SequenceOption <-\n"
	"	SeqSetCycle /\n"
	"	SeqSetIncrement /\n"
	"	SeqSetMinMax /\n"
	"	SeqNoMinMax /\n"
	"	SeqStartWith /\n"
	"	SeqOwnedBy\n"
	"SeqSetCycle <- 'NO'? 'CYCLE'\n"
	"SeqSetIncrement <- 'INCREMENT' 'BY'? Expression\n"
	"SeqSetMinMax <- SeqMinOrMax Expression\n"
	"SeqNoMinMax <- 'NO' SeqMinOrMax\n"
	"SeqStartWith <- 'START' 'WITH'? Expression\n"
	"SeqOwnedBy <- 'OWNED' 'BY' QualifiedName\n"
	"SeqMinOrMax <- 'MINVALUE' / 'MAXVALUE'\n"
	"Statement <-\n"
	"	CreateStatement /\n"
	"	SelectStatement /\n"
	"	SetStatement /\n"
	"	PragmaStatement /\n"
	"	CallStatement /\n"
	"	InsertStatement /\n"
	"	DropStatement /\n"
	"	CopyStatement /\n"
	"	ExplainStatement /\n"
	"	UpdateStatement /\n"
	"	PrepareStatement /\n"
	"	ExecuteStatement /\n"
	"	AlterStatement /\n"
	"	TransactionStatement /\n"
	"	DeleteStatement /\n"
	"	AttachStatement /\n"
	"	UseStatement /\n"
	"	DetachStatement /\n"
	"	CheckpointStatement /\n"
	"	VacuumStatement /\n"
	"	ResetStatement /\n"
	"	ExportStatement /\n"
	"	ImportStatement /\n"
	"	CommentStatement /\n"
	"	DeallocateStatement /\n"
	"	TruncateStatement /\n"
	"	LoadStatement /\n"
	"	InstallStatement /\n"
	"	AnalyzeStatement /\n"
	"	MergeIntoStatement\n"
	"CatalogName <- Identifier\n"
	"SchemaName <- Identifier\n"
	"ReservedSchemaName <- Identifier\n"
	"TableName <- Identifier\n"
	"ReservedTableName <- Identifier\n"
	"ReservedIdentifier <- Identifier\n"
	"ColumnName <- Identifier\n"
	"ReservedColumnName <- Identifier\n"
	"IndexName <- Identifier\n"
	"SettingName <- Identifier\n"
	"PragmaName <- Identifier\n"
	"FunctionName <- Identifier\n"
	"ReservedFunctionName <- Identifier\n"
	"TableFunctionName <- Identifier\n"
	"ConstraintName <- ColIdOrString\n"
	"SequenceName <- Identifier\n"
	"CollationName <- Identifier\n"
	"CopyOptionName <- ColLabel\n"
	"SecretName <- ColId\n"
	"NumberLiteral <- < [+-]?[0-9]*([.][0-9]*)? >\n"
	"StringLiteral <- '\\'' [^\\']* '\\''\n"
	"Type <- (TimeType / IntervalType / BitType / RowType / MapType / UnionType / NumericType / SetofType / SimpleType) ArrayBounds*\n"
	"SimpleType <- (QualifiedTypeName / CharacterType) TypeModifiers?\n"
	"CharacterType <- ('CHARACTER' 'VARYING'?) /\n"
	"                 ('CHAR' 'VARYING'?) /\n"
	"                 ('NATIONAL' 'CHARACTER' 'VARYING'?) /\n"
	"                 ('NATIONAL' 'CHAR' 'VARYING'?) /\n"
	"                 ('NCHAR' 'VARYING'?) /\n"
	"                 'VARCHAR'\n"
	"IntervalType <- ('INTERVAL' Interval?) / ('INTERVAL' Parens(NumberLiteral))\n"
	"YearKeyword         <- 'YEAR' / 'YEARS'\n"
	"MonthKeyword        <- 'MONTH' / 'MONTHS'\n"
	"DayKeyword          <- 'DAY' / 'DAYS'\n"
	"HourKeyword         <- 'HOUR' / 'HOURS'\n"
	"MinuteKeyword       <- 'MINUTE' / 'MINUTES'\n"
	"SecondKeyword       <- 'SECOND' / 'SECONDS'\n"
	"MillisecondKeyword  <- 'MILLISECOND' / 'MILLISECONDS'\n"
	"MicrosecondKeyword  <- 'MICROSECOND' / 'MICROSECONDS'\n"
	"WeekKeyword         <- 'WEEK' / 'WEEKS'\n"
	"QuarterKeyword      <- 'QUARTER' / 'QUARTERS'\n"
	"DecadeKeyword       <- 'DECADE' / 'DECADES'\n"
	"CenturyKeyword      <- 'CENTURY' / 'CENTURIES'\n"
	"MillenniumKeyword   <- 'MILLENNIUM' / 'MILLENNIA'\n"
	"Interval <- YearKeyword /\n"
	"    MonthKeyword /\n"
	"    DayKeyword /\n"
	"    HourKeyword /\n"
	"    MinuteKeyword /\n"
	"    SecondKeyword /\n"
	"    MillisecondKeyword /\n"
	"    MicrosecondKeyword /\n"
	"    WeekKeyword /\n"
	"    QuarterKeyword /\n"
	"    DecadeKeyword /\n"
	"    CenturyKeyword /\n"
	"    MillenniumKeyword /\n"
	"    (YearKeyword 'TO' MonthKeyword) /\n"
	"    (DayKeyword 'TO' HourKeyword) /\n"
	"    (DayKeyword 'TO' MinuteKeyword) /\n"
	"    (DayKeyword 'TO' SecondKeyword) /\n"
	"    (HourKeyword 'TO' MinuteKeyword) /\n"
	"    (HourKeyword 'TO' SecondKeyword) /\n"
	"    (MinuteKeyword 'TO' SecondKeyword)\n"
	"BitType <- 'BIT' 'VARYING'? Parens(List(Expression))?\n"
	"NumericType <- 'INT' /\n"
	"               'INTEGER' /\n"
	"               'SMALLINT' /\n"
	"               'BIGINT' /\n"
	"               'REAL' /\n"
	"               'BOOLEAN' /\n"
	"               ('FLOAT' Parens(NumberLiteral)?) /\n"
	"               ('DOUBLE' 'PRECISION') /\n"
	"               ('DECIMAL' TypeModifiers?) /\n"
	"               ('DEC' TypeModifiers?) /\n"
	"               ('NUMERIC' TypeModifiers?)\n"
	"QualifiedTypeName <- CatalogQualification? SchemaQualification? TypeName\n"
	"TypeModifiers <- Parens(List(Expression)?)\n"
	"RowType <- RowOrStruct Parens(List(ColIdType))\n"
	"UnionType <- 'UNION' Parens(List(ColIdType))\n"
	"SetofType <- 'SETOF' Type\n"
	"MapType <- 'MAP' Parens(List(Type))\n"
	"ColIdType <- ColId Type\n"
	"ArrayBounds <- ('[' NumberLiteral? ']') / 'ARRAY'\n"
	"TimeType <- TimeOrTimestamp TypeModifiers? TimeZone?\n"
	"TimeOrTimestamp <- 'TIME' / 'TIMESTAMP'\n"
	"TimeZone <- WithOrWithout 'TIME' 'ZONE'\n"
	"WithOrWithout <- 'WITH' / 'WITHOUT'\n"
	"RowOrStruct <- 'ROW' / 'STRUCT'\n"
	"# internal definitions\n"
	"%whitespace <- [ \\t\\n\\r]*\n"
	"List(D) <- D (',' D)* ','?\n"
	"Parens(D) <- '(' D ')'\n"
	"ExplainStatement <- 'EXPLAIN' 'ANALYZE'? ExplainOptions? Statement\n"
	"ExplainOptions <- Parens(GenericCopyOptionList)\n"
	"AnalyzeStatement <- 'ANALYZE' 'VERBOSE'? AnalyzeTarget?\n"
	"AnalyzeTarget <- QualifiedName Parens(List(Name))?\n"
	"Name <- ColId ('.' ColLabel)*\n"
	"CreateMacroStmt <- MacroOrFunction IfNotExists? QualifiedName List(MacroDefinition)\n"
	"MacroOrFunction <- 'MACRO' / 'FUNCTION'\n"
	"MacroDefinition <- Parens(MacroParameters?) 'AS' (TableMacroDefinition / ScalarMacroDefinition)\n"
	"MacroParameters <- List(MacroParameter)\n"
	"MacroParameter <- NamedParameter / (TypeFuncName Type?)\n"
	"ScalarMacroDefinition <- Expression\n"
	"TableMacroDefinition <- 'TABLE' SelectStatement\n"
	"CommentStatement <- 'COMMENT' 'ON' CommentOnType ColumnReference 'IS' CommentValue\n"
	"CommentOnType <- 'TABLE' / 'SEQUENCE' / 'FUNCTION' / ('MACRO' 'TABLE'?) / 'VIEW' / 'DATABASE' / 'INDEX' / 'SCHEMA' / 'TYPE' / 'COLUMN'\n"
	"CommentValue <- 'NULL' / StringLiteral\n"
	"AttachStatement <- 'ATTACH' OrReplace? IfNotExists? Database? DatabasePath AttachAlias? AttachOptions?\n"
	"Database <- 'DATABASE'\n"
	"DatabasePath <- StringLiteral\n"
	"AttachAlias <- 'AS' ColId\n"
	"AttachOptions <- Parens(GenericCopyOptionList)\n"
	"DetachStatement <- 'DETACH' Database? IfExists? CatalogName\n"
	"UseStatement <- 'USE' UseTarget\n"
	"UseTarget <- (CatalogName '.' ReservedSchemaName) / SchemaName / CatalogName\n"
	"CallStatement <- 'CALL' TableFunctionName TableFunctionArguments\n"

};

} // namespace duckdb
