// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RELATION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_RELATION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "Expression_generated.h"
#include "Schema_generated.h"
#include "Literal_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace computeir {
namespace flatbuf {

struct Remap;
struct RemapBuilder;

struct PassThrough;
struct PassThroughBuilder;

struct RelBase;
struct RelBaseBuilder;

struct Filter;
struct FilterBuilder;

struct Project;
struct ProjectBuilder;

struct Grouping;
struct GroupingBuilder;

struct Aggregate;
struct AggregateBuilder;

struct Join;
struct JoinBuilder;

struct OrderBy;
struct OrderByBuilder;

struct Limit;
struct LimitBuilder;

struct SetOperation;
struct SetOperationBuilder;

struct LiteralColumn;
struct LiteralColumnBuilder;

struct LiteralRelation;
struct LiteralRelationBuilder;

struct Source;
struct SourceBuilder;

struct Relation;
struct RelationBuilder;

inline const flatbuffers::TypeTable *RemapTypeTable();

inline const flatbuffers::TypeTable *PassThroughTypeTable();

inline const flatbuffers::TypeTable *RelBaseTypeTable();

inline const flatbuffers::TypeTable *FilterTypeTable();

inline const flatbuffers::TypeTable *ProjectTypeTable();

inline const flatbuffers::TypeTable *GroupingTypeTable();

inline const flatbuffers::TypeTable *AggregateTypeTable();

inline const flatbuffers::TypeTable *JoinTypeTable();

inline const flatbuffers::TypeTable *OrderByTypeTable();

inline const flatbuffers::TypeTable *LimitTypeTable();

inline const flatbuffers::TypeTable *SetOperationTypeTable();

inline const flatbuffers::TypeTable *LiteralColumnTypeTable();

inline const flatbuffers::TypeTable *LiteralRelationTypeTable();

inline const flatbuffers::TypeTable *SourceTypeTable();

inline const flatbuffers::TypeTable *RelationTypeTable();

/// A union for the different colum remapping variants
enum Emit : uint8_t {
  Emit_NONE = 0,
  Emit_Remap = 1,
  Emit_PassThrough = 2,
  Emit_MIN = Emit_NONE,
  Emit_MAX = Emit_PassThrough
};

inline const Emit (&EnumValuesEmit())[3] {
  static const Emit values[] = {
    Emit_NONE,
    Emit_Remap,
    Emit_PassThrough
  };
  return values;
}

inline const char * const *EnumNamesEmit() {
  static const char * const names[4] = {
    "NONE",
    "Remap",
    "PassThrough",
    nullptr
  };
  return names;
}

inline const char *EnumNameEmit(Emit e) {
  if (flatbuffers::IsOutRange(e, Emit_NONE, Emit_PassThrough)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEmit()[index];
}

template<typename T> struct EmitTraits {
  static const Emit enum_value = Emit_NONE;
};

template<> struct EmitTraits<org::apache::arrow::computeir::flatbuf::Remap> {
  static const Emit enum_value = Emit_Remap;
};

template<> struct EmitTraits<org::apache::arrow::computeir::flatbuf::PassThrough> {
  static const Emit enum_value = Emit_PassThrough;
};

bool VerifyEmit(flatbuffers::Verifier &verifier, const void *obj, Emit type);
bool VerifyEmitVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum JoinKind : uint8_t {
  JoinKind_Anti = 0,
  JoinKind_Cross = 1,
  JoinKind_FullOuter = 2,
  JoinKind_Inner = 3,
  JoinKind_LeftOuter = 4,
  JoinKind_LeftSemi = 5,
  JoinKind_RightOuter = 6,
  JoinKind_MIN = JoinKind_Anti,
  JoinKind_MAX = JoinKind_RightOuter
};

inline const JoinKind (&EnumValuesJoinKind())[7] {
  static const JoinKind values[] = {
    JoinKind_Anti,
    JoinKind_Cross,
    JoinKind_FullOuter,
    JoinKind_Inner,
    JoinKind_LeftOuter,
    JoinKind_LeftSemi,
    JoinKind_RightOuter
  };
  return values;
}

inline const char * const *EnumNamesJoinKind() {
  static const char * const names[8] = {
    "Anti",
    "Cross",
    "FullOuter",
    "Inner",
    "LeftOuter",
    "LeftSemi",
    "RightOuter",
    nullptr
  };
  return names;
}

inline const char *EnumNameJoinKind(JoinKind e) {
  if (flatbuffers::IsOutRange(e, JoinKind_Anti, JoinKind_RightOuter)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJoinKind()[index];
}

/// The kind of set operation being performed.
enum SetOpKind : uint8_t {
  SetOpKind_Union = 0,
  SetOpKind_Intersection = 1,
  SetOpKind_Difference = 2,
  SetOpKind_MIN = SetOpKind_Union,
  SetOpKind_MAX = SetOpKind_Difference
};

inline const SetOpKind (&EnumValuesSetOpKind())[3] {
  static const SetOpKind values[] = {
    SetOpKind_Union,
    SetOpKind_Intersection,
    SetOpKind_Difference
  };
  return values;
}

inline const char * const *EnumNamesSetOpKind() {
  static const char * const names[4] = {
    "Union",
    "Intersection",
    "Difference",
    nullptr
  };
  return names;
}

inline const char *EnumNameSetOpKind(SetOpKind e) {
  if (flatbuffers::IsOutRange(e, SetOpKind_Union, SetOpKind_Difference)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSetOpKind()[index];
}

/// The varieties of relations
enum RelationImpl : uint8_t {
  RelationImpl_NONE = 0,
  RelationImpl_Aggregate = 1,
  RelationImpl_Filter = 2,
  RelationImpl_Join = 3,
  RelationImpl_Limit = 4,
  RelationImpl_LiteralRelation = 5,
  RelationImpl_OrderBy = 6,
  RelationImpl_Project = 7,
  RelationImpl_SetOperation = 8,
  RelationImpl_Source = 9,
  RelationImpl_MIN = RelationImpl_NONE,
  RelationImpl_MAX = RelationImpl_Source
};

inline const RelationImpl (&EnumValuesRelationImpl())[10] {
  static const RelationImpl values[] = {
    RelationImpl_NONE,
    RelationImpl_Aggregate,
    RelationImpl_Filter,
    RelationImpl_Join,
    RelationImpl_Limit,
    RelationImpl_LiteralRelation,
    RelationImpl_OrderBy,
    RelationImpl_Project,
    RelationImpl_SetOperation,
    RelationImpl_Source
  };
  return values;
}

inline const char * const *EnumNamesRelationImpl() {
  static const char * const names[11] = {
    "NONE",
    "Aggregate",
    "Filter",
    "Join",
    "Limit",
    "LiteralRelation",
    "OrderBy",
    "Project",
    "SetOperation",
    "Source",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelationImpl(RelationImpl e) {
  if (flatbuffers::IsOutRange(e, RelationImpl_NONE, RelationImpl_Source)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRelationImpl()[index];
}

template<typename T> struct RelationImplTraits {
  static const RelationImpl enum_value = RelationImpl_NONE;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Aggregate> {
  static const RelationImpl enum_value = RelationImpl_Aggregate;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Filter> {
  static const RelationImpl enum_value = RelationImpl_Filter;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Join> {
  static const RelationImpl enum_value = RelationImpl_Join;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Limit> {
  static const RelationImpl enum_value = RelationImpl_Limit;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::LiteralRelation> {
  static const RelationImpl enum_value = RelationImpl_LiteralRelation;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::OrderBy> {
  static const RelationImpl enum_value = RelationImpl_OrderBy;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Project> {
  static const RelationImpl enum_value = RelationImpl_Project;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::SetOperation> {
  static const RelationImpl enum_value = RelationImpl_SetOperation;
};

template<> struct RelationImplTraits<org::apache::arrow::computeir::flatbuf::Source> {
  static const RelationImpl enum_value = RelationImpl_Source;
};

bool VerifyRelationImpl(flatbuffers::Verifier &verifier, const void *obj, RelationImpl type);
bool VerifyRelationImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// A data type indicating that a different mapping of columns
/// should occur in the output.
///
/// For example:
///
/// Given a query `SELECT b, a FROM t` where `t` has columns a, b, c
/// the mapping value for the projection would equal [1, 0].
struct Remap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemapBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RemapTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAPPING = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::FieldIndex>> *mapping() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::FieldIndex>> *>(VT_MAPPING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MAPPING) &&
           verifier.VerifyVector(mapping()) &&
           verifier.VerifyVectorOfTables(mapping()) &&
           verifier.EndTable();
  }
};

struct RemapBuilder {
  typedef Remap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mapping(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::FieldIndex>>> mapping) {
    fbb_.AddOffset(Remap::VT_MAPPING, mapping);
  }
  explicit RemapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Remap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Remap>(end);
    fbb_.Required(o, Remap::VT_MAPPING);
    return o;
  }
};

inline flatbuffers::Offset<Remap> CreateRemap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::FieldIndex>>> mapping = 0) {
  RemapBuilder builder_(_fbb);
  builder_.add_mapping(mapping);
  return builder_.Finish();
}

inline flatbuffers::Offset<Remap> CreateRemapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::FieldIndex>> *mapping = nullptr) {
  auto mapping__ = mapping ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::FieldIndex>>(*mapping) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateRemap(
      _fbb,
      mapping__);
}

struct PassThrough FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PassThroughBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PassThroughTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PassThroughBuilder {
  typedef PassThrough Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PassThroughBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PassThrough> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PassThrough>(end);
    return o;
  }
};

inline flatbuffers::Offset<PassThrough> CreatePassThrough(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PassThroughBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Fields common to every relational operator
struct RelBase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelBaseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RelBaseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_MAPPING_TYPE = 4,
    VT_OUTPUT_MAPPING = 6
  };
  org::apache::arrow::computeir::flatbuf::Emit output_mapping_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::Emit>(GetField<uint8_t>(VT_OUTPUT_MAPPING_TYPE, 0));
  }
  /// Output remapping of ordinal columns for a given operation
  const void *output_mapping() const {
    return GetPointer<const void *>(VT_OUTPUT_MAPPING);
  }
  template<typename T> const T *output_mapping_as() const;
  const org::apache::arrow::computeir::flatbuf::Remap *output_mapping_as_Remap() const {
    return output_mapping_type() == org::apache::arrow::computeir::flatbuf::Emit_Remap ? static_cast<const org::apache::arrow::computeir::flatbuf::Remap *>(output_mapping()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::PassThrough *output_mapping_as_PassThrough() const {
    return output_mapping_type() == org::apache::arrow::computeir::flatbuf::Emit_PassThrough ? static_cast<const org::apache::arrow::computeir::flatbuf::PassThrough *>(output_mapping()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUT_MAPPING_TYPE) &&
           VerifyOffsetRequired(verifier, VT_OUTPUT_MAPPING) &&
           VerifyEmit(verifier, output_mapping(), output_mapping_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Remap *RelBase::output_mapping_as<org::apache::arrow::computeir::flatbuf::Remap>() const {
  return output_mapping_as_Remap();
}

template<> inline const org::apache::arrow::computeir::flatbuf::PassThrough *RelBase::output_mapping_as<org::apache::arrow::computeir::flatbuf::PassThrough>() const {
  return output_mapping_as_PassThrough();
}

struct RelBaseBuilder {
  typedef RelBase Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_mapping_type(org::apache::arrow::computeir::flatbuf::Emit output_mapping_type) {
    fbb_.AddElement<uint8_t>(RelBase::VT_OUTPUT_MAPPING_TYPE, static_cast<uint8_t>(output_mapping_type), 0);
  }
  void add_output_mapping(flatbuffers::Offset<void> output_mapping) {
    fbb_.AddOffset(RelBase::VT_OUTPUT_MAPPING, output_mapping);
  }
  explicit RelBaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RelBase> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelBase>(end);
    fbb_.Required(o, RelBase::VT_OUTPUT_MAPPING);
    return o;
  }
};

inline flatbuffers::Offset<RelBase> CreateRelBase(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::Emit output_mapping_type = org::apache::arrow::computeir::flatbuf::Emit_NONE,
    flatbuffers::Offset<void> output_mapping = 0) {
  RelBaseBuilder builder_(_fbb);
  builder_.add_output_mapping(output_mapping);
  builder_.add_output_mapping_type(output_mapping_type);
  return builder_.Finish();
}

/// Filter operation
struct Filter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FilterBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FilterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_REL = 6,
    VT_PREDICATE = 8
  };
  /// Common options
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Child relation
  const org::apache::arrow::computeir::flatbuf::Relation *rel() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Relation *>(VT_REL);
  }
  /// The expression which will be evaluated against input rows
  /// to determine whether they should be excluded from the
  /// filter relation's output.
  const org::apache::arrow::computeir::flatbuf::Expression *predicate() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_PREDICATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_REL) &&
           verifier.VerifyTable(rel()) &&
           VerifyOffsetRequired(verifier, VT_PREDICATE) &&
           verifier.VerifyTable(predicate()) &&
           verifier.EndTable();
  }
};

struct FilterBuilder {
  typedef Filter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Filter::VT_BASE, base);
  }
  void add_rel(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel) {
    fbb_.AddOffset(Filter::VT_REL, rel);
  }
  void add_predicate(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> predicate) {
    fbb_.AddOffset(Filter::VT_PREDICATE, predicate);
  }
  explicit FilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Filter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Filter>(end);
    fbb_.Required(o, Filter::VT_BASE);
    fbb_.Required(o, Filter::VT_REL);
    fbb_.Required(o, Filter::VT_PREDICATE);
    return o;
  }
};

inline flatbuffers::Offset<Filter> CreateFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> predicate = 0) {
  FilterBuilder builder_(_fbb);
  builder_.add_predicate(predicate);
  builder_.add_rel(rel);
  builder_.add_base(base);
  return builder_.Finish();
}

/// Projection
struct Project FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProjectTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_REL = 6,
    VT_EXPRESSIONS = 8
  };
  /// Common options
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Child relation
  const org::apache::arrow::computeir::flatbuf::Relation *rel() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Relation *>(VT_REL);
  }
  /// Expressions which will be evaluated to produce to
  /// the rows of the project relation's output.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_EXPRESSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_REL) &&
           verifier.VerifyTable(rel()) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSIONS) &&
           verifier.VerifyVector(expressions()) &&
           verifier.VerifyVectorOfTables(expressions()) &&
           verifier.EndTable();
  }
};

struct ProjectBuilder {
  typedef Project Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Project::VT_BASE, base);
  }
  void add_rel(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel) {
    fbb_.AddOffset(Project::VT_REL, rel);
  }
  void add_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> expressions) {
    fbb_.AddOffset(Project::VT_EXPRESSIONS, expressions);
  }
  explicit ProjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Project> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Project>(end);
    fbb_.Required(o, Project::VT_BASE);
    fbb_.Required(o, Project::VT_REL);
    fbb_.Required(o, Project::VT_EXPRESSIONS);
    return o;
  }
};

inline flatbuffers::Offset<Project> CreateProject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> expressions = 0) {
  ProjectBuilder builder_(_fbb);
  builder_.add_expressions(expressions);
  builder_.add_rel(rel);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Project> CreateProjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *expressions = nullptr) {
  auto expressions__ = expressions ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*expressions) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateProject(
      _fbb,
      base,
      rel,
      expressions__);
}

/// A set of grouping keys
struct Grouping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GroupingBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GroupingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4
  };
  /// Expressions to group by
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           verifier.EndTable();
  }
};

struct GroupingBuilder {
  typedef Grouping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> keys) {
    fbb_.AddOffset(Grouping::VT_KEYS, keys);
  }
  explicit GroupingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Grouping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Grouping>(end);
    fbb_.Required(o, Grouping::VT_KEYS);
    return o;
  }
};

inline flatbuffers::Offset<Grouping> CreateGrouping(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> keys = 0) {
  GroupingBuilder builder_(_fbb);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline flatbuffers::Offset<Grouping> CreateGroupingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *keys = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*keys) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateGrouping(
      _fbb,
      keys__);
}

/// Aggregate operation
struct Aggregate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AggregateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AggregateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_REL = 6,
    VT_MEASURES = 8,
    VT_GROUPINGS = 10
  };
  /// Common options
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Child relation
  const org::apache::arrow::computeir::flatbuf::Relation *rel() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Relation *>(VT_REL);
  }
  /// Expressions which will be evaluated to produce to
  /// the rows of the aggregate relation's output.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *measures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(VT_MEASURES);
  }
  /// Keys by which `aggregations` will be grouped.
  ///
  /// The nested list here is to support grouping sets
  /// eg
  ///
  /// SELECT a, b, c, sum(d)
  /// FROM t
  /// GROUP BY
  ///   GROUPING SETS (
  ///     (a, b, c),
  ///     (a, b),
  ///     (a),
  ///     ()
  ///   );
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Grouping>> *groupings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Grouping>> *>(VT_GROUPINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_REL) &&
           verifier.VerifyTable(rel()) &&
           VerifyOffsetRequired(verifier, VT_MEASURES) &&
           verifier.VerifyVector(measures()) &&
           verifier.VerifyVectorOfTables(measures()) &&
           VerifyOffsetRequired(verifier, VT_GROUPINGS) &&
           verifier.VerifyVector(groupings()) &&
           verifier.VerifyVectorOfTables(groupings()) &&
           verifier.EndTable();
  }
};

struct AggregateBuilder {
  typedef Aggregate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Aggregate::VT_BASE, base);
  }
  void add_rel(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel) {
    fbb_.AddOffset(Aggregate::VT_REL, rel);
  }
  void add_measures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> measures) {
    fbb_.AddOffset(Aggregate::VT_MEASURES, measures);
  }
  void add_groupings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Grouping>>> groupings) {
    fbb_.AddOffset(Aggregate::VT_GROUPINGS, groupings);
  }
  explicit AggregateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Aggregate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Aggregate>(end);
    fbb_.Required(o, Aggregate::VT_BASE);
    fbb_.Required(o, Aggregate::VT_REL);
    fbb_.Required(o, Aggregate::VT_MEASURES);
    fbb_.Required(o, Aggregate::VT_GROUPINGS);
    return o;
  }
};

inline flatbuffers::Offset<Aggregate> CreateAggregate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>> measures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Grouping>>> groupings = 0) {
  AggregateBuilder builder_(_fbb);
  builder_.add_groupings(groupings);
  builder_.add_measures(measures);
  builder_.add_rel(rel);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Aggregate> CreateAggregateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *measures = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Grouping>> *groupings = nullptr) {
  auto measures__ = measures ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*measures) : 0;
  auto groupings__ = groupings ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Grouping>>(*groupings) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateAggregate(
      _fbb,
      base,
      rel,
      measures__,
      groupings__);
}

/// Join between two tables
struct Join FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return JoinTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_LEFT = 6,
    VT_RIGHT = 8,
    VT_ON_EXPRESSION = 10,
    VT_JOIN_KIND = 12
  };
  /// Common options
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Left relation
  const org::apache::arrow::computeir::flatbuf::Relation *left() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Relation *>(VT_LEFT);
  }
  /// Right relation
  const org::apache::arrow::computeir::flatbuf::Relation *right() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Relation *>(VT_RIGHT);
  }
  /// The expression which will be evaluated against rows from each
  /// input to determine whether they should be included in the
  /// join relation's output.
  const org::apache::arrow::computeir::flatbuf::Expression *on_expression() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_ON_EXPRESSION);
  }
  /// The kind of join to use.
  org::apache::arrow::computeir::flatbuf::JoinKind join_kind() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::JoinKind>(GetField<uint8_t>(VT_JOIN_KIND, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_LEFT) &&
           verifier.VerifyTable(left()) &&
           VerifyOffsetRequired(verifier, VT_RIGHT) &&
           verifier.VerifyTable(right()) &&
           VerifyOffsetRequired(verifier, VT_ON_EXPRESSION) &&
           verifier.VerifyTable(on_expression()) &&
           VerifyField<uint8_t>(verifier, VT_JOIN_KIND) &&
           verifier.EndTable();
  }
};

struct JoinBuilder {
  typedef Join Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Join::VT_BASE, base);
  }
  void add_left(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> left) {
    fbb_.AddOffset(Join::VT_LEFT, left);
  }
  void add_right(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> right) {
    fbb_.AddOffset(Join::VT_RIGHT, right);
  }
  void add_on_expression(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> on_expression) {
    fbb_.AddOffset(Join::VT_ON_EXPRESSION, on_expression);
  }
  void add_join_kind(org::apache::arrow::computeir::flatbuf::JoinKind join_kind) {
    fbb_.AddElement<uint8_t>(Join::VT_JOIN_KIND, static_cast<uint8_t>(join_kind), 0);
  }
  explicit JoinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Join> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Join>(end);
    fbb_.Required(o, Join::VT_BASE);
    fbb_.Required(o, Join::VT_LEFT);
    fbb_.Required(o, Join::VT_RIGHT);
    fbb_.Required(o, Join::VT_ON_EXPRESSION);
    return o;
  }
};

inline flatbuffers::Offset<Join> CreateJoin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> left = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> right = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> on_expression = 0,
    org::apache::arrow::computeir::flatbuf::JoinKind join_kind = org::apache::arrow::computeir::flatbuf::JoinKind_Anti) {
  JoinBuilder builder_(_fbb);
  builder_.add_on_expression(on_expression);
  builder_.add_right(right);
  builder_.add_left(left);
  builder_.add_base(base);
  builder_.add_join_kind(join_kind);
  return builder_.Finish();
}

/// Order by relation
struct OrderBy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderByBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OrderByTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_REL = 6,
    VT_KEYS = 8
  };
  /// Common options
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Child relation
  const org::apache::arrow::computeir::flatbuf::Relation *rel() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Relation *>(VT_REL);
  }
  /// Define sort order for rows of output.
  /// Keys with higher precedence are ordered ahead of other keys.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_REL) &&
           verifier.VerifyTable(rel()) &&
           VerifyOffsetRequired(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           verifier.EndTable();
  }
};

struct OrderByBuilder {
  typedef OrderBy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(OrderBy::VT_BASE, base);
  }
  void add_rel(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel) {
    fbb_.AddOffset(OrderBy::VT_REL, rel);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>> keys) {
    fbb_.AddOffset(OrderBy::VT_KEYS, keys);
  }
  explicit OrderByBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OrderBy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderBy>(end);
    fbb_.Required(o, OrderBy::VT_BASE);
    fbb_.Required(o, OrderBy::VT_REL);
    fbb_.Required(o, OrderBy::VT_KEYS);
    return o;
  }
};

inline flatbuffers::Offset<OrderBy> CreateOrderBy(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>> keys = 0) {
  OrderByBuilder builder_(_fbb);
  builder_.add_keys(keys);
  builder_.add_rel(rel);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderBy> CreateOrderByDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *keys = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>(*keys) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateOrderBy(
      _fbb,
      base,
      rel,
      keys__);
}

/// Limit operation
struct Limit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LimitBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LimitTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_REL = 6,
    VT_OFFSET = 8,
    VT_COUNT = 10
  };
  /// Common options
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Child relation
  const org::apache::arrow::computeir::flatbuf::Relation *rel() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Relation *>(VT_REL);
  }
  /// Starting index of rows
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  /// The maximum number of rows of output.
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_REL) &&
           verifier.VerifyTable(rel()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET) &&
           VerifyField<uint32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct LimitBuilder {
  typedef Limit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Limit::VT_BASE, base);
  }
  void add_rel(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel) {
    fbb_.AddOffset(Limit::VT_REL, rel);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(Limit::VT_OFFSET, offset, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(Limit::VT_COUNT, count, 0);
  }
  explicit LimitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Limit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Limit>(end);
    fbb_.Required(o, Limit::VT_BASE);
    fbb_.Required(o, Limit::VT_REL);
    return o;
  }
};

inline flatbuffers::Offset<Limit> CreateLimit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> rel = 0,
    uint32_t offset = 0,
    uint32_t count = 0) {
  LimitBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_offset(offset);
  builder_.add_rel(rel);
  builder_.add_base(base);
  return builder_.Finish();
}

/// A set operation on two or more relations
struct SetOperation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetOperationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetOperationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_RELS = 6,
    VT_SET_OP = 8
  };
  /// Common options
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// Child relations
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *rels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *>(VT_RELS);
  }
  /// The kind of set operation
  org::apache::arrow::computeir::flatbuf::SetOpKind set_op() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::SetOpKind>(GetField<uint8_t>(VT_SET_OP, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_RELS) &&
           verifier.VerifyVector(rels()) &&
           verifier.VerifyVectorOfTables(rels()) &&
           VerifyField<uint8_t>(verifier, VT_SET_OP) &&
           verifier.EndTable();
  }
};

struct SetOperationBuilder {
  typedef SetOperation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(SetOperation::VT_BASE, base);
  }
  void add_rels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>> rels) {
    fbb_.AddOffset(SetOperation::VT_RELS, rels);
  }
  void add_set_op(org::apache::arrow::computeir::flatbuf::SetOpKind set_op) {
    fbb_.AddElement<uint8_t>(SetOperation::VT_SET_OP, static_cast<uint8_t>(set_op), 0);
  }
  explicit SetOperationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetOperation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetOperation>(end);
    fbb_.Required(o, SetOperation::VT_BASE);
    fbb_.Required(o, SetOperation::VT_RELS);
    return o;
  }
};

inline flatbuffers::Offset<SetOperation> CreateSetOperation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>> rels = 0,
    org::apache::arrow::computeir::flatbuf::SetOpKind set_op = org::apache::arrow::computeir::flatbuf::SetOpKind_Union) {
  SetOperationBuilder builder_(_fbb);
  builder_.add_rels(rels);
  builder_.add_base(base);
  builder_.add_set_op(set_op);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetOperation> CreateSetOperationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>> *rels = nullptr,
    org::apache::arrow::computeir::flatbuf::SetOpKind set_op = org::apache::arrow::computeir::flatbuf::SetOpKind_Union) {
  auto rels__ = rels ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation>>(*rels) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateSetOperation(
      _fbb,
      base,
      rels__,
      set_op);
}

/// A single column of literal values.
struct LiteralColumn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiteralColumnBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LiteralColumnTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTS = 4
  };
  /// The literal values of the column
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *elements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *>(VT_ELEMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.VerifyVectorOfTables(elements()) &&
           verifier.EndTable();
  }
};

struct LiteralColumnBuilder {
  typedef LiteralColumn Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>> elements) {
    fbb_.AddOffset(LiteralColumn::VT_ELEMENTS, elements);
  }
  explicit LiteralColumnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LiteralColumn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiteralColumn>(end);
    fbb_.Required(o, LiteralColumn::VT_ELEMENTS);
    return o;
  }
};

inline flatbuffers::Offset<LiteralColumn> CreateLiteralColumn(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>> elements = 0) {
  LiteralColumnBuilder builder_(_fbb);
  builder_.add_elements(elements);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiteralColumn> CreateLiteralColumnDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *elements = nullptr) {
  auto elements__ = elements ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>(*elements) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateLiteralColumn(
      _fbb,
      elements__);
}

/// Literal relation
struct LiteralRelation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiteralRelationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LiteralRelationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_COLUMNS = 6
  };
  /// Common options
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  /// The columns of this literal relation.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::LiteralColumn>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::LiteralColumn>> *>(VT_COLUMNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           verifier.EndTable();
  }
};

struct LiteralRelationBuilder {
  typedef LiteralRelation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(LiteralRelation::VT_BASE, base);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::LiteralColumn>>> columns) {
    fbb_.AddOffset(LiteralRelation::VT_COLUMNS, columns);
  }
  explicit LiteralRelationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LiteralRelation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiteralRelation>(end);
    fbb_.Required(o, LiteralRelation::VT_BASE);
    fbb_.Required(o, LiteralRelation::VT_COLUMNS);
    return o;
  }
};

inline flatbuffers::Offset<LiteralRelation> CreateLiteralRelation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::LiteralColumn>>> columns = 0) {
  LiteralRelationBuilder builder_(_fbb);
  builder_.add_columns(columns);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiteralRelation> CreateLiteralRelationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::LiteralColumn>> *columns = nullptr) {
  auto columns__ = columns ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::LiteralColumn>>(*columns) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateLiteralRelation(
      _fbb,
      base,
      columns__);
}

/// An external source of tabular data
struct Source FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SourceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SourceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_NAME = 6,
    VT_SCHEMA = 8
  };
  const org::apache::arrow::computeir::flatbuf::RelBase *base() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::RelBase *>(VT_BASE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const org::apache::arrow::flatbuf::Schema *schema() const {
    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           verifier.EndTable();
  }
};

struct SourceBuilder {
  typedef Source Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base) {
    fbb_.AddOffset(Source::VT_BASE, base);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Source::VT_NAME, name);
  }
  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
    fbb_.AddOffset(Source::VT_SCHEMA, schema);
  }
  explicit SourceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Source> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Source>(end);
    fbb_.Required(o, Source::VT_BASE);
    fbb_.Required(o, Source::VT_NAME);
    fbb_.Required(o, Source::VT_SCHEMA);
    return o;
  }
};

inline flatbuffers::Offset<Source> CreateSource(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  SourceBuilder builder_(_fbb);
  builder_.add_schema(schema);
  builder_.add_name(name);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<Source> CreateSourceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::RelBase> base = 0,
    const char *name = nullptr,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateSource(
      _fbb,
      base,
      name__,
      schema);
}

/// A table holding an instance of the possible relation types.
struct Relation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RelationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPL_TYPE = 4,
    VT_IMPL = 6
  };
  org::apache::arrow::computeir::flatbuf::RelationImpl impl_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::RelationImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
  }
  const void *impl() const {
    return GetPointer<const void *>(VT_IMPL);
  }
  template<typename T> const T *impl_as() const;
  const org::apache::arrow::computeir::flatbuf::Aggregate *impl_as_Aggregate() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl_Aggregate ? static_cast<const org::apache::arrow::computeir::flatbuf::Aggregate *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Filter *impl_as_Filter() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl_Filter ? static_cast<const org::apache::arrow::computeir::flatbuf::Filter *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Join *impl_as_Join() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl_Join ? static_cast<const org::apache::arrow::computeir::flatbuf::Join *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Limit *impl_as_Limit() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl_Limit ? static_cast<const org::apache::arrow::computeir::flatbuf::Limit *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::LiteralRelation *impl_as_LiteralRelation() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl_LiteralRelation ? static_cast<const org::apache::arrow::computeir::flatbuf::LiteralRelation *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::OrderBy *impl_as_OrderBy() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl_OrderBy ? static_cast<const org::apache::arrow::computeir::flatbuf::OrderBy *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Project *impl_as_Project() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl_Project ? static_cast<const org::apache::arrow::computeir::flatbuf::Project *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::SetOperation *impl_as_SetOperation() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl_SetOperation ? static_cast<const org::apache::arrow::computeir::flatbuf::SetOperation *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Source *impl_as_Source() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::RelationImpl_Source ? static_cast<const org::apache::arrow::computeir::flatbuf::Source *>(impl()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
           VerifyOffsetRequired(verifier, VT_IMPL) &&
           VerifyRelationImpl(verifier, impl(), impl_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::Aggregate *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Aggregate>() const {
  return impl_as_Aggregate();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Filter *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Filter>() const {
  return impl_as_Filter();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Join *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Join>() const {
  return impl_as_Join();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Limit *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Limit>() const {
  return impl_as_Limit();
}

template<> inline const org::apache::arrow::computeir::flatbuf::LiteralRelation *Relation::impl_as<org::apache::arrow::computeir::flatbuf::LiteralRelation>() const {
  return impl_as_LiteralRelation();
}

template<> inline const org::apache::arrow::computeir::flatbuf::OrderBy *Relation::impl_as<org::apache::arrow::computeir::flatbuf::OrderBy>() const {
  return impl_as_OrderBy();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Project *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Project>() const {
  return impl_as_Project();
}

template<> inline const org::apache::arrow::computeir::flatbuf::SetOperation *Relation::impl_as<org::apache::arrow::computeir::flatbuf::SetOperation>() const {
  return impl_as_SetOperation();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Source *Relation::impl_as<org::apache::arrow::computeir::flatbuf::Source>() const {
  return impl_as_Source();
}

struct RelationBuilder {
  typedef Relation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impl_type(org::apache::arrow::computeir::flatbuf::RelationImpl impl_type) {
    fbb_.AddElement<uint8_t>(Relation::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
  }
  void add_impl(flatbuffers::Offset<void> impl) {
    fbb_.AddOffset(Relation::VT_IMPL, impl);
  }
  explicit RelationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Relation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relation>(end);
    fbb_.Required(o, Relation::VT_IMPL);
    return o;
  }
};

inline flatbuffers::Offset<Relation> CreateRelation(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::RelationImpl impl_type = org::apache::arrow::computeir::flatbuf::RelationImpl_NONE,
    flatbuffers::Offset<void> impl = 0) {
  RelationBuilder builder_(_fbb);
  builder_.add_impl(impl);
  builder_.add_impl_type(impl_type);
  return builder_.Finish();
}

inline bool VerifyEmit(flatbuffers::Verifier &verifier, const void *obj, Emit type) {
  switch (type) {
    case Emit_NONE: {
      return true;
    }
    case Emit_Remap: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Remap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Emit_PassThrough: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::PassThrough *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEmitVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEmit(
        verifier,  values->Get(i), types->GetEnum<Emit>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRelationImpl(flatbuffers::Verifier &verifier, const void *obj, RelationImpl type) {
  switch (type) {
    case RelationImpl_NONE: {
      return true;
    }
    case RelationImpl_Aggregate: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Aggregate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl_Filter: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Filter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl_Join: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Join *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl_Limit: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Limit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl_LiteralRelation: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::LiteralRelation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl_OrderBy: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::OrderBy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl_Project: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Project *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl_SetOperation: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::SetOperation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelationImpl_Source: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Source *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRelationImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRelationImpl(
        verifier,  values->Get(i), types->GetEnum<RelationImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *EmitTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RemapTypeTable,
    org::apache::arrow::computeir::flatbuf::PassThroughTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Remap",
    "PassThrough"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *JoinKindTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::JoinKindTypeTable
  };
  static const char * const names[] = {
    "Anti",
    "Cross",
    "FullOuter",
    "Inner",
    "LeftOuter",
    "LeftSemi",
    "RightOuter"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SetOpKindTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::SetOpKindTypeTable
  };
  static const char * const names[] = {
    "Union",
    "Intersection",
    "Difference"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RelationImplTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::AggregateTypeTable,
    org::apache::arrow::computeir::flatbuf::FilterTypeTable,
    org::apache::arrow::computeir::flatbuf::JoinTypeTable,
    org::apache::arrow::computeir::flatbuf::LimitTypeTable,
    org::apache::arrow::computeir::flatbuf::LiteralRelationTypeTable,
    org::apache::arrow::computeir::flatbuf::OrderByTypeTable,
    org::apache::arrow::computeir::flatbuf::ProjectTypeTable,
    org::apache::arrow::computeir::flatbuf::SetOperationTypeTable,
    org::apache::arrow::computeir::flatbuf::SourceTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Aggregate",
    "Filter",
    "Join",
    "Limit",
    "LiteralRelation",
    "OrderBy",
    "Project",
    "SetOperation",
    "Source"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RemapTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::FieldIndexTypeTable
  };
  static const char * const names[] = {
    "mapping"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PassThroughTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RelBaseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::EmitTypeTable
  };
  static const char * const names[] = {
    "output_mapping_type",
    "output_mapping"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FilterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RelBaseTypeTable,
    org::apache::arrow::computeir::flatbuf::RelationTypeTable,
    org::apache::arrow::computeir::flatbuf::ExpressionTypeTable
  };
  static const char * const names[] = {
    "base",
    "rel",
    "predicate"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProjectTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RelBaseTypeTable,
    org::apache::arrow::computeir::flatbuf::RelationTypeTable,
    org::apache::arrow::computeir::flatbuf::ExpressionTypeTable
  };
  static const char * const names[] = {
    "base",
    "rel",
    "expressions"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GroupingTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::ExpressionTypeTable
  };
  static const char * const names[] = {
    "keys"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AggregateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RelBaseTypeTable,
    org::apache::arrow::computeir::flatbuf::RelationTypeTable,
    org::apache::arrow::computeir::flatbuf::ExpressionTypeTable,
    org::apache::arrow::computeir::flatbuf::GroupingTypeTable
  };
  static const char * const names[] = {
    "base",
    "rel",
    "measures",
    "groupings"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *JoinTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_UCHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RelBaseTypeTable,
    org::apache::arrow::computeir::flatbuf::RelationTypeTable,
    org::apache::arrow::computeir::flatbuf::ExpressionTypeTable,
    org::apache::arrow::computeir::flatbuf::JoinKindTypeTable
  };
  static const char * const names[] = {
    "base",
    "left",
    "right",
    "on_expression",
    "join_kind"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OrderByTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RelBaseTypeTable,
    org::apache::arrow::computeir::flatbuf::RelationTypeTable,
    org::apache::arrow::computeir::flatbuf::SortKeyTypeTable
  };
  static const char * const names[] = {
    "base",
    "rel",
    "keys"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LimitTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RelBaseTypeTable,
    org::apache::arrow::computeir::flatbuf::RelationTypeTable
  };
  static const char * const names[] = {
    "base",
    "rel",
    "offset",
    "count"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SetOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_UCHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RelBaseTypeTable,
    org::apache::arrow::computeir::flatbuf::RelationTypeTable,
    org::apache::arrow::computeir::flatbuf::SetOpKindTypeTable
  };
  static const char * const names[] = {
    "base",
    "rels",
    "set_op"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LiteralColumnTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::LiteralTypeTable
  };
  static const char * const names[] = {
    "elements"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LiteralRelationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RelBaseTypeTable,
    org::apache::arrow::computeir::flatbuf::LiteralColumnTypeTable
  };
  static const char * const names[] = {
    "base",
    "columns"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SourceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RelBaseTypeTable,
    org::apache::arrow::flatbuf::SchemaTypeTable
  };
  static const char * const names[] = {
    "base",
    "name",
    "schema"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RelationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    org::apache::arrow::computeir::flatbuf::RelationImplTypeTable
  };
  static const char * const names[] = {
    "impl_type",
    "impl"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const org::apache::arrow::computeir::flatbuf::Relation *GetRelation(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::computeir::flatbuf::Relation>(buf);
}

inline const org::apache::arrow::computeir::flatbuf::Relation *GetSizePrefixedRelation(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::computeir::flatbuf::Relation>(buf);
}

inline bool VerifyRelationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::computeir::flatbuf::Relation>(nullptr);
}

inline bool VerifySizePrefixedRelationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::computeir::flatbuf::Relation>(nullptr);
}

inline void FinishRelationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRelationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Relation> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace computeir
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_RELATION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
