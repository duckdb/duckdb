// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_LITERAL_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_LITERAL_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "Schema_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace computeir {
namespace flatbuf {

struct ListLiteral;
struct ListLiteralBuilder;

struct StructLiteralField;
struct StructLiteralFieldBuilder;

struct StructLiteral;
struct StructLiteralBuilder;

struct KeyValue;
struct KeyValueBuilder;

struct MapLiteral;
struct MapLiteralBuilder;

struct Int8Literal;
struct Int8LiteralBuilder;

struct Int16Literal;
struct Int16LiteralBuilder;

struct Int32Literal;
struct Int32LiteralBuilder;

struct Int64Literal;
struct Int64LiteralBuilder;

struct UInt8Literal;
struct UInt8LiteralBuilder;

struct UInt16Literal;
struct UInt16LiteralBuilder;

struct UInt32Literal;
struct UInt32LiteralBuilder;

struct UInt64Literal;
struct UInt64LiteralBuilder;

struct Float16Literal;
struct Float16LiteralBuilder;

struct Float32Literal;
struct Float32LiteralBuilder;

struct Float64Literal;
struct Float64LiteralBuilder;

struct DecimalLiteral;
struct DecimalLiteralBuilder;

struct BooleanLiteral;
struct BooleanLiteralBuilder;

struct NullLiteral;
struct NullLiteralBuilder;

struct DateLiteral;
struct DateLiteralBuilder;

struct TimeLiteral;
struct TimeLiteralBuilder;

struct TimestampLiteral;
struct TimestampLiteralBuilder;

struct IntervalLiteralMonths;
struct IntervalLiteralMonthsBuilder;

struct IntervalLiteralDaysMilliseconds;
struct IntervalLiteralDaysMillisecondsBuilder;

struct IntervalLiteral;
struct IntervalLiteralBuilder;

struct DurationLiteral;
struct DurationLiteralBuilder;

struct BinaryLiteral;
struct BinaryLiteralBuilder;

struct FixedSizeBinaryLiteral;
struct FixedSizeBinaryLiteralBuilder;

struct StringLiteral;
struct StringLiteralBuilder;

struct Literal;
struct LiteralBuilder;

inline const flatbuffers::TypeTable *ListLiteralTypeTable();

inline const flatbuffers::TypeTable *StructLiteralFieldTypeTable();

inline const flatbuffers::TypeTable *StructLiteralTypeTable();

inline const flatbuffers::TypeTable *KeyValueTypeTable();

inline const flatbuffers::TypeTable *MapLiteralTypeTable();

inline const flatbuffers::TypeTable *Int8LiteralTypeTable();

inline const flatbuffers::TypeTable *Int16LiteralTypeTable();

inline const flatbuffers::TypeTable *Int32LiteralTypeTable();

inline const flatbuffers::TypeTable *Int64LiteralTypeTable();

inline const flatbuffers::TypeTable *UInt8LiteralTypeTable();

inline const flatbuffers::TypeTable *UInt16LiteralTypeTable();

inline const flatbuffers::TypeTable *UInt32LiteralTypeTable();

inline const flatbuffers::TypeTable *UInt64LiteralTypeTable();

inline const flatbuffers::TypeTable *Float16LiteralTypeTable();

inline const flatbuffers::TypeTable *Float32LiteralTypeTable();

inline const flatbuffers::TypeTable *Float64LiteralTypeTable();

inline const flatbuffers::TypeTable *DecimalLiteralTypeTable();

inline const flatbuffers::TypeTable *BooleanLiteralTypeTable();

inline const flatbuffers::TypeTable *NullLiteralTypeTable();

inline const flatbuffers::TypeTable *DateLiteralTypeTable();

inline const flatbuffers::TypeTable *TimeLiteralTypeTable();

inline const flatbuffers::TypeTable *TimestampLiteralTypeTable();

inline const flatbuffers::TypeTable *IntervalLiteralMonthsTypeTable();

inline const flatbuffers::TypeTable *IntervalLiteralDaysMillisecondsTypeTable();

inline const flatbuffers::TypeTable *IntervalLiteralTypeTable();

inline const flatbuffers::TypeTable *DurationLiteralTypeTable();

inline const flatbuffers::TypeTable *BinaryLiteralTypeTable();

inline const flatbuffers::TypeTable *FixedSizeBinaryLiteralTypeTable();

inline const flatbuffers::TypeTable *StringLiteralTypeTable();

inline const flatbuffers::TypeTable *LiteralTypeTable();

enum IntervalLiteralImpl : uint8_t {
	IntervalLiteralImpl_NONE = 0,
	IntervalLiteralImpl_IntervalLiteralMonths = 1,
	IntervalLiteralImpl_IntervalLiteralDaysMilliseconds = 2,
	IntervalLiteralImpl_MIN = IntervalLiteralImpl_NONE,
	IntervalLiteralImpl_MAX = IntervalLiteralImpl_IntervalLiteralDaysMilliseconds
};

inline const IntervalLiteralImpl (&EnumValuesIntervalLiteralImpl())[3] {
	static const IntervalLiteralImpl values[] = {IntervalLiteralImpl_NONE, IntervalLiteralImpl_IntervalLiteralMonths,
	                                             IntervalLiteralImpl_IntervalLiteralDaysMilliseconds};
	return values;
}

inline const char *const *EnumNamesIntervalLiteralImpl() {
	static const char *const names[4] = {"NONE", "IntervalLiteralMonths", "IntervalLiteralDaysMilliseconds", nullptr};
	return names;
}

inline const char *EnumNameIntervalLiteralImpl(IntervalLiteralImpl e) {
	if (flatbuffers::IsOutRange(e, IntervalLiteralImpl_NONE, IntervalLiteralImpl_IntervalLiteralDaysMilliseconds))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesIntervalLiteralImpl()[index];
}

template <typename T>
struct IntervalLiteralImplTraits {
	static const IntervalLiteralImpl enum_value = IntervalLiteralImpl_NONE;
};

template <>
struct IntervalLiteralImplTraits<org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths> {
	static const IntervalLiteralImpl enum_value = IntervalLiteralImpl_IntervalLiteralMonths;
};

template <>
struct IntervalLiteralImplTraits<org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds> {
	static const IntervalLiteralImpl enum_value = IntervalLiteralImpl_IntervalLiteralDaysMilliseconds;
};

bool VerifyIntervalLiteralImpl(flatbuffers::Verifier &verifier, const void *obj, IntervalLiteralImpl type);
bool VerifyIntervalLiteralImplVector(flatbuffers::Verifier &verifier,
                                     const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                     const flatbuffers::Vector<uint8_t> *types);

enum LiteralImpl : uint8_t {
	LiteralImpl_NONE = 0,
	LiteralImpl_NullLiteral = 1,
	LiteralImpl_BooleanLiteral = 2,
	LiteralImpl_Int8Literal = 3,
	LiteralImpl_Int16Literal = 4,
	LiteralImpl_Int32Literal = 5,
	LiteralImpl_Int64Literal = 6,
	LiteralImpl_UInt8Literal = 7,
	LiteralImpl_UInt16Literal = 8,
	LiteralImpl_UInt32Literal = 9,
	LiteralImpl_UInt64Literal = 10,
	LiteralImpl_DateLiteral = 11,
	LiteralImpl_TimeLiteral = 12,
	LiteralImpl_TimestampLiteral = 13,
	LiteralImpl_IntervalLiteral = 14,
	LiteralImpl_DurationLiteral = 15,
	LiteralImpl_DecimalLiteral = 16,
	LiteralImpl_Float16Literal = 17,
	LiteralImpl_Float32Literal = 18,
	LiteralImpl_Float64Literal = 19,
	LiteralImpl_ListLiteral = 20,
	LiteralImpl_StructLiteral = 21,
	LiteralImpl_MapLiteral = 22,
	LiteralImpl_StringLiteral = 23,
	LiteralImpl_BinaryLiteral = 24,
	LiteralImpl_FixedSizeBinaryLiteral = 25,
	LiteralImpl_MIN = LiteralImpl_NONE,
	LiteralImpl_MAX = LiteralImpl_FixedSizeBinaryLiteral
};

inline const LiteralImpl (&EnumValuesLiteralImpl())[26] {
	static const LiteralImpl values[] = {LiteralImpl_NONE,
	                                     LiteralImpl_NullLiteral,
	                                     LiteralImpl_BooleanLiteral,
	                                     LiteralImpl_Int8Literal,
	                                     LiteralImpl_Int16Literal,
	                                     LiteralImpl_Int32Literal,
	                                     LiteralImpl_Int64Literal,
	                                     LiteralImpl_UInt8Literal,
	                                     LiteralImpl_UInt16Literal,
	                                     LiteralImpl_UInt32Literal,
	                                     LiteralImpl_UInt64Literal,
	                                     LiteralImpl_DateLiteral,
	                                     LiteralImpl_TimeLiteral,
	                                     LiteralImpl_TimestampLiteral,
	                                     LiteralImpl_IntervalLiteral,
	                                     LiteralImpl_DurationLiteral,
	                                     LiteralImpl_DecimalLiteral,
	                                     LiteralImpl_Float16Literal,
	                                     LiteralImpl_Float32Literal,
	                                     LiteralImpl_Float64Literal,
	                                     LiteralImpl_ListLiteral,
	                                     LiteralImpl_StructLiteral,
	                                     LiteralImpl_MapLiteral,
	                                     LiteralImpl_StringLiteral,
	                                     LiteralImpl_BinaryLiteral,
	                                     LiteralImpl_FixedSizeBinaryLiteral};
	return values;
}

inline const char *const *EnumNamesLiteralImpl() {
	static const char *const names[27] = {"NONE",
	                                      "NullLiteral",
	                                      "BooleanLiteral",
	                                      "Int8Literal",
	                                      "Int16Literal",
	                                      "Int32Literal",
	                                      "Int64Literal",
	                                      "UInt8Literal",
	                                      "UInt16Literal",
	                                      "UInt32Literal",
	                                      "UInt64Literal",
	                                      "DateLiteral",
	                                      "TimeLiteral",
	                                      "TimestampLiteral",
	                                      "IntervalLiteral",
	                                      "DurationLiteral",
	                                      "DecimalLiteral",
	                                      "Float16Literal",
	                                      "Float32Literal",
	                                      "Float64Literal",
	                                      "ListLiteral",
	                                      "StructLiteral",
	                                      "MapLiteral",
	                                      "StringLiteral",
	                                      "BinaryLiteral",
	                                      "FixedSizeBinaryLiteral",
	                                      nullptr};
	return names;
}

inline const char *EnumNameLiteralImpl(LiteralImpl e) {
	if (flatbuffers::IsOutRange(e, LiteralImpl_NONE, LiteralImpl_FixedSizeBinaryLiteral))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesLiteralImpl()[index];
}

template <typename T>
struct LiteralImplTraits {
	static const LiteralImpl enum_value = LiteralImpl_NONE;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::NullLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_NullLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::BooleanLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_BooleanLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Int8Literal> {
	static const LiteralImpl enum_value = LiteralImpl_Int8Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Int16Literal> {
	static const LiteralImpl enum_value = LiteralImpl_Int16Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Int32Literal> {
	static const LiteralImpl enum_value = LiteralImpl_Int32Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Int64Literal> {
	static const LiteralImpl enum_value = LiteralImpl_Int64Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::UInt8Literal> {
	static const LiteralImpl enum_value = LiteralImpl_UInt8Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::UInt16Literal> {
	static const LiteralImpl enum_value = LiteralImpl_UInt16Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::UInt32Literal> {
	static const LiteralImpl enum_value = LiteralImpl_UInt32Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::UInt64Literal> {
	static const LiteralImpl enum_value = LiteralImpl_UInt64Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::DateLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_DateLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::TimeLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_TimeLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::TimestampLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_TimestampLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::IntervalLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_IntervalLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::DurationLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_DurationLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::DecimalLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_DecimalLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Float16Literal> {
	static const LiteralImpl enum_value = LiteralImpl_Float16Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Float32Literal> {
	static const LiteralImpl enum_value = LiteralImpl_Float32Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Float64Literal> {
	static const LiteralImpl enum_value = LiteralImpl_Float64Literal;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::ListLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_ListLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::StructLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_StructLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::MapLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_MapLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::StringLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_StringLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::BinaryLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_BinaryLiteral;
};

template <>
struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral> {
	static const LiteralImpl enum_value = LiteralImpl_FixedSizeBinaryLiteral;
};

bool VerifyLiteralImpl(flatbuffers::Verifier &verifier, const void *obj, LiteralImpl type);
bool VerifyLiteralImplVector(flatbuffers::Verifier &verifier,
                             const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                             const flatbuffers::Vector<uint8_t> *types);

struct ListLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef ListLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return ListLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUES = 4 };
	const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *values() const {
		return GetPointer<
		    const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *>(
		    VT_VALUES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_VALUES) &&
		       verifier.VerifyVector(values()) && verifier.VerifyVectorOfTables(values()) && verifier.EndTable();
	}
};

struct ListLiteralBuilder {
	typedef ListLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_values(
	    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>>
	        values) {
		fbb_.AddOffset(ListLiteral::VT_VALUES, values);
	}
	explicit ListLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<ListLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<ListLiteral>(end);
		fbb_.Required(o, ListLiteral::VT_VALUES);
		return o;
	}
};

inline flatbuffers::Offset<ListLiteral> CreateListLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>>
        values = 0) {
	ListLiteralBuilder builder_(_fbb);
	builder_.add_values(values);
	return builder_.Finish();
}

inline flatbuffers::Offset<ListLiteral> CreateListLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *values = nullptr) {
	auto values__ =
	    values ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>(*values) : 0;
	return org::apache::arrow::computeir::flatbuf::CreateListLiteral(_fbb, values__);
}

struct StructLiteralField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StructLiteralFieldBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return StructLiteralFieldTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NAME = 4, VT_VALUE = 6 };
	const flatbuffers::String *name() const {
		return GetPointer<const flatbuffers::String *>(VT_NAME);
	}
	const org::apache::arrow::computeir::flatbuf::Literal *value() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Literal *>(VT_VALUE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
		       VerifyOffsetRequired(verifier, VT_VALUE) && verifier.VerifyTable(value()) && verifier.EndTable();
	}
};

struct StructLiteralFieldBuilder {
	typedef StructLiteralField Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_name(flatbuffers::Offset<flatbuffers::String> name) {
		fbb_.AddOffset(StructLiteralField::VT_NAME, name);
	}
	void add_value(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> value) {
		fbb_.AddOffset(StructLiteralField::VT_VALUE, value);
	}
	explicit StructLiteralFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StructLiteralField> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StructLiteralField>(end);
		fbb_.Required(o, StructLiteralField::VT_NAME);
		fbb_.Required(o, StructLiteralField::VT_VALUE);
		return o;
	}
};

inline flatbuffers::Offset<StructLiteralField>
CreateStructLiteralField(flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::String> name = 0,
                         flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> value = 0) {
	StructLiteralFieldBuilder builder_(_fbb);
	builder_.add_value(value);
	builder_.add_name(name);
	return builder_.Finish();
}

inline flatbuffers::Offset<StructLiteralField>
CreateStructLiteralFieldDirect(flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
                               flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> value = 0) {
	auto name__ = name ? _fbb.CreateString(name) : 0;
	return org::apache::arrow::computeir::flatbuf::CreateStructLiteralField(_fbb, name__, value);
}

struct StructLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StructLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return StructLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUES = 4 };
	const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::StructLiteralField>> *
	values() const {
		return GetPointer<const flatbuffers::Vector<
		    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::StructLiteralField>> *>(VT_VALUES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_VALUES) &&
		       verifier.VerifyVector(values()) && verifier.VerifyVectorOfTables(values()) && verifier.EndTable();
	}
};

struct StructLiteralBuilder {
	typedef StructLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void
	add_values(flatbuffers::Offset<
	           flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::StructLiteralField>>>
	               values) {
		fbb_.AddOffset(StructLiteral::VT_VALUES, values);
	}
	explicit StructLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StructLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StructLiteral>(end);
		fbb_.Required(o, StructLiteral::VT_VALUES);
		return o;
	}
};

inline flatbuffers::Offset<StructLiteral> CreateStructLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::StructLiteralField>>>
        values = 0) {
	StructLiteralBuilder builder_(_fbb);
	builder_.add_values(values);
	return builder_.Finish();
}

inline flatbuffers::Offset<StructLiteral> CreateStructLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::StructLiteralField>> *values =
        nullptr) {
	auto values__ =
	    values ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::StructLiteralField>>(
	                 *values)
	           : 0;
	return org::apache::arrow::computeir::flatbuf::CreateStructLiteral(_fbb, values__);
}

struct KeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef KeyValueBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return KeyValueTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_KEY = 4, VT_VALUE = 6 };
	const org::apache::arrow::computeir::flatbuf::Literal *key() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Literal *>(VT_KEY);
	}
	const org::apache::arrow::computeir::flatbuf::Literal *value() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Literal *>(VT_VALUE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_KEY) && verifier.VerifyTable(key()) &&
		       VerifyOffsetRequired(verifier, VT_VALUE) && verifier.VerifyTable(value()) && verifier.EndTable();
	}
};

struct KeyValueBuilder {
	typedef KeyValue Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_key(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> key) {
		fbb_.AddOffset(KeyValue::VT_KEY, key);
	}
	void add_value(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> value) {
		fbb_.AddOffset(KeyValue::VT_VALUE, value);
	}
	explicit KeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<KeyValue> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<KeyValue>(end);
		fbb_.Required(o, KeyValue::VT_KEY);
		fbb_.Required(o, KeyValue::VT_VALUE);
		return o;
	}
};

inline flatbuffers::Offset<KeyValue>
CreateKeyValue(flatbuffers::FlatBufferBuilder &_fbb,
               flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> key = 0,
               flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> value = 0) {
	KeyValueBuilder builder_(_fbb);
	builder_.add_value(value);
	builder_.add_key(key);
	return builder_.Finish();
}

struct MapLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MapLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return MapLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUES = 4 };
	const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *values() const {
		return GetPointer<
		    const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *>(
		    VT_VALUES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_VALUES) &&
		       verifier.VerifyVector(values()) && verifier.VerifyVectorOfTables(values()) && verifier.EndTable();
	}
};

struct MapLiteralBuilder {
	typedef MapLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_values(
	    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>>
	        values) {
		fbb_.AddOffset(MapLiteral::VT_VALUES, values);
	}
	explicit MapLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<MapLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<MapLiteral>(end);
		fbb_.Required(o, MapLiteral::VT_VALUES);
		return o;
	}
};

inline flatbuffers::Offset<MapLiteral> CreateMapLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>>
        values = 0) {
	MapLiteralBuilder builder_(_fbb);
	builder_.add_values(values);
	return builder_.Finish();
}

inline flatbuffers::Offset<MapLiteral> CreateMapLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *values = nullptr) {
	auto values__ =
	    values ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>(*values) : 0;
	return org::apache::arrow::computeir::flatbuf::CreateMapLiteral(_fbb, values__);
}

struct Int8Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Int8LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return Int8LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	int8_t value() const {
		return GetField<int8_t>(VT_VALUE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct Int8LiteralBuilder {
	typedef Int8Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(int8_t value) {
		fbb_.AddElement<int8_t>(Int8Literal::VT_VALUE, value, 0);
	}
	explicit Int8LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Int8Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Int8Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<Int8Literal> CreateInt8Literal(flatbuffers::FlatBufferBuilder &_fbb, int8_t value = 0) {
	Int8LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct Int16Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Int16LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return Int16LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	int16_t value() const {
		return GetField<int16_t>(VT_VALUE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int16_t>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct Int16LiteralBuilder {
	typedef Int16Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(int16_t value) {
		fbb_.AddElement<int16_t>(Int16Literal::VT_VALUE, value, 0);
	}
	explicit Int16LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Int16Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Int16Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<Int16Literal> CreateInt16Literal(flatbuffers::FlatBufferBuilder &_fbb, int16_t value = 0) {
	Int16LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct Int32Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Int32LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return Int32LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	int32_t value() const {
		return GetField<int32_t>(VT_VALUE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct Int32LiteralBuilder {
	typedef Int32Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(int32_t value) {
		fbb_.AddElement<int32_t>(Int32Literal::VT_VALUE, value, 0);
	}
	explicit Int32LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Int32Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Int32Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<Int32Literal> CreateInt32Literal(flatbuffers::FlatBufferBuilder &_fbb, int32_t value = 0) {
	Int32LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct Int64Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Int64LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return Int64LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	int64_t value() const {
		return GetField<int64_t>(VT_VALUE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct Int64LiteralBuilder {
	typedef Int64Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(int64_t value) {
		fbb_.AddElement<int64_t>(Int64Literal::VT_VALUE, value, 0);
	}
	explicit Int64LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Int64Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Int64Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<Int64Literal> CreateInt64Literal(flatbuffers::FlatBufferBuilder &_fbb, int64_t value = 0) {
	Int64LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct UInt8Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef UInt8LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return UInt8LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	uint8_t value() const {
		return GetField<uint8_t>(VT_VALUE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct UInt8LiteralBuilder {
	typedef UInt8Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(uint8_t value) {
		fbb_.AddElement<uint8_t>(UInt8Literal::VT_VALUE, value, 0);
	}
	explicit UInt8LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<UInt8Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<UInt8Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<UInt8Literal> CreateUInt8Literal(flatbuffers::FlatBufferBuilder &_fbb, uint8_t value = 0) {
	UInt8LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct UInt16Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef UInt16LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return UInt16LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	uint16_t value() const {
		return GetField<uint16_t>(VT_VALUE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct UInt16LiteralBuilder {
	typedef UInt16Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(uint16_t value) {
		fbb_.AddElement<uint16_t>(UInt16Literal::VT_VALUE, value, 0);
	}
	explicit UInt16LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<UInt16Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<UInt16Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<UInt16Literal> CreateUInt16Literal(flatbuffers::FlatBufferBuilder &_fbb,
                                                              uint16_t value = 0) {
	UInt16LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct UInt32Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef UInt32LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return UInt32LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	uint32_t value() const {
		return GetField<uint32_t>(VT_VALUE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct UInt32LiteralBuilder {
	typedef UInt32Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(uint32_t value) {
		fbb_.AddElement<uint32_t>(UInt32Literal::VT_VALUE, value, 0);
	}
	explicit UInt32LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<UInt32Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<UInt32Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<UInt32Literal> CreateUInt32Literal(flatbuffers::FlatBufferBuilder &_fbb,
                                                              uint32_t value = 0) {
	UInt32LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct UInt64Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef UInt64LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return UInt64LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	uint64_t value() const {
		return GetField<uint64_t>(VT_VALUE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint64_t>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct UInt64LiteralBuilder {
	typedef UInt64Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(uint64_t value) {
		fbb_.AddElement<uint64_t>(UInt64Literal::VT_VALUE, value, 0);
	}
	explicit UInt64LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<UInt64Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<UInt64Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<UInt64Literal> CreateUInt64Literal(flatbuffers::FlatBufferBuilder &_fbb,
                                                              uint64_t value = 0) {
	UInt64LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct Float16Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Float16LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return Float16LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	uint16_t value() const {
		return GetField<uint16_t>(VT_VALUE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct Float16LiteralBuilder {
	typedef Float16Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(uint16_t value) {
		fbb_.AddElement<uint16_t>(Float16Literal::VT_VALUE, value, 0);
	}
	explicit Float16LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Float16Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Float16Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<Float16Literal> CreateFloat16Literal(flatbuffers::FlatBufferBuilder &_fbb,
                                                                uint16_t value = 0) {
	Float16LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct Float32Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Float32LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return Float32LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	float value() const {
		return GetField<float>(VT_VALUE, 0.0f);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct Float32LiteralBuilder {
	typedef Float32Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(float value) {
		fbb_.AddElement<float>(Float32Literal::VT_VALUE, value, 0.0f);
	}
	explicit Float32LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Float32Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Float32Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<Float32Literal> CreateFloat32Literal(flatbuffers::FlatBufferBuilder &_fbb,
                                                                float value = 0.0f) {
	Float32LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct Float64Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Float64LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return Float64LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	double value() const {
		return GetField<double>(VT_VALUE, 0.0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<double>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct Float64LiteralBuilder {
	typedef Float64Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(double value) {
		fbb_.AddElement<double>(Float64Literal::VT_VALUE, value, 0.0);
	}
	explicit Float64LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Float64Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Float64Literal>(end);
		return o;
	}
};

inline flatbuffers::Offset<Float64Literal> CreateFloat64Literal(flatbuffers::FlatBufferBuilder &_fbb,
                                                                double value = 0.0) {
	Float64LiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct DecimalLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef DecimalLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return DecimalLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4, VT_SCALE = 6, VT_PRECISION = 8 };
	/// These bytes must be in little-endian order.
	const flatbuffers::Vector<int8_t> *value() const {
		return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
	}
	int32_t scale() const {
		return GetField<int32_t>(VT_SCALE, 0);
	}
	int32_t precision() const {
		return GetField<int32_t>(VT_PRECISION, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_VALUE) &&
		       verifier.VerifyVector(value()) && VerifyField<int32_t>(verifier, VT_SCALE) &&
		       VerifyField<int32_t>(verifier, VT_PRECISION) && verifier.EndTable();
	}
};

struct DecimalLiteralBuilder {
	typedef DecimalLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
		fbb_.AddOffset(DecimalLiteral::VT_VALUE, value);
	}
	void add_scale(int32_t scale) {
		fbb_.AddElement<int32_t>(DecimalLiteral::VT_SCALE, scale, 0);
	}
	void add_precision(int32_t precision) {
		fbb_.AddElement<int32_t>(DecimalLiteral::VT_PRECISION, precision, 0);
	}
	explicit DecimalLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<DecimalLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<DecimalLiteral>(end);
		fbb_.Required(o, DecimalLiteral::VT_VALUE);
		return o;
	}
};

inline flatbuffers::Offset<DecimalLiteral>
CreateDecimalLiteral(flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0,
                     int32_t scale = 0, int32_t precision = 0) {
	DecimalLiteralBuilder builder_(_fbb);
	builder_.add_precision(precision);
	builder_.add_scale(scale);
	builder_.add_value(value);
	return builder_.Finish();
}

inline flatbuffers::Offset<DecimalLiteral> CreateDecimalLiteralDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                                      const std::vector<int8_t> *value = nullptr,
                                                                      int32_t scale = 0, int32_t precision = 0) {
	auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
	return org::apache::arrow::computeir::flatbuf::CreateDecimalLiteral(_fbb, value__, scale, precision);
}

struct BooleanLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef BooleanLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return BooleanLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	bool value() const {
		return GetField<uint8_t>(VT_VALUE, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_VALUE) && verifier.EndTable();
	}
};

struct BooleanLiteralBuilder {
	typedef BooleanLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(bool value) {
		fbb_.AddElement<uint8_t>(BooleanLiteral::VT_VALUE, static_cast<uint8_t>(value), 0);
	}
	explicit BooleanLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<BooleanLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<BooleanLiteral>(end);
		return o;
	}
};

inline flatbuffers::Offset<BooleanLiteral> CreateBooleanLiteral(flatbuffers::FlatBufferBuilder &_fbb,
                                                                bool value = false) {
	BooleanLiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

struct NullLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef NullLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return NullLiteralTypeTable();
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && verifier.EndTable();
	}
};

struct NullLiteralBuilder {
	typedef NullLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	explicit NullLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<NullLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<NullLiteral>(end);
		return o;
	}
};

inline flatbuffers::Offset<NullLiteral> CreateNullLiteral(flatbuffers::FlatBufferBuilder &_fbb) {
	NullLiteralBuilder builder_(_fbb);
	return builder_.Finish();
}

struct DateLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef DateLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return DateLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4, VT_UNIT = 6 };
	int64_t value() const {
		return GetField<int64_t>(VT_VALUE, 0);
	}
	org::apache::arrow::flatbuf::DateUnit unit() const {
		return static_cast<org::apache::arrow::flatbuf::DateUnit>(GetField<int16_t>(VT_UNIT, 1));
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_VALUE) &&
		       VerifyField<int16_t>(verifier, VT_UNIT) && verifier.EndTable();
	}
};

struct DateLiteralBuilder {
	typedef DateLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(int64_t value) {
		fbb_.AddElement<int64_t>(DateLiteral::VT_VALUE, value, 0);
	}
	void add_unit(org::apache::arrow::flatbuf::DateUnit unit) {
		fbb_.AddElement<int16_t>(DateLiteral::VT_UNIT, static_cast<int16_t>(unit), 1);
	}
	explicit DateLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<DateLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<DateLiteral>(end);
		return o;
	}
};

inline flatbuffers::Offset<DateLiteral>
CreateDateLiteral(flatbuffers::FlatBufferBuilder &_fbb, int64_t value = 0,
                  org::apache::arrow::flatbuf::DateUnit unit = org::apache::arrow::flatbuf::DateUnit_MILLISECOND) {
	DateLiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	builder_.add_unit(unit);
	return builder_.Finish();
}

struct TimeLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TimeLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return TimeLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4, VT_UNIT = 6 };
	int64_t value() const {
		return GetField<int64_t>(VT_VALUE, 0);
	}
	org::apache::arrow::flatbuf::TimeUnit unit() const {
		return static_cast<org::apache::arrow::flatbuf::TimeUnit>(GetField<int16_t>(VT_UNIT, 1));
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_VALUE) &&
		       VerifyField<int16_t>(verifier, VT_UNIT) && verifier.EndTable();
	}
};

struct TimeLiteralBuilder {
	typedef TimeLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(int64_t value) {
		fbb_.AddElement<int64_t>(TimeLiteral::VT_VALUE, value, 0);
	}
	void add_unit(org::apache::arrow::flatbuf::TimeUnit unit) {
		fbb_.AddElement<int16_t>(TimeLiteral::VT_UNIT, static_cast<int16_t>(unit), 1);
	}
	explicit TimeLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TimeLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TimeLiteral>(end);
		return o;
	}
};

inline flatbuffers::Offset<TimeLiteral>
CreateTimeLiteral(flatbuffers::FlatBufferBuilder &_fbb, int64_t value = 0,
                  org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_MILLISECOND) {
	TimeLiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	builder_.add_unit(unit);
	return builder_.Finish();
}

struct TimestampLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TimestampLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return TimestampLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4, VT_UNIT = 6, VT_TIMEZONE = 8 };
	int64_t value() const {
		return GetField<int64_t>(VT_VALUE, 0);
	}
	org::apache::arrow::flatbuf::TimeUnit unit() const {
		return static_cast<org::apache::arrow::flatbuf::TimeUnit>(GetField<int16_t>(VT_UNIT, 0));
	}
	const flatbuffers::String *timezone() const {
		return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_VALUE) &&
		       VerifyField<int16_t>(verifier, VT_UNIT) && VerifyOffset(verifier, VT_TIMEZONE) &&
		       verifier.VerifyString(timezone()) && verifier.EndTable();
	}
};

struct TimestampLiteralBuilder {
	typedef TimestampLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(int64_t value) {
		fbb_.AddElement<int64_t>(TimestampLiteral::VT_VALUE, value, 0);
	}
	void add_unit(org::apache::arrow::flatbuf::TimeUnit unit) {
		fbb_.AddElement<int16_t>(TimestampLiteral::VT_UNIT, static_cast<int16_t>(unit), 0);
	}
	void add_timezone(flatbuffers::Offset<flatbuffers::String> timezone) {
		fbb_.AddOffset(TimestampLiteral::VT_TIMEZONE, timezone);
	}
	explicit TimestampLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TimestampLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TimestampLiteral>(end);
		return o;
	}
};

inline flatbuffers::Offset<TimestampLiteral>
CreateTimestampLiteral(flatbuffers::FlatBufferBuilder &_fbb, int64_t value = 0,
                       org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_SECOND,
                       flatbuffers::Offset<flatbuffers::String> timezone = 0) {
	TimestampLiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	builder_.add_timezone(timezone);
	builder_.add_unit(unit);
	return builder_.Finish();
}

inline flatbuffers::Offset<TimestampLiteral>
CreateTimestampLiteralDirect(flatbuffers::FlatBufferBuilder &_fbb, int64_t value = 0,
                             org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_SECOND,
                             const char *timezone = nullptr) {
	auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
	return org::apache::arrow::computeir::flatbuf::CreateTimestampLiteral(_fbb, value, unit, timezone__);
}

struct IntervalLiteralMonths FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef IntervalLiteralMonthsBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return IntervalLiteralMonthsTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_MONTHS = 4 };
	int32_t months() const {
		return GetField<int32_t>(VT_MONTHS, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_MONTHS) && verifier.EndTable();
	}
};

struct IntervalLiteralMonthsBuilder {
	typedef IntervalLiteralMonths Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_months(int32_t months) {
		fbb_.AddElement<int32_t>(IntervalLiteralMonths::VT_MONTHS, months, 0);
	}
	explicit IntervalLiteralMonthsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<IntervalLiteralMonths> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<IntervalLiteralMonths>(end);
		return o;
	}
};

inline flatbuffers::Offset<IntervalLiteralMonths> CreateIntervalLiteralMonths(flatbuffers::FlatBufferBuilder &_fbb,
                                                                              int32_t months = 0) {
	IntervalLiteralMonthsBuilder builder_(_fbb);
	builder_.add_months(months);
	return builder_.Finish();
}

struct IntervalLiteralDaysMilliseconds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef IntervalLiteralDaysMillisecondsBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return IntervalLiteralDaysMillisecondsTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_DAYS = 4, VT_MILLISECONDS = 6 };
	int32_t days() const {
		return GetField<int32_t>(VT_DAYS, 0);
	}
	int32_t milliseconds() const {
		return GetField<int32_t>(VT_MILLISECONDS, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_DAYS) &&
		       VerifyField<int32_t>(verifier, VT_MILLISECONDS) && verifier.EndTable();
	}
};

struct IntervalLiteralDaysMillisecondsBuilder {
	typedef IntervalLiteralDaysMilliseconds Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_days(int32_t days) {
		fbb_.AddElement<int32_t>(IntervalLiteralDaysMilliseconds::VT_DAYS, days, 0);
	}
	void add_milliseconds(int32_t milliseconds) {
		fbb_.AddElement<int32_t>(IntervalLiteralDaysMilliseconds::VT_MILLISECONDS, milliseconds, 0);
	}
	explicit IntervalLiteralDaysMillisecondsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<IntervalLiteralDaysMilliseconds> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<IntervalLiteralDaysMilliseconds>(end);
		return o;
	}
};

inline flatbuffers::Offset<IntervalLiteralDaysMilliseconds>
CreateIntervalLiteralDaysMilliseconds(flatbuffers::FlatBufferBuilder &_fbb, int32_t days = 0,
                                      int32_t milliseconds = 0) {
	IntervalLiteralDaysMillisecondsBuilder builder_(_fbb);
	builder_.add_milliseconds(milliseconds);
	builder_.add_days(days);
	return builder_.Finish();
}

struct IntervalLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef IntervalLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return IntervalLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE_TYPE = 4, VT_VALUE = 6 };
	org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl value_type() const {
		return static_cast<org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl>(
		    GetField<uint8_t>(VT_VALUE_TYPE, 0));
	}
	const void *value() const {
		return GetPointer<const void *>(VT_VALUE);
	}
	template <typename T>
	const T *value_as() const;
	const org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths *value_as_IntervalLiteralMonths() const {
		return value_type() == org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl_IntervalLiteralMonths
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths *>(value())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds *
	value_as_IntervalLiteralDaysMilliseconds() const {
		return value_type() ==
		               org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl_IntervalLiteralDaysMilliseconds
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds *>(
		                 value())
		           : nullptr;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
		       VerifyOffsetRequired(verifier, VT_VALUE) && VerifyIntervalLiteralImpl(verifier, value(), value_type()) &&
		       verifier.EndTable();
	}
};

template <>
inline const org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths *
IntervalLiteral::value_as<org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths>() const {
	return value_as_IntervalLiteralMonths();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds *
IntervalLiteral::value_as<org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds>() const {
	return value_as_IntervalLiteralDaysMilliseconds();
}

struct IntervalLiteralBuilder {
	typedef IntervalLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value_type(org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl value_type) {
		fbb_.AddElement<uint8_t>(IntervalLiteral::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
	}
	void add_value(flatbuffers::Offset<void> value) {
		fbb_.AddOffset(IntervalLiteral::VT_VALUE, value);
	}
	explicit IntervalLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<IntervalLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<IntervalLiteral>(end);
		fbb_.Required(o, IntervalLiteral::VT_VALUE);
		return o;
	}
};

inline flatbuffers::Offset<IntervalLiteral>
CreateIntervalLiteral(flatbuffers::FlatBufferBuilder &_fbb,
                      org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl value_type =
                          org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl_NONE,
                      flatbuffers::Offset<void> value = 0) {
	IntervalLiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	builder_.add_value_type(value_type);
	return builder_.Finish();
}

struct DurationLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef DurationLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return DurationLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4, VT_UNIT = 6 };
	int64_t value() const {
		return GetField<int64_t>(VT_VALUE, 0);
	}
	org::apache::arrow::flatbuf::TimeUnit unit() const {
		return static_cast<org::apache::arrow::flatbuf::TimeUnit>(GetField<int16_t>(VT_UNIT, 1));
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_VALUE) &&
		       VerifyField<int16_t>(verifier, VT_UNIT) && verifier.EndTable();
	}
};

struct DurationLiteralBuilder {
	typedef DurationLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(int64_t value) {
		fbb_.AddElement<int64_t>(DurationLiteral::VT_VALUE, value, 0);
	}
	void add_unit(org::apache::arrow::flatbuf::TimeUnit unit) {
		fbb_.AddElement<int16_t>(DurationLiteral::VT_UNIT, static_cast<int16_t>(unit), 1);
	}
	explicit DurationLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<DurationLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<DurationLiteral>(end);
		return o;
	}
};

inline flatbuffers::Offset<DurationLiteral>
CreateDurationLiteral(flatbuffers::FlatBufferBuilder &_fbb, int64_t value = 0,
                      org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_MILLISECOND) {
	DurationLiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	builder_.add_unit(unit);
	return builder_.Finish();
}

struct BinaryLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef BinaryLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return BinaryLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	const flatbuffers::Vector<int8_t> *value() const {
		return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_VALUE) &&
		       verifier.VerifyVector(value()) && verifier.EndTable();
	}
};

struct BinaryLiteralBuilder {
	typedef BinaryLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
		fbb_.AddOffset(BinaryLiteral::VT_VALUE, value);
	}
	explicit BinaryLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<BinaryLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<BinaryLiteral>(end);
		fbb_.Required(o, BinaryLiteral::VT_VALUE);
		return o;
	}
};

inline flatbuffers::Offset<BinaryLiteral>
CreateBinaryLiteral(flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
	BinaryLiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

inline flatbuffers::Offset<BinaryLiteral> CreateBinaryLiteralDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const std::vector<int8_t> *value = nullptr) {
	auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
	return org::apache::arrow::computeir::flatbuf::CreateBinaryLiteral(_fbb, value__);
}

struct FixedSizeBinaryLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef FixedSizeBinaryLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return FixedSizeBinaryLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4, VT_SIZE = 6 };
	const flatbuffers::Vector<int8_t> *value() const {
		return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
	}
	int32_t size() const {
		return GetField<int32_t>(VT_SIZE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_VALUE) &&
		       verifier.VerifyVector(value()) && VerifyField<int32_t>(verifier, VT_SIZE) && verifier.EndTable();
	}
};

struct FixedSizeBinaryLiteralBuilder {
	typedef FixedSizeBinaryLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
		fbb_.AddOffset(FixedSizeBinaryLiteral::VT_VALUE, value);
	}
	void add_size(int32_t size) {
		fbb_.AddElement<int32_t>(FixedSizeBinaryLiteral::VT_SIZE, size, 0);
	}
	explicit FixedSizeBinaryLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<FixedSizeBinaryLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<FixedSizeBinaryLiteral>(end);
		fbb_.Required(o, FixedSizeBinaryLiteral::VT_VALUE);
		return o;
	}
};

inline flatbuffers::Offset<FixedSizeBinaryLiteral>
CreateFixedSizeBinaryLiteral(flatbuffers::FlatBufferBuilder &_fbb,
                             flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0, int32_t size = 0) {
	FixedSizeBinaryLiteralBuilder builder_(_fbb);
	builder_.add_size(size);
	builder_.add_value(value);
	return builder_.Finish();
}

inline flatbuffers::Offset<FixedSizeBinaryLiteral>
CreateFixedSizeBinaryLiteralDirect(flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int8_t> *value = nullptr,
                                   int32_t size = 0) {
	auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
	return org::apache::arrow::computeir::flatbuf::CreateFixedSizeBinaryLiteral(_fbb, value__, size);
}

struct StringLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StringLiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return StringLiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
	const flatbuffers::String *value() const {
		return GetPointer<const flatbuffers::String *>(VT_VALUE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_VALUE) &&
		       verifier.VerifyString(value()) && verifier.EndTable();
	}
};

struct StringLiteralBuilder {
	typedef StringLiteral Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(flatbuffers::Offset<flatbuffers::String> value) {
		fbb_.AddOffset(StringLiteral::VT_VALUE, value);
	}
	explicit StringLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StringLiteral> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StringLiteral>(end);
		fbb_.Required(o, StringLiteral::VT_VALUE);
		return o;
	}
};

inline flatbuffers::Offset<StringLiteral> CreateStringLiteral(flatbuffers::FlatBufferBuilder &_fbb,
                                                              flatbuffers::Offset<flatbuffers::String> value = 0) {
	StringLiteralBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

inline flatbuffers::Offset<StringLiteral> CreateStringLiteralDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const char *value = nullptr) {
	auto value__ = value ? _fbb.CreateString(value) : 0;
	return org::apache::arrow::computeir::flatbuf::CreateStringLiteral(_fbb, value__);
}

struct Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef LiteralBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return LiteralTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_IMPL_TYPE = 4, VT_IMPL = 6 };
	org::apache::arrow::computeir::flatbuf::LiteralImpl impl_type() const {
		return static_cast<org::apache::arrow::computeir::flatbuf::LiteralImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
	}
	const void *impl() const {
		return GetPointer<const void *>(VT_IMPL);
	}
	template <typename T>
	const T *impl_as() const;
	const org::apache::arrow::computeir::flatbuf::NullLiteral *impl_as_NullLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_NullLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::NullLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::BooleanLiteral *impl_as_BooleanLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_BooleanLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::BooleanLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Int8Literal *impl_as_Int8Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_Int8Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Int8Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Int16Literal *impl_as_Int16Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_Int16Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Int16Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Int32Literal *impl_as_Int32Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_Int32Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Int32Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Int64Literal *impl_as_Int64Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_Int64Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Int64Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::UInt8Literal *impl_as_UInt8Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_UInt8Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt8Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::UInt16Literal *impl_as_UInt16Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_UInt16Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt16Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::UInt32Literal *impl_as_UInt32Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_UInt32Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt32Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::UInt64Literal *impl_as_UInt64Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_UInt64Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt64Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::DateLiteral *impl_as_DateLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_DateLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::DateLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::TimeLiteral *impl_as_TimeLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_TimeLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::TimeLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::TimestampLiteral *impl_as_TimestampLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_TimestampLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::TimestampLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::IntervalLiteral *impl_as_IntervalLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_IntervalLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::DurationLiteral *impl_as_DurationLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_DurationLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::DurationLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::DecimalLiteral *impl_as_DecimalLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_DecimalLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::DecimalLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Float16Literal *impl_as_Float16Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_Float16Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Float16Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Float32Literal *impl_as_Float32Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_Float32Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Float32Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Float64Literal *impl_as_Float64Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_Float64Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Float64Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::ListLiteral *impl_as_ListLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_ListLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::ListLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::StructLiteral *impl_as_StructLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_StructLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::StructLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::MapLiteral *impl_as_MapLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_MapLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::MapLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::StringLiteral *impl_as_StringLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_StringLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::StringLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::BinaryLiteral *impl_as_BinaryLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_BinaryLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::BinaryLiteral *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral *impl_as_FixedSizeBinaryLiteral() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl_FixedSizeBinaryLiteral
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral *>(impl())
		           : nullptr;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
		       VerifyOffsetRequired(verifier, VT_IMPL) && VerifyLiteralImpl(verifier, impl(), impl_type()) &&
		       verifier.EndTable();
	}
};

template <>
inline const org::apache::arrow::computeir::flatbuf::NullLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::NullLiteral>() const {
	return impl_as_NullLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::BooleanLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::BooleanLiteral>() const {
	return impl_as_BooleanLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Int8Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::Int8Literal>() const {
	return impl_as_Int8Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Int16Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::Int16Literal>() const {
	return impl_as_Int16Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Int32Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::Int32Literal>() const {
	return impl_as_Int32Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Int64Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::Int64Literal>() const {
	return impl_as_Int64Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::UInt8Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::UInt8Literal>() const {
	return impl_as_UInt8Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::UInt16Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::UInt16Literal>() const {
	return impl_as_UInt16Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::UInt32Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::UInt32Literal>() const {
	return impl_as_UInt32Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::UInt64Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::UInt64Literal>() const {
	return impl_as_UInt64Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::DateLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::DateLiteral>() const {
	return impl_as_DateLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::TimeLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::TimeLiteral>() const {
	return impl_as_TimeLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::TimestampLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::TimestampLiteral>() const {
	return impl_as_TimestampLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::IntervalLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::IntervalLiteral>() const {
	return impl_as_IntervalLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::DurationLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::DurationLiteral>() const {
	return impl_as_DurationLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::DecimalLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::DecimalLiteral>() const {
	return impl_as_DecimalLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Float16Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::Float16Literal>() const {
	return impl_as_Float16Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Float32Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::Float32Literal>() const {
	return impl_as_Float32Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Float64Literal *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::Float64Literal>() const {
	return impl_as_Float64Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::ListLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::ListLiteral>() const {
	return impl_as_ListLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::StructLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::StructLiteral>() const {
	return impl_as_StructLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::MapLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::MapLiteral>() const {
	return impl_as_MapLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::StringLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::StringLiteral>() const {
	return impl_as_StringLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::BinaryLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::BinaryLiteral>() const {
	return impl_as_BinaryLiteral();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral *
Literal::impl_as<org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral>() const {
	return impl_as_FixedSizeBinaryLiteral();
}

struct LiteralBuilder {
	typedef Literal Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_impl_type(org::apache::arrow::computeir::flatbuf::LiteralImpl impl_type) {
		fbb_.AddElement<uint8_t>(Literal::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
	}
	void add_impl(flatbuffers::Offset<void> impl) {
		fbb_.AddOffset(Literal::VT_IMPL, impl);
	}
	explicit LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Literal> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Literal>(end);
		fbb_.Required(o, Literal::VT_IMPL);
		return o;
	}
};

inline flatbuffers::Offset<Literal> CreateLiteral(flatbuffers::FlatBufferBuilder &_fbb,
                                                  org::apache::arrow::computeir::flatbuf::LiteralImpl impl_type =
                                                      org::apache::arrow::computeir::flatbuf::LiteralImpl_NONE,
                                                  flatbuffers::Offset<void> impl = 0) {
	LiteralBuilder builder_(_fbb);
	builder_.add_impl(impl);
	builder_.add_impl_type(impl_type);
	return builder_.Finish();
}

inline bool VerifyIntervalLiteralImpl(flatbuffers::Verifier &verifier, const void *obj, IntervalLiteralImpl type) {
	switch (type) {
	case IntervalLiteralImpl_NONE: {
		return true;
	}
	case IntervalLiteralImpl_IntervalLiteralMonths: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case IntervalLiteralImpl_IntervalLiteralDaysMilliseconds: {
		auto ptr =
		    reinterpret_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds *>(obj);
		return verifier.VerifyTable(ptr);
	}
	default:
		return true;
	}
}

inline bool VerifyIntervalLiteralImplVector(flatbuffers::Verifier &verifier,
                                            const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                            const flatbuffers::Vector<uint8_t> *types) {
	if (!values || !types)
		return !values && !types;
	if (values->size() != types->size())
		return false;
	for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
		if (!VerifyIntervalLiteralImpl(verifier, values->Get(i), types->GetEnum<IntervalLiteralImpl>(i))) {
			return false;
		}
	}
	return true;
}

inline bool VerifyLiteralImpl(flatbuffers::Verifier &verifier, const void *obj, LiteralImpl type) {
	switch (type) {
	case LiteralImpl_NONE: {
		return true;
	}
	case LiteralImpl_NullLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::NullLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_BooleanLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::BooleanLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_Int8Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int8Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_Int16Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int16Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_Int32Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int32Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_Int64Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int64Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_UInt8Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt8Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_UInt16Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt16Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_UInt32Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt32Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_UInt64Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt64Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_DateLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::DateLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_TimeLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::TimeLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_TimestampLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::TimestampLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_IntervalLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_DurationLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::DurationLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_DecimalLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::DecimalLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_Float16Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Float16Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_Float32Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Float32Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_Float64Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Float64Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_ListLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::ListLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_StructLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::StructLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_MapLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::MapLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_StringLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::StringLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_BinaryLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::BinaryLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case LiteralImpl_FixedSizeBinaryLiteral: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral *>(obj);
		return verifier.VerifyTable(ptr);
	}
	default:
		return true;
	}
}

inline bool VerifyLiteralImplVector(flatbuffers::Verifier &verifier,
                                    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                    const flatbuffers::Vector<uint8_t> *types) {
	if (!values || !types)
		return !values && !types;
	if (values->size() != types->size())
		return false;
	for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
		if (!VerifyLiteralImpl(verifier, values->Get(i), types->GetEnum<LiteralImpl>(i))) {
			return false;
		}
	}
	return true;
}

inline const flatbuffers::TypeTable *IntervalLiteralImplTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_SEQUENCE, 0, -1}, {flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 1}};
	static const flatbuffers::TypeFunction type_refs[] = {
	    org::apache::arrow::computeir::flatbuf::IntervalLiteralMonthsTypeTable,
	    org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMillisecondsTypeTable};
	static const char *const names[] = {"NONE", "IntervalLiteralMonths", "IntervalLiteralDaysMilliseconds"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *LiteralImplTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_SEQUENCE, 0, -1}, {flatbuffers::ET_SEQUENCE, 0, 0},  {flatbuffers::ET_SEQUENCE, 0, 1},
	    {flatbuffers::ET_SEQUENCE, 0, 2},  {flatbuffers::ET_SEQUENCE, 0, 3},  {flatbuffers::ET_SEQUENCE, 0, 4},
	    {flatbuffers::ET_SEQUENCE, 0, 5},  {flatbuffers::ET_SEQUENCE, 0, 6},  {flatbuffers::ET_SEQUENCE, 0, 7},
	    {flatbuffers::ET_SEQUENCE, 0, 8},  {flatbuffers::ET_SEQUENCE, 0, 9},  {flatbuffers::ET_SEQUENCE, 0, 10},
	    {flatbuffers::ET_SEQUENCE, 0, 11}, {flatbuffers::ET_SEQUENCE, 0, 12}, {flatbuffers::ET_SEQUENCE, 0, 13},
	    {flatbuffers::ET_SEQUENCE, 0, 14}, {flatbuffers::ET_SEQUENCE, 0, 15}, {flatbuffers::ET_SEQUENCE, 0, 16},
	    {flatbuffers::ET_SEQUENCE, 0, 17}, {flatbuffers::ET_SEQUENCE, 0, 18}, {flatbuffers::ET_SEQUENCE, 0, 19},
	    {flatbuffers::ET_SEQUENCE, 0, 20}, {flatbuffers::ET_SEQUENCE, 0, 21}, {flatbuffers::ET_SEQUENCE, 0, 22},
	    {flatbuffers::ET_SEQUENCE, 0, 23}, {flatbuffers::ET_SEQUENCE, 0, 24}};
	static const flatbuffers::TypeFunction type_refs[] = {
	    org::apache::arrow::computeir::flatbuf::NullLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::BooleanLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::Int8LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::Int16LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::Int32LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::Int64LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::UInt8LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::UInt16LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::UInt32LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::UInt64LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::DateLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::TimeLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::TimestampLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::IntervalLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::DurationLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::DecimalLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::Float16LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::Float32LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::Float64LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::ListLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::StructLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::MapLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::StringLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::BinaryLiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteralTypeTable};
	static const char *const names[] = {"NONE",           "NullLiteral",           "BooleanLiteral",  "Int8Literal",
	                                    "Int16Literal",   "Int32Literal",          "Int64Literal",    "UInt8Literal",
	                                    "UInt16Literal",  "UInt32Literal",         "UInt64Literal",   "DateLiteral",
	                                    "TimeLiteral",    "TimestampLiteral",      "IntervalLiteral", "DurationLiteral",
	                                    "DecimalLiteral", "Float16Literal",        "Float32Literal",  "Float64Literal",
	                                    "ListLiteral",    "StructLiteral",         "MapLiteral",      "StringLiteral",
	                                    "BinaryLiteral",  "FixedSizeBinaryLiteral"};
	static const flatbuffers::TypeTable tt = {
	    flatbuffers::ST_UNION, 26, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *ListLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_SEQUENCE, 1, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::LiteralTypeTable};
	static const char *const names[] = {"values"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *StructLiteralFieldTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_STRING, 0, -1},
	                                                   {flatbuffers::ET_SEQUENCE, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::LiteralTypeTable};
	static const char *const names[] = {"name", "value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *StructLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_SEQUENCE, 1, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {
	    org::apache::arrow::computeir::flatbuf::StructLiteralFieldTypeTable};
	static const char *const names[] = {"values"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *KeyValueTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_SEQUENCE, 0, 0},
	                                                   {flatbuffers::ET_SEQUENCE, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::LiteralTypeTable};
	static const char *const names[] = {"key", "value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *MapLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_SEQUENCE, 1, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::KeyValueTypeTable};
	static const char *const names[] = {"values"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *Int8LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_CHAR, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *Int16LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_SHORT, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *Int32LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *Int64LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_LONG, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *UInt8LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UCHAR, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *UInt16LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_USHORT, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *UInt32LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UINT, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *UInt64LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_ULONG, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *Float16LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_USHORT, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *Float32LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_FLOAT, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *Float64LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_DOUBLE, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *DecimalLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_CHAR, 1, -1}, {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
	static const char *const names[] = {"value", "scale", "precision"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *BooleanLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_BOOL, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *NullLiteralTypeTable() {
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr};
	return &tt;
}

inline const flatbuffers::TypeTable *DateLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_LONG, 0, -1}, {flatbuffers::ET_SHORT, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::flatbuf::DateUnitTypeTable};
	static const char *const names[] = {"value", "unit"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *TimeLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_LONG, 0, -1}, {flatbuffers::ET_SHORT, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::flatbuf::TimeUnitTypeTable};
	static const char *const names[] = {"value", "unit"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *TimestampLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_LONG, 0, -1}, {flatbuffers::ET_SHORT, 0, 0}, {flatbuffers::ET_STRING, 0, -1}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::flatbuf::TimeUnitTypeTable};
	static const char *const names[] = {"value", "unit", "timezone"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *IntervalLiteralMonthsTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
	static const char *const names[] = {"months"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *IntervalLiteralDaysMillisecondsTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
	static const char *const names[] = {"days", "milliseconds"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *IntervalLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UTYPE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {
	    org::apache::arrow::computeir::flatbuf::IntervalLiteralImplTypeTable};
	static const char *const names[] = {"value_type", "value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *DurationLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_LONG, 0, -1}, {flatbuffers::ET_SHORT, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::flatbuf::TimeUnitTypeTable};
	static const char *const names[] = {"value", "unit"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *BinaryLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_CHAR, 1, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *FixedSizeBinaryLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_CHAR, 1, -1}, {flatbuffers::ET_INT, 0, -1}};
	static const char *const names[] = {"value", "size"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *StringLiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_STRING, 0, -1}};
	static const char *const names[] = {"value"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *LiteralTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UTYPE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::LiteralImplTypeTable};
	static const char *const names[] = {"impl_type", "impl"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const org::apache::arrow::computeir::flatbuf::Literal *GetLiteral(const void *buf) {
	return flatbuffers::GetRoot<org::apache::arrow::computeir::flatbuf::Literal>(buf);
}

inline const org::apache::arrow::computeir::flatbuf::Literal *GetSizePrefixedLiteral(const void *buf) {
	return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::computeir::flatbuf::Literal>(buf);
}

inline bool VerifyLiteralBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifyBuffer<org::apache::arrow::computeir::flatbuf::Literal>(nullptr);
}

inline bool VerifySizePrefixedLiteralBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifySizePrefixedBuffer<org::apache::arrow::computeir::flatbuf::Literal>(nullptr);
}

inline void FinishLiteralBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> root) {
	fbb.Finish(root);
}

inline void FinishSizePrefixedLiteralBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                            flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> root) {
	fbb.FinishSizePrefixed(root);
}

} // namespace flatbuf
} // namespace computeir
} // namespace arrow
} // namespace apache
} // namespace org

#endif // FLATBUFFERS_GENERATED_LITERAL_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
