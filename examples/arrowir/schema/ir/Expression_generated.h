// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_EXPRESSION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_EXPRESSION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "Schema_generated.h"
#include "Literal_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace computeir {
namespace flatbuf {

struct MapKey;
struct MapKeyBuilder;

struct StructField;
struct StructFieldBuilder;

struct ArraySubscript;
struct ArraySubscriptBuilder;

struct ArraySlice;
struct ArraySliceBuilder;

struct FieldIndex;
struct FieldIndexBuilder;

struct FieldRef;
struct FieldRefBuilder;

struct Call;
struct CallBuilder;

struct CaseFragment;
struct CaseFragmentBuilder;

struct ConditionalCase;
struct ConditionalCaseBuilder;

struct SimpleCase;
struct SimpleCaseBuilder;

struct SortKey;
struct SortKeyBuilder;

struct Unbounded;
struct UnboundedBuilder;

struct Preceding;
struct PrecedingBuilder;

struct Following;
struct FollowingBuilder;

struct CurrentRow;
struct CurrentRowBuilder;

struct WindowCall;
struct WindowCallBuilder;

struct Expression;
struct ExpressionBuilder;

inline const flatbuffers::TypeTable *MapKeyTypeTable();

inline const flatbuffers::TypeTable *StructFieldTypeTable();

inline const flatbuffers::TypeTable *ArraySubscriptTypeTable();

inline const flatbuffers::TypeTable *ArraySliceTypeTable();

inline const flatbuffers::TypeTable *FieldIndexTypeTable();

inline const flatbuffers::TypeTable *FieldRefTypeTable();

inline const flatbuffers::TypeTable *CallTypeTable();

inline const flatbuffers::TypeTable *CaseFragmentTypeTable();

inline const flatbuffers::TypeTable *ConditionalCaseTypeTable();

inline const flatbuffers::TypeTable *SimpleCaseTypeTable();

inline const flatbuffers::TypeTable *SortKeyTypeTable();

inline const flatbuffers::TypeTable *UnboundedTypeTable();

inline const flatbuffers::TypeTable *PrecedingTypeTable();

inline const flatbuffers::TypeTable *FollowingTypeTable();

inline const flatbuffers::TypeTable *CurrentRowTypeTable();

inline const flatbuffers::TypeTable *WindowCallTypeTable();

inline const flatbuffers::TypeTable *ExpressionTypeTable();

/// A union of possible dereference operations
enum Deref : uint8_t {
	Deref_NONE = 0,
	/// Access a value for a given map key
	Deref_MapKey = 1,
	/// Access the value at a struct field
	Deref_StructField = 2,
	/// Access the element at a given index in an array
	Deref_ArraySubscript = 3,
	/// Access a range of elements in an array
	Deref_ArraySlice = 4,
	/// Access a field of a relation
	Deref_FieldIndex = 5,
	Deref_MIN = Deref_NONE,
	Deref_MAX = Deref_FieldIndex
};

inline const Deref (&EnumValuesDeref())[6] {
	static const Deref values[] = {Deref_NONE,           Deref_MapKey,     Deref_StructField,
	                               Deref_ArraySubscript, Deref_ArraySlice, Deref_FieldIndex};
	return values;
}

inline const char *const *EnumNamesDeref() {
	static const char *const names[7] = {"NONE",       "MapKey",     "StructField", "ArraySubscript",
	                                     "ArraySlice", "FieldIndex", nullptr};
	return names;
}

inline const char *EnumNameDeref(Deref e) {
	if (flatbuffers::IsOutRange(e, Deref_NONE, Deref_FieldIndex))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesDeref()[index];
}

template <typename T>
struct DerefTraits {
	static const Deref enum_value = Deref_NONE;
};

template <>
struct DerefTraits<org::apache::arrow::computeir::flatbuf::MapKey> {
	static const Deref enum_value = Deref_MapKey;
};

template <>
struct DerefTraits<org::apache::arrow::computeir::flatbuf::StructField> {
	static const Deref enum_value = Deref_StructField;
};

template <>
struct DerefTraits<org::apache::arrow::computeir::flatbuf::ArraySubscript> {
	static const Deref enum_value = Deref_ArraySubscript;
};

template <>
struct DerefTraits<org::apache::arrow::computeir::flatbuf::ArraySlice> {
	static const Deref enum_value = Deref_ArraySlice;
};

template <>
struct DerefTraits<org::apache::arrow::computeir::flatbuf::FieldIndex> {
	static const Deref enum_value = Deref_FieldIndex;
};

bool VerifyDeref(flatbuffers::Verifier &verifier, const void *obj, Deref type);
bool VerifyDerefVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                       const flatbuffers::Vector<uint8_t> *types);

/// Whether lesser values should precede greater or vice versa,
/// also whether nulls should preced or follow values
enum Ordering : uint8_t {
	Ordering_ASCENDING_THEN_NULLS = 0,
	Ordering_DESCENDING_THEN_NULLS = 1,
	Ordering_NULLS_THEN_ASCENDING = 2,
	Ordering_NULLS_THEN_DESCENDING = 3,
	Ordering_MIN = Ordering_ASCENDING_THEN_NULLS,
	Ordering_MAX = Ordering_NULLS_THEN_DESCENDING
};

inline const Ordering (&EnumValuesOrdering())[4] {
	static const Ordering values[] = {Ordering_ASCENDING_THEN_NULLS, Ordering_DESCENDING_THEN_NULLS,
	                                  Ordering_NULLS_THEN_ASCENDING, Ordering_NULLS_THEN_DESCENDING};
	return values;
}

inline const char *const *EnumNamesOrdering() {
	static const char *const names[5] = {"ASCENDING_THEN_NULLS", "DESCENDING_THEN_NULLS", "NULLS_THEN_ASCENDING",
	                                     "NULLS_THEN_DESCENDING", nullptr};
	return names;
}

inline const char *EnumNameOrdering(Ordering e) {
	if (flatbuffers::IsOutRange(e, Ordering_ASCENDING_THEN_NULLS, Ordering_NULLS_THEN_DESCENDING))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesOrdering()[index];
}

/// A concrete bound, which can be an expression or unbounded
enum ConcreteBoundImpl : uint8_t {
	ConcreteBoundImpl_NONE = 0,
	ConcreteBoundImpl_Expression = 1,
	ConcreteBoundImpl_Unbounded = 2,
	ConcreteBoundImpl_MIN = ConcreteBoundImpl_NONE,
	ConcreteBoundImpl_MAX = ConcreteBoundImpl_Unbounded
};

inline const ConcreteBoundImpl (&EnumValuesConcreteBoundImpl())[3] {
	static const ConcreteBoundImpl values[] = {ConcreteBoundImpl_NONE, ConcreteBoundImpl_Expression,
	                                           ConcreteBoundImpl_Unbounded};
	return values;
}

inline const char *const *EnumNamesConcreteBoundImpl() {
	static const char *const names[4] = {"NONE", "Expression", "Unbounded", nullptr};
	return names;
}

inline const char *EnumNameConcreteBoundImpl(ConcreteBoundImpl e) {
	if (flatbuffers::IsOutRange(e, ConcreteBoundImpl_NONE, ConcreteBoundImpl_Unbounded))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesConcreteBoundImpl()[index];
}

template <typename T>
struct ConcreteBoundImplTraits {
	static const ConcreteBoundImpl enum_value = ConcreteBoundImpl_NONE;
};

template <>
struct ConcreteBoundImplTraits<org::apache::arrow::computeir::flatbuf::Expression> {
	static const ConcreteBoundImpl enum_value = ConcreteBoundImpl_Expression;
};

template <>
struct ConcreteBoundImplTraits<org::apache::arrow::computeir::flatbuf::Unbounded> {
	static const ConcreteBoundImpl enum_value = ConcreteBoundImpl_Unbounded;
};

bool VerifyConcreteBoundImpl(flatbuffers::Verifier &verifier, const void *obj, ConcreteBoundImpl type);
bool VerifyConcreteBoundImplVector(flatbuffers::Verifier &verifier,
                                   const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                   const flatbuffers::Vector<uint8_t> *types);

enum Bound : uint8_t {
	Bound_NONE = 0,
	Bound_Preceding = 1,
	Bound_Following = 2,
	Bound_CurrentRow = 3,
	Bound_MIN = Bound_NONE,
	Bound_MAX = Bound_CurrentRow
};

inline const Bound (&EnumValuesBound())[4] {
	static const Bound values[] = {Bound_NONE, Bound_Preceding, Bound_Following, Bound_CurrentRow};
	return values;
}

inline const char *const *EnumNamesBound() {
	static const char *const names[5] = {"NONE", "Preceding", "Following", "CurrentRow", nullptr};
	return names;
}

inline const char *EnumNameBound(Bound e) {
	if (flatbuffers::IsOutRange(e, Bound_NONE, Bound_CurrentRow))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesBound()[index];
}

template <typename T>
struct BoundTraits {
	static const Bound enum_value = Bound_NONE;
};

template <>
struct BoundTraits<org::apache::arrow::computeir::flatbuf::Preceding> {
	static const Bound enum_value = Bound_Preceding;
};

template <>
struct BoundTraits<org::apache::arrow::computeir::flatbuf::Following> {
	static const Bound enum_value = Bound_Following;
};

template <>
struct BoundTraits<org::apache::arrow::computeir::flatbuf::CurrentRow> {
	static const Bound enum_value = Bound_CurrentRow;
};

bool VerifyBound(flatbuffers::Verifier &verifier, const void *obj, Bound type);
bool VerifyBoundVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                       const flatbuffers::Vector<uint8_t> *types);

/// The kind of window function to be executed
enum Frame : uint8_t { Frame_Rows = 0, Frame_Range = 1, Frame_MIN = Frame_Rows, Frame_MAX = Frame_Range };

inline const Frame (&EnumValuesFrame())[2] {
	static const Frame values[] = {Frame_Rows, Frame_Range};
	return values;
}

inline const char *const *EnumNamesFrame() {
	static const char *const names[3] = {"Rows", "Range", nullptr};
	return names;
}

inline const char *EnumNameFrame(Frame e) {
	if (flatbuffers::IsOutRange(e, Frame_Rows, Frame_Range))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesFrame()[index];
}

/// Various expression types
///
/// WindowCall is a separate variant
/// due to special options for each that don't apply to generic
/// function calls. Again this is done to make it easier
/// for consumers to deal with the structure of the operation
enum ExpressionImpl : uint8_t {
	ExpressionImpl_NONE = 0,
	ExpressionImpl_Literal = 1,
	ExpressionImpl_FieldRef = 2,
	ExpressionImpl_Call = 3,
	ExpressionImpl_ConditionalCase = 4,
	ExpressionImpl_SimpleCase = 5,
	ExpressionImpl_WindowCall = 6,
	ExpressionImpl_MIN = ExpressionImpl_NONE,
	ExpressionImpl_MAX = ExpressionImpl_WindowCall
};

inline const ExpressionImpl (&EnumValuesExpressionImpl())[7] {
	static const ExpressionImpl values[] = {
	    ExpressionImpl_NONE,      ExpressionImpl_Literal,         ExpressionImpl_FieldRef,
	    ExpressionImpl_Call,      ExpressionImpl_ConditionalCase, ExpressionImpl_SimpleCase,
	    ExpressionImpl_WindowCall};
	return values;
}

inline const char *const *EnumNamesExpressionImpl() {
	static const char *const names[8] = {"NONE",       "Literal",    "FieldRef", "Call", "ConditionalCase",
	                                     "SimpleCase", "WindowCall", nullptr};
	return names;
}

inline const char *EnumNameExpressionImpl(ExpressionImpl e) {
	if (flatbuffers::IsOutRange(e, ExpressionImpl_NONE, ExpressionImpl_WindowCall))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesExpressionImpl()[index];
}

template <typename T>
struct ExpressionImplTraits {
	static const ExpressionImpl enum_value = ExpressionImpl_NONE;
};

template <>
struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::Literal> {
	static const ExpressionImpl enum_value = ExpressionImpl_Literal;
};

template <>
struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::FieldRef> {
	static const ExpressionImpl enum_value = ExpressionImpl_FieldRef;
};

template <>
struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::Call> {
	static const ExpressionImpl enum_value = ExpressionImpl_Call;
};

template <>
struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::ConditionalCase> {
	static const ExpressionImpl enum_value = ExpressionImpl_ConditionalCase;
};

template <>
struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::SimpleCase> {
	static const ExpressionImpl enum_value = ExpressionImpl_SimpleCase;
};

template <>
struct ExpressionImplTraits<org::apache::arrow::computeir::flatbuf::WindowCall> {
	static const ExpressionImpl enum_value = ExpressionImpl_WindowCall;
};

bool VerifyExpressionImpl(flatbuffers::Verifier &verifier, const void *obj, ExpressionImpl type);
bool VerifyExpressionImplVector(flatbuffers::Verifier &verifier,
                                const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                const flatbuffers::Vector<uint8_t> *types);

/// Access a value for a given map key
struct MapKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MapKeyBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return MapKeyTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_KEY = 4 };
	/// Any expression can be a map key.
	const org::apache::arrow::computeir::flatbuf::Expression *key() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_KEY);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_KEY) && verifier.VerifyTable(key()) &&
		       verifier.EndTable();
	}
};

struct MapKeyBuilder {
	typedef MapKey Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_key(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> key) {
		fbb_.AddOffset(MapKey::VT_KEY, key);
	}
	explicit MapKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<MapKey> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<MapKey>(end);
		fbb_.Required(o, MapKey::VT_KEY);
		return o;
	}
};

inline flatbuffers::Offset<MapKey>
CreateMapKey(flatbuffers::FlatBufferBuilder &_fbb,
             flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> key = 0) {
	MapKeyBuilder builder_(_fbb);
	builder_.add_key(key);
	return builder_.Finish();
}

/// Struct field access
struct StructField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StructFieldBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return StructFieldTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_POSITION = 4 };
	/// The position of the field in the struct schema
	uint32_t position() const {
		return GetField<uint32_t>(VT_POSITION, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_POSITION) && verifier.EndTable();
	}
};

struct StructFieldBuilder {
	typedef StructField Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_position(uint32_t position) {
		fbb_.AddElement<uint32_t>(StructField::VT_POSITION, position, 0);
	}
	explicit StructFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StructField> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StructField>(end);
		return o;
	}
};

inline flatbuffers::Offset<StructField> CreateStructField(flatbuffers::FlatBufferBuilder &_fbb, uint32_t position = 0) {
	StructFieldBuilder builder_(_fbb);
	builder_.add_position(position);
	return builder_.Finish();
}

/// Zero-based array index
struct ArraySubscript FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef ArraySubscriptBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return ArraySubscriptTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_POSITION = 4 };
	uint32_t position() const {
		return GetField<uint32_t>(VT_POSITION, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_POSITION) && verifier.EndTable();
	}
};

struct ArraySubscriptBuilder {
	typedef ArraySubscript Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_position(uint32_t position) {
		fbb_.AddElement<uint32_t>(ArraySubscript::VT_POSITION, position, 0);
	}
	explicit ArraySubscriptBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<ArraySubscript> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<ArraySubscript>(end);
		return o;
	}
};

inline flatbuffers::Offset<ArraySubscript> CreateArraySubscript(flatbuffers::FlatBufferBuilder &_fbb,
                                                                uint32_t position = 0) {
	ArraySubscriptBuilder builder_(_fbb);
	builder_.add_position(position);
	return builder_.Finish();
}

/// Zero-based range of elements in an array
struct ArraySlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef ArraySliceBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return ArraySliceTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_START_INCLUSIVE = 4, VT_END_EXCLUSIVE = 6 };
	/// The start of an array slice, inclusive
	uint32_t start_inclusive() const {
		return GetField<uint32_t>(VT_START_INCLUSIVE, 0);
	}
	/// The end of an array slice, exclusive
	uint32_t end_exclusive() const {
		return GetField<uint32_t>(VT_END_EXCLUSIVE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_START_INCLUSIVE) &&
		       VerifyField<uint32_t>(verifier, VT_END_EXCLUSIVE) && verifier.EndTable();
	}
};

struct ArraySliceBuilder {
	typedef ArraySlice Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_start_inclusive(uint32_t start_inclusive) {
		fbb_.AddElement<uint32_t>(ArraySlice::VT_START_INCLUSIVE, start_inclusive, 0);
	}
	void add_end_exclusive(uint32_t end_exclusive) {
		fbb_.AddElement<uint32_t>(ArraySlice::VT_END_EXCLUSIVE, end_exclusive, 0);
	}
	explicit ArraySliceBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<ArraySlice> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<ArraySlice>(end);
		return o;
	}
};

inline flatbuffers::Offset<ArraySlice> CreateArraySlice(flatbuffers::FlatBufferBuilder &_fbb,
                                                        uint32_t start_inclusive = 0, uint32_t end_exclusive = 0) {
	ArraySliceBuilder builder_(_fbb);
	builder_.add_end_exclusive(end_exclusive);
	builder_.add_start_inclusive(start_inclusive);
	return builder_.Finish();
}

/// Field name in a relation, in ordinal position of the relation's schema.
struct FieldIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef FieldIndexBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return FieldIndexTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_POSITION = 4 };
	uint32_t position() const {
		return GetField<uint32_t>(VT_POSITION, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_POSITION) && verifier.EndTable();
	}
};

struct FieldIndexBuilder {
	typedef FieldIndex Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_position(uint32_t position) {
		fbb_.AddElement<uint32_t>(FieldIndex::VT_POSITION, position, 0);
	}
	explicit FieldIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<FieldIndex> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<FieldIndex>(end);
		return o;
	}
};

inline flatbuffers::Offset<FieldIndex> CreateFieldIndex(flatbuffers::FlatBufferBuilder &_fbb, uint32_t position = 0) {
	FieldIndexBuilder builder_(_fbb);
	builder_.add_position(position);
	return builder_.Finish();
}

/// Access the data of a field
struct FieldRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef FieldRefBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return FieldRefTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_REF_TYPE = 4,
		VT_REF = 6,
		VT_RELATION_INDEX = 8
	};
	org::apache::arrow::computeir::flatbuf::Deref ref_type() const {
		return static_cast<org::apache::arrow::computeir::flatbuf::Deref>(GetField<uint8_t>(VT_REF_TYPE, 0));
	}
	const void *ref() const {
		return GetPointer<const void *>(VT_REF);
	}
	template <typename T>
	const T *ref_as() const;
	const org::apache::arrow::computeir::flatbuf::MapKey *ref_as_MapKey() const {
		return ref_type() == org::apache::arrow::computeir::flatbuf::Deref_MapKey
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::MapKey *>(ref())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::StructField *ref_as_StructField() const {
		return ref_type() == org::apache::arrow::computeir::flatbuf::Deref_StructField
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::StructField *>(ref())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::ArraySubscript *ref_as_ArraySubscript() const {
		return ref_type() == org::apache::arrow::computeir::flatbuf::Deref_ArraySubscript
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::ArraySubscript *>(ref())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::ArraySlice *ref_as_ArraySlice() const {
		return ref_type() == org::apache::arrow::computeir::flatbuf::Deref_ArraySlice
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::ArraySlice *>(ref())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::FieldIndex *ref_as_FieldIndex() const {
		return ref_type() == org::apache::arrow::computeir::flatbuf::Deref_FieldIndex
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::FieldIndex *>(ref())
		           : nullptr;
	}
	/// For Expressions which might reference fields in multiple Relations,
	/// this index may be provided to indicate which Relation's fields
	/// `ref` points into. For example in the case of a join,
	/// 0 refers to the left relation and 1 to the right relation.
	int32_t relation_index() const {
		return GetField<int32_t>(VT_RELATION_INDEX, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_REF_TYPE) &&
		       VerifyOffsetRequired(verifier, VT_REF) && VerifyDeref(verifier, ref(), ref_type()) &&
		       VerifyField<int32_t>(verifier, VT_RELATION_INDEX) && verifier.EndTable();
	}
};

template <>
inline const org::apache::arrow::computeir::flatbuf::MapKey *
FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::MapKey>() const {
	return ref_as_MapKey();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::StructField *
FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::StructField>() const {
	return ref_as_StructField();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::ArraySubscript *
FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::ArraySubscript>() const {
	return ref_as_ArraySubscript();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::ArraySlice *
FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::ArraySlice>() const {
	return ref_as_ArraySlice();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::FieldIndex *
FieldRef::ref_as<org::apache::arrow::computeir::flatbuf::FieldIndex>() const {
	return ref_as_FieldIndex();
}

struct FieldRefBuilder {
	typedef FieldRef Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_ref_type(org::apache::arrow::computeir::flatbuf::Deref ref_type) {
		fbb_.AddElement<uint8_t>(FieldRef::VT_REF_TYPE, static_cast<uint8_t>(ref_type), 0);
	}
	void add_ref(flatbuffers::Offset<void> ref) {
		fbb_.AddOffset(FieldRef::VT_REF, ref);
	}
	void add_relation_index(int32_t relation_index) {
		fbb_.AddElement<int32_t>(FieldRef::VT_RELATION_INDEX, relation_index, 0);
	}
	explicit FieldRefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<FieldRef> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<FieldRef>(end);
		fbb_.Required(o, FieldRef::VT_REF);
		return o;
	}
};

inline flatbuffers::Offset<FieldRef> CreateFieldRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::Deref ref_type = org::apache::arrow::computeir::flatbuf::Deref_NONE,
    flatbuffers::Offset<void> ref = 0, int32_t relation_index = 0) {
	FieldRefBuilder builder_(_fbb);
	builder_.add_relation_index(relation_index);
	builder_.add_ref(ref);
	builder_.add_ref_type(ref_type);
	return builder_.Finish();
}

/// A function call expression
struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef CallBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return CallTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NAME = 4, VT_ARGUMENTS = 6, VT_ORDERINGS = 8 };
	/// The function to call
	const flatbuffers::String *name() const {
		return GetPointer<const flatbuffers::String *>(VT_NAME);
	}
	/// The arguments passed to `name`.
	const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *
	arguments() const {
		return GetPointer<
		    const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(
		    VT_ARGUMENTS);
	}
	/// Possible ordering of input. These are useful
	/// in aggregates where ordering in meaningful such as
	/// string concatenation
	const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *orderings() const {
		return GetPointer<
		    const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *>(
		    VT_ORDERINGS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
		       VerifyOffsetRequired(verifier, VT_ARGUMENTS) && verifier.VerifyVector(arguments()) &&
		       verifier.VerifyVectorOfTables(arguments()) && VerifyOffset(verifier, VT_ORDERINGS) &&
		       verifier.VerifyVector(orderings()) && verifier.VerifyVectorOfTables(orderings()) && verifier.EndTable();
	}
};

struct CallBuilder {
	typedef Call Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_name(flatbuffers::Offset<flatbuffers::String> name) {
		fbb_.AddOffset(Call::VT_NAME, name);
	}
	void add_arguments(flatbuffers::Offset<
	                   flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>>
	                       arguments) {
		fbb_.AddOffset(Call::VT_ARGUMENTS, arguments);
	}
	void add_orderings(
	    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>>
	        orderings) {
		fbb_.AddOffset(Call::VT_ORDERINGS, orderings);
	}
	explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Call> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Call>(end);
		fbb_.Required(o, Call::VT_NAME);
		fbb_.Required(o, Call::VT_ARGUMENTS);
		return o;
	}
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>>
        arguments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>>
        orderings = 0) {
	CallBuilder builder_(_fbb);
	builder_.add_orderings(orderings);
	builder_.add_arguments(arguments);
	builder_.add_name(name);
	return builder_.Finish();
}

inline flatbuffers::Offset<Call> CreateCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *arguments = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *orderings = nullptr) {
	auto name__ = name ? _fbb.CreateString(name) : 0;
	auto arguments__ =
	    arguments
	        ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*arguments)
	        : 0;
	auto orderings__ =
	    orderings ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>(*orderings)
	              : 0;
	return org::apache::arrow::computeir::flatbuf::CreateCall(_fbb, name__, arguments__, orderings__);
}

/// A single WHEN x THEN y fragment.
struct CaseFragment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef CaseFragmentBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return CaseFragmentTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_MATCH = 4, VT_RESULT = 6 };
	const org::apache::arrow::computeir::flatbuf::Expression *match() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_MATCH);
	}
	const org::apache::arrow::computeir::flatbuf::Expression *result() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_RESULT);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_MATCH) &&
		       verifier.VerifyTable(match()) && VerifyOffsetRequired(verifier, VT_RESULT) &&
		       verifier.VerifyTable(result()) && verifier.EndTable();
	}
};

struct CaseFragmentBuilder {
	typedef CaseFragment Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_match(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> match) {
		fbb_.AddOffset(CaseFragment::VT_MATCH, match);
	}
	void add_result(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> result) {
		fbb_.AddOffset(CaseFragment::VT_RESULT, result);
	}
	explicit CaseFragmentBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<CaseFragment> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<CaseFragment>(end);
		fbb_.Required(o, CaseFragment::VT_MATCH);
		fbb_.Required(o, CaseFragment::VT_RESULT);
		return o;
	}
};

inline flatbuffers::Offset<CaseFragment>
CreateCaseFragment(flatbuffers::FlatBufferBuilder &_fbb,
                   flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> match = 0,
                   flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> result = 0) {
	CaseFragmentBuilder builder_(_fbb);
	builder_.add_result(result);
	builder_.add_match(match);
	return builder_.Finish();
}

/// Conditional case statement expression
struct ConditionalCase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef ConditionalCaseBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return ConditionalCaseTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_CONDITIONS = 4, VT_ELSE_ = 6 };
	/// List of conditions to evaluate
	const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>> *
	conditions() const {
		return GetPointer<
		    const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>> *>(
		    VT_CONDITIONS);
	}
	/// The default value if no cases match. This is typically NULL in SQL
	/// implementations.
	///
	/// Defaulting to NULL is a frontend choice, so producers must specify NULL
	/// if that's their desired behavior.
	const org::apache::arrow::computeir::flatbuf::Expression *else_() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_ELSE_);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_CONDITIONS) &&
		       verifier.VerifyVector(conditions()) && verifier.VerifyVectorOfTables(conditions()) &&
		       VerifyOffsetRequired(verifier, VT_ELSE_) && verifier.VerifyTable(else_()) && verifier.EndTable();
	}
};

struct ConditionalCaseBuilder {
	typedef ConditionalCase Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_conditions(flatbuffers::Offset<
	                    flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>>>
	                        conditions) {
		fbb_.AddOffset(ConditionalCase::VT_CONDITIONS, conditions);
	}
	void add_else_(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> else_) {
		fbb_.AddOffset(ConditionalCase::VT_ELSE_, else_);
	}
	explicit ConditionalCaseBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<ConditionalCase> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<ConditionalCase>(end);
		fbb_.Required(o, ConditionalCase::VT_CONDITIONS);
		fbb_.Required(o, ConditionalCase::VT_ELSE_);
		return o;
	}
};

inline flatbuffers::Offset<ConditionalCase> CreateConditionalCase(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>>>
        conditions = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> else_ = 0) {
	ConditionalCaseBuilder builder_(_fbb);
	builder_.add_else_(else_);
	builder_.add_conditions(conditions);
	return builder_.Finish();
}

inline flatbuffers::Offset<ConditionalCase> CreateConditionalCaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>> *conditions = nullptr,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> else_ = 0) {
	auto conditions__ =
	    conditions
	        ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>>(*conditions)
	        : 0;
	return org::apache::arrow::computeir::flatbuf::CreateConditionalCase(_fbb, conditions__, else_);
}

/// Switch-style case expression
struct SimpleCase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef SimpleCaseBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return SimpleCaseTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_EXPRESSION = 4, VT_MATCHES = 6, VT_ELSE_ = 8 };
	/// The expression whose value will be matched
	const org::apache::arrow::computeir::flatbuf::Expression *expression() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_EXPRESSION);
	}
	/// Matches for `expression`
	const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>> *
	matches() const {
		return GetPointer<
		    const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>> *>(
		    VT_MATCHES);
	}
	/// The default value if no cases match
	const org::apache::arrow::computeir::flatbuf::Expression *else_() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_ELSE_);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_EXPRESSION) &&
		       verifier.VerifyTable(expression()) && VerifyOffsetRequired(verifier, VT_MATCHES) &&
		       verifier.VerifyVector(matches()) && verifier.VerifyVectorOfTables(matches()) &&
		       VerifyOffsetRequired(verifier, VT_ELSE_) && verifier.VerifyTable(else_()) && verifier.EndTable();
	}
};

struct SimpleCaseBuilder {
	typedef SimpleCase Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_expression(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression) {
		fbb_.AddOffset(SimpleCase::VT_EXPRESSION, expression);
	}
	void add_matches(flatbuffers::Offset<
	                 flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>>>
	                     matches) {
		fbb_.AddOffset(SimpleCase::VT_MATCHES, matches);
	}
	void add_else_(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> else_) {
		fbb_.AddOffset(SimpleCase::VT_ELSE_, else_);
	}
	explicit SimpleCaseBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<SimpleCase> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<SimpleCase>(end);
		fbb_.Required(o, SimpleCase::VT_EXPRESSION);
		fbb_.Required(o, SimpleCase::VT_MATCHES);
		fbb_.Required(o, SimpleCase::VT_ELSE_);
		return o;
	}
};

inline flatbuffers::Offset<SimpleCase> CreateSimpleCase(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>>>
        matches = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> else_ = 0) {
	SimpleCaseBuilder builder_(_fbb);
	builder_.add_else_(else_);
	builder_.add_matches(matches);
	builder_.add_expression(expression);
	return builder_.Finish();
}

inline flatbuffers::Offset<SimpleCase> CreateSimpleCaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>> *matches = nullptr,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> else_ = 0) {
	auto matches__ =
	    matches ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::CaseFragment>>(*matches)
	            : 0;
	return org::apache::arrow::computeir::flatbuf::CreateSimpleCase(_fbb, expression, matches__, else_);
}

/// An expression with an order
struct SortKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef SortKeyBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return SortKeyTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_EXPRESSION = 4, VT_ORDERING = 6 };
	const org::apache::arrow::computeir::flatbuf::Expression *expression() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_EXPRESSION);
	}
	org::apache::arrow::computeir::flatbuf::Ordering ordering() const {
		return static_cast<org::apache::arrow::computeir::flatbuf::Ordering>(GetField<uint8_t>(VT_ORDERING, 0));
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_EXPRESSION) &&
		       verifier.VerifyTable(expression()) && VerifyField<uint8_t>(verifier, VT_ORDERING) && verifier.EndTable();
	}
};

struct SortKeyBuilder {
	typedef SortKey Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_expression(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression) {
		fbb_.AddOffset(SortKey::VT_EXPRESSION, expression);
	}
	void add_ordering(org::apache::arrow::computeir::flatbuf::Ordering ordering) {
		fbb_.AddElement<uint8_t>(SortKey::VT_ORDERING, static_cast<uint8_t>(ordering), 0);
	}
	explicit SortKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<SortKey> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<SortKey>(end);
		fbb_.Required(o, SortKey::VT_EXPRESSION);
		return o;
	}
};

inline flatbuffers::Offset<SortKey>
CreateSortKey(flatbuffers::FlatBufferBuilder &_fbb,
              flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
              org::apache::arrow::computeir::flatbuf::Ordering ordering =
                  org::apache::arrow::computeir::flatbuf::Ordering_ASCENDING_THEN_NULLS) {
	SortKeyBuilder builder_(_fbb);
	builder_.add_expression(expression);
	builder_.add_ordering(ordering);
	return builder_.Finish();
}

/// An unbounded window bound
struct Unbounded FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef UnboundedBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return UnboundedTypeTable();
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && verifier.EndTable();
	}
};

struct UnboundedBuilder {
	typedef Unbounded Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	explicit UnboundedBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Unbounded> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Unbounded>(end);
		return o;
	}
};

inline flatbuffers::Offset<Unbounded> CreateUnbounded(flatbuffers::FlatBufferBuilder &_fbb) {
	UnboundedBuilder builder_(_fbb);
	return builder_.Finish();
}

/// Boundary is preceding rows, determined by the contained expression
struct Preceding FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef PrecedingBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return PrecedingTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_IMPL_TYPE = 4, VT_IMPL = 6 };
	org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl impl_type() const {
		return static_cast<org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl>(
		    GetField<uint8_t>(VT_IMPL_TYPE, 0));
	}
	const void *impl() const {
		return GetPointer<const void *>(VT_IMPL);
	}
	template <typename T>
	const T *impl_as() const;
	const org::apache::arrow::computeir::flatbuf::Expression *impl_as_Expression() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl_Expression
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Expression *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Unbounded *impl_as_Unbounded() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl_Unbounded
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Unbounded *>(impl())
		           : nullptr;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
		       VerifyOffsetRequired(verifier, VT_IMPL) && VerifyConcreteBoundImpl(verifier, impl(), impl_type()) &&
		       verifier.EndTable();
	}
};

template <>
inline const org::apache::arrow::computeir::flatbuf::Expression *
Preceding::impl_as<org::apache::arrow::computeir::flatbuf::Expression>() const {
	return impl_as_Expression();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Unbounded *
Preceding::impl_as<org::apache::arrow::computeir::flatbuf::Unbounded>() const {
	return impl_as_Unbounded();
}

struct PrecedingBuilder {
	typedef Preceding Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_impl_type(org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl impl_type) {
		fbb_.AddElement<uint8_t>(Preceding::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
	}
	void add_impl(flatbuffers::Offset<void> impl) {
		fbb_.AddOffset(Preceding::VT_IMPL, impl);
	}
	explicit PrecedingBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Preceding> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Preceding>(end);
		fbb_.Required(o, Preceding::VT_IMPL);
		return o;
	}
};

inline flatbuffers::Offset<Preceding>
CreatePreceding(flatbuffers::FlatBufferBuilder &_fbb,
                org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl impl_type =
                    org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl_NONE,
                flatbuffers::Offset<void> impl = 0) {
	PrecedingBuilder builder_(_fbb);
	builder_.add_impl(impl);
	builder_.add_impl_type(impl_type);
	return builder_.Finish();
}

/// Boundary is following rows, determined by the contained expression
struct Following FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef FollowingBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return FollowingTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_IMPL_TYPE = 4, VT_IMPL = 6 };
	org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl impl_type() const {
		return static_cast<org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl>(
		    GetField<uint8_t>(VT_IMPL_TYPE, 0));
	}
	const void *impl() const {
		return GetPointer<const void *>(VT_IMPL);
	}
	template <typename T>
	const T *impl_as() const;
	const org::apache::arrow::computeir::flatbuf::Expression *impl_as_Expression() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl_Expression
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Expression *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Unbounded *impl_as_Unbounded() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl_Unbounded
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Unbounded *>(impl())
		           : nullptr;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
		       VerifyOffsetRequired(verifier, VT_IMPL) && VerifyConcreteBoundImpl(verifier, impl(), impl_type()) &&
		       verifier.EndTable();
	}
};

template <>
inline const org::apache::arrow::computeir::flatbuf::Expression *
Following::impl_as<org::apache::arrow::computeir::flatbuf::Expression>() const {
	return impl_as_Expression();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Unbounded *
Following::impl_as<org::apache::arrow::computeir::flatbuf::Unbounded>() const {
	return impl_as_Unbounded();
}

struct FollowingBuilder {
	typedef Following Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_impl_type(org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl impl_type) {
		fbb_.AddElement<uint8_t>(Following::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
	}
	void add_impl(flatbuffers::Offset<void> impl) {
		fbb_.AddOffset(Following::VT_IMPL, impl);
	}
	explicit FollowingBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Following> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Following>(end);
		fbb_.Required(o, Following::VT_IMPL);
		return o;
	}
};

inline flatbuffers::Offset<Following>
CreateFollowing(flatbuffers::FlatBufferBuilder &_fbb,
                org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl impl_type =
                    org::apache::arrow::computeir::flatbuf::ConcreteBoundImpl_NONE,
                flatbuffers::Offset<void> impl = 0) {
	FollowingBuilder builder_(_fbb);
	builder_.add_impl(impl);
	builder_.add_impl_type(impl_type);
	return builder_.Finish();
}

/// Boundary is the current row
struct CurrentRow FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef CurrentRowBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return CurrentRowTypeTable();
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && verifier.EndTable();
	}
};

struct CurrentRowBuilder {
	typedef CurrentRow Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	explicit CurrentRowBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<CurrentRow> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<CurrentRow>(end);
		return o;
	}
};

inline flatbuffers::Offset<CurrentRow> CreateCurrentRow(flatbuffers::FlatBufferBuilder &_fbb) {
	CurrentRowBuilder builder_(_fbb);
	return builder_.Finish();
}

/// An expression representing a window function call.
struct WindowCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef WindowCallBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return WindowCallTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_EXPRESSION = 4,
		VT_KIND = 6,
		VT_PARTITIONS = 8,
		VT_ORDERINGS = 10,
		VT_LOWER_BOUND_TYPE = 12,
		VT_LOWER_BOUND = 14,
		VT_UPPER_BOUND_TYPE = 16,
		VT_UPPER_BOUND = 18
	};
	/// The expression to operate over
	const org::apache::arrow::computeir::flatbuf::Expression *expression() const {
		return GetPointer<const org::apache::arrow::computeir::flatbuf::Expression *>(VT_EXPRESSION);
	}
	/// The kind of window frame
	org::apache::arrow::computeir::flatbuf::Frame kind() const {
		return static_cast<org::apache::arrow::computeir::flatbuf::Frame>(GetField<uint8_t>(VT_KIND, 0));
	}
	/// Partition keys
	const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *
	partitions() const {
		return GetPointer<
		    const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *>(
		    VT_PARTITIONS);
	}
	/// Sort keys
	const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *orderings() const {
		return GetPointer<
		    const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *>(
		    VT_ORDERINGS);
	}
	org::apache::arrow::computeir::flatbuf::Bound lower_bound_type() const {
		return static_cast<org::apache::arrow::computeir::flatbuf::Bound>(GetField<uint8_t>(VT_LOWER_BOUND_TYPE, 0));
	}
	/// Lower window bound
	const void *lower_bound() const {
		return GetPointer<const void *>(VT_LOWER_BOUND);
	}
	template <typename T>
	const T *lower_bound_as() const;
	const org::apache::arrow::computeir::flatbuf::Preceding *lower_bound_as_Preceding() const {
		return lower_bound_type() == org::apache::arrow::computeir::flatbuf::Bound_Preceding
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Preceding *>(lower_bound())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Following *lower_bound_as_Following() const {
		return lower_bound_type() == org::apache::arrow::computeir::flatbuf::Bound_Following
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Following *>(lower_bound())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::CurrentRow *lower_bound_as_CurrentRow() const {
		return lower_bound_type() == org::apache::arrow::computeir::flatbuf::Bound_CurrentRow
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::CurrentRow *>(lower_bound())
		           : nullptr;
	}
	org::apache::arrow::computeir::flatbuf::Bound upper_bound_type() const {
		return static_cast<org::apache::arrow::computeir::flatbuf::Bound>(GetField<uint8_t>(VT_UPPER_BOUND_TYPE, 0));
	}
	/// Upper window bound
	const void *upper_bound() const {
		return GetPointer<const void *>(VT_UPPER_BOUND);
	}
	template <typename T>
	const T *upper_bound_as() const;
	const org::apache::arrow::computeir::flatbuf::Preceding *upper_bound_as_Preceding() const {
		return upper_bound_type() == org::apache::arrow::computeir::flatbuf::Bound_Preceding
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Preceding *>(upper_bound())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Following *upper_bound_as_Following() const {
		return upper_bound_type() == org::apache::arrow::computeir::flatbuf::Bound_Following
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Following *>(upper_bound())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::CurrentRow *upper_bound_as_CurrentRow() const {
		return upper_bound_type() == org::apache::arrow::computeir::flatbuf::Bound_CurrentRow
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::CurrentRow *>(upper_bound())
		           : nullptr;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_EXPRESSION) &&
		       verifier.VerifyTable(expression()) && VerifyField<uint8_t>(verifier, VT_KIND) &&
		       VerifyOffsetRequired(verifier, VT_PARTITIONS) && verifier.VerifyVector(partitions()) &&
		       verifier.VerifyVectorOfTables(partitions()) && VerifyOffsetRequired(verifier, VT_ORDERINGS) &&
		       verifier.VerifyVector(orderings()) && verifier.VerifyVectorOfTables(orderings()) &&
		       VerifyField<uint8_t>(verifier, VT_LOWER_BOUND_TYPE) && VerifyOffsetRequired(verifier, VT_LOWER_BOUND) &&
		       VerifyBound(verifier, lower_bound(), lower_bound_type()) &&
		       VerifyField<uint8_t>(verifier, VT_UPPER_BOUND_TYPE) && VerifyOffsetRequired(verifier, VT_UPPER_BOUND) &&
		       VerifyBound(verifier, upper_bound(), upper_bound_type()) && verifier.EndTable();
	}
};

template <>
inline const org::apache::arrow::computeir::flatbuf::Preceding *
WindowCall::lower_bound_as<org::apache::arrow::computeir::flatbuf::Preceding>() const {
	return lower_bound_as_Preceding();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Following *
WindowCall::lower_bound_as<org::apache::arrow::computeir::flatbuf::Following>() const {
	return lower_bound_as_Following();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::CurrentRow *
WindowCall::lower_bound_as<org::apache::arrow::computeir::flatbuf::CurrentRow>() const {
	return lower_bound_as_CurrentRow();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Preceding *
WindowCall::upper_bound_as<org::apache::arrow::computeir::flatbuf::Preceding>() const {
	return upper_bound_as_Preceding();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Following *
WindowCall::upper_bound_as<org::apache::arrow::computeir::flatbuf::Following>() const {
	return upper_bound_as_Following();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::CurrentRow *
WindowCall::upper_bound_as<org::apache::arrow::computeir::flatbuf::CurrentRow>() const {
	return upper_bound_as_CurrentRow();
}

struct WindowCallBuilder {
	typedef WindowCall Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_expression(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression) {
		fbb_.AddOffset(WindowCall::VT_EXPRESSION, expression);
	}
	void add_kind(org::apache::arrow::computeir::flatbuf::Frame kind) {
		fbb_.AddElement<uint8_t>(WindowCall::VT_KIND, static_cast<uint8_t>(kind), 0);
	}
	void add_partitions(flatbuffers::Offset<
	                    flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>>
	                        partitions) {
		fbb_.AddOffset(WindowCall::VT_PARTITIONS, partitions);
	}
	void add_orderings(
	    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>>
	        orderings) {
		fbb_.AddOffset(WindowCall::VT_ORDERINGS, orderings);
	}
	void add_lower_bound_type(org::apache::arrow::computeir::flatbuf::Bound lower_bound_type) {
		fbb_.AddElement<uint8_t>(WindowCall::VT_LOWER_BOUND_TYPE, static_cast<uint8_t>(lower_bound_type), 0);
	}
	void add_lower_bound(flatbuffers::Offset<void> lower_bound) {
		fbb_.AddOffset(WindowCall::VT_LOWER_BOUND, lower_bound);
	}
	void add_upper_bound_type(org::apache::arrow::computeir::flatbuf::Bound upper_bound_type) {
		fbb_.AddElement<uint8_t>(WindowCall::VT_UPPER_BOUND_TYPE, static_cast<uint8_t>(upper_bound_type), 0);
	}
	void add_upper_bound(flatbuffers::Offset<void> upper_bound) {
		fbb_.AddOffset(WindowCall::VT_UPPER_BOUND, upper_bound);
	}
	explicit WindowCallBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<WindowCall> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<WindowCall>(end);
		fbb_.Required(o, WindowCall::VT_EXPRESSION);
		fbb_.Required(o, WindowCall::VT_PARTITIONS);
		fbb_.Required(o, WindowCall::VT_ORDERINGS);
		fbb_.Required(o, WindowCall::VT_LOWER_BOUND);
		fbb_.Required(o, WindowCall::VT_UPPER_BOUND);
		return o;
	}
};

inline flatbuffers::Offset<WindowCall> CreateWindowCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
    org::apache::arrow::computeir::flatbuf::Frame kind = org::apache::arrow::computeir::flatbuf::Frame_Rows,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>>
        partitions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>>
        orderings = 0,
    org::apache::arrow::computeir::flatbuf::Bound lower_bound_type = org::apache::arrow::computeir::flatbuf::Bound_NONE,
    flatbuffers::Offset<void> lower_bound = 0,
    org::apache::arrow::computeir::flatbuf::Bound upper_bound_type = org::apache::arrow::computeir::flatbuf::Bound_NONE,
    flatbuffers::Offset<void> upper_bound = 0) {
	WindowCallBuilder builder_(_fbb);
	builder_.add_upper_bound(upper_bound);
	builder_.add_lower_bound(lower_bound);
	builder_.add_orderings(orderings);
	builder_.add_partitions(partitions);
	builder_.add_expression(expression);
	builder_.add_upper_bound_type(upper_bound_type);
	builder_.add_lower_bound_type(lower_bound_type);
	builder_.add_kind(kind);
	return builder_.Finish();
}

inline flatbuffers::Offset<WindowCall> CreateWindowCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> expression = 0,
    org::apache::arrow::computeir::flatbuf::Frame kind = org::apache::arrow::computeir::flatbuf::Frame_Rows,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>> *partitions = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>> *orderings = nullptr,
    org::apache::arrow::computeir::flatbuf::Bound lower_bound_type = org::apache::arrow::computeir::flatbuf::Bound_NONE,
    flatbuffers::Offset<void> lower_bound = 0,
    org::apache::arrow::computeir::flatbuf::Bound upper_bound_type = org::apache::arrow::computeir::flatbuf::Bound_NONE,
    flatbuffers::Offset<void> upper_bound = 0) {
	auto partitions__ =
	    partitions
	        ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression>>(*partitions)
	        : 0;
	auto orderings__ =
	    orderings ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::SortKey>>(*orderings)
	              : 0;
	return org::apache::arrow::computeir::flatbuf::CreateWindowCall(_fbb, expression, kind, partitions__, orderings__,
	                                                                lower_bound_type, lower_bound, upper_bound_type,
	                                                                upper_bound);
}

/// Expression types
///
/// Expressions have a concrete `impl` value, which is a specific operation.
///
/// This is a workaround for flatbuffers' lack of support for direct use of
/// union types.
struct Expression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef ExpressionBuilder Builder;
	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return ExpressionTypeTable();
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_IMPL_TYPE = 4, VT_IMPL = 6 };
	org::apache::arrow::computeir::flatbuf::ExpressionImpl impl_type() const {
		return static_cast<org::apache::arrow::computeir::flatbuf::ExpressionImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
	}
	const void *impl() const {
		return GetPointer<const void *>(VT_IMPL);
	}
	template <typename T>
	const T *impl_as() const;
	const org::apache::arrow::computeir::flatbuf::Literal *impl_as_Literal() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl_Literal
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Literal *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::FieldRef *impl_as_FieldRef() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl_FieldRef
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::FieldRef *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::Call *impl_as_Call() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl_Call
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::Call *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::ConditionalCase *impl_as_ConditionalCase() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl_ConditionalCase
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::ConditionalCase *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::SimpleCase *impl_as_SimpleCase() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl_SimpleCase
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::SimpleCase *>(impl())
		           : nullptr;
	}
	const org::apache::arrow::computeir::flatbuf::WindowCall *impl_as_WindowCall() const {
		return impl_type() == org::apache::arrow::computeir::flatbuf::ExpressionImpl_WindowCall
		           ? static_cast<const org::apache::arrow::computeir::flatbuf::WindowCall *>(impl())
		           : nullptr;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
		       VerifyOffsetRequired(verifier, VT_IMPL) && VerifyExpressionImpl(verifier, impl(), impl_type()) &&
		       verifier.EndTable();
	}
};

template <>
inline const org::apache::arrow::computeir::flatbuf::Literal *
Expression::impl_as<org::apache::arrow::computeir::flatbuf::Literal>() const {
	return impl_as_Literal();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::FieldRef *
Expression::impl_as<org::apache::arrow::computeir::flatbuf::FieldRef>() const {
	return impl_as_FieldRef();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::Call *
Expression::impl_as<org::apache::arrow::computeir::flatbuf::Call>() const {
	return impl_as_Call();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::ConditionalCase *
Expression::impl_as<org::apache::arrow::computeir::flatbuf::ConditionalCase>() const {
	return impl_as_ConditionalCase();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::SimpleCase *
Expression::impl_as<org::apache::arrow::computeir::flatbuf::SimpleCase>() const {
	return impl_as_SimpleCase();
}

template <>
inline const org::apache::arrow::computeir::flatbuf::WindowCall *
Expression::impl_as<org::apache::arrow::computeir::flatbuf::WindowCall>() const {
	return impl_as_WindowCall();
}

struct ExpressionBuilder {
	typedef Expression Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_impl_type(org::apache::arrow::computeir::flatbuf::ExpressionImpl impl_type) {
		fbb_.AddElement<uint8_t>(Expression::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
	}
	void add_impl(flatbuffers::Offset<void> impl) {
		fbb_.AddOffset(Expression::VT_IMPL, impl);
	}
	explicit ExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Expression> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Expression>(end);
		fbb_.Required(o, Expression::VT_IMPL);
		return o;
	}
};

inline flatbuffers::Offset<Expression>
CreateExpression(flatbuffers::FlatBufferBuilder &_fbb,
                 org::apache::arrow::computeir::flatbuf::ExpressionImpl impl_type =
                     org::apache::arrow::computeir::flatbuf::ExpressionImpl_NONE,
                 flatbuffers::Offset<void> impl = 0) {
	ExpressionBuilder builder_(_fbb);
	builder_.add_impl(impl);
	builder_.add_impl_type(impl_type);
	return builder_.Finish();
}

inline bool VerifyDeref(flatbuffers::Verifier &verifier, const void *obj, Deref type) {
	switch (type) {
	case Deref_NONE: {
		return true;
	}
	case Deref_MapKey: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::MapKey *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case Deref_StructField: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::StructField *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case Deref_ArraySubscript: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::ArraySubscript *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case Deref_ArraySlice: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::ArraySlice *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case Deref_FieldIndex: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::FieldIndex *>(obj);
		return verifier.VerifyTable(ptr);
	}
	default:
		return true;
	}
}

inline bool VerifyDerefVector(flatbuffers::Verifier &verifier,
                              const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                              const flatbuffers::Vector<uint8_t> *types) {
	if (!values || !types)
		return !values && !types;
	if (values->size() != types->size())
		return false;
	for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
		if (!VerifyDeref(verifier, values->Get(i), types->GetEnum<Deref>(i))) {
			return false;
		}
	}
	return true;
}

inline bool VerifyConcreteBoundImpl(flatbuffers::Verifier &verifier, const void *obj, ConcreteBoundImpl type) {
	switch (type) {
	case ConcreteBoundImpl_NONE: {
		return true;
	}
	case ConcreteBoundImpl_Expression: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Expression *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case ConcreteBoundImpl_Unbounded: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Unbounded *>(obj);
		return verifier.VerifyTable(ptr);
	}
	default:
		return true;
	}
}

inline bool VerifyConcreteBoundImplVector(flatbuffers::Verifier &verifier,
                                          const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                          const flatbuffers::Vector<uint8_t> *types) {
	if (!values || !types)
		return !values && !types;
	if (values->size() != types->size())
		return false;
	for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
		if (!VerifyConcreteBoundImpl(verifier, values->Get(i), types->GetEnum<ConcreteBoundImpl>(i))) {
			return false;
		}
	}
	return true;
}

inline bool VerifyBound(flatbuffers::Verifier &verifier, const void *obj, Bound type) {
	switch (type) {
	case Bound_NONE: {
		return true;
	}
	case Bound_Preceding: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Preceding *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case Bound_Following: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Following *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case Bound_CurrentRow: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::CurrentRow *>(obj);
		return verifier.VerifyTable(ptr);
	}
	default:
		return true;
	}
}

inline bool VerifyBoundVector(flatbuffers::Verifier &verifier,
                              const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                              const flatbuffers::Vector<uint8_t> *types) {
	if (!values || !types)
		return !values && !types;
	if (values->size() != types->size())
		return false;
	for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
		if (!VerifyBound(verifier, values->Get(i), types->GetEnum<Bound>(i))) {
			return false;
		}
	}
	return true;
}

inline bool VerifyExpressionImpl(flatbuffers::Verifier &verifier, const void *obj, ExpressionImpl type) {
	switch (type) {
	case ExpressionImpl_NONE: {
		return true;
	}
	case ExpressionImpl_Literal: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Literal *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case ExpressionImpl_FieldRef: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::FieldRef *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case ExpressionImpl_Call: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Call *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case ExpressionImpl_ConditionalCase: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::ConditionalCase *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case ExpressionImpl_SimpleCase: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::SimpleCase *>(obj);
		return verifier.VerifyTable(ptr);
	}
	case ExpressionImpl_WindowCall: {
		auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::WindowCall *>(obj);
		return verifier.VerifyTable(ptr);
	}
	default:
		return true;
	}
}

inline bool VerifyExpressionImplVector(flatbuffers::Verifier &verifier,
                                       const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                       const flatbuffers::Vector<uint8_t> *types) {
	if (!values || !types)
		return !values && !types;
	if (values->size() != types->size())
		return false;
	for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
		if (!VerifyExpressionImpl(verifier, values->Get(i), types->GetEnum<ExpressionImpl>(i))) {
			return false;
		}
	}
	return true;
}

inline const flatbuffers::TypeTable *DerefTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_SEQUENCE, 0, -1}, {flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 1},
	    {flatbuffers::ET_SEQUENCE, 0, 2},  {flatbuffers::ET_SEQUENCE, 0, 3}, {flatbuffers::ET_SEQUENCE, 0, 4}};
	static const flatbuffers::TypeFunction type_refs[] = {
	    org::apache::arrow::computeir::flatbuf::MapKeyTypeTable,
	    org::apache::arrow::computeir::flatbuf::StructFieldTypeTable,
	    org::apache::arrow::computeir::flatbuf::ArraySubscriptTypeTable,
	    org::apache::arrow::computeir::flatbuf::ArraySliceTypeTable,
	    org::apache::arrow::computeir::flatbuf::FieldIndexTypeTable};
	static const char *const names[] = {"NONE", "MapKey", "StructField", "ArraySubscript", "ArraySlice", "FieldIndex"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *OrderingTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UCHAR, 0, 0},
	                                                   {flatbuffers::ET_UCHAR, 0, 0},
	                                                   {flatbuffers::ET_UCHAR, 0, 0},
	                                                   {flatbuffers::ET_UCHAR, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::OrderingTypeTable};
	static const char *const names[] = {"ASCENDING_THEN_NULLS", "DESCENDING_THEN_NULLS", "NULLS_THEN_ASCENDING",
	                                    "NULLS_THEN_DESCENDING"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *ConcreteBoundImplTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_SEQUENCE, 0, -1}, {flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 1}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::ExpressionTypeTable,
	                                                      org::apache::arrow::computeir::flatbuf::UnboundedTypeTable};
	static const char *const names[] = {"NONE", "Expression", "Unbounded"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *BoundTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_SEQUENCE, 0, -1},
	                                                   {flatbuffers::ET_SEQUENCE, 0, 0},
	                                                   {flatbuffers::ET_SEQUENCE, 0, 1},
	                                                   {flatbuffers::ET_SEQUENCE, 0, 2}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::PrecedingTypeTable,
	                                                      org::apache::arrow::computeir::flatbuf::FollowingTypeTable,
	                                                      org::apache::arrow::computeir::flatbuf::CurrentRowTypeTable};
	static const char *const names[] = {"NONE", "Preceding", "Following", "CurrentRow"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *FrameTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UCHAR, 0, 0}, {flatbuffers::ET_UCHAR, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::FrameTypeTable};
	static const char *const names[] = {"Rows", "Range"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *ExpressionImplTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_SEQUENCE, 0, -1}, {flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 1},
	    {flatbuffers::ET_SEQUENCE, 0, 2},  {flatbuffers::ET_SEQUENCE, 0, 3}, {flatbuffers::ET_SEQUENCE, 0, 4},
	    {flatbuffers::ET_SEQUENCE, 0, 5}};
	static const flatbuffers::TypeFunction type_refs[] = {
	    org::apache::arrow::computeir::flatbuf::LiteralTypeTable,
	    org::apache::arrow::computeir::flatbuf::FieldRefTypeTable,
	    org::apache::arrow::computeir::flatbuf::CallTypeTable,
	    org::apache::arrow::computeir::flatbuf::ConditionalCaseTypeTable,
	    org::apache::arrow::computeir::flatbuf::SimpleCaseTypeTable,
	    org::apache::arrow::computeir::flatbuf::WindowCallTypeTable};
	static const char *const names[] = {"NONE",       "Literal",   "FieldRef", "Call", "ConditionalCase",
	                                    "SimpleCase", "WindowCall"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_UNION, 7, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *MapKeyTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_SEQUENCE, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::ExpressionTypeTable};
	static const char *const names[] = {"key"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *StructFieldTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UINT, 0, -1}};
	static const char *const names[] = {"position"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *ArraySubscriptTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UINT, 0, -1}};
	static const char *const names[] = {"position"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *ArraySliceTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UINT, 0, -1}, {flatbuffers::ET_UINT, 0, -1}};
	static const char *const names[] = {"start_inclusive", "end_exclusive"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *FieldIndexTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UINT, 0, -1}};
	static const char *const names[] = {"position"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *FieldRefTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_UTYPE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_INT, 0, -1}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::DerefTypeTable};
	static const char *const names[] = {"ref_type", "ref", "relation_index"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *CallTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_SEQUENCE, 1, 0}, {flatbuffers::ET_SEQUENCE, 1, 1}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::ExpressionTypeTable,
	                                                      org::apache::arrow::computeir::flatbuf::SortKeyTypeTable};
	static const char *const names[] = {"name", "arguments", "orderings"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *CaseFragmentTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_SEQUENCE, 0, 0},
	                                                   {flatbuffers::ET_SEQUENCE, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::ExpressionTypeTable};
	static const char *const names[] = {"match", "result"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *ConditionalCaseTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_SEQUENCE, 1, 0},
	                                                   {flatbuffers::ET_SEQUENCE, 0, 1}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::CaseFragmentTypeTable,
	                                                      org::apache::arrow::computeir::flatbuf::ExpressionTypeTable};
	static const char *const names[] = {"conditions", "else_"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *SimpleCaseTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_SEQUENCE, 1, 1}, {flatbuffers::ET_SEQUENCE, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {
	    org::apache::arrow::computeir::flatbuf::ExpressionTypeTable,
	    org::apache::arrow::computeir::flatbuf::CaseFragmentTypeTable};
	static const char *const names[] = {"expression", "matches", "else_"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *SortKeyTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_UCHAR, 0, 1}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::ExpressionTypeTable,
	                                                      org::apache::arrow::computeir::flatbuf::OrderingTypeTable};
	static const char *const names[] = {"expression", "ordering"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *UnboundedTypeTable() {
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr};
	return &tt;
}

inline const flatbuffers::TypeTable *PrecedingTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UTYPE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {
	    org::apache::arrow::computeir::flatbuf::ConcreteBoundImplTypeTable};
	static const char *const names[] = {"impl_type", "impl"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *FollowingTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UTYPE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {
	    org::apache::arrow::computeir::flatbuf::ConcreteBoundImplTypeTable};
	static const char *const names[] = {"impl_type", "impl"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *CurrentRowTypeTable() {
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr};
	return &tt;
}

inline const flatbuffers::TypeTable *WindowCallTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
	    {flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_UCHAR, 0, 1},   {flatbuffers::ET_SEQUENCE, 1, 0},
	    {flatbuffers::ET_SEQUENCE, 1, 2}, {flatbuffers::ET_UTYPE, 0, 3},   {flatbuffers::ET_SEQUENCE, 0, 3},
	    {flatbuffers::ET_UTYPE, 0, 3},    {flatbuffers::ET_SEQUENCE, 0, 3}};
	static const flatbuffers::TypeFunction type_refs[] = {org::apache::arrow::computeir::flatbuf::ExpressionTypeTable,
	                                                      org::apache::arrow::computeir::flatbuf::FrameTypeTable,
	                                                      org::apache::arrow::computeir::flatbuf::SortKeyTypeTable,
	                                                      org::apache::arrow::computeir::flatbuf::BoundTypeTable};
	static const char *const names[] = {"expression",       "kind",        "partitions",       "orderings",
	                                    "lower_bound_type", "lower_bound", "upper_bound_type", "upper_bound"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *ExpressionTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UTYPE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 0}};
	static const flatbuffers::TypeFunction type_refs[] = {
	    org::apache::arrow::computeir::flatbuf::ExpressionImplTypeTable};
	static const char *const names[] = {"impl_type", "impl"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
	return &tt;
}

inline const org::apache::arrow::computeir::flatbuf::Expression *GetExpression(const void *buf) {
	return flatbuffers::GetRoot<org::apache::arrow::computeir::flatbuf::Expression>(buf);
}

inline const org::apache::arrow::computeir::flatbuf::Expression *GetSizePrefixedExpression(const void *buf) {
	return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::computeir::flatbuf::Expression>(buf);
}

inline bool VerifyExpressionBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifyBuffer<org::apache::arrow::computeir::flatbuf::Expression>(nullptr);
}

inline bool VerifySizePrefixedExpressionBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifySizePrefixedBuffer<org::apache::arrow::computeir::flatbuf::Expression>(nullptr);
}

inline void FinishExpressionBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                   flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> root) {
	fbb.Finish(root);
}

inline void
FinishSizePrefixedExpressionBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                   flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Expression> root) {
	fbb.FinishSizePrefixed(root);
}

} // namespace flatbuf
} // namespace computeir
} // namespace arrow
} // namespace apache
} // namespace org

#endif // FLATBUFFERS_GENERATED_EXPRESSION_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
