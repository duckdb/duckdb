#include "duckdb/common/wait_events.hpp"

#include "duckdb/main/client_context.hpp"
#include "duckdb/main/config.hpp"
#include "duckdb/parallel/task_scheduler.hpp"
#include <unordered_map>
#include <vector>

namespace duckdb {

namespace {

struct ThreadLocalWaitInfo {
	uint64_t connection_id = 0;
	optional_idx query_id; // invalid by default
	string query_string;
	uint64_t thread_id = 0;
};

// Global switches
atomic<bool> g_wait_enabled(false);
atomic<uint64_t> g_min_duration_us(0);

// Per-connection event buffers
mutex g_events_lock;
unordered_map<uint64_t, vector<WaitEventRecord>> g_events_per_connection;

// Thread-local context
thread_local ThreadLocalWaitInfo g_tls_wait_info;

} // namespace

void WaitEvents::RegisterSettings(DBConfig &config) {
	// Register as extension options to avoid touching autogenerated settings
	config.AddExtensionOption(
	    "enable_wait_events", "Enable wait event collection", LogicalType::BOOLEAN, Value::BOOLEAN(false),
	    [](ClientContext &ctx, SetScope scope, Value &val) {
		    ::duckdb::WaitEvents::SetEnabled(val.IsNull() ? false : val.GetValue<bool>());
	    },
	    SetScope::GLOBAL);

	config.AddExtensionOption(
	    "wait_event_min_duration_us", "Only record waits with duration >= this many microseconds (0 = record all)",
	    LogicalType::UBIGINT, Value::UBIGINT(0),
	    [](ClientContext &ctx, SetScope scope, Value &val) {
		    uint64_t v = 0;
		    if (!val.IsNull()) {
			    v = val.GetValue<uint64_t>();
		    }
		    ::duckdb::WaitEvents::SetMinDurationUs(v);
	    },
	    SetScope::GLOBAL);
}

void WaitEvents::SetEnabled(bool enabled) {
	g_wait_enabled = enabled;
}

void WaitEvents::SetMinDurationUs(uint64_t min_duration_us) {
	g_min_duration_us = min_duration_us;
}

void WaitEvents::OnThreadStart(ClientContext &context) {
	if (!IsEnabled()) {
		return;
	}
	g_tls_wait_info.connection_id = context.GetConnectionId();
	g_tls_wait_info.thread_id = TaskScheduler::GetEstimatedCPUId();
}

void WaitEvents::OnQueryStart(ClientContext &context) {
	if (!IsEnabled()) {
		return;
	}
	if (context.transaction.HasActiveTransaction()) {
		auto qid = context.transaction.GetActiveQuery();
		if (qid != DConstants::INVALID_INDEX) {
			g_tls_wait_info.query_id = qid;
			g_tls_wait_info.query_string = context.GetCurrentQuery();
		} else {
			g_tls_wait_info.query_id = optional_idx();
			g_tls_wait_info.query_string.clear();
		}
	} else {
		g_tls_wait_info.query_id = optional_idx();
		g_tls_wait_info.query_string.clear();
	}
}

void WaitEvents::Record(WaitEventType type, int64_t start_us, int64_t end_us, const string &metadata) {
	if (!IsEnabled()) {
		return;
	}
	auto dur = end_us - start_us;
	if (dur < 0) {
		return;
	}
	auto min_dur = UnsafeNumericCast<int64_t>(g_min_duration_us.load());
	if (dur < min_dur) {
		return;
	}
	WaitEventRecord rec;
	rec.connection_id = g_tls_wait_info.connection_id;
	rec.query_id = g_tls_wait_info.query_id;
	rec.query_string = g_tls_wait_info.query_string;
	rec.thread_id = g_tls_wait_info.thread_id;
	rec.type = type;
	rec.duration_us = dur;
	rec.metadata = metadata;

	if (rec.connection_id == 0) {
		// if we don't have a connection id, drop the event
		return;
	}

	lock_guard<mutex> guard(g_events_lock);
	g_events_per_connection[rec.connection_id].push_back(std::move(rec));
}

vector<WaitEventRecord> WaitEvents::CollectForCurrentConnection(ClientContext &context) {
	vector<WaitEventRecord> result;
	auto cid = context.GetConnectionId();
	lock_guard<mutex> guard(g_events_lock);
	auto it = g_events_per_connection.find(cid);
	if (it != g_events_per_connection.end()) {
		result = std::move(it->second);
		g_events_per_connection.erase(it);
	}
	return result;
}

const char *WaitEvents::TypeToString(WaitEventType type) {
	switch (type) {
	case WaitEventType::INVALID:
		return "INVALID";
	case WaitEventType::IO_READ:
		return "IO_READ";
	case WaitEventType::IO_WRITE:
		return "IO_WRITE";
	case WaitEventType::SCHEDULER_IDLE:
		return "SCHEDULER_IDLE";
	case WaitEventType::TIMEOUT:
		return "TIMEOUT";
	default:
		return "UNKNOWN";
	}
}

bool WaitEvents::IsEnabled() {
	return g_wait_enabled.load();
}

uint64_t WaitEvents::NowMicros() {
	// Use steady_clock to measure durations in microseconds
	auto now = steady_clock::now().time_since_epoch();
	return NumericCast<uint64_t>(duration_cast<microseconds>(now).count());
}

} // namespace duckdb
