// This file is automatically generated by scripts/generate_metric_enums.py
// Do not edit this file manually, your changes will be overwritten

#include "duckdb/common/enums/metric_type.hpp"
#include "duckdb/common/enum_util.hpp"

namespace duckdb {

profiler_settings_t MetricsUtils::GetAllMetrics() {
	profiler_settings_t result;
	for (auto metric = START_CORE; metric <= END_PHASE_TIMING; metric++) {
		result.insert(static_cast<MetricType>(metric));
	}
	return result;
}

profiler_settings_t MetricsUtils::GetMetricsByGroupType(MetricGroup type) {
	switch(type) {
	case MetricGroup::ALL:
		return GetAllMetrics();
	case MetricGroup::CORE:
		return GetCoreMetrics();
	case MetricGroup::DEFAULT:
		return GetDefaultMetrics();
	case MetricGroup::EXECUTION:
		return GetExecutionMetrics();
	case MetricGroup::FILE:
		return GetFileMetrics();
	case MetricGroup::OPERATOR:
		return GetOperatorMetrics();
	case MetricGroup::OPTIMIZER:
		return GetOptimizerMetrics();
	case MetricGroup::PHASE_TIMING:
		return GetPhaseTimingMetrics();
	default:
		throw InternalException("The MetricGroup passed is invalid");
	}
}

profiler_settings_t MetricsUtils::GetCoreMetrics() {
	profiler_settings_t result;
	for (auto metric = START_CORE; metric <= END_CORE; metric++) {
		result.insert(static_cast<MetricType>(metric));
	}
	return result;
}

bool MetricsUtils::IsCoreMetric(MetricType type) {
	return static_cast<uint8_t>(type) <= END_CORE;
}

profiler_settings_t MetricsUtils::GetDefaultMetrics() {
	return {
		MetricType::ATTACH_LOAD_STORAGE_LATENCY,
		MetricType::ATTACH_REPLAY_WAL_LATENCY,
		MetricType::BLOCKED_THREAD_TIME,
		MetricType::CHECKPOINT_LATENCY,
		MetricType::COMMIT_LOCAL_STORAGE_LATENCY,
		MetricType::CPU_TIME,
		MetricType::CUMULATIVE_CARDINALITY,
		MetricType::CUMULATIVE_ROWS_SCANNED,
		MetricType::EXTRA_INFO,
		MetricType::LATENCY,
		MetricType::OPERATOR_CARDINALITY,
		MetricType::OPERATOR_NAME,
		MetricType::OPERATOR_ROWS_SCANNED,
		MetricType::OPERATOR_TIMING,
		MetricType::OPERATOR_TYPE,
		MetricType::QUERY_NAME,
		MetricType::RESULT_SET_SIZE,
		MetricType::ROWS_RETURNED,
		MetricType::SYSTEM_PEAK_BUFFER_MEMORY,
		MetricType::SYSTEM_PEAK_TEMP_DIR_SIZE,
		MetricType::TOTAL_BYTES_READ,
		MetricType::TOTAL_BYTES_WRITTEN,
		MetricType::TOTAL_MEMORY_ALLOCATED,
		MetricType::WAITING_TO_ATTACH_LATENCY,
		MetricType::WAL_REPLAY_ENTRY_COUNT,
		MetricType::WRITE_TO_WAL_LATENCY,
	};
}

bool MetricsUtils::IsDefaultMetric(MetricType type) {
	switch(type) {
	case MetricType::ATTACH_LOAD_STORAGE_LATENCY:
	case MetricType::ATTACH_REPLAY_WAL_LATENCY:
	case MetricType::BLOCKED_THREAD_TIME:
	case MetricType::CHECKPOINT_LATENCY:
	case MetricType::COMMIT_LOCAL_STORAGE_LATENCY:
	case MetricType::CPU_TIME:
	case MetricType::CUMULATIVE_CARDINALITY:
	case MetricType::CUMULATIVE_ROWS_SCANNED:
	case MetricType::EXTRA_INFO:
	case MetricType::LATENCY:
	case MetricType::OPERATOR_CARDINALITY:
	case MetricType::OPERATOR_NAME:
	case MetricType::OPERATOR_ROWS_SCANNED:
	case MetricType::OPERATOR_TIMING:
	case MetricType::OPERATOR_TYPE:
	case MetricType::QUERY_NAME:
	case MetricType::RESULT_SET_SIZE:
	case MetricType::ROWS_RETURNED:
	case MetricType::SYSTEM_PEAK_BUFFER_MEMORY:
	case MetricType::SYSTEM_PEAK_TEMP_DIR_SIZE:
	case MetricType::TOTAL_BYTES_READ:
	case MetricType::TOTAL_BYTES_WRITTEN:
	case MetricType::TOTAL_MEMORY_ALLOCATED:
	case MetricType::WAITING_TO_ATTACH_LATENCY:
	case MetricType::WAL_REPLAY_ENTRY_COUNT:
	case MetricType::WRITE_TO_WAL_LATENCY:
		return true;
	default:
		return false;
	}
}

profiler_settings_t MetricsUtils::GetExecutionMetrics() {
	profiler_settings_t result;
	for (auto metric = START_EXECUTION; metric <= END_EXECUTION; metric++) {
		result.insert(static_cast<MetricType>(metric));
	}
	return result;
}

bool MetricsUtils::IsExecutionMetric(MetricType type) {
	return static_cast<uint8_t>(type) >= START_EXECUTION && static_cast<uint8_t>(type) <= END_EXECUTION;
}

profiler_settings_t MetricsUtils::GetFileMetrics() {
	profiler_settings_t result;
	for (auto metric = START_FILE; metric <= END_FILE; metric++) {
		result.insert(static_cast<MetricType>(metric));
	}
	return result;
}

bool MetricsUtils::IsFileMetric(MetricType type) {
	return static_cast<uint8_t>(type) >= START_FILE && static_cast<uint8_t>(type) <= END_FILE;
}

profiler_settings_t MetricsUtils::GetOperatorMetrics() {
	profiler_settings_t result;
	for (auto metric = START_OPERATOR; metric <= END_OPERATOR; metric++) {
		result.insert(static_cast<MetricType>(metric));
	}
	return result;
}

bool MetricsUtils::IsOperatorMetric(MetricType type) {
	return static_cast<uint8_t>(type) >= START_OPERATOR && static_cast<uint8_t>(type) <= END_OPERATOR;
}

profiler_settings_t MetricsUtils::GetOptimizerMetrics() {
	profiler_settings_t result;
	for (auto metric = START_OPTIMIZER; metric <= END_OPTIMIZER; metric++) {
		result.insert(static_cast<MetricType>(metric));
	}
	return result;
}

bool MetricsUtils::IsOptimizerMetric(MetricType type) {
	return static_cast<uint8_t>(type) >= START_OPTIMIZER && static_cast<uint8_t>(type) <= END_OPTIMIZER;
}


MetricType MetricsUtils::GetOptimizerMetricByType(OptimizerType type) {
	if (type == OptimizerType::INVALID) {
		throw InternalException("Invalid OptimizerType: INVALID");
	}

	const auto base_opt = static_cast<uint8_t>(OptimizerType::EXPRESSION_REWRITER);
	const auto idx = static_cast<uint8_t>(type) - base_opt;

	const auto metric_u8 = static_cast<uint8_t>(START_OPTIMIZER + idx);
    if (metric_u8 < START_OPTIMIZER || metric_u8 > END_OPTIMIZER) { // This shouldn't happen, but we want to fail gracefully if it does
		throw InternalException("OptimizerType out of MetricType optimizer range");
	}
	return static_cast<MetricType>(metric_u8);
}

OptimizerType MetricsUtils::GetOptimizerTypeByMetric(MetricType type) {
	const auto metric_u8 = static_cast<uint8_t>(type);
	if (!IsOptimizerMetric(type)) {
		throw InternalException("MetricType is not an optimizer metric");
	}

	const auto idx = static_cast<uint8_t>(metric_u8 - START_OPTIMIZER);
	const auto result = static_cast<uint8_t>(OptimizerType::EXPRESSION_REWRITER) + idx;
	return static_cast<OptimizerType>(result);
}

profiler_settings_t MetricsUtils::GetPhaseTimingMetrics() {
	profiler_settings_t result;
	for (auto metric = START_PHASE_TIMING; metric <= END_PHASE_TIMING; metric++) {
		result.insert(static_cast<MetricType>(metric));
	}
	return result;
}

bool MetricsUtils::IsPhaseTimingMetric(MetricType type) {
	return static_cast<uint8_t>(type) >= START_PHASE_TIMING && static_cast<uint8_t>(type) <= END_PHASE_TIMING;
}

profiler_settings_t MetricsUtils::GetRootScopeMetrics() {
	return {
		MetricType::ATTACH_LOAD_STORAGE_LATENCY,
		MetricType::ATTACH_REPLAY_WAL_LATENCY,
		MetricType::BLOCKED_THREAD_TIME,
		MetricType::CHECKPOINT_LATENCY,
		MetricType::COMMIT_LOCAL_STORAGE_LATENCY,
		MetricType::LATENCY,
		MetricType::QUERY_NAME,
		MetricType::ROWS_RETURNED,
		MetricType::TOTAL_BYTES_READ,
		MetricType::TOTAL_BYTES_WRITTEN,
		MetricType::TOTAL_MEMORY_ALLOCATED,
		MetricType::WAITING_TO_ATTACH_LATENCY,
		MetricType::WAL_REPLAY_ENTRY_COUNT,
		MetricType::WRITE_TO_WAL_LATENCY,
	};
}

bool MetricsUtils::IsRootScopeMetric(MetricType type) {
	switch(type) {
	case MetricType::ATTACH_LOAD_STORAGE_LATENCY:
	case MetricType::ATTACH_REPLAY_WAL_LATENCY:
	case MetricType::BLOCKED_THREAD_TIME:
	case MetricType::CHECKPOINT_LATENCY:
	case MetricType::COMMIT_LOCAL_STORAGE_LATENCY:
	case MetricType::LATENCY:
	case MetricType::QUERY_NAME:
	case MetricType::ROWS_RETURNED:
	case MetricType::TOTAL_BYTES_READ:
	case MetricType::TOTAL_BYTES_WRITTEN:
	case MetricType::TOTAL_MEMORY_ALLOCATED:
	case MetricType::WAITING_TO_ATTACH_LATENCY:
	case MetricType::WAL_REPLAY_ENTRY_COUNT:
	case MetricType::WRITE_TO_WAL_LATENCY:
		return true;
	default:
		return false;
	}
}

}
