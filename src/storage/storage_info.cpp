#include "duckdb/storage/storage_info.hpp"
#include "duckdb/common/numeric_utils.hpp"
#include "duckdb/common/optional_idx.hpp"

namespace duckdb {
constexpr idx_t Storage::MAX_ROW_GROUP_SIZE;
constexpr idx_t Storage::MAX_BLOCK_ALLOC_SIZE;
constexpr idx_t Storage::MIN_BLOCK_ALLOC_SIZE;
constexpr idx_t Storage::DEFAULT_BLOCK_HEADER_SIZE;

const uint64_t VERSION_NUMBER = 64;
const uint64_t VERSION_NUMBER_LOWER = 64;
const uint64_t VERSION_NUMBER_UPPER = 68;

static_assert(VERSION_NUMBER_LOWER <= VERSION_NUMBER, "Check on VERSION_NUMBER lower bound");
static_assert(VERSION_NUMBER <= VERSION_NUMBER_UPPER, "Check on VERSION_NUMBER upper bound");

// These sections are automatically generated by scripts/generate_storage_info.py
// Do not edit them manually, your changes will be overwritten
// clang-format off
// START OF STORAGE_ARRAY VERSION INFO
static const StorageVersionInfo storage_version_info[] = {
	{"v0.0.4", StorageVersion::V0_0_4},
	{"v0.1.0", StorageVersion::V0_1_0},
	{"v0.1.1", StorageVersion::V0_1_1},
	{"v0.1.2", StorageVersion::V0_1_2},
	{"v0.1.3", StorageVersion::V0_1_3},
	{"v0.1.4", StorageVersion::V0_1_4},
	{"v0.1.5", StorageVersion::V0_1_5},
	{"v0.1.6", StorageVersion::V0_1_6},
	{"v0.1.7", StorageVersion::V0_1_7},
	{"v0.1.8", StorageVersion::V0_1_8},
	{"v0.1.9", StorageVersion::V0_1_9},
	{"v0.2.0", StorageVersion::V0_2_0},
	{"v0.2.1", StorageVersion::V0_2_1},
	{"v0.2.2", StorageVersion::V0_2_2},
	{"v0.2.3", StorageVersion::V0_2_3},
	{"v0.2.4", StorageVersion::V0_2_4},
	{"v0.2.5", StorageVersion::V0_2_5},
	{"v0.2.6", StorageVersion::V0_2_6},
	{"v0.2.7", StorageVersion::V0_2_7},
	{"v0.2.8", StorageVersion::V0_2_8},
	{"v0.2.9", StorageVersion::V0_2_9},
	{"v0.3.0", StorageVersion::V0_3_0},
	{"v0.3.1", StorageVersion::V0_3_1},
	{"v0.3.2", StorageVersion::V0_3_2},
	{"v0.3.3", StorageVersion::V0_3_3},
	{"v0.3.4", StorageVersion::V0_3_4},
	{"v0.3.5", StorageVersion::V0_3_5},
	{"v0.4.0", StorageVersion::V0_4_0},
	{"v0.5.0", StorageVersion::V0_5_0},
	{"v0.5.1", StorageVersion::V0_5_1},
	{"v0.6.0", StorageVersion::V0_6_0},
	{"v0.6.1", StorageVersion::V0_6_1},
	{"v0.7.0", StorageVersion::V0_7_0},
	{"v0.7.1", StorageVersion::V0_7_1},
	{"v0.8.0", StorageVersion::V0_8_0},
	{"v0.8.1", StorageVersion::V0_8_1},
	{"v0.9.0", StorageVersion::V0_9_0},
	{"v0.9.1", StorageVersion::V0_9_1},
	{"v0.9.2", StorageVersion::V0_9_2},
	{"v0.10.0", StorageVersion::V0_10_0},
	{"v0.10.1", StorageVersion::V0_10_1},
	{"v0.10.2", StorageVersion::V0_10_2},
	{"v0.10.3", StorageVersion::V0_10_3},
	{"v1.0.0", StorageVersion::V1_0_0},
	{"v1.1.0", StorageVersion::V1_1_0},
	{"v1.1.1", StorageVersion::V1_1_1},
	{"v1.1.2", StorageVersion::V1_1_2},
	{"v1.1.3", StorageVersion::V1_1_3},
	{"v1.2.0", StorageVersion::V1_2_0},
	{"v1.2.1", StorageVersion::V1_2_1},
	{"v1.2.2", StorageVersion::V1_2_2},
	{"v1.3.0", StorageVersion::V1_3_0},
	{"v1.3.1", StorageVersion::V1_3_1},
	{"v1.3.2", StorageVersion::V1_3_2},
	{"v1.4.0", StorageVersion::V1_4_0},
	{"v1.4.1", StorageVersion::V1_4_1},
	{"v1.4.2", StorageVersion::V1_4_2},
	{"v1.4.3", StorageVersion::V1_4_3},
	{"v1.5.0", StorageVersion::V1_5_0},
	{"latest", StorageVersion::V1_5_0},
	{nullptr, StorageVersion::INVALID}
};
// END OF STORAGE_ARRAY VERSION INFO
// clang-format on

// These sections are automatically generated by scripts/generate_storage_info.py
// Do not edit them manually, your changes will be overwritten
// clang-format off
// START OF SER_ARRAY VERSION INFO
static const SerializationVersionInfo serialization_version_info[] = {
	{"v0.10.0", SerializationVersionDeprecated::V0_10_0},
	{"v0.10.1", SerializationVersionDeprecated::V0_10_1},
	{"v0.10.2", SerializationVersionDeprecated::V0_10_2},
	{"v0.10.3", SerializationVersionDeprecated::V0_10_3},
	{"v1.0.0", SerializationVersionDeprecated::V1_0_0},
	{"v1.1.0", SerializationVersionDeprecated::V1_1_0},
	{"v1.1.1", SerializationVersionDeprecated::V1_1_1},
	{"v1.1.2", SerializationVersionDeprecated::V1_1_2},
	{"v1.1.3", SerializationVersionDeprecated::V1_1_3},
	{"v1.2.0", SerializationVersionDeprecated::V1_2_0},
	{"v1.2.1", SerializationVersionDeprecated::V1_2_1},
	{"v1.2.2", SerializationVersionDeprecated::V1_2_2},
	{"v1.3.0", SerializationVersionDeprecated::V1_3_0},
	{"v1.3.1", SerializationVersionDeprecated::V1_3_1},
	{"v1.3.2", SerializationVersionDeprecated::V1_3_2},
	{"v1.4.0", SerializationVersionDeprecated::V1_4_0},
	{"v1.4.1", SerializationVersionDeprecated::V1_4_1},
	{"v1.4.2", SerializationVersionDeprecated::V1_4_2},
	{"v1.4.3", SerializationVersionDeprecated::V1_4_3},
	{"v1.5.0", SerializationVersionDeprecated::V1_5_0},
	{"latest", SerializationVersionDeprecated::V1_5_0},
	{nullptr, SerializationVersionDeprecated::INVALID}
};
// END OF SER_ARRAY VERSION INFO
// clang-format on

static constexpr StorageVersion DEFAULT_STORAGE_VERSION_INFO = StorageVersion::V0_10_2;
static_assert(StorageVersionInfo::GetStorageVersionValue(DEFAULT_STORAGE_VERSION_INFO) == VERSION_NUMBER,
              "Check on VERSION_INFO");

string GetStorageVersionNameInternal(const idx_t storage_version) {
	if (storage_version <= static_cast<idx_t>(StorageVersion::V0_10_2)) {
		// serialization version 1 is used for everything below 0.10.3
		return "v0.10.2";
	}

	optional_idx min_idx;
	for (idx_t i = 0; storage_version_info[i].version_name; i++) {
		if (strcmp(storage_version_info[i].version_name, "latest") == 0) {
			continue;
		}
		if (StorageVersionInfo::GetStorageVersionValue(storage_version_info[i].storage_version) != storage_version) {
			continue;
		}
		if (!min_idx.IsValid()) {
			min_idx = i;
		}
	}
	if (!min_idx.IsValid()) {
		D_ASSERT(0);
		return "";
	}

	return string(storage_version_info[min_idx.GetIndex()].version_name);
}

string GetStorageVersionName(const idx_t storage_version, const bool add_suffix) {
	if (storage_version < GetStorageVersionValue("v1.2.0")) {
		// special handling for lower storage versions
		return "v1.0.0+";
	}

	auto name = GetStorageVersionNameInternal(storage_version);
	if (name.empty()) {
		return "--UNKNOWN--";
	}

	if (add_suffix) {
		name += "+";
	}

	return name;
}

idx_t GetSerializationVersionDeprecated(const char *version_string) {
	for (idx_t i = 0; serialization_version_info[i].version_name; i++) {
		if (!strcmp(serialization_version_info[i].version_name, version_string)) {
			return SerializationVersionInfo::GetSerializationVersionValue(
			    serialization_version_info[i].storage_version);
		}
	}
	return SerializationVersionInfo::Invalid();
}

idx_t GetStorageVersionValue(const char *version_string) {
	for (idx_t i = 0; storage_version_info[i].version_name; i++) {
		if (!strcmp(storage_version_info[i].version_name, version_string)) {
			return StorageVersionInfo::GetStorageVersionValue(storage_version_info[i].storage_version);
		}
	}
	return StorageVersionInfo::Invalid();
}

StorageVersionMapping GetStorageVersion(const char *version_string) {
	StorageVersionMapping result;
	for (idx_t i = 0; storage_version_info[i].version_name; i++) {
		if (!strcmp(storage_version_info[i].version_name, version_string)) {
			result.version = GetStorageVersionValue(version_string);
			if (result.version.IsValid()) {
				result.version_string = version_string;
			}
			return result;
		}
	}
	return result;
}

vector<string> GetStorageCandidates() {
	vector<string> candidates;
	for (idx_t i = 0; storage_version_info[i].version_name; i++) {
		candidates.push_back(storage_version_info[i].version_name);
	}
	return candidates;
}

string GetDuckDBVersions(idx_t version_number) {
	vector<string> versions;
	for (idx_t i = 0; storage_version_info[i].version_name; i++) {
		if (version_number == StorageVersionInfo::GetStorageVersionValue(storage_version_info[i].storage_version)) {
			versions.push_back(string(storage_version_info[i].version_name));
		}
	}
	if (versions.empty()) {
		return string();
	}
	string result;
	for (idx_t i = 0; i < versions.size(); i++) {
		string sep = "";
		if (i) {
			sep = i + 1 == versions.size() ? " or " : ", ";
		}
		result += sep;
		result += versions[i];
	}
	return result;
}

void Storage::VerifyBlockAllocSize(const idx_t block_alloc_size) {
	if (!IsPowerOfTwo(block_alloc_size)) {
		throw InvalidInputException("the block size must be a power of two, got %llu", block_alloc_size);
	}
	if (block_alloc_size < MIN_BLOCK_ALLOC_SIZE) {
		throw InvalidInputException(
		    "the block size must be greater or equal than the minimum block size of %llu, got %llu",
		    MIN_BLOCK_ALLOC_SIZE, block_alloc_size);
	}
	if (block_alloc_size > MAX_BLOCK_ALLOC_SIZE) {
		throw InvalidInputException(
		    "the block size must be lesser or equal than the maximum block size of %llu, got %llu",
		    MAX_BLOCK_ALLOC_SIZE, block_alloc_size);
	}
	auto max_value = NumericCast<idx_t>(NumericLimits<int32_t>().Maximum());
	if (block_alloc_size > max_value) {
		throw InvalidInputException(
		    "the block size must not be greater than the maximum 32-bit signed integer value of %llu, got %llu",
		    max_value, block_alloc_size);
	}
}

void Storage::VerifyBlockHeaderSize(const idx_t block_header_size) {
	if ((block_header_size & 7) != 0) {
		// Alignment to 8 bytes is necessary for computing the checksum
		throw InvalidInputException("the block size must a multiple of 8, got %llu", block_header_size);
	}
	if (block_header_size < DEFAULT_BLOCK_HEADER_SIZE) {
		throw InvalidInputException(
		    "the block header size must be greater or equal than the default block header of %llu, got %llu",
		    DEFAULT_BLOCK_HEADER_SIZE, block_header_size);
	}
	if (block_header_size > MAX_BLOCK_HEADER_SIZE) {
		throw InvalidInputException(
		    "the block header size must be lesser or equal than the maximum block size of %llu, got %llu",
		    MAX_BLOCK_ALLOC_SIZE, block_header_size);
	}
}

} // namespace duckdb
