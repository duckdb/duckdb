//===----------------------------------------------------------------------===//
// This file is automatically generated by scripts/generate_serialization.py
// Do not edit this file manually, your changes will be overwritten
//===----------------------------------------------------------------------===//

#include "duckdb/common/serializer/format_serializer.hpp"
#include "duckdb/common/serializer/format_deserializer.hpp"
#include "duckdb/parser/tableref/list.hpp"

namespace duckdb {

void TableRef::FormatSerialize(FormatSerializer &serializer) const {
	serializer.WriteProperty("type", type);
	serializer.WriteProperty("alias", alias);
	serializer.WriteOptionalProperty("sample", sample);
}

unique_ptr<TableRef> TableRef::FormatDeserialize(FormatDeserializer &deserializer) {
	auto type = deserializer.ReadProperty<TableReferenceType>("type");
	auto alias = deserializer.ReadProperty<string>("alias");
	auto sample = deserializer.ReadOptionalProperty<unique_ptr<SampleOptions>>("sample");
	unique_ptr<TableRef> result;
	switch (type) {
	case TableReferenceType::BASE_TABLE:
		result = BaseTableRef::FormatDeserialize(deserializer);
		break;
	case TableReferenceType::EMPTY:
		result = EmptyTableRef::FormatDeserialize(deserializer);
		break;
	case TableReferenceType::EXPRESSION_LIST:
		result = ExpressionListRef::FormatDeserialize(deserializer);
		break;
	case TableReferenceType::JOIN:
		result = JoinRef::FormatDeserialize(deserializer);
		break;
	case TableReferenceType::PIVOT:
		result = PivotRef::FormatDeserialize(deserializer);
		break;
	case TableReferenceType::SUBQUERY:
		result = SubqueryRef::FormatDeserialize(deserializer);
		break;
	case TableReferenceType::TABLE_FUNCTION:
		result = TableFunctionRef::FormatDeserialize(deserializer);
		break;
	default:
		throw SerializationException("Unsupported type for deserialization of TableRef!");
	}
	result->alias = std::move(alias);
	result->sample = std::move(sample);
	return result;
}

void BaseTableRef::FormatSerialize(FormatSerializer &serializer) const {
	TableRef::FormatSerialize(serializer);
	serializer.WriteProperty("schema_name", schema_name);
	serializer.WriteProperty("table_name", table_name);
	serializer.WriteProperty("column_name_alias", column_name_alias);
	serializer.WriteProperty("catalog_name", catalog_name);
}

unique_ptr<TableRef> BaseTableRef::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<BaseTableRef>(new BaseTableRef());
	deserializer.ReadProperty("schema_name", result->schema_name);
	deserializer.ReadProperty("table_name", result->table_name);
	deserializer.ReadProperty("column_name_alias", result->column_name_alias);
	deserializer.ReadProperty("catalog_name", result->catalog_name);
	return std::move(result);
}

void JoinRef::FormatSerialize(FormatSerializer &serializer) const {
	TableRef::FormatSerialize(serializer);
	serializer.WriteProperty("left", *left);
	serializer.WriteProperty("right", *right);
	serializer.WriteOptionalProperty("condition", condition);
	serializer.WriteProperty("type", type);
	serializer.WriteProperty("ref_type", ref_type);
	serializer.WriteProperty("using_columns", using_columns);
}

unique_ptr<TableRef> JoinRef::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<JoinRef>(new JoinRef());
	deserializer.ReadProperty("left", result->left);
	deserializer.ReadProperty("right", result->right);
	deserializer.ReadOptionalProperty("condition", result->condition);
	deserializer.ReadProperty("type", result->type);
	deserializer.ReadProperty("ref_type", result->ref_type);
	deserializer.ReadProperty("using_columns", result->using_columns);
	return std::move(result);
}

void SubqueryRef::FormatSerialize(FormatSerializer &serializer) const {
	TableRef::FormatSerialize(serializer);
	serializer.WriteProperty("subquery", *subquery);
	serializer.WriteProperty("column_name_alias", column_name_alias);
}

unique_ptr<TableRef> SubqueryRef::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<SubqueryRef>(new SubqueryRef());
	deserializer.ReadProperty("subquery", result->subquery);
	deserializer.ReadProperty("column_name_alias", result->column_name_alias);
	return std::move(result);
}

void TableFunctionRef::FormatSerialize(FormatSerializer &serializer) const {
	TableRef::FormatSerialize(serializer);
	serializer.WriteProperty("function", *function);
	serializer.WriteProperty("alias", alias);
	serializer.WriteProperty("column_name_alias", column_name_alias);
}

unique_ptr<TableRef> TableFunctionRef::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<TableFunctionRef>(new TableFunctionRef());
	deserializer.ReadProperty("function", result->function);
	deserializer.ReadProperty("alias", result->alias);
	deserializer.ReadProperty("column_name_alias", result->column_name_alias);
	return std::move(result);
}

void EmptyTableRef::FormatSerialize(FormatSerializer &serializer) const {
	TableRef::FormatSerialize(serializer);
}

unique_ptr<TableRef> EmptyTableRef::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<EmptyTableRef>(new EmptyTableRef());
	return std::move(result);
}

void ExpressionListRef::FormatSerialize(FormatSerializer &serializer) const {
	TableRef::FormatSerialize(serializer);
	serializer.WriteProperty("expected_names", expected_names);
	serializer.WriteProperty("expected_types", expected_types);
	serializer.WriteProperty("values", values);
}

unique_ptr<TableRef> ExpressionListRef::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<ExpressionListRef>(new ExpressionListRef());
	deserializer.ReadProperty("expected_names", result->expected_names);
	deserializer.ReadProperty("expected_types", result->expected_types);
	deserializer.ReadProperty("values", result->values);
	return std::move(result);
}

void PivotRef::FormatSerialize(FormatSerializer &serializer) const {
	TableRef::FormatSerialize(serializer);
	serializer.WriteProperty("source", *source);
	serializer.WriteProperty("aggregates", aggregates);
	serializer.WriteProperty("unpivot_names", unpivot_names);
	serializer.WriteProperty("pivots", pivots);
	serializer.WriteProperty("groups", groups);
	serializer.WriteProperty("column_name_alias", column_name_alias);
	serializer.WriteProperty("include_nulls", include_nulls);
}

unique_ptr<TableRef> PivotRef::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<PivotRef>(new PivotRef());
	deserializer.ReadProperty("source", result->source);
	deserializer.ReadProperty("aggregates", result->aggregates);
	deserializer.ReadProperty("unpivot_names", result->unpivot_names);
	deserializer.ReadProperty("pivots", result->pivots);
	deserializer.ReadProperty("groups", result->groups);
	deserializer.ReadProperty("column_name_alias", result->column_name_alias);
	deserializer.ReadProperty("include_nulls", result->include_nulls);
	return std::move(result);
}

} // namespace duckdb
