//===----------------------------------------------------------------------===//
// This file is automatically generated by scripts/generate_serialization.py
// Do not edit this file manually, your changes will be overwritten
//===----------------------------------------------------------------------===//

#include "duckdb/common/serializer/format_serializer.hpp"
#include "duckdb/common/serializer/format_deserializer.hpp"
#include "duckdb/parser/constraints/list.hpp"

namespace duckdb {

void Constraint::FormatSerialize(FormatSerializer &serializer) const {
	serializer.WriteProperty("type", type);
}

unique_ptr<Constraint> Constraint::FormatDeserialize(FormatDeserializer &deserializer) {
	auto type = deserializer.ReadProperty<ConstraintType>("type");
	unique_ptr<Constraint> result;
	switch (type) {
	case ConstraintType::CHECK:
		result = CheckConstraint::FormatDeserialize(deserializer);
		break;
	case ConstraintType::FOREIGN_KEY:
		result = ForeignKeyConstraint::FormatDeserialize(deserializer);
		break;
	case ConstraintType::NOT_NULL:
		result = NotNullConstraint::FormatDeserialize(deserializer);
		break;
	case ConstraintType::UNIQUE:
		result = UniqueConstraint::FormatDeserialize(deserializer);
		break;
	default:
		throw SerializationException("Unsupported type for deserialization of Constraint!");
	}
	return result;
}

void CheckConstraint::FormatSerialize(FormatSerializer &serializer) const {
	Constraint::FormatSerialize(serializer);
	serializer.WriteProperty("expression", *expression);
}

unique_ptr<Constraint> CheckConstraint::FormatDeserialize(FormatDeserializer &deserializer) {
	auto expression = deserializer.ReadProperty<unique_ptr<ParsedExpression>>("expression");
	auto result = duckdb::unique_ptr<CheckConstraint>(new CheckConstraint(std::move(expression)));
	return std::move(result);
}

void ForeignKeyConstraint::FormatSerialize(FormatSerializer &serializer) const {
	Constraint::FormatSerialize(serializer);
	serializer.WriteProperty("pk_columns", pk_columns);
	serializer.WriteProperty("fk_columns", fk_columns);
	serializer.WriteProperty("type", info.type);
	serializer.WriteProperty("schema", info.schema);
	serializer.WriteProperty("table", info.table);
	serializer.WriteProperty("pk_keys", info.pk_keys);
	serializer.WriteProperty("fk_keys", info.fk_keys);
}

unique_ptr<Constraint> ForeignKeyConstraint::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<ForeignKeyConstraint>(new ForeignKeyConstraint());
	deserializer.ReadProperty("pk_columns", result->pk_columns);
	deserializer.ReadProperty("fk_columns", result->fk_columns);
	deserializer.ReadProperty("type", result->info.type);
	deserializer.ReadProperty("schema", result->info.schema);
	deserializer.ReadProperty("table", result->info.table);
	deserializer.ReadProperty("pk_keys", result->info.pk_keys);
	deserializer.ReadProperty("fk_keys", result->info.fk_keys);
	return std::move(result);
}

void NotNullConstraint::FormatSerialize(FormatSerializer &serializer) const {
	Constraint::FormatSerialize(serializer);
	serializer.WriteProperty("index", index);
}

unique_ptr<Constraint> NotNullConstraint::FormatDeserialize(FormatDeserializer &deserializer) {
	auto index = deserializer.ReadProperty<LogicalIndex>("index");
	auto result = duckdb::unique_ptr<NotNullConstraint>(new NotNullConstraint(index));
	return std::move(result);
}

void UniqueConstraint::FormatSerialize(FormatSerializer &serializer) const {
	Constraint::FormatSerialize(serializer);
	serializer.WriteProperty("is_primary_key", is_primary_key);
	serializer.WriteProperty("index", index);
	serializer.WriteProperty("columns", columns);
}

unique_ptr<Constraint> UniqueConstraint::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<UniqueConstraint>(new UniqueConstraint());
	deserializer.ReadProperty("is_primary_key", result->is_primary_key);
	deserializer.ReadProperty("index", result->index);
	deserializer.ReadProperty("columns", result->columns);
	return std::move(result);
}

} // namespace duckdb
