//===----------------------------------------------------------------------===//
// This file is automatically generated by scripts/generate_serialization.py
// Do not edit this file manually, your changes will be overwritten
//===----------------------------------------------------------------------===//

#include "duckdb/common/serializer/format_serializer.hpp"
#include "duckdb/common/serializer/format_deserializer.hpp"
#include "duckdb/parser/parsed_data/create_info.hpp"
#include "duckdb/parser/parsed_data/create_index_info.hpp"
#include "duckdb/parser/parsed_data/create_table_info.hpp"
#include "duckdb/parser/parsed_data/create_schema_info.hpp"
#include "duckdb/parser/parsed_data/create_view_info.hpp"
#include "duckdb/parser/parsed_data/create_type_info.hpp"
#include "duckdb/parser/parsed_data/create_macro_info.hpp"
#include "duckdb/parser/parsed_data/create_sequence_info.hpp"

namespace duckdb {

void CreateInfo::FormatSerialize(FormatSerializer &serializer) const {
	serializer.WriteProperty("type", type);
	serializer.WriteProperty("catalog", catalog);
	serializer.WriteProperty("schema", schema);
	serializer.WriteProperty("temporary", temporary);
	serializer.WriteProperty("internal", internal);
	serializer.WriteProperty("on_conflict", on_conflict);
	serializer.WriteProperty("sql", sql);
}

unique_ptr<CreateInfo> CreateInfo::FormatDeserialize(FormatDeserializer &deserializer) {
	auto type = deserializer.ReadProperty<CatalogType>("type");
	auto catalog = deserializer.ReadProperty<string>("catalog");
	auto schema = deserializer.ReadProperty<string>("schema");
	auto temporary = deserializer.ReadProperty<bool>("temporary");
	auto internal = deserializer.ReadProperty<bool>("internal");
	auto on_conflict = deserializer.ReadProperty<OnCreateConflict>("on_conflict");
	auto sql = deserializer.ReadProperty<string>("sql");
	unique_ptr<CreateInfo> result;
	switch (type) {
	case CatalogType::INDEX_ENTRY:
		result = CreateIndexInfo::FormatDeserialize(deserializer);
		break;
	case CatalogType::MACRO_ENTRY:
		result = CreateMacroInfo::FormatDeserialize(deserializer);
		break;
	case CatalogType::SCHEMA_ENTRY:
		result = CreateSchemaInfo::FormatDeserialize(deserializer);
		break;
	case CatalogType::SEQUENCE_ENTRY:
		result = CreateSequenceInfo::FormatDeserialize(deserializer);
		break;
	case CatalogType::TABLE_ENTRY:
		result = CreateTableInfo::FormatDeserialize(deserializer);
		break;
	case CatalogType::TABLE_MACRO_ENTRY:
		result = CreateMacroInfo::FormatDeserialize(deserializer);
		break;
	case CatalogType::TYPE_ENTRY:
		result = CreateTypeInfo::FormatDeserialize(deserializer);
		break;
	case CatalogType::VIEW_ENTRY:
		result = CreateViewInfo::FormatDeserialize(deserializer);
		break;
	default:
		throw SerializationException("Unsupported type for deserialization of CreateInfo!");
	}
	result->catalog = std::move(catalog);
	result->schema = std::move(schema);
	result->temporary = temporary;
	result->internal = internal;
	result->on_conflict = on_conflict;
	result->sql = std::move(sql);
	return result;
}

void CreateIndexInfo::FormatSerialize(FormatSerializer &serializer) const {
	CreateInfo::FormatSerialize(serializer);
	serializer.WriteProperty("name", index_name);
	serializer.WriteProperty("table", table);
	serializer.WriteProperty("index_type", index_type);
	serializer.WriteProperty("constraint_type", constraint_type);
	serializer.WriteProperty("parsed_expressions", parsed_expressions);
	serializer.WriteProperty("names", names);
	serializer.WriteProperty("column_ids", column_ids);
}

unique_ptr<CreateInfo> CreateIndexInfo::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<CreateIndexInfo>(new CreateIndexInfo());
	deserializer.ReadProperty("name", result->index_name);
	deserializer.ReadProperty("table", result->table);
	deserializer.ReadProperty("index_type", result->index_type);
	deserializer.ReadProperty("constraint_type", result->constraint_type);
	deserializer.ReadProperty("parsed_expressions", result->parsed_expressions);
	deserializer.ReadProperty("names", result->names);
	deserializer.ReadProperty("column_ids", result->column_ids);
	return std::move(result);
}

void CreateMacroInfo::FormatSerialize(FormatSerializer &serializer) const {
	CreateInfo::FormatSerialize(serializer);
	serializer.WriteProperty("name", name);
	serializer.WriteProperty("function", *function);
}

unique_ptr<CreateInfo> CreateMacroInfo::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<CreateMacroInfo>(new CreateMacroInfo());
	deserializer.ReadProperty("name", result->name);
	deserializer.ReadProperty("function", result->function);
	return std::move(result);
}

void CreateSchemaInfo::FormatSerialize(FormatSerializer &serializer) const {
	CreateInfo::FormatSerialize(serializer);
}

unique_ptr<CreateInfo> CreateSchemaInfo::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<CreateSchemaInfo>(new CreateSchemaInfo());
	return std::move(result);
}

void CreateSequenceInfo::FormatSerialize(FormatSerializer &serializer) const {
	CreateInfo::FormatSerialize(serializer);
	serializer.WriteProperty("name", name);
	serializer.WriteProperty("usage_count", usage_count);
	serializer.WriteProperty("increment", increment);
	serializer.WriteProperty("min_value", min_value);
	serializer.WriteProperty("max_value", max_value);
	serializer.WriteProperty("start_value", start_value);
	serializer.WriteProperty("cycle", cycle);
}

unique_ptr<CreateInfo> CreateSequenceInfo::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<CreateSequenceInfo>(new CreateSequenceInfo());
	deserializer.ReadProperty("name", result->name);
	deserializer.ReadProperty("usage_count", result->usage_count);
	deserializer.ReadProperty("increment", result->increment);
	deserializer.ReadProperty("min_value", result->min_value);
	deserializer.ReadProperty("max_value", result->max_value);
	deserializer.ReadProperty("start_value", result->start_value);
	deserializer.ReadProperty("cycle", result->cycle);
	return std::move(result);
}

void CreateTableInfo::FormatSerialize(FormatSerializer &serializer) const {
	CreateInfo::FormatSerialize(serializer);
	serializer.WriteProperty("table", table);
	serializer.WriteProperty("columns", columns);
	serializer.WriteProperty("constraints", constraints);
	serializer.WriteOptionalProperty("query", query);
}

unique_ptr<CreateInfo> CreateTableInfo::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<CreateTableInfo>(new CreateTableInfo());
	deserializer.ReadProperty("table", result->table);
	deserializer.ReadProperty("columns", result->columns);
	deserializer.ReadProperty("constraints", result->constraints);
	deserializer.ReadOptionalProperty("query", result->query);
	return std::move(result);
}

void CreateTypeInfo::FormatSerialize(FormatSerializer &serializer) const {
	CreateInfo::FormatSerialize(serializer);
	serializer.WriteProperty("name", name);
	serializer.WriteProperty("type", type);
}

unique_ptr<CreateInfo> CreateTypeInfo::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<CreateTypeInfo>(new CreateTypeInfo());
	deserializer.ReadProperty("name", result->name);
	deserializer.ReadProperty("type", result->type);
	return std::move(result);
}

void CreateViewInfo::FormatSerialize(FormatSerializer &serializer) const {
	CreateInfo::FormatSerialize(serializer);
	serializer.WriteProperty("view_name", view_name);
	serializer.WriteProperty("aliases", aliases);
	serializer.WriteProperty("types", types);
	serializer.WriteOptionalProperty("query", query);
}

unique_ptr<CreateInfo> CreateViewInfo::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<CreateViewInfo>(new CreateViewInfo());
	deserializer.ReadProperty("view_name", result->view_name);
	deserializer.ReadProperty("aliases", result->aliases);
	deserializer.ReadProperty("types", result->types);
	deserializer.ReadOptionalProperty("query", result->query);
	return std::move(result);
}

} // namespace duckdb
