//---------------------------------------------------------------------------
//	@filename:
//		COptimizationContext.h
//
//	@doc:
//		Optimization context object stores properties required to hold
//		on the plan generated by the optimizer
//---------------------------------------------------------------------------
#ifndef GPOPT_COptimizationContext_H
#define GPOPT_COptimizationContext_H

#include "duckdb/optimizer/cascade/base.h"
#include "duckdb/optimizer/cascade/base/CReqdPropPlan.h"
#include "duckdb/optimizer/cascade/search/CJobQueue.h"
 
#define GPOPT_INVALID_OPTCTXT_ID gpos::ulong_max

namespace gpopt
{
using namespace gpos;

// forward declarations
class CGroup;
class CGroupExpression;
class CCostContext;
class COptimizationContext;
class CReqdPropRelational;

// optimization context pointer definition
typedef COptimizationContext* OPTCTXT_PTR;

//---------------------------------------------------------------------------
//	@class:
//		COptimizationContext
//
//	@doc:
//		Optimization context
//
//---------------------------------------------------------------------------
class COptimizationContext
{
public:
	// states of optimization context
	enum EState
	{ estUnoptimized, estOptimizing, estOptimized, estSentinel };

public:
	// unique id within owner group, used for debugging
	ULONG m_id;

	// back pointer to owner group, used for debugging
	CGroup* m_pgroup;

	// required plan properties
	CReqdPropPlan* m_prpp;

	// required relational properties -- used for stats computation during costing
	CReqdPropRelational* m_prprel;

	// index of search stage where context is generated
	ULONG m_ulSearchStageIndex;

	// best cost context under the optimization context
	CCostContext* m_pccBest;

	// optimization context state
	EState m_estate;

	// is there a multi-stage Agg plan satisfying required properties
	bool m_fHasMultiStageAggPlan;

	// context's optimization job queue
	CJobQueue m_jqOptimization;

	// link for optimization context hash table in CGroup
	SLink m_link;

	// invalid optimization context, needed for hash table iteration
	static const COptimizationContext m_ocInvalid;

	// invalid optimization context pointer, needed for cost contexts hash table iteration
	static const OPTCTXT_PTR m_pocInvalid;

public:
	// dummy ctor; used for creating invalid context
	COptimizationContext()
		: m_id(GPOPT_INVALID_OPTCTXT_ID), m_pgroup(NULL), m_prpp(NULL), m_prprel(NULL), m_ulSearchStageIndex(0), m_pccBest(NULL), m_estate(estUnoptimized), m_fHasMultiStageAggPlan(false){};
	
	//---------------------------------------------------------------------------
	// ctor
	// @inputs:
	//	 CReqdPropRelational* prprel: required relational props -- used during stats derivation
	//	 IStatisticsArray* stats_ctxt: stats of previously optimized expressions
	//---------------------------------------------------------------------------
	COptimizationContext(CGroup* pgroup, CReqdPropPlan* prpp, CReqdPropRelational* prprel, ULONG ulSearchStageIndex)
		: m_id(GPOPT_INVALID_OPTCTXT_ID), m_pgroup(pgroup), m_prpp(prpp), m_prprel(prprel), m_ulSearchStageIndex(ulSearchStageIndex), m_pccBest(NULL), m_estate(estUnoptimized), m_fHasMultiStageAggPlan(false)
	{
	}

	// copy ctor
	COptimizationContext(const COptimizationContext &) = delete;

	// dtor
	virtual ~COptimizationContext();

public:
	// internal matching function
	bool FMatchSortColumns(COptimizationContext* poc) const;	

	// best group expression accessor
	CGroupExpression* PgexprBest() const;

	// match optimization contexts
	bool Matches(const COptimizationContext* poc) const;

	// search stage index accessor
	ULONG UlSearchStageIndex() const
	{
		return m_ulSearchStageIndex;
	}

	// optimization job queue accessor
	CJobQueue* PjqOptimization()
	{
		return &m_jqOptimization;
	}

	// set optimization context id
	void SetId(ULONG id)
	{
		m_id = id;
	}

	// set optimization context state
	void SetState(EState estNewState)
	{
		m_estate = estNewState;
	}

	// set best cost context
	void SetBest(CCostContext* pcc);

	// comparison operator for hashtables
	bool operator==(const COptimizationContext &oc) const
	{
		return oc.Matches(this);
	}

	// check equality of optimization contexts
	static bool Equals(const COptimizationContext &ocLeft, const COptimizationContext &ocRight)
	{
		return ocLeft == ocRight;
	}

	ULONG HashValue()
	{
		return m_prpp->HashValue();
	}

	// hash function for optimization context
	static ULONG HashValue(const COptimizationContext &oc)
	{
		return oc.m_prpp->HashValue();
	}

	// equality function for cost contexts hash table
	static bool Equals(const OPTCTXT_PTR &pocLeft, const OPTCTXT_PTR &pocRight)
	{
		if (pocLeft == m_pocInvalid || pocRight == m_pocInvalid)
		{
			return pocLeft == m_pocInvalid && pocRight == m_pocInvalid;
		}
		return *pocLeft == *pocRight;
	}

	// hash function for cost contexts hash table
	static ULONG HashValue(const OPTCTXT_PTR &poc)
	{
		return HashValue(*poc);
	}

	// hash function used for computing stats during costing
	static ULONG UlHashForStats(const COptimizationContext* poc)
	{
		return HashValue(*poc);
	}

	// equality function used for computing stats during costing
	static bool FEqualForStats(const COptimizationContext *pocLeft, const COptimizationContext *pocRight);

	// check if Agg node should be optimized for the given context
	static bool FOptimizeAgg(CGroupExpression* pgexprParent, CGroupExpression* pgexprAgg, COptimizationContext* poc, ULONG ulSearchStages);

	// check if Sort node should be optimized for the given context
	static bool FOptimizeSort(CGroupExpression* pgexprParent, CGroupExpression* pgexprSort, COptimizationContext* poc, ULONG ulSearchStages);

	// check if Motion node should be optimized for the given context
	static bool FOptimizeMotion(CGroupExpression* pgexprParent, CGroupExpression* pgexprMotion, COptimizationContext* poc, ULONG ulSearchStages);

	// check if NL join node should be optimized for the given context
	static bool FOptimizeNLJoin(CGroupExpression* pgexprParent, CGroupExpression* pgexprMotion, COptimizationContext* poc, ULONG ulSearchStages);

	// return true if given group expression should be optimized under given context
	static bool FOptimize(CGroupExpression* pgexprParent, CGroupExpression* pgexprChild, COptimizationContext* pocChild, ULONG ulSearchStages);

	// compare array of contexts based on context ids
	static bool FEqualContextIds(duckdb::vector<COptimizationContext*> pdrgpocFst, duckdb::vector<COptimizationContext*> pdrgpocSnd);

	// compute required properties to CTE producer based on plan properties of CTE consumer
	// static CReqdPropPlan *PrppCTEProducer(COptimizationContext *poc, ULONG ulSearchStages);
};	// class COptimizationContext
}  // namespace gpopt
#endif