// !!!!!!!
// WARNING: this file is used for header generation by scripts/generate_metric_enums.py after modifying the code below, rerun
//          the script to apply changes to the generated files
// !!!!!!!

// DUCKDB_START_OF_FILE

#pragma once

#include "duckdb/common/enums/metric_type.hpp"
#include "duckdb/main/query_profiler.hpp"
#include "duckdb/main/profiling_node.hpp"

namespace duckdb_yyjson {
struct yyjson_mut_doc;
struct yyjson_mut_val;
} // namespace duckdb_yyjson

namespace duckdb {

struct ActiveTimer;

// DUCKDB_INSERT_CODE_HERE

class ProfilingUtils {
public:
	static void SetMetricToDefault(profiler_metrics_t &metrics, const MetricType &type);
	static void MetricToJson(duckdb_yyjson::yyjson_mut_doc *doc, duckdb_yyjson::yyjson_mut_val *dest, const char *key_ptr,  profiler_metrics_t &metrics, const MetricType &type);
	static void CollectMetrics(const MetricType &type, QueryMetrics &query_metrics, Value &metric, ProfilingNode &node, ProfilingInfo &child_info);
};

struct ActiveTimer {
public:
	ActiveTimer(QueryMetrics &query_metrics, const MetricType metric, const bool is_active = true) : query_metrics(query_metrics), metric(metric), is_active(is_active) {
		// start on constructor
		if (!is_active) {
			return;
		}
		profiler.Start();
	}

	~ActiveTimer() {
		if (is_active) {
			// automatically end in destructor
			EndTimer();
		}
	}

	// Automatically called in the destructor.
	void EndTimer() {
		if (!is_active) {
			return;
		}
		// stop profiling and report
		is_active = false;
		profiler.End();
		query_metrics.AddTiming(metric, profiler.Elapsed());
	}

	void Reset() {
	    if (!is_active) {
			return;
		}
		profiler.Reset();
		is_active = false;
	}

private:
	QueryMetrics &query_metrics;
	const MetricType metric;
	Profiler profiler;
	bool is_active;
};

}
