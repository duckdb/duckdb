diff --git a/src/include/duckdb/main/profiling_utils.hpp b/src/include/duckdb/main/profiling_utils.hpp
index 0376193094..0c92d532ac 100644
--- a/src/include/duckdb/main/profiling_utils.hpp
+++ b/src/include/duckdb/main/profiling_utils.hpp
@@ -53,6 +53,9 @@ public:
         for(idx_t i = 0; i < ACTIVELY_TRACKED_METRICS; i++) {
             active_metrics[i] = 0;
         }
+
+    	latency_timer.reset();
+    	query_name = "";
     }
 
     void Merge(const QueryMetrics &other) {
diff --git a/test/api/test_query_profiler.cpp b/test/api/test_query_profiler.cpp
index 882ba75cbe..ac08028fe9 100644
--- a/test/api/test_query_profiler.cpp
+++ b/test/api/test_query_profiler.cpp
@@ -2,6 +2,7 @@
 #include "test_helpers.hpp"
 
 #include <iostream>
+#include <thread>
 
 using namespace duckdb;
 using namespace std;
@@ -57,3 +58,32 @@ TEST_CASE("Test query profiler, no query in the profiling output.", "[api]") {
 	query_not_found_in_output = output.find(query) == std::string::npos;
 	REQUIRE(query_not_found_in_output);
 }
+
+TEST_CASE("Test latency when interrupting query", "[api]") {
+	duckdb::unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+
+	con.EnableQueryVerification();
+	con.EnableProfiling();
+
+	con.context->config.emit_profiler_output = false;
+
+	// Test interupting a query and running a new one afterward.
+	// The latency should reflect the new one.
+	thread t([&con]() {
+		string query = "explain analyze select sum(range) from range(1_000_000_000);";
+		con.Query(query);
+	});
+
+	this_thread::sleep_for(chrono::milliseconds(100));
+	con.Interrupt();
+	t.join();
+
+	string query = "explain analyze select sum(range) from range(1_000_000);";
+	REQUIRE_NO_FAIL(con.Query(query));
+
+	auto profiling_info = con.GetProfilingTree()->GetProfilingInfo();
+	auto latency = profiling_info.GetMetricAsString(MetricType::LATENCY);
+	REQUIRE(latency == "0.0");
+}
