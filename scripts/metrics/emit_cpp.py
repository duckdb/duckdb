from __future__ import annotations
from typing import Dict, List
from pathlib import Path

from .inputs import _to_pascal_case
from .writer import IndentedFileWriter

HPP_HEADER = """//-------------------------------------------------------------------------
//                         DuckDB
//
// duckdb/common/enums/metric_type.hpp
// 
// This file is automatically generated by scripts/generate_metric_enums.py
// Do not edit this file manually, your changes will be overwritten
//-------------------------------------------------------------------------

#pragma once

#include "duckdb/common/types/value.hpp"
#include "duckdb/common/unordered_set.hpp"
#include "duckdb/common/constants.hpp"
#include "duckdb/common/enums/optimizer_type.hpp"

namespace duckdb {

"""

HPP_TYPEDEFS = """
struct MetricsTypeHashFunction {
    uint64_t operator()(const MetricsType &index) const {
        return std::hash<uint8_t>()(static_cast<uint8_t>(index));
    }
};

typedef unordered_set<MetricsType, MetricsTypeHashFunction> profiler_settings_t;
typedef unordered_map<MetricsType, Value, MetricsTypeHashFunction> profiler_metrics_t;

"""

CPP_HEADER = """// This file is automatically generated by scripts/generate_metric_enums.py
// Do not edit this file manually, your changes will be overwritten

#include "duckdb/common/enums/metric_type.hpp"
#include "duckdb/common/enum_util.hpp"

namespace duckdb {

"""


def _setup_hpp(f: IndentedFileWriter, all_metrics: Dict[str, List[str]]):
    f.write(HPP_HEADER)

    f.write("enum class MetricGroup : uint8_t {\n")

    groups = sorted([g.upper() for g in all_metrics] + ["INVALID"])
    for g in groups:
        f.write_indented(1, f"{g},")
    f.write("};\n\n")

    f.write("enum class MetricsType : uint8_t {\n")
    for metric in all_metrics["all"]:
        f.write_indented(1, f"{metric},")
    f.write("};\n")

    f.write(HPP_TYPEDEFS)
    f.write('class MetricsUtils {\n')
    f.write('public:\n')


def _generate_standard_functions(
    group: str, hpp_f: IndentedFileWriter, cpp_f: IndentedFileWriter, metrics: Dict[str, List[str]]
):
    formatted = _to_pascal_case(group)
    get_fn = f"Get{formatted}Metrics"

    hpp_f.write('\n')
    hpp_f.write_indented(1, f"// {formatted} metrics")
    hpp_f.write_indented(1, f"static profiler_settings_t {get_fn}();")

    cpp_f.write(f"profiler_settings_t MetricsUtils::{get_fn}() {{\n")
    cpp_f.write_indented(1, "return {")
    for m in metrics[group]:
        cpp_f.write_indented(2, f"MetricsType::{m},")
    cpp_f.write_indented(1, "};")
    cpp_f.write('}\n\n')

    if group == "all":
        _generate_get_metric_by_group_function(hpp_f, cpp_f, metrics)
        return

    check_fn = f"Is{formatted}Metric"
    hpp_f.write_indented(1, f"static bool {check_fn}(MetricsType type);")

    cpp_f.write(f"bool MetricsUtils::{check_fn}(MetricsType type) {{\n")
    cpp_f.write_indented(1, "switch(type) {")
    for m in metrics[group]:
        cpp_f.write_indented(2, f"case MetricsType::{m}:")
    cpp_f.write_indented(3, "return true;")
    cpp_f.write_indented(2, "default:")
    cpp_f.write_indented(3, "return false;")
    cpp_f.write_indented(1, "}")
    cpp_f.write("}\n\n")


def _generate_custom_optimizer_functions(optimizers: List[str], hpp_f: IndentedFileWriter, cpp_f: IndentedFileWriter):
    by_type = "GetOptimizerMetricByType(OptimizerType type)"
    by_metric = "GetOptimizerTypeByMetric(MetricsType type)"

    hpp_f.write_indented(1, f"static MetricsType {by_type};")
    hpp_f.write_indented(1, f"static OptimizerType {by_metric};")

    cpp_f.write(f"MetricsType MetricsUtils::{by_type} {{\n")
    cpp_f.write_indented(1, "switch(type) {")
    for o in optimizers:
        cpp_f.write_indented(2, f"case OptimizerType::{o}:")
        cpp_f.write_indented(3, f"return MetricsType::OPTIMIZER_{o};")
    cpp_f.write_indented(2, "default:")
    cpp_f.write_indented(
        3, 'throw InternalException("OptimizerType %s cannot be converted to a MetricsType", EnumUtil::ToString(type));'
    )
    cpp_f.write_indented(1, "}")
    cpp_f.write('}\n\n')

    cpp_f.write(f"OptimizerType MetricsUtils::{by_metric} {{\n")
    cpp_f.write_indented(1, "switch(type) {")
    for o in optimizers:
        cpp_f.write_indented(2, f"case MetricsType::OPTIMIZER_{o}:")
        cpp_f.write_indented(3, f"return OptimizerType::{o};")
    cpp_f.write_indented(2, "default:")
    cpp_f.write_indented(3, "return OptimizerType::INVALID;")
    cpp_f.write_indented(1, "}")
    cpp_f.write('}\n\n')


def _generate_get_metric_by_group_function(
    hpp_f: IndentedFileWriter, cpp_f: IndentedFileWriter, all_metrics: Dict[str, List[str]]
):
    fn = "GetMetricsByGroupType(MetricGroup type)"
    hpp_f.write_indented(1, f"static profiler_settings_t {fn};")

    cpp_f.write(f"profiler_settings_t MetricsUtils::{fn} {{\n")
    cpp_f.write_indented(1, "switch(type) {")
    for group in all_metrics:
        formatted = group.upper()
        cpp_f.write_indented(1, f"case MetricGroup::{formatted}:")
        cpp_f.write_indented(2, "return {")
        for m in all_metrics[group]:
            cpp_f.write_indented(3, f"MetricsType::{m},")
        cpp_f.write_indented(3, "};")
    cpp_f.write_indented(1, "default:")
    cpp_f.write_indented(2, 'throw InternalException("The MetricGroup passed is invalid");')
    cpp_f.write_indented(1, "}")
    cpp_f.write('}\n')


def _generate_profiling_utils(out_hpp: Path, out_cpp: Path, all_metrics: Dict[str, List[str]]):
    with IndentedFileWriter(out_hpp) as hpp_f, IndentedFileWriter(out_cpp) as cpp_f:
        hpp_f.write(HPP_HEADER)
        cpp_f.write(CPP_HEADER)


def generate_metric_type_files(
    out_hpp: Path,
    out_cpp: Path,
    all_metrics: Dict[str, List[str]],
    optimizers: List[str],
    root_scope_metrics: List[str],
) -> None:
    with IndentedFileWriter(out_hpp) as hpp_f, IndentedFileWriter(out_cpp) as cpp_f:
        _setup_hpp(hpp_f, all_metrics)
        cpp_f.write(CPP_HEADER)

        for group in all_metrics:
            _generate_standard_functions(group, hpp_f, cpp_f, all_metrics)
            if group == "optimizer":
                _generate_custom_optimizer_functions(optimizers, hpp_f, cpp_f)

        temp = {"root_scope": root_scope_metrics}
        _generate_standard_functions("root_scope", hpp_f, cpp_f, temp)

        hpp_f.write("};\n")
        hpp_f.write("} // namespace duckdb\n")
        cpp_f.write("}\n")
