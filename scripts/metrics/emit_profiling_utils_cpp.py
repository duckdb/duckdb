from collections import namedtuple
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Optional, Callable

from .model import MetricIndex
from .writer import IndentedFileWriter

HPP_HEADER = """//-------------------------------------------------------------------------
//                         DuckDB
//
// duckdb/main/profiling_utils.hpp
// 
// This file is automatically generated by scripts/generate_metric_enums.py
// Do not edit this file manually, your changes will be overwritten
//-------------------------------------------------------------------------

#pragma once

#include "duckdb/common/enums/metric_type.hpp"
#include "duckdb/main/query_profiler.hpp"
#include "duckdb/main/profiling_node.hpp"

namespace duckdb_yyjson {
struct yyjson_mut_doc;
struct yyjson_mut_val;
} // namespace duckdb_yyjson

namespace duckdb {

"""

CPP_HEADER = """// This file is automatically generated by scripts/generate_metric_enums.py
// Do not edit this file manually, your changes will be overwritten

#include "duckdb/main/profiling_utils.hpp"
#include "duckdb/common/enum_util.hpp"
#include "duckdb/main/profiling_node.hpp"
#include "duckdb/main/query_profiler.hpp"

#include "yyjson.hpp"

using namespace duckdb_yyjson; // NOLINT

namespace duckdb {
"""


def _operator_to_string_function(class_name: str, return_type: str, function_name: str) -> str:
    return f"""
{return_type} {class_name}::{function_name} {{
    const auto type = static_cast<PhysicalOperatorType>(val.GetValue<uint8_t>());
    return EnumUtil::ToString(type);
}}
"""


def _aggregate_metric_function(class_name: str, return_type: str, function_name: str) -> str:
    return f"""
template <class METRIC_TYPE>
{return_type} {class_name}::{function_name} {{
	auto &info = node.GetProfilingInfo();
	info.metrics[aggregated_metric] = info.metrics[child_metric];

	for (idx_t i = 0; i < node.GetChildCount(); i++) {{
		auto child = node.GetChild(i);
		AggregateMetric<METRIC_TYPE>(*child, aggregated_metric, child_metric, update_fun);

		auto &child_info = child->GetProfilingInfo();
		auto value = child_info.GetMetricValue<METRIC_TYPE>(aggregated_metric);
		info.MetricUpdate<METRIC_TYPE>(aggregated_metric, value, update_fun);
	}}
}}
"""


def _get_cumulative_metric_function(class_name: str, return_type: str, function_name: str) -> str:
    return f"""
template <class METRIC_TYPE>
{return_type} {class_name}::{function_name} {{
	AggregateMetric<METRIC_TYPE>(
	    node, cumulative_metric, child_metric,
	    [](const METRIC_TYPE &old_value, const METRIC_TYPE &new_value) {{ return old_value + new_value; }});
}}
"""


def _get_cumulative_optimizers_function(class_name: str, return_type: str, function_name: str) -> str:
    return f"""
{return_type} {class_name}::{function_name} {{
	auto &metrics = node.GetProfilingInfo().metrics;
	double count = 0;
	for (auto &metric : metrics) {{
		if (MetricsUtils::IsOptimizerMetric(metric.first)) {{
			count += metric.second.GetValue<double>();
		}}
	}}
	return Value::CreateValue(count);
}}

"""


def _default_case_logic(t: str) -> Optional[str]:
    val = "Value::"
    if t == "map":
        val += "MAP(InsertionOrderPreservingMap<string>())"
    else:
        val += "CreateValue"
        if t == "string":
            val += "(\"\")"
        elif t == "double":
            val += "(0.0)"
        elif t == "uint64":
            val += "<uint64_t>(0)"
        elif t == "uint8":
            val += "<uint8_t>(0)"

    return f"metrics[type] = {val};"


def _metric_to_json_case_logic(t: str) -> Optional[str]:
    if t == "map":
        return None
    elif t == "string":
        return "yyjson_mut_obj_add_strcpy(doc, dest, key_ptr, metrics[type].GetValue<string>().c_str());"
    elif t == "double":
        return "yyjson_mut_obj_add_real(doc, dest, key_ptr, metrics[type].GetValue<double>());"
    elif t == "uint64":
        return "yyjson_mut_obj_add_uint(doc, dest, key_ptr, metrics[type].GetValue<uint64_t>());"
    elif t == "uint8":
        return "yyjson_mut_obj_add_strcpy(doc, dest, key_ptr, OperatorToString(metrics[type]).c_str());"
    return None


def _write_function(
    cpp_f: IndentedFileWriter,
    types: Dict[str, list[str]],
    class_name: str,
    function_name: str,
    case_logic: Callable[[str], Optional[str]],
) -> None:
    # set metric to default
    cpp_f.write_indented(0, f"void {class_name}::{function_name} {{")
    cpp_f.write_indented(1, "switch(type) {")
    for t in types:
        for m in types[t]:
            cpp_f.write_indented(2, f"case MetricsType::{m}:")

        res = case_logic(t)
        if res is not None:
            cpp_f.write_indented(3, res)
        cpp_f.write_indented(3, "break;")

    cpp_f.write_indented(2, "default:")
    cpp_f.write_indented(3, "throw InternalException(\"Unknown metric type %s\", EnumUtil::ToString(type));")
    cpp_f.write_indented(1, "}")
    cpp_f.write_indented(0, "}\n")


def _generate_collection_methods(
    cpp_f: IndentedFileWriter, class_name: str, function_name: str, metric_index: MetricIndex
) -> None:
    cpp_f.write_indented(0, f"void {class_name}::{function_name} {{")
    cpp_f.write_indented(1, "switch(type) {")
    for c in metric_index.collection_index():
        for m in metric_index.metrics_per_collection(c):
            cpp_f.write_indented(2, f"case MetricsType::{m}:")
            if c == "timer":
                cpp_f.write_indented(3, f"metric = query_metrics.{m.lower()}.Elapsed();")
            elif c == "child":
                cpp_f.write_indented(3, f"metric = child_info.metrics[MetricsType::{metric_index.metric_child(m)}];")
            elif c == "cumulative_operators":
                cpp_f.write_indented(3, f"metric = GetCumulativeOptimizers(node);")
            elif c == "query_metric" and metric_index.metric_type(m) == "uint64_t":
                cpp_f.write_indented(3, f"metric = Value::UBIGINT(query_metrics.{m.lower()});")
            elif c == "cumulative":
                cpp_f.write_indented(
                    3,
                    f"GetCumulativeMetric<{metric_index.metric_type(m)}>(node, MetricsType::{m}, MetricsType::{metric_index.metric_child(m)});",
                )
            else:
                raise Exception(f"Unknown collection type {c} or metric {m}")
            cpp_f.write_indented(3, f"break;")

    cpp_f.write_indented(2, "default:")
    cpp_f.write_indented(3, "return;")
    cpp_f.write_indented(1, "}")
    cpp_f.write_indented(0, "}\n")


def generate_profiling_utils(
    out_hpp: Path,
    out_cpp: Path,
    metric_index: MetricIndex,
) -> None:
    with IndentedFileWriter(out_hpp) as hpp_f, IndentedFileWriter(out_cpp) as cpp_f:
        hpp_f.write(HPP_HEADER)
        cpp_f.write(CPP_HEADER)

        class_name = "ProfilingUtils"

        default_function = "SetMetricToDefault(profiler_metrics_t &metrics, const MetricsType &type)"
        metric_to_json = "MetricToJson(duckdb_yyjson::yyjson_mut_doc *doc, duckdb_yyjson::yyjson_mut_val *dest, const char *key_ptr,  profiler_metrics_t &metrics, const MetricsType &type)"
        collect_metrics = "CollectMetrics(const MetricsType &type, QueryMetrics &query_metrics, Value &metric, ProfilingNode &node, ProfilingInfo &child_info)"

        hpp_f.write_indented(0, f"class {class_name} {{")
        hpp_f.write_indented(0, "public:")
        hpp_f.write_indented(1, f"static void {default_function};")
        hpp_f.write_indented(1, f"static void {metric_to_json};")
        hpp_f.write_indented(1, f"static void {collect_metrics};")
        hpp_f.write_indented(0, "\nprivate:")

        @dataclass
        class PrivateFunction:
            f: callable
            ret: str
            func_name: str
            template: Optional[str]

        private_functions = [
            PrivateFunction(
                f=_operator_to_string_function,
                ret="string",
                func_name="OperatorToString(const Value &val)",
                template=None,
            ),
            PrivateFunction(
                f=_aggregate_metric_function,
                ret="void",
                func_name="AggregateMetric(ProfilingNode &node, MetricsType aggregated_metric, MetricsType child_metric, const std::function<METRIC_TYPE(const METRIC_TYPE &, const METRIC_TYPE &)> &update_fun)",
                template="template <class METRIC_TYPE>",
            ),
            PrivateFunction(
                f=_get_cumulative_metric_function,
                ret="void",
                func_name="GetCumulativeMetric(ProfilingNode &node, MetricsType cumulative_metric, MetricsType child_metric)",
                template="template <class METRIC_TYPE>",
            ),
            PrivateFunction(
                f=_get_cumulative_optimizers_function,
                ret="Value",
                func_name="GetCumulativeOptimizers(ProfilingNode &node)",
                template=None,
            ),
        ]

        for pf in private_functions:
            if pf.template is not None:
                hpp_f.write_indented(1, f"{pf.template}")
            hpp_f.write_indented(1, f"static {pf.ret} {pf.func_name};\n")
            cpp_f.write(pf.f(class_name, pf.ret, pf.func_name))

        _write_function(cpp_f, metric_index.types_index(), class_name, default_function, _default_case_logic)
        _write_function(cpp_f, metric_index.types_index(), class_name, metric_to_json, _metric_to_json_case_logic)

        _generate_collection_methods(cpp_f, class_name, collect_metrics, metric_index)

        hpp_f.write_indented(0, "};\n")
        hpp_f.write_indented(0, "}")
        cpp_f.write_indented(0, "}")
