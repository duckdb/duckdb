// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: substrait/expression.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_substrait_2fexpression_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_substrait_2fexpression_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "substrait/type.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_substrait_2fexpression_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_substrait_2fexpression_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[49]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_substrait_2fexpression_2eproto;
namespace substrait {
class AggregateFunction;
struct AggregateFunctionDefaultTypeInternal;
extern AggregateFunctionDefaultTypeInternal _AggregateFunction_default_instance_;
class Expression;
struct ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
class Expression_Cast;
struct Expression_CastDefaultTypeInternal;
extern Expression_CastDefaultTypeInternal _Expression_Cast_default_instance_;
class Expression_EmbeddedFunction;
struct Expression_EmbeddedFunctionDefaultTypeInternal;
extern Expression_EmbeddedFunctionDefaultTypeInternal _Expression_EmbeddedFunction_default_instance_;
class Expression_EmbeddedFunction_PythonPickleFunction;
struct Expression_EmbeddedFunction_PythonPickleFunctionDefaultTypeInternal;
extern Expression_EmbeddedFunction_PythonPickleFunctionDefaultTypeInternal _Expression_EmbeddedFunction_PythonPickleFunction_default_instance_;
class Expression_EmbeddedFunction_WebAssemblyFunction;
struct Expression_EmbeddedFunction_WebAssemblyFunctionDefaultTypeInternal;
extern Expression_EmbeddedFunction_WebAssemblyFunctionDefaultTypeInternal _Expression_EmbeddedFunction_WebAssemblyFunction_default_instance_;
class Expression_Enum;
struct Expression_EnumDefaultTypeInternal;
extern Expression_EnumDefaultTypeInternal _Expression_Enum_default_instance_;
class Expression_Enum_Empty;
struct Expression_Enum_EmptyDefaultTypeInternal;
extern Expression_Enum_EmptyDefaultTypeInternal _Expression_Enum_Empty_default_instance_;
class Expression_FieldReference;
struct Expression_FieldReferenceDefaultTypeInternal;
extern Expression_FieldReferenceDefaultTypeInternal _Expression_FieldReference_default_instance_;
class Expression_FieldReference_RootReference;
struct Expression_FieldReference_RootReferenceDefaultTypeInternal;
extern Expression_FieldReference_RootReferenceDefaultTypeInternal _Expression_FieldReference_RootReference_default_instance_;
class Expression_IfThen;
struct Expression_IfThenDefaultTypeInternal;
extern Expression_IfThenDefaultTypeInternal _Expression_IfThen_default_instance_;
class Expression_IfThen_IfClause;
struct Expression_IfThen_IfClauseDefaultTypeInternal;
extern Expression_IfThen_IfClauseDefaultTypeInternal _Expression_IfThen_IfClause_default_instance_;
class Expression_Literal;
struct Expression_LiteralDefaultTypeInternal;
extern Expression_LiteralDefaultTypeInternal _Expression_Literal_default_instance_;
class Expression_Literal_Decimal;
struct Expression_Literal_DecimalDefaultTypeInternal;
extern Expression_Literal_DecimalDefaultTypeInternal _Expression_Literal_Decimal_default_instance_;
class Expression_Literal_IntervalDayToSecond;
struct Expression_Literal_IntervalDayToSecondDefaultTypeInternal;
extern Expression_Literal_IntervalDayToSecondDefaultTypeInternal _Expression_Literal_IntervalDayToSecond_default_instance_;
class Expression_Literal_IntervalYearToMonth;
struct Expression_Literal_IntervalYearToMonthDefaultTypeInternal;
extern Expression_Literal_IntervalYearToMonthDefaultTypeInternal _Expression_Literal_IntervalYearToMonth_default_instance_;
class Expression_Literal_List;
struct Expression_Literal_ListDefaultTypeInternal;
extern Expression_Literal_ListDefaultTypeInternal _Expression_Literal_List_default_instance_;
class Expression_Literal_Map;
struct Expression_Literal_MapDefaultTypeInternal;
extern Expression_Literal_MapDefaultTypeInternal _Expression_Literal_Map_default_instance_;
class Expression_Literal_Map_KeyValue;
struct Expression_Literal_Map_KeyValueDefaultTypeInternal;
extern Expression_Literal_Map_KeyValueDefaultTypeInternal _Expression_Literal_Map_KeyValue_default_instance_;
class Expression_Literal_Struct;
struct Expression_Literal_StructDefaultTypeInternal;
extern Expression_Literal_StructDefaultTypeInternal _Expression_Literal_Struct_default_instance_;
class Expression_Literal_VarChar;
struct Expression_Literal_VarCharDefaultTypeInternal;
extern Expression_Literal_VarCharDefaultTypeInternal _Expression_Literal_VarChar_default_instance_;
class Expression_MaskExpression;
struct Expression_MaskExpressionDefaultTypeInternal;
extern Expression_MaskExpressionDefaultTypeInternal _Expression_MaskExpression_default_instance_;
class Expression_MaskExpression_ListSelect;
struct Expression_MaskExpression_ListSelectDefaultTypeInternal;
extern Expression_MaskExpression_ListSelectDefaultTypeInternal _Expression_MaskExpression_ListSelect_default_instance_;
class Expression_MaskExpression_ListSelect_ListSelectItem;
struct Expression_MaskExpression_ListSelect_ListSelectItemDefaultTypeInternal;
extern Expression_MaskExpression_ListSelect_ListSelectItemDefaultTypeInternal _Expression_MaskExpression_ListSelect_ListSelectItem_default_instance_;
class Expression_MaskExpression_ListSelect_ListSelectItem_ListElement;
struct Expression_MaskExpression_ListSelect_ListSelectItem_ListElementDefaultTypeInternal;
extern Expression_MaskExpression_ListSelect_ListSelectItem_ListElementDefaultTypeInternal _Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_;
class Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice;
struct Expression_MaskExpression_ListSelect_ListSelectItem_ListSliceDefaultTypeInternal;
extern Expression_MaskExpression_ListSelect_ListSelectItem_ListSliceDefaultTypeInternal _Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_;
class Expression_MaskExpression_MapSelect;
struct Expression_MaskExpression_MapSelectDefaultTypeInternal;
extern Expression_MaskExpression_MapSelectDefaultTypeInternal _Expression_MaskExpression_MapSelect_default_instance_;
class Expression_MaskExpression_MapSelect_MapKey;
struct Expression_MaskExpression_MapSelect_MapKeyDefaultTypeInternal;
extern Expression_MaskExpression_MapSelect_MapKeyDefaultTypeInternal _Expression_MaskExpression_MapSelect_MapKey_default_instance_;
class Expression_MaskExpression_MapSelect_MapKeyExpression;
struct Expression_MaskExpression_MapSelect_MapKeyExpressionDefaultTypeInternal;
extern Expression_MaskExpression_MapSelect_MapKeyExpressionDefaultTypeInternal _Expression_MaskExpression_MapSelect_MapKeyExpression_default_instance_;
class Expression_MaskExpression_Select;
struct Expression_MaskExpression_SelectDefaultTypeInternal;
extern Expression_MaskExpression_SelectDefaultTypeInternal _Expression_MaskExpression_Select_default_instance_;
class Expression_MaskExpression_StructItem;
struct Expression_MaskExpression_StructItemDefaultTypeInternal;
extern Expression_MaskExpression_StructItemDefaultTypeInternal _Expression_MaskExpression_StructItem_default_instance_;
class Expression_MaskExpression_StructSelect;
struct Expression_MaskExpression_StructSelectDefaultTypeInternal;
extern Expression_MaskExpression_StructSelectDefaultTypeInternal _Expression_MaskExpression_StructSelect_default_instance_;
class Expression_MultiOrList;
struct Expression_MultiOrListDefaultTypeInternal;
extern Expression_MultiOrListDefaultTypeInternal _Expression_MultiOrList_default_instance_;
class Expression_MultiOrList_Record;
struct Expression_MultiOrList_RecordDefaultTypeInternal;
extern Expression_MultiOrList_RecordDefaultTypeInternal _Expression_MultiOrList_Record_default_instance_;
class Expression_ReferenceSegment;
struct Expression_ReferenceSegmentDefaultTypeInternal;
extern Expression_ReferenceSegmentDefaultTypeInternal _Expression_ReferenceSegment_default_instance_;
class Expression_ReferenceSegment_ListElement;
struct Expression_ReferenceSegment_ListElementDefaultTypeInternal;
extern Expression_ReferenceSegment_ListElementDefaultTypeInternal _Expression_ReferenceSegment_ListElement_default_instance_;
class Expression_ReferenceSegment_MapKey;
struct Expression_ReferenceSegment_MapKeyDefaultTypeInternal;
extern Expression_ReferenceSegment_MapKeyDefaultTypeInternal _Expression_ReferenceSegment_MapKey_default_instance_;
class Expression_ReferenceSegment_StructField;
struct Expression_ReferenceSegment_StructFieldDefaultTypeInternal;
extern Expression_ReferenceSegment_StructFieldDefaultTypeInternal _Expression_ReferenceSegment_StructField_default_instance_;
class Expression_ScalarFunction;
struct Expression_ScalarFunctionDefaultTypeInternal;
extern Expression_ScalarFunctionDefaultTypeInternal _Expression_ScalarFunction_default_instance_;
class Expression_SingularOrList;
struct Expression_SingularOrListDefaultTypeInternal;
extern Expression_SingularOrListDefaultTypeInternal _Expression_SingularOrList_default_instance_;
class Expression_SwitchExpression;
struct Expression_SwitchExpressionDefaultTypeInternal;
extern Expression_SwitchExpressionDefaultTypeInternal _Expression_SwitchExpression_default_instance_;
class Expression_SwitchExpression_IfValue;
struct Expression_SwitchExpression_IfValueDefaultTypeInternal;
extern Expression_SwitchExpression_IfValueDefaultTypeInternal _Expression_SwitchExpression_IfValue_default_instance_;
class Expression_WindowFunction;
struct Expression_WindowFunctionDefaultTypeInternal;
extern Expression_WindowFunctionDefaultTypeInternal _Expression_WindowFunction_default_instance_;
class Expression_WindowFunction_Bound;
struct Expression_WindowFunction_BoundDefaultTypeInternal;
extern Expression_WindowFunction_BoundDefaultTypeInternal _Expression_WindowFunction_Bound_default_instance_;
class Expression_WindowFunction_Bound_CurrentRow;
struct Expression_WindowFunction_Bound_CurrentRowDefaultTypeInternal;
extern Expression_WindowFunction_Bound_CurrentRowDefaultTypeInternal _Expression_WindowFunction_Bound_CurrentRow_default_instance_;
class Expression_WindowFunction_Bound_Following;
struct Expression_WindowFunction_Bound_FollowingDefaultTypeInternal;
extern Expression_WindowFunction_Bound_FollowingDefaultTypeInternal _Expression_WindowFunction_Bound_Following_default_instance_;
class Expression_WindowFunction_Bound_Preceding;
struct Expression_WindowFunction_Bound_PrecedingDefaultTypeInternal;
extern Expression_WindowFunction_Bound_PrecedingDefaultTypeInternal _Expression_WindowFunction_Bound_Preceding_default_instance_;
class Expression_WindowFunction_Bound_Unbounded;
struct Expression_WindowFunction_Bound_UnboundedDefaultTypeInternal;
extern Expression_WindowFunction_Bound_UnboundedDefaultTypeInternal _Expression_WindowFunction_Bound_Unbounded_default_instance_;
class SortField;
struct SortFieldDefaultTypeInternal;
extern SortFieldDefaultTypeInternal _SortField_default_instance_;
}  // namespace substrait
PROTOBUF_NAMESPACE_OPEN
template<> ::substrait::AggregateFunction* Arena::CreateMaybeMessage<::substrait::AggregateFunction>(Arena*);
template<> ::substrait::Expression* Arena::CreateMaybeMessage<::substrait::Expression>(Arena*);
template<> ::substrait::Expression_Cast* Arena::CreateMaybeMessage<::substrait::Expression_Cast>(Arena*);
template<> ::substrait::Expression_EmbeddedFunction* Arena::CreateMaybeMessage<::substrait::Expression_EmbeddedFunction>(Arena*);
template<> ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Arena::CreateMaybeMessage<::substrait::Expression_EmbeddedFunction_PythonPickleFunction>(Arena*);
template<> ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Arena::CreateMaybeMessage<::substrait::Expression_EmbeddedFunction_WebAssemblyFunction>(Arena*);
template<> ::substrait::Expression_Enum* Arena::CreateMaybeMessage<::substrait::Expression_Enum>(Arena*);
template<> ::substrait::Expression_Enum_Empty* Arena::CreateMaybeMessage<::substrait::Expression_Enum_Empty>(Arena*);
template<> ::substrait::Expression_FieldReference* Arena::CreateMaybeMessage<::substrait::Expression_FieldReference>(Arena*);
template<> ::substrait::Expression_FieldReference_RootReference* Arena::CreateMaybeMessage<::substrait::Expression_FieldReference_RootReference>(Arena*);
template<> ::substrait::Expression_IfThen* Arena::CreateMaybeMessage<::substrait::Expression_IfThen>(Arena*);
template<> ::substrait::Expression_IfThen_IfClause* Arena::CreateMaybeMessage<::substrait::Expression_IfThen_IfClause>(Arena*);
template<> ::substrait::Expression_Literal* Arena::CreateMaybeMessage<::substrait::Expression_Literal>(Arena*);
template<> ::substrait::Expression_Literal_Decimal* Arena::CreateMaybeMessage<::substrait::Expression_Literal_Decimal>(Arena*);
template<> ::substrait::Expression_Literal_IntervalDayToSecond* Arena::CreateMaybeMessage<::substrait::Expression_Literal_IntervalDayToSecond>(Arena*);
template<> ::substrait::Expression_Literal_IntervalYearToMonth* Arena::CreateMaybeMessage<::substrait::Expression_Literal_IntervalYearToMonth>(Arena*);
template<> ::substrait::Expression_Literal_List* Arena::CreateMaybeMessage<::substrait::Expression_Literal_List>(Arena*);
template<> ::substrait::Expression_Literal_Map* Arena::CreateMaybeMessage<::substrait::Expression_Literal_Map>(Arena*);
template<> ::substrait::Expression_Literal_Map_KeyValue* Arena::CreateMaybeMessage<::substrait::Expression_Literal_Map_KeyValue>(Arena*);
template<> ::substrait::Expression_Literal_Struct* Arena::CreateMaybeMessage<::substrait::Expression_Literal_Struct>(Arena*);
template<> ::substrait::Expression_Literal_VarChar* Arena::CreateMaybeMessage<::substrait::Expression_Literal_VarChar>(Arena*);
template<> ::substrait::Expression_MaskExpression* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression>(Arena*);
template<> ::substrait::Expression_MaskExpression_ListSelect* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_ListSelect>(Arena*);
template<> ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem>(Arena*);
template<> ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement>(Arena*);
template<> ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice>(Arena*);
template<> ::substrait::Expression_MaskExpression_MapSelect* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_MapSelect>(Arena*);
template<> ::substrait::Expression_MaskExpression_MapSelect_MapKey* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_MapSelect_MapKey>(Arena*);
template<> ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression>(Arena*);
template<> ::substrait::Expression_MaskExpression_Select* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_Select>(Arena*);
template<> ::substrait::Expression_MaskExpression_StructItem* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_StructItem>(Arena*);
template<> ::substrait::Expression_MaskExpression_StructSelect* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_StructSelect>(Arena*);
template<> ::substrait::Expression_MultiOrList* Arena::CreateMaybeMessage<::substrait::Expression_MultiOrList>(Arena*);
template<> ::substrait::Expression_MultiOrList_Record* Arena::CreateMaybeMessage<::substrait::Expression_MultiOrList_Record>(Arena*);
template<> ::substrait::Expression_ReferenceSegment* Arena::CreateMaybeMessage<::substrait::Expression_ReferenceSegment>(Arena*);
template<> ::substrait::Expression_ReferenceSegment_ListElement* Arena::CreateMaybeMessage<::substrait::Expression_ReferenceSegment_ListElement>(Arena*);
template<> ::substrait::Expression_ReferenceSegment_MapKey* Arena::CreateMaybeMessage<::substrait::Expression_ReferenceSegment_MapKey>(Arena*);
template<> ::substrait::Expression_ReferenceSegment_StructField* Arena::CreateMaybeMessage<::substrait::Expression_ReferenceSegment_StructField>(Arena*);
template<> ::substrait::Expression_ScalarFunction* Arena::CreateMaybeMessage<::substrait::Expression_ScalarFunction>(Arena*);
template<> ::substrait::Expression_SingularOrList* Arena::CreateMaybeMessage<::substrait::Expression_SingularOrList>(Arena*);
template<> ::substrait::Expression_SwitchExpression* Arena::CreateMaybeMessage<::substrait::Expression_SwitchExpression>(Arena*);
template<> ::substrait::Expression_SwitchExpression_IfValue* Arena::CreateMaybeMessage<::substrait::Expression_SwitchExpression_IfValue>(Arena*);
template<> ::substrait::Expression_WindowFunction* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction>(Arena*);
template<> ::substrait::Expression_WindowFunction_Bound* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound>(Arena*);
template<> ::substrait::Expression_WindowFunction_Bound_CurrentRow* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound_CurrentRow>(Arena*);
template<> ::substrait::Expression_WindowFunction_Bound_Following* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound_Following>(Arena*);
template<> ::substrait::Expression_WindowFunction_Bound_Preceding* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound_Preceding>(Arena*);
template<> ::substrait::Expression_WindowFunction_Bound_Unbounded* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound_Unbounded>(Arena*);
template<> ::substrait::SortField* Arena::CreateMaybeMessage<::substrait::SortField>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace substrait {

enum SortField_SortDirection : int {
  SortField_SortDirection_SORT_DIRECTION_UNSPECIFIED = 0,
  SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_FIRST = 1,
  SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_LAST = 2,
  SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_FIRST = 3,
  SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_LAST = 4,
  SortField_SortDirection_SORT_DIRECTION_CLUSTERED = 5,
  SortField_SortDirection_SortField_SortDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SortField_SortDirection_SortField_SortDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SortField_SortDirection_IsValid(int value);
constexpr SortField_SortDirection SortField_SortDirection_SortDirection_MIN = SortField_SortDirection_SORT_DIRECTION_UNSPECIFIED;
constexpr SortField_SortDirection SortField_SortDirection_SortDirection_MAX = SortField_SortDirection_SORT_DIRECTION_CLUSTERED;
constexpr int SortField_SortDirection_SortDirection_ARRAYSIZE = SortField_SortDirection_SortDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SortField_SortDirection_descriptor();
template<typename T>
inline const std::string& SortField_SortDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SortField_SortDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SortField_SortDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SortField_SortDirection_descriptor(), enum_t_value);
}
inline bool SortField_SortDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SortField_SortDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SortField_SortDirection>(
    SortField_SortDirection_descriptor(), name, value);
}
enum AggregationPhase : int {
  AGGREGATION_PHASE_UNSPECIFIED = 0,
  AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE = 1,
  AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE = 2,
  AGGREGATION_PHASE_INITIAL_TO_RESULT = 3,
  AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT = 4,
  AggregationPhase_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AggregationPhase_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AggregationPhase_IsValid(int value);
constexpr AggregationPhase AggregationPhase_MIN = AGGREGATION_PHASE_UNSPECIFIED;
constexpr AggregationPhase AggregationPhase_MAX = AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT;
constexpr int AggregationPhase_ARRAYSIZE = AggregationPhase_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AggregationPhase_descriptor();
template<typename T>
inline const std::string& AggregationPhase_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AggregationPhase>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AggregationPhase_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AggregationPhase_descriptor(), enum_t_value);
}
inline bool AggregationPhase_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AggregationPhase* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AggregationPhase>(
    AggregationPhase_descriptor(), name, value);
}
// ===================================================================

class Expression_Enum_Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:substrait.Expression.Enum.Empty) */ {
 public:
  inline Expression_Enum_Empty() : Expression_Enum_Empty(nullptr) {}
  explicit constexpr Expression_Enum_Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Enum_Empty(const Expression_Enum_Empty& from);
  Expression_Enum_Empty(Expression_Enum_Empty&& from) noexcept
    : Expression_Enum_Empty() {
    *this = ::std::move(from);
  }

  inline Expression_Enum_Empty& operator=(const Expression_Enum_Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Enum_Empty& operator=(Expression_Enum_Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Enum_Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_Enum_Empty* internal_default_instance() {
    return reinterpret_cast<const Expression_Enum_Empty*>(
               &_Expression_Enum_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Expression_Enum_Empty& a, Expression_Enum_Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Enum_Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Enum_Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Enum_Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Enum_Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Expression_Enum_Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Expression_Enum_Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Enum.Empty";
  }
  protected:
  explicit Expression_Enum_Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.Expression.Enum.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Enum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Enum) */ {
 public:
  inline Expression_Enum() : Expression_Enum(nullptr) {}
  ~Expression_Enum() override;
  explicit constexpr Expression_Enum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Enum(const Expression_Enum& from);
  Expression_Enum(Expression_Enum&& from) noexcept
    : Expression_Enum() {
    *this = ::std::move(from);
  }

  inline Expression_Enum& operator=(const Expression_Enum& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Enum& operator=(Expression_Enum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Enum& default_instance() {
    return *internal_default_instance();
  }
  enum EnumKindCase {
    kSpecified = 1,
    kUnspecified = 2,
    ENUM_KIND_NOT_SET = 0,
  };

  static inline const Expression_Enum* internal_default_instance() {
    return reinterpret_cast<const Expression_Enum*>(
               &_Expression_Enum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Expression_Enum& a, Expression_Enum& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Enum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Enum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Enum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Enum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Enum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Enum& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Enum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Enum";
  }
  protected:
  explicit Expression_Enum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Enum_Empty Empty;

  // accessors -------------------------------------------------------

  enum : int {
    kSpecifiedFieldNumber = 1,
    kUnspecifiedFieldNumber = 2,
  };
  // string specified = 1 [json_name = "specified"];
  bool has_specified() const;
  private:
  bool _internal_has_specified() const;
  public:
  void clear_specified();
  const std::string& specified() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_specified(ArgT0&& arg0, ArgT... args);
  std::string* mutable_specified();
  PROTOBUF_NODISCARD std::string* release_specified();
  void set_allocated_specified(std::string* specified);
  private:
  const std::string& _internal_specified() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_specified(const std::string& value);
  std::string* _internal_mutable_specified();
  public:

  // .substrait.Expression.Enum.Empty unspecified = 2 [json_name = "unspecified"];
  bool has_unspecified() const;
  private:
  bool _internal_has_unspecified() const;
  public:
  void clear_unspecified();
  const ::substrait::Expression_Enum_Empty& unspecified() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Enum_Empty* release_unspecified();
  ::substrait::Expression_Enum_Empty* mutable_unspecified();
  void set_allocated_unspecified(::substrait::Expression_Enum_Empty* unspecified);
  private:
  const ::substrait::Expression_Enum_Empty& _internal_unspecified() const;
  ::substrait::Expression_Enum_Empty* _internal_mutable_unspecified();
  public:
  void unsafe_arena_set_allocated_unspecified(
      ::substrait::Expression_Enum_Empty* unspecified);
  ::substrait::Expression_Enum_Empty* unsafe_arena_release_unspecified();

  void clear_enum_kind();
  EnumKindCase enum_kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Enum)
 private:
  class _Internal;
  void set_has_specified();
  void set_has_unspecified();

  inline bool has_enum_kind() const;
  inline void clear_has_enum_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EnumKindUnion {
    constexpr EnumKindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr specified_;
    ::substrait::Expression_Enum_Empty* unspecified_;
  } enum_kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Literal_VarChar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.VarChar) */ {
 public:
  inline Expression_Literal_VarChar() : Expression_Literal_VarChar(nullptr) {}
  ~Expression_Literal_VarChar() override;
  explicit constexpr Expression_Literal_VarChar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Literal_VarChar(const Expression_Literal_VarChar& from);
  Expression_Literal_VarChar(Expression_Literal_VarChar&& from) noexcept
    : Expression_Literal_VarChar() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_VarChar& operator=(const Expression_Literal_VarChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_VarChar& operator=(Expression_Literal_VarChar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_VarChar& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_Literal_VarChar* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_VarChar*>(
               &_Expression_Literal_VarChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Expression_Literal_VarChar& a, Expression_Literal_VarChar& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Literal_VarChar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_VarChar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_VarChar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Literal_VarChar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_VarChar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_VarChar& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_VarChar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Literal.VarChar";
  }
  protected:
  explicit Expression_Literal_VarChar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kLengthFieldNumber = 2,
  };
  // string value = 1 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint32 length = 2 [json_name = "length"];
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.VarChar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  uint32_t length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Literal_Decimal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Decimal) */ {
 public:
  inline Expression_Literal_Decimal() : Expression_Literal_Decimal(nullptr) {}
  ~Expression_Literal_Decimal() override;
  explicit constexpr Expression_Literal_Decimal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Literal_Decimal(const Expression_Literal_Decimal& from);
  Expression_Literal_Decimal(Expression_Literal_Decimal&& from) noexcept
    : Expression_Literal_Decimal() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_Decimal& operator=(const Expression_Literal_Decimal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_Decimal& operator=(Expression_Literal_Decimal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_Decimal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_Literal_Decimal* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_Decimal*>(
               &_Expression_Literal_Decimal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Expression_Literal_Decimal& a, Expression_Literal_Decimal& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Literal_Decimal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_Decimal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_Decimal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Literal_Decimal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_Decimal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_Decimal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_Decimal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Literal.Decimal";
  }
  protected:
  explicit Expression_Literal_Decimal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kPrecisionFieldNumber = 2,
    kScaleFieldNumber = 3,
  };
  // bytes value = 1 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // int32 precision = 2 [json_name = "precision"];
  void clear_precision();
  int32_t precision() const;
  void set_precision(int32_t value);
  private:
  int32_t _internal_precision() const;
  void _internal_set_precision(int32_t value);
  public:

  // int32 scale = 3 [json_name = "scale"];
  void clear_scale();
  int32_t scale() const;
  void set_scale(int32_t value);
  private:
  int32_t _internal_scale() const;
  void _internal_set_scale(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Decimal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int32_t precision_;
  int32_t scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Literal_Map_KeyValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Map.KeyValue) */ {
 public:
  inline Expression_Literal_Map_KeyValue() : Expression_Literal_Map_KeyValue(nullptr) {}
  ~Expression_Literal_Map_KeyValue() override;
  explicit constexpr Expression_Literal_Map_KeyValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Literal_Map_KeyValue(const Expression_Literal_Map_KeyValue& from);
  Expression_Literal_Map_KeyValue(Expression_Literal_Map_KeyValue&& from) noexcept
    : Expression_Literal_Map_KeyValue() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_Map_KeyValue& operator=(const Expression_Literal_Map_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_Map_KeyValue& operator=(Expression_Literal_Map_KeyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_Map_KeyValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_Literal_Map_KeyValue* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_Map_KeyValue*>(
               &_Expression_Literal_Map_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Expression_Literal_Map_KeyValue& a, Expression_Literal_Map_KeyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Literal_Map_KeyValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_Map_KeyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_Map_KeyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Literal_Map_KeyValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_Map_KeyValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_Map_KeyValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_Map_KeyValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Literal.Map.KeyValue";
  }
  protected:
  explicit Expression_Literal_Map_KeyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .substrait.Expression.Literal key = 1 [json_name = "key"];
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::substrait::Expression_Literal& key() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal* release_key();
  ::substrait::Expression_Literal* mutable_key();
  void set_allocated_key(::substrait::Expression_Literal* key);
  private:
  const ::substrait::Expression_Literal& _internal_key() const;
  ::substrait::Expression_Literal* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::substrait::Expression_Literal* key);
  ::substrait::Expression_Literal* unsafe_arena_release_key();

  // .substrait.Expression.Literal value = 2 [json_name = "value"];
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::substrait::Expression_Literal& value() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal* release_value();
  ::substrait::Expression_Literal* mutable_value();
  void set_allocated_value(::substrait::Expression_Literal* value);
  private:
  const ::substrait::Expression_Literal& _internal_value() const;
  ::substrait::Expression_Literal* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::substrait::Expression_Literal* value);
  ::substrait::Expression_Literal* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Map.KeyValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Expression_Literal* key_;
  ::substrait::Expression_Literal* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Literal_Map final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Map) */ {
 public:
  inline Expression_Literal_Map() : Expression_Literal_Map(nullptr) {}
  ~Expression_Literal_Map() override;
  explicit constexpr Expression_Literal_Map(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Literal_Map(const Expression_Literal_Map& from);
  Expression_Literal_Map(Expression_Literal_Map&& from) noexcept
    : Expression_Literal_Map() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_Map& operator=(const Expression_Literal_Map& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_Map& operator=(Expression_Literal_Map&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_Map& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_Literal_Map* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_Map*>(
               &_Expression_Literal_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Expression_Literal_Map& a, Expression_Literal_Map& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Literal_Map* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_Map* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_Map* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Literal_Map>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_Map& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_Map& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_Map* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Literal.Map";
  }
  protected:
  explicit Expression_Literal_Map(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Literal_Map_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  enum : int {
    kKeyValuesFieldNumber = 1,
  };
  // repeated .substrait.Expression.Literal.Map.KeyValue key_values = 1 [json_name = "keyValues"];
  int key_values_size() const;
  private:
  int _internal_key_values_size() const;
  public:
  void clear_key_values();
  ::substrait::Expression_Literal_Map_KeyValue* mutable_key_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue >*
      mutable_key_values();
  private:
  const ::substrait::Expression_Literal_Map_KeyValue& _internal_key_values(int index) const;
  ::substrait::Expression_Literal_Map_KeyValue* _internal_add_key_values();
  public:
  const ::substrait::Expression_Literal_Map_KeyValue& key_values(int index) const;
  ::substrait::Expression_Literal_Map_KeyValue* add_key_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue >&
      key_values() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Map)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue > key_values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Literal_IntervalYearToMonth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.IntervalYearToMonth) */ {
 public:
  inline Expression_Literal_IntervalYearToMonth() : Expression_Literal_IntervalYearToMonth(nullptr) {}
  ~Expression_Literal_IntervalYearToMonth() override;
  explicit constexpr Expression_Literal_IntervalYearToMonth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Literal_IntervalYearToMonth(const Expression_Literal_IntervalYearToMonth& from);
  Expression_Literal_IntervalYearToMonth(Expression_Literal_IntervalYearToMonth&& from) noexcept
    : Expression_Literal_IntervalYearToMonth() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_IntervalYearToMonth& operator=(const Expression_Literal_IntervalYearToMonth& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_IntervalYearToMonth& operator=(Expression_Literal_IntervalYearToMonth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_IntervalYearToMonth& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_Literal_IntervalYearToMonth* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_IntervalYearToMonth*>(
               &_Expression_Literal_IntervalYearToMonth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Expression_Literal_IntervalYearToMonth& a, Expression_Literal_IntervalYearToMonth& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Literal_IntervalYearToMonth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_IntervalYearToMonth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_IntervalYearToMonth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Literal_IntervalYearToMonth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_IntervalYearToMonth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_IntervalYearToMonth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_IntervalYearToMonth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Literal.IntervalYearToMonth";
  }
  protected:
  explicit Expression_Literal_IntervalYearToMonth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYearsFieldNumber = 1,
    kMonthsFieldNumber = 2,
  };
  // int32 years = 1 [json_name = "years"];
  void clear_years();
  int32_t years() const;
  void set_years(int32_t value);
  private:
  int32_t _internal_years() const;
  void _internal_set_years(int32_t value);
  public:

  // int32 months = 2 [json_name = "months"];
  void clear_months();
  int32_t months() const;
  void set_months(int32_t value);
  private:
  int32_t _internal_months() const;
  void _internal_set_months(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.IntervalYearToMonth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t years_;
  int32_t months_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Literal_IntervalDayToSecond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.IntervalDayToSecond) */ {
 public:
  inline Expression_Literal_IntervalDayToSecond() : Expression_Literal_IntervalDayToSecond(nullptr) {}
  ~Expression_Literal_IntervalDayToSecond() override;
  explicit constexpr Expression_Literal_IntervalDayToSecond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Literal_IntervalDayToSecond(const Expression_Literal_IntervalDayToSecond& from);
  Expression_Literal_IntervalDayToSecond(Expression_Literal_IntervalDayToSecond&& from) noexcept
    : Expression_Literal_IntervalDayToSecond() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_IntervalDayToSecond& operator=(const Expression_Literal_IntervalDayToSecond& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_IntervalDayToSecond& operator=(Expression_Literal_IntervalDayToSecond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_IntervalDayToSecond& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_Literal_IntervalDayToSecond* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_IntervalDayToSecond*>(
               &_Expression_Literal_IntervalDayToSecond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Expression_Literal_IntervalDayToSecond& a, Expression_Literal_IntervalDayToSecond& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Literal_IntervalDayToSecond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_IntervalDayToSecond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_IntervalDayToSecond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Literal_IntervalDayToSecond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_IntervalDayToSecond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_IntervalDayToSecond& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_IntervalDayToSecond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Literal.IntervalDayToSecond";
  }
  protected:
  explicit Expression_Literal_IntervalDayToSecond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDaysFieldNumber = 1,
    kSecondsFieldNumber = 2,
  };
  // int32 days = 1 [json_name = "days"];
  void clear_days();
  int32_t days() const;
  void set_days(int32_t value);
  private:
  int32_t _internal_days() const;
  void _internal_set_days(int32_t value);
  public:

  // int32 seconds = 2 [json_name = "seconds"];
  void clear_seconds();
  int32_t seconds() const;
  void set_seconds(int32_t value);
  private:
  int32_t _internal_seconds() const;
  void _internal_set_seconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.IntervalDayToSecond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t days_;
  int32_t seconds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Literal_Struct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Struct) */ {
 public:
  inline Expression_Literal_Struct() : Expression_Literal_Struct(nullptr) {}
  ~Expression_Literal_Struct() override;
  explicit constexpr Expression_Literal_Struct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Literal_Struct(const Expression_Literal_Struct& from);
  Expression_Literal_Struct(Expression_Literal_Struct&& from) noexcept
    : Expression_Literal_Struct() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_Struct& operator=(const Expression_Literal_Struct& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_Struct& operator=(Expression_Literal_Struct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_Struct& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_Literal_Struct* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_Struct*>(
               &_Expression_Literal_Struct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Expression_Literal_Struct& a, Expression_Literal_Struct& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Literal_Struct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_Struct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_Struct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Literal_Struct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_Struct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_Struct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_Struct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Literal.Struct";
  }
  protected:
  explicit Expression_Literal_Struct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .substrait.Expression.Literal fields = 1 [json_name = "fields"];
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::substrait::Expression_Literal* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal >*
      mutable_fields();
  private:
  const ::substrait::Expression_Literal& _internal_fields(int index) const;
  ::substrait::Expression_Literal* _internal_add_fields();
  public:
  const ::substrait::Expression_Literal& fields(int index) const;
  ::substrait::Expression_Literal* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal >&
      fields() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Struct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal > fields_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Literal_List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.List) */ {
 public:
  inline Expression_Literal_List() : Expression_Literal_List(nullptr) {}
  ~Expression_Literal_List() override;
  explicit constexpr Expression_Literal_List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Literal_List(const Expression_Literal_List& from);
  Expression_Literal_List(Expression_Literal_List&& from) noexcept
    : Expression_Literal_List() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_List& operator=(const Expression_Literal_List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_List& operator=(Expression_Literal_List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_Literal_List* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_List*>(
               &_Expression_Literal_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Expression_Literal_List& a, Expression_Literal_List& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Literal_List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Literal_List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_List& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Literal.List";
  }
  protected:
  explicit Expression_Literal_List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .substrait.Expression.Literal values = 1 [json_name = "values"];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::substrait::Expression_Literal* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal >*
      mutable_values();
  private:
  const ::substrait::Expression_Literal& _internal_values(int index) const;
  ::substrait::Expression_Literal* _internal_add_values();
  public:
  const ::substrait::Expression_Literal& values(int index) const;
  ::substrait::Expression_Literal* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal >&
      values() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Literal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal) */ {
 public:
  inline Expression_Literal() : Expression_Literal(nullptr) {}
  ~Expression_Literal() override;
  explicit constexpr Expression_Literal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Literal(const Expression_Literal& from);
  Expression_Literal(Expression_Literal&& from) noexcept
    : Expression_Literal() {
    *this = ::std::move(from);
  }

  inline Expression_Literal& operator=(const Expression_Literal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal& operator=(Expression_Literal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal& default_instance() {
    return *internal_default_instance();
  }
  enum LiteralTypeCase {
    kBoolean = 1,
    kI8 = 2,
    kI16 = 3,
    kI32 = 5,
    kI64 = 7,
    kFp32 = 10,
    kFp64 = 11,
    kString = 12,
    kBinary = 13,
    kTimestamp = 14,
    kDate = 16,
    kTime = 17,
    kIntervalYearToMonth = 19,
    kIntervalDayToSecond = 20,
    kFixedChar = 21,
    kVarChar = 22,
    kFixedBinary = 23,
    kDecimal = 24,
    kStruct = 25,
    kMap = 26,
    kTimestampTz = 27,
    kUuid = 28,
    kNull = 29,
    kList = 30,
    kEmptyList = 31,
    kEmptyMap = 32,
    LITERAL_TYPE_NOT_SET = 0,
  };

  static inline const Expression_Literal* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal*>(
               &_Expression_Literal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Expression_Literal& a, Expression_Literal& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Literal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Literal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Literal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Literal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Literal";
  }
  protected:
  explicit Expression_Literal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Literal_VarChar VarChar;
  typedef Expression_Literal_Decimal Decimal;
  typedef Expression_Literal_Map Map;
  typedef Expression_Literal_IntervalYearToMonth IntervalYearToMonth;
  typedef Expression_Literal_IntervalDayToSecond IntervalDayToSecond;
  typedef Expression_Literal_Struct Struct;
  typedef Expression_Literal_List List;

  // accessors -------------------------------------------------------

  enum : int {
    kNullableFieldNumber = 50,
    kBooleanFieldNumber = 1,
    kI8FieldNumber = 2,
    kI16FieldNumber = 3,
    kI32FieldNumber = 5,
    kI64FieldNumber = 7,
    kFp32FieldNumber = 10,
    kFp64FieldNumber = 11,
    kStringFieldNumber = 12,
    kBinaryFieldNumber = 13,
    kTimestampFieldNumber = 14,
    kDateFieldNumber = 16,
    kTimeFieldNumber = 17,
    kIntervalYearToMonthFieldNumber = 19,
    kIntervalDayToSecondFieldNumber = 20,
    kFixedCharFieldNumber = 21,
    kVarCharFieldNumber = 22,
    kFixedBinaryFieldNumber = 23,
    kDecimalFieldNumber = 24,
    kStructFieldNumber = 25,
    kMapFieldNumber = 26,
    kTimestampTzFieldNumber = 27,
    kUuidFieldNumber = 28,
    kNullFieldNumber = 29,
    kListFieldNumber = 30,
    kEmptyListFieldNumber = 31,
    kEmptyMapFieldNumber = 32,
  };
  // bool nullable = 50 [json_name = "nullable"];
  void clear_nullable();
  bool nullable() const;
  void set_nullable(bool value);
  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);
  public:

  // bool boolean = 1 [json_name = "boolean"];
  bool has_boolean() const;
  private:
  bool _internal_has_boolean() const;
  public:
  void clear_boolean();
  bool boolean() const;
  void set_boolean(bool value);
  private:
  bool _internal_boolean() const;
  void _internal_set_boolean(bool value);
  public:

  // int32 i8 = 2 [json_name = "i8"];
  bool has_i8() const;
  private:
  bool _internal_has_i8() const;
  public:
  void clear_i8();
  int32_t i8() const;
  void set_i8(int32_t value);
  private:
  int32_t _internal_i8() const;
  void _internal_set_i8(int32_t value);
  public:

  // int32 i16 = 3 [json_name = "i16"];
  bool has_i16() const;
  private:
  bool _internal_has_i16() const;
  public:
  void clear_i16();
  int32_t i16() const;
  void set_i16(int32_t value);
  private:
  int32_t _internal_i16() const;
  void _internal_set_i16(int32_t value);
  public:

  // int32 i32 = 5 [json_name = "i32"];
  bool has_i32() const;
  private:
  bool _internal_has_i32() const;
  public:
  void clear_i32();
  int32_t i32() const;
  void set_i32(int32_t value);
  private:
  int32_t _internal_i32() const;
  void _internal_set_i32(int32_t value);
  public:

  // int64 i64 = 7 [json_name = "i64"];
  bool has_i64() const;
  private:
  bool _internal_has_i64() const;
  public:
  void clear_i64();
  int64_t i64() const;
  void set_i64(int64_t value);
  private:
  int64_t _internal_i64() const;
  void _internal_set_i64(int64_t value);
  public:

  // float fp32 = 10 [json_name = "fp32"];
  bool has_fp32() const;
  private:
  bool _internal_has_fp32() const;
  public:
  void clear_fp32();
  float fp32() const;
  void set_fp32(float value);
  private:
  float _internal_fp32() const;
  void _internal_set_fp32(float value);
  public:

  // double fp64 = 11 [json_name = "fp64"];
  bool has_fp64() const;
  private:
  bool _internal_has_fp64() const;
  public:
  void clear_fp64();
  double fp64() const;
  void set_fp64(double value);
  private:
  double _internal_fp64() const;
  void _internal_set_fp64(double value);
  public:

  // string string = 12 [json_name = "string"];
  bool has_string() const;
  private:
  bool _internal_has_string() const;
  public:
  void clear_string();
  const std::string& string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string();
  PROTOBUF_NODISCARD std::string* release_string();
  void set_allocated_string(std::string* string);
  private:
  const std::string& _internal_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string(const std::string& value);
  std::string* _internal_mutable_string();
  public:

  // bytes binary = 13 [json_name = "binary"];
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;
  public:
  void clear_binary();
  const std::string& binary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary();
  PROTOBUF_NODISCARD std::string* release_binary();
  void set_allocated_binary(std::string* binary);
  private:
  const std::string& _internal_binary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary(const std::string& value);
  std::string* _internal_mutable_binary();
  public:

  // int64 timestamp = 14 [json_name = "timestamp"];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 date = 16 [json_name = "date"];
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  int32_t date() const;
  void set_date(int32_t value);
  private:
  int32_t _internal_date() const;
  void _internal_set_date(int32_t value);
  public:

  // int64 time = 17 [json_name = "time"];
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // .substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 19 [json_name = "intervalYearToMonth"];
  bool has_interval_year_to_month() const;
  private:
  bool _internal_has_interval_year_to_month() const;
  public:
  void clear_interval_year_to_month();
  const ::substrait::Expression_Literal_IntervalYearToMonth& interval_year_to_month() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal_IntervalYearToMonth* release_interval_year_to_month();
  ::substrait::Expression_Literal_IntervalYearToMonth* mutable_interval_year_to_month();
  void set_allocated_interval_year_to_month(::substrait::Expression_Literal_IntervalYearToMonth* interval_year_to_month);
  private:
  const ::substrait::Expression_Literal_IntervalYearToMonth& _internal_interval_year_to_month() const;
  ::substrait::Expression_Literal_IntervalYearToMonth* _internal_mutable_interval_year_to_month();
  public:
  void unsafe_arena_set_allocated_interval_year_to_month(
      ::substrait::Expression_Literal_IntervalYearToMonth* interval_year_to_month);
  ::substrait::Expression_Literal_IntervalYearToMonth* unsafe_arena_release_interval_year_to_month();

  // .substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 20 [json_name = "intervalDayToSecond"];
  bool has_interval_day_to_second() const;
  private:
  bool _internal_has_interval_day_to_second() const;
  public:
  void clear_interval_day_to_second();
  const ::substrait::Expression_Literal_IntervalDayToSecond& interval_day_to_second() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal_IntervalDayToSecond* release_interval_day_to_second();
  ::substrait::Expression_Literal_IntervalDayToSecond* mutable_interval_day_to_second();
  void set_allocated_interval_day_to_second(::substrait::Expression_Literal_IntervalDayToSecond* interval_day_to_second);
  private:
  const ::substrait::Expression_Literal_IntervalDayToSecond& _internal_interval_day_to_second() const;
  ::substrait::Expression_Literal_IntervalDayToSecond* _internal_mutable_interval_day_to_second();
  public:
  void unsafe_arena_set_allocated_interval_day_to_second(
      ::substrait::Expression_Literal_IntervalDayToSecond* interval_day_to_second);
  ::substrait::Expression_Literal_IntervalDayToSecond* unsafe_arena_release_interval_day_to_second();

  // string fixed_char = 21 [json_name = "fixedChar"];
  bool has_fixed_char() const;
  private:
  bool _internal_has_fixed_char() const;
  public:
  void clear_fixed_char();
  const std::string& fixed_char() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fixed_char(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fixed_char();
  PROTOBUF_NODISCARD std::string* release_fixed_char();
  void set_allocated_fixed_char(std::string* fixed_char);
  private:
  const std::string& _internal_fixed_char() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fixed_char(const std::string& value);
  std::string* _internal_mutable_fixed_char();
  public:

  // .substrait.Expression.Literal.VarChar var_char = 22 [json_name = "varChar"];
  bool has_var_char() const;
  private:
  bool _internal_has_var_char() const;
  public:
  void clear_var_char();
  const ::substrait::Expression_Literal_VarChar& var_char() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal_VarChar* release_var_char();
  ::substrait::Expression_Literal_VarChar* mutable_var_char();
  void set_allocated_var_char(::substrait::Expression_Literal_VarChar* var_char);
  private:
  const ::substrait::Expression_Literal_VarChar& _internal_var_char() const;
  ::substrait::Expression_Literal_VarChar* _internal_mutable_var_char();
  public:
  void unsafe_arena_set_allocated_var_char(
      ::substrait::Expression_Literal_VarChar* var_char);
  ::substrait::Expression_Literal_VarChar* unsafe_arena_release_var_char();

  // bytes fixed_binary = 23 [json_name = "fixedBinary"];
  bool has_fixed_binary() const;
  private:
  bool _internal_has_fixed_binary() const;
  public:
  void clear_fixed_binary();
  const std::string& fixed_binary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fixed_binary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fixed_binary();
  PROTOBUF_NODISCARD std::string* release_fixed_binary();
  void set_allocated_fixed_binary(std::string* fixed_binary);
  private:
  const std::string& _internal_fixed_binary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fixed_binary(const std::string& value);
  std::string* _internal_mutable_fixed_binary();
  public:

  // .substrait.Expression.Literal.Decimal decimal = 24 [json_name = "decimal"];
  bool has_decimal() const;
  private:
  bool _internal_has_decimal() const;
  public:
  void clear_decimal();
  const ::substrait::Expression_Literal_Decimal& decimal() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal_Decimal* release_decimal();
  ::substrait::Expression_Literal_Decimal* mutable_decimal();
  void set_allocated_decimal(::substrait::Expression_Literal_Decimal* decimal);
  private:
  const ::substrait::Expression_Literal_Decimal& _internal_decimal() const;
  ::substrait::Expression_Literal_Decimal* _internal_mutable_decimal();
  public:
  void unsafe_arena_set_allocated_decimal(
      ::substrait::Expression_Literal_Decimal* decimal);
  ::substrait::Expression_Literal_Decimal* unsafe_arena_release_decimal();

  // .substrait.Expression.Literal.Struct struct = 25 [json_name = "struct"];
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;
  public:
  void clear_struct_();
  const ::substrait::Expression_Literal_Struct& struct_() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal_Struct* release_struct_();
  ::substrait::Expression_Literal_Struct* mutable_struct_();
  void set_allocated_struct_(::substrait::Expression_Literal_Struct* struct_);
  private:
  const ::substrait::Expression_Literal_Struct& _internal_struct_() const;
  ::substrait::Expression_Literal_Struct* _internal_mutable_struct_();
  public:
  void unsafe_arena_set_allocated_struct_(
      ::substrait::Expression_Literal_Struct* struct_);
  ::substrait::Expression_Literal_Struct* unsafe_arena_release_struct_();

  // .substrait.Expression.Literal.Map map = 26 [json_name = "map"];
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::substrait::Expression_Literal_Map& map() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal_Map* release_map();
  ::substrait::Expression_Literal_Map* mutable_map();
  void set_allocated_map(::substrait::Expression_Literal_Map* map);
  private:
  const ::substrait::Expression_Literal_Map& _internal_map() const;
  ::substrait::Expression_Literal_Map* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::substrait::Expression_Literal_Map* map);
  ::substrait::Expression_Literal_Map* unsafe_arena_release_map();

  // int64 timestamp_tz = 27 [json_name = "timestampTz"];
  bool has_timestamp_tz() const;
  private:
  bool _internal_has_timestamp_tz() const;
  public:
  void clear_timestamp_tz();
  int64_t timestamp_tz() const;
  void set_timestamp_tz(int64_t value);
  private:
  int64_t _internal_timestamp_tz() const;
  void _internal_set_timestamp_tz(int64_t value);
  public:

  // bytes uuid = 28 [json_name = "uuid"];
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .substrait.Type null = 29 [json_name = "null"];
  bool has_null() const;
  private:
  bool _internal_has_null() const;
  public:
  void clear_null();
  const ::substrait::Type& null() const;
  PROTOBUF_NODISCARD ::substrait::Type* release_null();
  ::substrait::Type* mutable_null();
  void set_allocated_null(::substrait::Type* null);
  private:
  const ::substrait::Type& _internal_null() const;
  ::substrait::Type* _internal_mutable_null();
  public:
  void unsafe_arena_set_allocated_null(
      ::substrait::Type* null);
  ::substrait::Type* unsafe_arena_release_null();

  // .substrait.Expression.Literal.List list = 30 [json_name = "list"];
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::substrait::Expression_Literal_List& list() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal_List* release_list();
  ::substrait::Expression_Literal_List* mutable_list();
  void set_allocated_list(::substrait::Expression_Literal_List* list);
  private:
  const ::substrait::Expression_Literal_List& _internal_list() const;
  ::substrait::Expression_Literal_List* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::substrait::Expression_Literal_List* list);
  ::substrait::Expression_Literal_List* unsafe_arena_release_list();

  // .substrait.Type.List empty_list = 31 [json_name = "emptyList"];
  bool has_empty_list() const;
  private:
  bool _internal_has_empty_list() const;
  public:
  void clear_empty_list();
  const ::substrait::Type_List& empty_list() const;
  PROTOBUF_NODISCARD ::substrait::Type_List* release_empty_list();
  ::substrait::Type_List* mutable_empty_list();
  void set_allocated_empty_list(::substrait::Type_List* empty_list);
  private:
  const ::substrait::Type_List& _internal_empty_list() const;
  ::substrait::Type_List* _internal_mutable_empty_list();
  public:
  void unsafe_arena_set_allocated_empty_list(
      ::substrait::Type_List* empty_list);
  ::substrait::Type_List* unsafe_arena_release_empty_list();

  // .substrait.Type.Map empty_map = 32 [json_name = "emptyMap"];
  bool has_empty_map() const;
  private:
  bool _internal_has_empty_map() const;
  public:
  void clear_empty_map();
  const ::substrait::Type_Map& empty_map() const;
  PROTOBUF_NODISCARD ::substrait::Type_Map* release_empty_map();
  ::substrait::Type_Map* mutable_empty_map();
  void set_allocated_empty_map(::substrait::Type_Map* empty_map);
  private:
  const ::substrait::Type_Map& _internal_empty_map() const;
  ::substrait::Type_Map* _internal_mutable_empty_map();
  public:
  void unsafe_arena_set_allocated_empty_map(
      ::substrait::Type_Map* empty_map);
  ::substrait::Type_Map* unsafe_arena_release_empty_map();

  void clear_literal_type();
  LiteralTypeCase literal_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal)
 private:
  class _Internal;
  void set_has_boolean();
  void set_has_i8();
  void set_has_i16();
  void set_has_i32();
  void set_has_i64();
  void set_has_fp32();
  void set_has_fp64();
  void set_has_string();
  void set_has_binary();
  void set_has_timestamp();
  void set_has_date();
  void set_has_time();
  void set_has_interval_year_to_month();
  void set_has_interval_day_to_second();
  void set_has_fixed_char();
  void set_has_var_char();
  void set_has_fixed_binary();
  void set_has_decimal();
  void set_has_struct_();
  void set_has_map();
  void set_has_timestamp_tz();
  void set_has_uuid();
  void set_has_null();
  void set_has_list();
  void set_has_empty_list();
  void set_has_empty_map();

  inline bool has_literal_type() const;
  inline void clear_has_literal_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool nullable_;
  union LiteralTypeUnion {
    constexpr LiteralTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool boolean_;
    int32_t i8_;
    int32_t i16_;
    int32_t i32_;
    int64_t i64_;
    float fp32_;
    double fp64_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_;
    int64_t timestamp_;
    int32_t date_;
    int64_t time_;
    ::substrait::Expression_Literal_IntervalYearToMonth* interval_year_to_month_;
    ::substrait::Expression_Literal_IntervalDayToSecond* interval_day_to_second_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fixed_char_;
    ::substrait::Expression_Literal_VarChar* var_char_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fixed_binary_;
    ::substrait::Expression_Literal_Decimal* decimal_;
    ::substrait::Expression_Literal_Struct* struct__;
    ::substrait::Expression_Literal_Map* map_;
    int64_t timestamp_tz_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::substrait::Type* null_;
    ::substrait::Expression_Literal_List* list_;
    ::substrait::Type_List* empty_list_;
    ::substrait::Type_Map* empty_map_;
  } literal_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_ScalarFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.ScalarFunction) */ {
 public:
  inline Expression_ScalarFunction() : Expression_ScalarFunction(nullptr) {}
  ~Expression_ScalarFunction() override;
  explicit constexpr Expression_ScalarFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_ScalarFunction(const Expression_ScalarFunction& from);
  Expression_ScalarFunction(Expression_ScalarFunction&& from) noexcept
    : Expression_ScalarFunction() {
    *this = ::std::move(from);
  }

  inline Expression_ScalarFunction& operator=(const Expression_ScalarFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_ScalarFunction& operator=(Expression_ScalarFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_ScalarFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_ScalarFunction* internal_default_instance() {
    return reinterpret_cast<const Expression_ScalarFunction*>(
               &_Expression_ScalarFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Expression_ScalarFunction& a, Expression_ScalarFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_ScalarFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_ScalarFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_ScalarFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_ScalarFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_ScalarFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_ScalarFunction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_ScalarFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.ScalarFunction";
  }
  protected:
  explicit Expression_ScalarFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kOutputTypeFieldNumber = 3,
    kFunctionReferenceFieldNumber = 1,
  };
  // repeated .substrait.Expression args = 2 [json_name = "args"];
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::substrait::Expression* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
      mutable_args();
  private:
  const ::substrait::Expression& _internal_args(int index) const;
  ::substrait::Expression* _internal_add_args();
  public:
  const ::substrait::Expression& args(int index) const;
  ::substrait::Expression* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
      args() const;

  // .substrait.Type output_type = 3 [json_name = "outputType"];
  bool has_output_type() const;
  private:
  bool _internal_has_output_type() const;
  public:
  void clear_output_type();
  const ::substrait::Type& output_type() const;
  PROTOBUF_NODISCARD ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* output_type);
  private:
  const ::substrait::Type& _internal_output_type() const;
  ::substrait::Type* _internal_mutable_output_type();
  public:
  void unsafe_arena_set_allocated_output_type(
      ::substrait::Type* output_type);
  ::substrait::Type* unsafe_arena_release_output_type();

  // uint32 function_reference = 1 [json_name = "functionReference"];
  void clear_function_reference();
  uint32_t function_reference() const;
  void set_function_reference(uint32_t value);
  private:
  uint32_t _internal_function_reference() const;
  void _internal_set_function_reference(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.ScalarFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression > args_;
  ::substrait::Type* output_type_;
  uint32_t function_reference_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_Preceding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.Preceding) */ {
 public:
  inline Expression_WindowFunction_Bound_Preceding() : Expression_WindowFunction_Bound_Preceding(nullptr) {}
  ~Expression_WindowFunction_Bound_Preceding() override;
  explicit constexpr Expression_WindowFunction_Bound_Preceding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_WindowFunction_Bound_Preceding(const Expression_WindowFunction_Bound_Preceding& from);
  Expression_WindowFunction_Bound_Preceding(Expression_WindowFunction_Bound_Preceding&& from) noexcept
    : Expression_WindowFunction_Bound_Preceding() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction_Bound_Preceding& operator=(const Expression_WindowFunction_Bound_Preceding& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction_Bound_Preceding& operator=(Expression_WindowFunction_Bound_Preceding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction_Bound_Preceding& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_WindowFunction_Bound_Preceding* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction_Bound_Preceding*>(
               &_Expression_WindowFunction_Bound_Preceding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Expression_WindowFunction_Bound_Preceding& a, Expression_WindowFunction_Bound_Preceding& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_WindowFunction_Bound_Preceding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction_Bound_Preceding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction_Bound_Preceding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_Preceding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_WindowFunction_Bound_Preceding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_WindowFunction_Bound_Preceding& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_WindowFunction_Bound_Preceding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.WindowFunction.Bound.Preceding";
  }
  protected:
  explicit Expression_WindowFunction_Bound_Preceding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
  };
  // int64 offset = 1 [json_name = "offset"];
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.Preceding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_Following final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.Following) */ {
 public:
  inline Expression_WindowFunction_Bound_Following() : Expression_WindowFunction_Bound_Following(nullptr) {}
  ~Expression_WindowFunction_Bound_Following() override;
  explicit constexpr Expression_WindowFunction_Bound_Following(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_WindowFunction_Bound_Following(const Expression_WindowFunction_Bound_Following& from);
  Expression_WindowFunction_Bound_Following(Expression_WindowFunction_Bound_Following&& from) noexcept
    : Expression_WindowFunction_Bound_Following() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction_Bound_Following& operator=(const Expression_WindowFunction_Bound_Following& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction_Bound_Following& operator=(Expression_WindowFunction_Bound_Following&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction_Bound_Following& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_WindowFunction_Bound_Following* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction_Bound_Following*>(
               &_Expression_WindowFunction_Bound_Following_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Expression_WindowFunction_Bound_Following& a, Expression_WindowFunction_Bound_Following& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_WindowFunction_Bound_Following* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction_Bound_Following* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction_Bound_Following* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_Following>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_WindowFunction_Bound_Following& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_WindowFunction_Bound_Following& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_WindowFunction_Bound_Following* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.WindowFunction.Bound.Following";
  }
  protected:
  explicit Expression_WindowFunction_Bound_Following(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
  };
  // int64 offset = 1 [json_name = "offset"];
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.Following)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_CurrentRow final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.CurrentRow) */ {
 public:
  inline Expression_WindowFunction_Bound_CurrentRow() : Expression_WindowFunction_Bound_CurrentRow(nullptr) {}
  explicit constexpr Expression_WindowFunction_Bound_CurrentRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_WindowFunction_Bound_CurrentRow(const Expression_WindowFunction_Bound_CurrentRow& from);
  Expression_WindowFunction_Bound_CurrentRow(Expression_WindowFunction_Bound_CurrentRow&& from) noexcept
    : Expression_WindowFunction_Bound_CurrentRow() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction_Bound_CurrentRow& operator=(const Expression_WindowFunction_Bound_CurrentRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction_Bound_CurrentRow& operator=(Expression_WindowFunction_Bound_CurrentRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction_Bound_CurrentRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_WindowFunction_Bound_CurrentRow* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction_Bound_CurrentRow*>(
               &_Expression_WindowFunction_Bound_CurrentRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Expression_WindowFunction_Bound_CurrentRow& a, Expression_WindowFunction_Bound_CurrentRow& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_WindowFunction_Bound_CurrentRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction_Bound_CurrentRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction_Bound_CurrentRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_CurrentRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Expression_WindowFunction_Bound_CurrentRow& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Expression_WindowFunction_Bound_CurrentRow& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.WindowFunction.Bound.CurrentRow";
  }
  protected:
  explicit Expression_WindowFunction_Bound_CurrentRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.CurrentRow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_Unbounded final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.Unbounded) */ {
 public:
  inline Expression_WindowFunction_Bound_Unbounded() : Expression_WindowFunction_Bound_Unbounded(nullptr) {}
  explicit constexpr Expression_WindowFunction_Bound_Unbounded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_WindowFunction_Bound_Unbounded(const Expression_WindowFunction_Bound_Unbounded& from);
  Expression_WindowFunction_Bound_Unbounded(Expression_WindowFunction_Bound_Unbounded&& from) noexcept
    : Expression_WindowFunction_Bound_Unbounded() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction_Bound_Unbounded& operator=(const Expression_WindowFunction_Bound_Unbounded& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction_Bound_Unbounded& operator=(Expression_WindowFunction_Bound_Unbounded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction_Bound_Unbounded& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_WindowFunction_Bound_Unbounded* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction_Bound_Unbounded*>(
               &_Expression_WindowFunction_Bound_Unbounded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Expression_WindowFunction_Bound_Unbounded& a, Expression_WindowFunction_Bound_Unbounded& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_WindowFunction_Bound_Unbounded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction_Bound_Unbounded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction_Bound_Unbounded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_Unbounded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Expression_WindowFunction_Bound_Unbounded& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Expression_WindowFunction_Bound_Unbounded& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.WindowFunction.Bound.Unbounded";
  }
  protected:
  explicit Expression_WindowFunction_Bound_Unbounded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.Unbounded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound) */ {
 public:
  inline Expression_WindowFunction_Bound() : Expression_WindowFunction_Bound(nullptr) {}
  ~Expression_WindowFunction_Bound() override;
  explicit constexpr Expression_WindowFunction_Bound(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_WindowFunction_Bound(const Expression_WindowFunction_Bound& from);
  Expression_WindowFunction_Bound(Expression_WindowFunction_Bound&& from) noexcept
    : Expression_WindowFunction_Bound() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction_Bound& operator=(const Expression_WindowFunction_Bound& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction_Bound& operator=(Expression_WindowFunction_Bound&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction_Bound& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kPreceding = 1,
    kFollowing = 2,
    kCurrentRow = 3,
    kUnbounded = 4,
    KIND_NOT_SET = 0,
  };

  static inline const Expression_WindowFunction_Bound* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction_Bound*>(
               &_Expression_WindowFunction_Bound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Expression_WindowFunction_Bound& a, Expression_WindowFunction_Bound& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_WindowFunction_Bound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction_Bound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction_Bound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_WindowFunction_Bound& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_WindowFunction_Bound& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_WindowFunction_Bound* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.WindowFunction.Bound";
  }
  protected:
  explicit Expression_WindowFunction_Bound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_WindowFunction_Bound_Preceding Preceding;
  typedef Expression_WindowFunction_Bound_Following Following;
  typedef Expression_WindowFunction_Bound_CurrentRow CurrentRow;
  typedef Expression_WindowFunction_Bound_Unbounded Unbounded;

  // accessors -------------------------------------------------------

  enum : int {
    kPrecedingFieldNumber = 1,
    kFollowingFieldNumber = 2,
    kCurrentRowFieldNumber = 3,
    kUnboundedFieldNumber = 4,
  };
  // .substrait.Expression.WindowFunction.Bound.Preceding preceding = 1 [json_name = "preceding"];
  bool has_preceding() const;
  private:
  bool _internal_has_preceding() const;
  public:
  void clear_preceding();
  const ::substrait::Expression_WindowFunction_Bound_Preceding& preceding() const;
  PROTOBUF_NODISCARD ::substrait::Expression_WindowFunction_Bound_Preceding* release_preceding();
  ::substrait::Expression_WindowFunction_Bound_Preceding* mutable_preceding();
  void set_allocated_preceding(::substrait::Expression_WindowFunction_Bound_Preceding* preceding);
  private:
  const ::substrait::Expression_WindowFunction_Bound_Preceding& _internal_preceding() const;
  ::substrait::Expression_WindowFunction_Bound_Preceding* _internal_mutable_preceding();
  public:
  void unsafe_arena_set_allocated_preceding(
      ::substrait::Expression_WindowFunction_Bound_Preceding* preceding);
  ::substrait::Expression_WindowFunction_Bound_Preceding* unsafe_arena_release_preceding();

  // .substrait.Expression.WindowFunction.Bound.Following following = 2 [json_name = "following"];
  bool has_following() const;
  private:
  bool _internal_has_following() const;
  public:
  void clear_following();
  const ::substrait::Expression_WindowFunction_Bound_Following& following() const;
  PROTOBUF_NODISCARD ::substrait::Expression_WindowFunction_Bound_Following* release_following();
  ::substrait::Expression_WindowFunction_Bound_Following* mutable_following();
  void set_allocated_following(::substrait::Expression_WindowFunction_Bound_Following* following);
  private:
  const ::substrait::Expression_WindowFunction_Bound_Following& _internal_following() const;
  ::substrait::Expression_WindowFunction_Bound_Following* _internal_mutable_following();
  public:
  void unsafe_arena_set_allocated_following(
      ::substrait::Expression_WindowFunction_Bound_Following* following);
  ::substrait::Expression_WindowFunction_Bound_Following* unsafe_arena_release_following();

  // .substrait.Expression.WindowFunction.Bound.CurrentRow current_row = 3 [json_name = "currentRow"];
  bool has_current_row() const;
  private:
  bool _internal_has_current_row() const;
  public:
  void clear_current_row();
  const ::substrait::Expression_WindowFunction_Bound_CurrentRow& current_row() const;
  PROTOBUF_NODISCARD ::substrait::Expression_WindowFunction_Bound_CurrentRow* release_current_row();
  ::substrait::Expression_WindowFunction_Bound_CurrentRow* mutable_current_row();
  void set_allocated_current_row(::substrait::Expression_WindowFunction_Bound_CurrentRow* current_row);
  private:
  const ::substrait::Expression_WindowFunction_Bound_CurrentRow& _internal_current_row() const;
  ::substrait::Expression_WindowFunction_Bound_CurrentRow* _internal_mutable_current_row();
  public:
  void unsafe_arena_set_allocated_current_row(
      ::substrait::Expression_WindowFunction_Bound_CurrentRow* current_row);
  ::substrait::Expression_WindowFunction_Bound_CurrentRow* unsafe_arena_release_current_row();

  // .substrait.Expression.WindowFunction.Bound.Unbounded unbounded = 4 [json_name = "unbounded"];
  bool has_unbounded() const;
  private:
  bool _internal_has_unbounded() const;
  public:
  void clear_unbounded();
  const ::substrait::Expression_WindowFunction_Bound_Unbounded& unbounded() const;
  PROTOBUF_NODISCARD ::substrait::Expression_WindowFunction_Bound_Unbounded* release_unbounded();
  ::substrait::Expression_WindowFunction_Bound_Unbounded* mutable_unbounded();
  void set_allocated_unbounded(::substrait::Expression_WindowFunction_Bound_Unbounded* unbounded);
  private:
  const ::substrait::Expression_WindowFunction_Bound_Unbounded& _internal_unbounded() const;
  ::substrait::Expression_WindowFunction_Bound_Unbounded* _internal_mutable_unbounded();
  public:
  void unsafe_arena_set_allocated_unbounded(
      ::substrait::Expression_WindowFunction_Bound_Unbounded* unbounded);
  ::substrait::Expression_WindowFunction_Bound_Unbounded* unsafe_arena_release_unbounded();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound)
 private:
  class _Internal;
  void set_has_preceding();
  void set_has_following();
  void set_has_current_row();
  void set_has_unbounded();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::substrait::Expression_WindowFunction_Bound_Preceding* preceding_;
    ::substrait::Expression_WindowFunction_Bound_Following* following_;
    ::substrait::Expression_WindowFunction_Bound_CurrentRow* current_row_;
    ::substrait::Expression_WindowFunction_Bound_Unbounded* unbounded_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_WindowFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction) */ {
 public:
  inline Expression_WindowFunction() : Expression_WindowFunction(nullptr) {}
  ~Expression_WindowFunction() override;
  explicit constexpr Expression_WindowFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_WindowFunction(const Expression_WindowFunction& from);
  Expression_WindowFunction(Expression_WindowFunction&& from) noexcept
    : Expression_WindowFunction() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction& operator=(const Expression_WindowFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction& operator=(Expression_WindowFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_WindowFunction* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction*>(
               &_Expression_WindowFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Expression_WindowFunction& a, Expression_WindowFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_WindowFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_WindowFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_WindowFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_WindowFunction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_WindowFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.WindowFunction";
  }
  protected:
  explicit Expression_WindowFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_WindowFunction_Bound Bound;

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionsFieldNumber = 2,
    kSortsFieldNumber = 3,
    kArgsFieldNumber = 8,
    kUpperBoundFieldNumber = 4,
    kLowerBoundFieldNumber = 5,
    kOutputTypeFieldNumber = 7,
    kFunctionReferenceFieldNumber = 1,
    kPhaseFieldNumber = 6,
  };
  // repeated .substrait.Expression partitions = 2 [json_name = "partitions"];
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;
  public:
  void clear_partitions();
  ::substrait::Expression* mutable_partitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
      mutable_partitions();
  private:
  const ::substrait::Expression& _internal_partitions(int index) const;
  ::substrait::Expression* _internal_add_partitions();
  public:
  const ::substrait::Expression& partitions(int index) const;
  ::substrait::Expression* add_partitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
      partitions() const;

  // repeated .substrait.SortField sorts = 3 [json_name = "sorts"];
  int sorts_size() const;
  private:
  int _internal_sorts_size() const;
  public:
  void clear_sorts();
  ::substrait::SortField* mutable_sorts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::SortField >*
      mutable_sorts();
  private:
  const ::substrait::SortField& _internal_sorts(int index) const;
  ::substrait::SortField* _internal_add_sorts();
  public:
  const ::substrait::SortField& sorts(int index) const;
  ::substrait::SortField* add_sorts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::SortField >&
      sorts() const;

  // repeated .substrait.Expression args = 8 [json_name = "args"];
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::substrait::Expression* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
      mutable_args();
  private:
  const ::substrait::Expression& _internal_args(int index) const;
  ::substrait::Expression* _internal_add_args();
  public:
  const ::substrait::Expression& args(int index) const;
  ::substrait::Expression* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
      args() const;

  // .substrait.Expression.WindowFunction.Bound upper_bound = 4 [json_name = "upperBound"];
  bool has_upper_bound() const;
  private:
  bool _internal_has_upper_bound() const;
  public:
  void clear_upper_bound();
  const ::substrait::Expression_WindowFunction_Bound& upper_bound() const;
  PROTOBUF_NODISCARD ::substrait::Expression_WindowFunction_Bound* release_upper_bound();
  ::substrait::Expression_WindowFunction_Bound* mutable_upper_bound();
  void set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* upper_bound);
  private:
  const ::substrait::Expression_WindowFunction_Bound& _internal_upper_bound() const;
  ::substrait::Expression_WindowFunction_Bound* _internal_mutable_upper_bound();
  public:
  void unsafe_arena_set_allocated_upper_bound(
      ::substrait::Expression_WindowFunction_Bound* upper_bound);
  ::substrait::Expression_WindowFunction_Bound* unsafe_arena_release_upper_bound();

  // .substrait.Expression.WindowFunction.Bound lower_bound = 5 [json_name = "lowerBound"];
  bool has_lower_bound() const;
  private:
  bool _internal_has_lower_bound() const;
  public:
  void clear_lower_bound();
  const ::substrait::Expression_WindowFunction_Bound& lower_bound() const;
  PROTOBUF_NODISCARD ::substrait::Expression_WindowFunction_Bound* release_lower_bound();
  ::substrait::Expression_WindowFunction_Bound* mutable_lower_bound();
  void set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* lower_bound);
  private:
  const ::substrait::Expression_WindowFunction_Bound& _internal_lower_bound() const;
  ::substrait::Expression_WindowFunction_Bound* _internal_mutable_lower_bound();
  public:
  void unsafe_arena_set_allocated_lower_bound(
      ::substrait::Expression_WindowFunction_Bound* lower_bound);
  ::substrait::Expression_WindowFunction_Bound* unsafe_arena_release_lower_bound();

  // .substrait.Type output_type = 7 [json_name = "outputType"];
  bool has_output_type() const;
  private:
  bool _internal_has_output_type() const;
  public:
  void clear_output_type();
  const ::substrait::Type& output_type() const;
  PROTOBUF_NODISCARD ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* output_type);
  private:
  const ::substrait::Type& _internal_output_type() const;
  ::substrait::Type* _internal_mutable_output_type();
  public:
  void unsafe_arena_set_allocated_output_type(
      ::substrait::Type* output_type);
  ::substrait::Type* unsafe_arena_release_output_type();

  // uint32 function_reference = 1 [json_name = "functionReference"];
  void clear_function_reference();
  uint32_t function_reference() const;
  void set_function_reference(uint32_t value);
  private:
  uint32_t _internal_function_reference() const;
  void _internal_set_function_reference(uint32_t value);
  public:

  // .substrait.AggregationPhase phase = 6 [json_name = "phase"];
  void clear_phase();
  ::substrait::AggregationPhase phase() const;
  void set_phase(::substrait::AggregationPhase value);
  private:
  ::substrait::AggregationPhase _internal_phase() const;
  void _internal_set_phase(::substrait::AggregationPhase value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression > partitions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::SortField > sorts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression > args_;
  ::substrait::Expression_WindowFunction_Bound* upper_bound_;
  ::substrait::Expression_WindowFunction_Bound* lower_bound_;
  ::substrait::Type* output_type_;
  uint32_t function_reference_;
  int phase_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_IfThen_IfClause final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.IfThen.IfClause) */ {
 public:
  inline Expression_IfThen_IfClause() : Expression_IfThen_IfClause(nullptr) {}
  ~Expression_IfThen_IfClause() override;
  explicit constexpr Expression_IfThen_IfClause(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_IfThen_IfClause(const Expression_IfThen_IfClause& from);
  Expression_IfThen_IfClause(Expression_IfThen_IfClause&& from) noexcept
    : Expression_IfThen_IfClause() {
    *this = ::std::move(from);
  }

  inline Expression_IfThen_IfClause& operator=(const Expression_IfThen_IfClause& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_IfThen_IfClause& operator=(Expression_IfThen_IfClause&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_IfThen_IfClause& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_IfThen_IfClause* internal_default_instance() {
    return reinterpret_cast<const Expression_IfThen_IfClause*>(
               &_Expression_IfThen_IfClause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Expression_IfThen_IfClause& a, Expression_IfThen_IfClause& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_IfThen_IfClause* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_IfThen_IfClause* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_IfThen_IfClause* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_IfThen_IfClause>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_IfThen_IfClause& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_IfThen_IfClause& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_IfThen_IfClause* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.IfThen.IfClause";
  }
  protected:
  explicit Expression_IfThen_IfClause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfFieldNumber = 1,
    kThenFieldNumber = 2,
  };
  // .substrait.Expression if = 1 [json_name = "if"];
  bool has_if_() const;
  private:
  bool _internal_has_if_() const;
  public:
  void clear_if_();
  const ::substrait::Expression& if_() const;
  PROTOBUF_NODISCARD ::substrait::Expression* release_if_();
  ::substrait::Expression* mutable_if_();
  void set_allocated_if_(::substrait::Expression* if_);
  private:
  const ::substrait::Expression& _internal_if_() const;
  ::substrait::Expression* _internal_mutable_if_();
  public:
  void unsafe_arena_set_allocated_if_(
      ::substrait::Expression* if_);
  ::substrait::Expression* unsafe_arena_release_if_();

  // .substrait.Expression then = 2 [json_name = "then"];
  bool has_then() const;
  private:
  bool _internal_has_then() const;
  public:
  void clear_then();
  const ::substrait::Expression& then() const;
  PROTOBUF_NODISCARD ::substrait::Expression* release_then();
  ::substrait::Expression* mutable_then();
  void set_allocated_then(::substrait::Expression* then);
  private:
  const ::substrait::Expression& _internal_then() const;
  ::substrait::Expression* _internal_mutable_then();
  public:
  void unsafe_arena_set_allocated_then(
      ::substrait::Expression* then);
  ::substrait::Expression* unsafe_arena_release_then();

  // @@protoc_insertion_point(class_scope:substrait.Expression.IfThen.IfClause)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Expression* if__;
  ::substrait::Expression* then_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_IfThen final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.IfThen) */ {
 public:
  inline Expression_IfThen() : Expression_IfThen(nullptr) {}
  ~Expression_IfThen() override;
  explicit constexpr Expression_IfThen(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_IfThen(const Expression_IfThen& from);
  Expression_IfThen(Expression_IfThen&& from) noexcept
    : Expression_IfThen() {
    *this = ::std::move(from);
  }

  inline Expression_IfThen& operator=(const Expression_IfThen& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_IfThen& operator=(Expression_IfThen&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_IfThen& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_IfThen* internal_default_instance() {
    return reinterpret_cast<const Expression_IfThen*>(
               &_Expression_IfThen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Expression_IfThen& a, Expression_IfThen& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_IfThen* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_IfThen* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_IfThen* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_IfThen>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_IfThen& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_IfThen& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_IfThen* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.IfThen";
  }
  protected:
  explicit Expression_IfThen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_IfThen_IfClause IfClause;

  // accessors -------------------------------------------------------

  enum : int {
    kIfsFieldNumber = 1,
    kElseFieldNumber = 2,
  };
  // repeated .substrait.Expression.IfThen.IfClause ifs = 1 [json_name = "ifs"];
  int ifs_size() const;
  private:
  int _internal_ifs_size() const;
  public:
  void clear_ifs();
  ::substrait::Expression_IfThen_IfClause* mutable_ifs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause >*
      mutable_ifs();
  private:
  const ::substrait::Expression_IfThen_IfClause& _internal_ifs(int index) const;
  ::substrait::Expression_IfThen_IfClause* _internal_add_ifs();
  public:
  const ::substrait::Expression_IfThen_IfClause& ifs(int index) const;
  ::substrait::Expression_IfThen_IfClause* add_ifs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause >&
      ifs() const;

  // .substrait.Expression else = 2 [json_name = "else"];
  bool has_else_() const;
  private:
  bool _internal_has_else_() const;
  public:
  void clear_else_();
  const ::substrait::Expression& else_() const;
  PROTOBUF_NODISCARD ::substrait::Expression* release_else_();
  ::substrait::Expression* mutable_else_();
  void set_allocated_else_(::substrait::Expression* else_);
  private:
  const ::substrait::Expression& _internal_else_() const;
  ::substrait::Expression* _internal_mutable_else_();
  public:
  void unsafe_arena_set_allocated_else_(
      ::substrait::Expression* else_);
  ::substrait::Expression* unsafe_arena_release_else_();

  // @@protoc_insertion_point(class_scope:substrait.Expression.IfThen)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause > ifs_;
  ::substrait::Expression* else__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_Cast final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Cast) */ {
 public:
  inline Expression_Cast() : Expression_Cast(nullptr) {}
  ~Expression_Cast() override;
  explicit constexpr Expression_Cast(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_Cast(const Expression_Cast& from);
  Expression_Cast(Expression_Cast&& from) noexcept
    : Expression_Cast() {
    *this = ::std::move(from);
  }

  inline Expression_Cast& operator=(const Expression_Cast& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Cast& operator=(Expression_Cast&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Cast& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_Cast* internal_default_instance() {
    return reinterpret_cast<const Expression_Cast*>(
               &_Expression_Cast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Expression_Cast& a, Expression_Cast& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_Cast* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Cast* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Cast* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_Cast>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_Cast& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_Cast& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Cast* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.Cast";
  }
  protected:
  explicit Expression_Cast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kInputFieldNumber = 2,
  };
  // .substrait.Type type = 1 [json_name = "type"];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::substrait::Type& type() const;
  PROTOBUF_NODISCARD ::substrait::Type* release_type();
  ::substrait::Type* mutable_type();
  void set_allocated_type(::substrait::Type* type);
  private:
  const ::substrait::Type& _internal_type() const;
  ::substrait::Type* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::substrait::Type* type);
  ::substrait::Type* unsafe_arena_release_type();

  // .substrait.Expression input = 2 [json_name = "input"];
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::substrait::Expression& input() const;
  PROTOBUF_NODISCARD ::substrait::Expression* release_input();
  ::substrait::Expression* mutable_input();
  void set_allocated_input(::substrait::Expression* input);
  private:
  const ::substrait::Expression& _internal_input() const;
  ::substrait::Expression* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::substrait::Expression* input);
  ::substrait::Expression* unsafe_arena_release_input();

  // @@protoc_insertion_point(class_scope:substrait.Expression.Cast)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Type* type_;
  ::substrait::Expression* input_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_SwitchExpression_IfValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.SwitchExpression.IfValue) */ {
 public:
  inline Expression_SwitchExpression_IfValue() : Expression_SwitchExpression_IfValue(nullptr) {}
  ~Expression_SwitchExpression_IfValue() override;
  explicit constexpr Expression_SwitchExpression_IfValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_SwitchExpression_IfValue(const Expression_SwitchExpression_IfValue& from);
  Expression_SwitchExpression_IfValue(Expression_SwitchExpression_IfValue&& from) noexcept
    : Expression_SwitchExpression_IfValue() {
    *this = ::std::move(from);
  }

  inline Expression_SwitchExpression_IfValue& operator=(const Expression_SwitchExpression_IfValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_SwitchExpression_IfValue& operator=(Expression_SwitchExpression_IfValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_SwitchExpression_IfValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_SwitchExpression_IfValue* internal_default_instance() {
    return reinterpret_cast<const Expression_SwitchExpression_IfValue*>(
               &_Expression_SwitchExpression_IfValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Expression_SwitchExpression_IfValue& a, Expression_SwitchExpression_IfValue& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_SwitchExpression_IfValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_SwitchExpression_IfValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_SwitchExpression_IfValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_SwitchExpression_IfValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_SwitchExpression_IfValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_SwitchExpression_IfValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_SwitchExpression_IfValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.SwitchExpression.IfValue";
  }
  protected:
  explicit Expression_SwitchExpression_IfValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfFieldNumber = 1,
    kThenFieldNumber = 2,
  };
  // .substrait.Expression.Literal if = 1 [json_name = "if"];
  bool has_if_() const;
  private:
  bool _internal_has_if_() const;
  public:
  void clear_if_();
  const ::substrait::Expression_Literal& if_() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal* release_if_();
  ::substrait::Expression_Literal* mutable_if_();
  void set_allocated_if_(::substrait::Expression_Literal* if_);
  private:
  const ::substrait::Expression_Literal& _internal_if_() const;
  ::substrait::Expression_Literal* _internal_mutable_if_();
  public:
  void unsafe_arena_set_allocated_if_(
      ::substrait::Expression_Literal* if_);
  ::substrait::Expression_Literal* unsafe_arena_release_if_();

  // .substrait.Expression then = 2 [json_name = "then"];
  bool has_then() const;
  private:
  bool _internal_has_then() const;
  public:
  void clear_then();
  const ::substrait::Expression& then() const;
  PROTOBUF_NODISCARD ::substrait::Expression* release_then();
  ::substrait::Expression* mutable_then();
  void set_allocated_then(::substrait::Expression* then);
  private:
  const ::substrait::Expression& _internal_then() const;
  ::substrait::Expression* _internal_mutable_then();
  public:
  void unsafe_arena_set_allocated_then(
      ::substrait::Expression* then);
  ::substrait::Expression* unsafe_arena_release_then();

  // @@protoc_insertion_point(class_scope:substrait.Expression.SwitchExpression.IfValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Expression_Literal* if__;
  ::substrait::Expression* then_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_SwitchExpression final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.SwitchExpression) */ {
 public:
  inline Expression_SwitchExpression() : Expression_SwitchExpression(nullptr) {}
  ~Expression_SwitchExpression() override;
  explicit constexpr Expression_SwitchExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_SwitchExpression(const Expression_SwitchExpression& from);
  Expression_SwitchExpression(Expression_SwitchExpression&& from) noexcept
    : Expression_SwitchExpression() {
    *this = ::std::move(from);
  }

  inline Expression_SwitchExpression& operator=(const Expression_SwitchExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_SwitchExpression& operator=(Expression_SwitchExpression&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_SwitchExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_SwitchExpression* internal_default_instance() {
    return reinterpret_cast<const Expression_SwitchExpression*>(
               &_Expression_SwitchExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Expression_SwitchExpression& a, Expression_SwitchExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_SwitchExpression* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_SwitchExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_SwitchExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_SwitchExpression>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_SwitchExpression& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_SwitchExpression& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_SwitchExpression* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.SwitchExpression";
  }
  protected:
  explicit Expression_SwitchExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_SwitchExpression_IfValue IfValue;

  // accessors -------------------------------------------------------

  enum : int {
    kIfsFieldNumber = 1,
    kElseFieldNumber = 2,
  };
  // repeated .substrait.Expression.SwitchExpression.IfValue ifs = 1 [json_name = "ifs"];
  int ifs_size() const;
  private:
  int _internal_ifs_size() const;
  public:
  void clear_ifs();
  ::substrait::Expression_SwitchExpression_IfValue* mutable_ifs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue >*
      mutable_ifs();
  private:
  const ::substrait::Expression_SwitchExpression_IfValue& _internal_ifs(int index) const;
  ::substrait::Expression_SwitchExpression_IfValue* _internal_add_ifs();
  public:
  const ::substrait::Expression_SwitchExpression_IfValue& ifs(int index) const;
  ::substrait::Expression_SwitchExpression_IfValue* add_ifs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue >&
      ifs() const;

  // .substrait.Expression else = 2 [json_name = "else"];
  bool has_else_() const;
  private:
  bool _internal_has_else_() const;
  public:
  void clear_else_();
  const ::substrait::Expression& else_() const;
  PROTOBUF_NODISCARD ::substrait::Expression* release_else_();
  ::substrait::Expression* mutable_else_();
  void set_allocated_else_(::substrait::Expression* else_);
  private:
  const ::substrait::Expression& _internal_else_() const;
  ::substrait::Expression* _internal_mutable_else_();
  public:
  void unsafe_arena_set_allocated_else_(
      ::substrait::Expression* else_);
  ::substrait::Expression* unsafe_arena_release_else_();

  // @@protoc_insertion_point(class_scope:substrait.Expression.SwitchExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue > ifs_;
  ::substrait::Expression* else__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_SingularOrList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.SingularOrList) */ {
 public:
  inline Expression_SingularOrList() : Expression_SingularOrList(nullptr) {}
  ~Expression_SingularOrList() override;
  explicit constexpr Expression_SingularOrList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_SingularOrList(const Expression_SingularOrList& from);
  Expression_SingularOrList(Expression_SingularOrList&& from) noexcept
    : Expression_SingularOrList() {
    *this = ::std::move(from);
  }

  inline Expression_SingularOrList& operator=(const Expression_SingularOrList& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_SingularOrList& operator=(Expression_SingularOrList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_SingularOrList& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_SingularOrList* internal_default_instance() {
    return reinterpret_cast<const Expression_SingularOrList*>(
               &_Expression_SingularOrList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Expression_SingularOrList& a, Expression_SingularOrList& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_SingularOrList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_SingularOrList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_SingularOrList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_SingularOrList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_SingularOrList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_SingularOrList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_SingularOrList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.SingularOrList";
  }
  protected:
  explicit Expression_SingularOrList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 2,
    kValueFieldNumber = 1,
  };
  // repeated .substrait.Expression options = 2 [json_name = "options"];
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  ::substrait::Expression* mutable_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
      mutable_options();
  private:
  const ::substrait::Expression& _internal_options(int index) const;
  ::substrait::Expression* _internal_add_options();
  public:
  const ::substrait::Expression& options(int index) const;
  ::substrait::Expression* add_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
      options() const;

  // .substrait.Expression value = 1 [json_name = "value"];
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::substrait::Expression& value() const;
  PROTOBUF_NODISCARD ::substrait::Expression* release_value();
  ::substrait::Expression* mutable_value();
  void set_allocated_value(::substrait::Expression* value);
  private:
  const ::substrait::Expression& _internal_value() const;
  ::substrait::Expression* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:substrait.Expression.SingularOrList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression > options_;
  ::substrait::Expression* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MultiOrList_Record final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MultiOrList.Record) */ {
 public:
  inline Expression_MultiOrList_Record() : Expression_MultiOrList_Record(nullptr) {}
  ~Expression_MultiOrList_Record() override;
  explicit constexpr Expression_MultiOrList_Record(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MultiOrList_Record(const Expression_MultiOrList_Record& from);
  Expression_MultiOrList_Record(Expression_MultiOrList_Record&& from) noexcept
    : Expression_MultiOrList_Record() {
    *this = ::std::move(from);
  }

  inline Expression_MultiOrList_Record& operator=(const Expression_MultiOrList_Record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MultiOrList_Record& operator=(Expression_MultiOrList_Record&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MultiOrList_Record& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_MultiOrList_Record* internal_default_instance() {
    return reinterpret_cast<const Expression_MultiOrList_Record*>(
               &_Expression_MultiOrList_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Expression_MultiOrList_Record& a, Expression_MultiOrList_Record& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MultiOrList_Record* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MultiOrList_Record* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MultiOrList_Record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MultiOrList_Record>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MultiOrList_Record& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MultiOrList_Record& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MultiOrList_Record* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MultiOrList.Record";
  }
  protected:
  explicit Expression_MultiOrList_Record(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .substrait.Expression fields = 1 [json_name = "fields"];
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::substrait::Expression* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
      mutable_fields();
  private:
  const ::substrait::Expression& _internal_fields(int index) const;
  ::substrait::Expression* _internal_add_fields();
  public:
  const ::substrait::Expression& fields(int index) const;
  ::substrait::Expression* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
      fields() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.MultiOrList.Record)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression > fields_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MultiOrList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MultiOrList) */ {
 public:
  inline Expression_MultiOrList() : Expression_MultiOrList(nullptr) {}
  ~Expression_MultiOrList() override;
  explicit constexpr Expression_MultiOrList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MultiOrList(const Expression_MultiOrList& from);
  Expression_MultiOrList(Expression_MultiOrList&& from) noexcept
    : Expression_MultiOrList() {
    *this = ::std::move(from);
  }

  inline Expression_MultiOrList& operator=(const Expression_MultiOrList& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MultiOrList& operator=(Expression_MultiOrList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MultiOrList& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_MultiOrList* internal_default_instance() {
    return reinterpret_cast<const Expression_MultiOrList*>(
               &_Expression_MultiOrList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Expression_MultiOrList& a, Expression_MultiOrList& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MultiOrList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MultiOrList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MultiOrList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MultiOrList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MultiOrList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MultiOrList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MultiOrList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MultiOrList";
  }
  protected:
  explicit Expression_MultiOrList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_MultiOrList_Record Record;

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kOptionsFieldNumber = 2,
  };
  // repeated .substrait.Expression value = 1 [json_name = "value"];
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::substrait::Expression* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
      mutable_value();
  private:
  const ::substrait::Expression& _internal_value(int index) const;
  ::substrait::Expression* _internal_add_value();
  public:
  const ::substrait::Expression& value(int index) const;
  ::substrait::Expression* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
      value() const;

  // repeated .substrait.Expression.MultiOrList.Record options = 2 [json_name = "options"];
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  ::substrait::Expression_MultiOrList_Record* mutable_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record >*
      mutable_options();
  private:
  const ::substrait::Expression_MultiOrList_Record& _internal_options(int index) const;
  ::substrait::Expression_MultiOrList_Record* _internal_add_options();
  public:
  const ::substrait::Expression_MultiOrList_Record& options(int index) const;
  ::substrait::Expression_MultiOrList_Record* add_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record >&
      options() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.MultiOrList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression > value_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record > options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_EmbeddedFunction_PythonPickleFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.EmbeddedFunction.PythonPickleFunction) */ {
 public:
  inline Expression_EmbeddedFunction_PythonPickleFunction() : Expression_EmbeddedFunction_PythonPickleFunction(nullptr) {}
  ~Expression_EmbeddedFunction_PythonPickleFunction() override;
  explicit constexpr Expression_EmbeddedFunction_PythonPickleFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_EmbeddedFunction_PythonPickleFunction(const Expression_EmbeddedFunction_PythonPickleFunction& from);
  Expression_EmbeddedFunction_PythonPickleFunction(Expression_EmbeddedFunction_PythonPickleFunction&& from) noexcept
    : Expression_EmbeddedFunction_PythonPickleFunction() {
    *this = ::std::move(from);
  }

  inline Expression_EmbeddedFunction_PythonPickleFunction& operator=(const Expression_EmbeddedFunction_PythonPickleFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_EmbeddedFunction_PythonPickleFunction& operator=(Expression_EmbeddedFunction_PythonPickleFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_EmbeddedFunction_PythonPickleFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_EmbeddedFunction_PythonPickleFunction* internal_default_instance() {
    return reinterpret_cast<const Expression_EmbeddedFunction_PythonPickleFunction*>(
               &_Expression_EmbeddedFunction_PythonPickleFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Expression_EmbeddedFunction_PythonPickleFunction& a, Expression_EmbeddedFunction_PythonPickleFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_EmbeddedFunction_PythonPickleFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_EmbeddedFunction_PythonPickleFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_EmbeddedFunction_PythonPickleFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_EmbeddedFunction_PythonPickleFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_EmbeddedFunction_PythonPickleFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_EmbeddedFunction_PythonPickleFunction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_EmbeddedFunction_PythonPickleFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.EmbeddedFunction.PythonPickleFunction";
  }
  protected:
  explicit Expression_EmbeddedFunction_PythonPickleFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrerequisiteFieldNumber = 2,
    kFunctionFieldNumber = 1,
  };
  // repeated string prerequisite = 2 [json_name = "prerequisite"];
  int prerequisite_size() const;
  private:
  int _internal_prerequisite_size() const;
  public:
  void clear_prerequisite();
  const std::string& prerequisite(int index) const;
  std::string* mutable_prerequisite(int index);
  void set_prerequisite(int index, const std::string& value);
  void set_prerequisite(int index, std::string&& value);
  void set_prerequisite(int index, const char* value);
  void set_prerequisite(int index, const char* value, size_t size);
  std::string* add_prerequisite();
  void add_prerequisite(const std::string& value);
  void add_prerequisite(std::string&& value);
  void add_prerequisite(const char* value);
  void add_prerequisite(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& prerequisite() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_prerequisite();
  private:
  const std::string& _internal_prerequisite(int index) const;
  std::string* _internal_add_prerequisite();
  public:

  // bytes function = 1 [json_name = "function"];
  void clear_function();
  const std::string& function() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function();
  PROTOBUF_NODISCARD std::string* release_function();
  void set_allocated_function(std::string* function);
  private:
  const std::string& _internal_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.EmbeddedFunction.PythonPickleFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> prerequisite_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_EmbeddedFunction_WebAssemblyFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.EmbeddedFunction.WebAssemblyFunction) */ {
 public:
  inline Expression_EmbeddedFunction_WebAssemblyFunction() : Expression_EmbeddedFunction_WebAssemblyFunction(nullptr) {}
  ~Expression_EmbeddedFunction_WebAssemblyFunction() override;
  explicit constexpr Expression_EmbeddedFunction_WebAssemblyFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_EmbeddedFunction_WebAssemblyFunction(const Expression_EmbeddedFunction_WebAssemblyFunction& from);
  Expression_EmbeddedFunction_WebAssemblyFunction(Expression_EmbeddedFunction_WebAssemblyFunction&& from) noexcept
    : Expression_EmbeddedFunction_WebAssemblyFunction() {
    *this = ::std::move(from);
  }

  inline Expression_EmbeddedFunction_WebAssemblyFunction& operator=(const Expression_EmbeddedFunction_WebAssemblyFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_EmbeddedFunction_WebAssemblyFunction& operator=(Expression_EmbeddedFunction_WebAssemblyFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_EmbeddedFunction_WebAssemblyFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_EmbeddedFunction_WebAssemblyFunction* internal_default_instance() {
    return reinterpret_cast<const Expression_EmbeddedFunction_WebAssemblyFunction*>(
               &_Expression_EmbeddedFunction_WebAssemblyFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Expression_EmbeddedFunction_WebAssemblyFunction& a, Expression_EmbeddedFunction_WebAssemblyFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_EmbeddedFunction_WebAssemblyFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_EmbeddedFunction_WebAssemblyFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_EmbeddedFunction_WebAssemblyFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_EmbeddedFunction_WebAssemblyFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_EmbeddedFunction_WebAssemblyFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_EmbeddedFunction_WebAssemblyFunction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_EmbeddedFunction_WebAssemblyFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.EmbeddedFunction.WebAssemblyFunction";
  }
  protected:
  explicit Expression_EmbeddedFunction_WebAssemblyFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrerequisiteFieldNumber = 2,
    kScriptFieldNumber = 1,
  };
  // repeated string prerequisite = 2 [json_name = "prerequisite"];
  int prerequisite_size() const;
  private:
  int _internal_prerequisite_size() const;
  public:
  void clear_prerequisite();
  const std::string& prerequisite(int index) const;
  std::string* mutable_prerequisite(int index);
  void set_prerequisite(int index, const std::string& value);
  void set_prerequisite(int index, std::string&& value);
  void set_prerequisite(int index, const char* value);
  void set_prerequisite(int index, const char* value, size_t size);
  std::string* add_prerequisite();
  void add_prerequisite(const std::string& value);
  void add_prerequisite(std::string&& value);
  void add_prerequisite(const char* value);
  void add_prerequisite(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& prerequisite() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_prerequisite();
  private:
  const std::string& _internal_prerequisite(int index) const;
  std::string* _internal_add_prerequisite();
  public:

  // bytes script = 1 [json_name = "script"];
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_NODISCARD std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.EmbeddedFunction.WebAssemblyFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> prerequisite_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_EmbeddedFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.EmbeddedFunction) */ {
 public:
  inline Expression_EmbeddedFunction() : Expression_EmbeddedFunction(nullptr) {}
  ~Expression_EmbeddedFunction() override;
  explicit constexpr Expression_EmbeddedFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_EmbeddedFunction(const Expression_EmbeddedFunction& from);
  Expression_EmbeddedFunction(Expression_EmbeddedFunction&& from) noexcept
    : Expression_EmbeddedFunction() {
    *this = ::std::move(from);
  }

  inline Expression_EmbeddedFunction& operator=(const Expression_EmbeddedFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_EmbeddedFunction& operator=(Expression_EmbeddedFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_EmbeddedFunction& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kPythonPickleFunction = 3,
    kWebAssemblyFunction = 4,
    KIND_NOT_SET = 0,
  };

  static inline const Expression_EmbeddedFunction* internal_default_instance() {
    return reinterpret_cast<const Expression_EmbeddedFunction*>(
               &_Expression_EmbeddedFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Expression_EmbeddedFunction& a, Expression_EmbeddedFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_EmbeddedFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_EmbeddedFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_EmbeddedFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_EmbeddedFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_EmbeddedFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_EmbeddedFunction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_EmbeddedFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.EmbeddedFunction";
  }
  protected:
  explicit Expression_EmbeddedFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_EmbeddedFunction_PythonPickleFunction PythonPickleFunction;
  typedef Expression_EmbeddedFunction_WebAssemblyFunction WebAssemblyFunction;

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 1,
    kOutputTypeFieldNumber = 2,
    kPythonPickleFunctionFieldNumber = 3,
    kWebAssemblyFunctionFieldNumber = 4,
  };
  // repeated .substrait.Expression arguments = 1 [json_name = "arguments"];
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  ::substrait::Expression* mutable_arguments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
      mutable_arguments();
  private:
  const ::substrait::Expression& _internal_arguments(int index) const;
  ::substrait::Expression* _internal_add_arguments();
  public:
  const ::substrait::Expression& arguments(int index) const;
  ::substrait::Expression* add_arguments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
      arguments() const;

  // .substrait.Type output_type = 2 [json_name = "outputType"];
  bool has_output_type() const;
  private:
  bool _internal_has_output_type() const;
  public:
  void clear_output_type();
  const ::substrait::Type& output_type() const;
  PROTOBUF_NODISCARD ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* output_type);
  private:
  const ::substrait::Type& _internal_output_type() const;
  ::substrait::Type* _internal_mutable_output_type();
  public:
  void unsafe_arena_set_allocated_output_type(
      ::substrait::Type* output_type);
  ::substrait::Type* unsafe_arena_release_output_type();

  // .substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function = 3 [json_name = "pythonPickleFunction"];
  bool has_python_pickle_function() const;
  private:
  bool _internal_has_python_pickle_function() const;
  public:
  void clear_python_pickle_function();
  const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& python_pickle_function() const;
  PROTOBUF_NODISCARD ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* release_python_pickle_function();
  ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* mutable_python_pickle_function();
  void set_allocated_python_pickle_function(::substrait::Expression_EmbeddedFunction_PythonPickleFunction* python_pickle_function);
  private:
  const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& _internal_python_pickle_function() const;
  ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* _internal_mutable_python_pickle_function();
  public:
  void unsafe_arena_set_allocated_python_pickle_function(
      ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* python_pickle_function);
  ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* unsafe_arena_release_python_pickle_function();

  // .substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function = 4 [json_name = "webAssemblyFunction"];
  bool has_web_assembly_function() const;
  private:
  bool _internal_has_web_assembly_function() const;
  public:
  void clear_web_assembly_function();
  const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& web_assembly_function() const;
  PROTOBUF_NODISCARD ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* release_web_assembly_function();
  ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* mutable_web_assembly_function();
  void set_allocated_web_assembly_function(::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* web_assembly_function);
  private:
  const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& _internal_web_assembly_function() const;
  ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* _internal_mutable_web_assembly_function();
  public:
  void unsafe_arena_set_allocated_web_assembly_function(
      ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* web_assembly_function);
  ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* unsafe_arena_release_web_assembly_function();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.EmbeddedFunction)
 private:
  class _Internal;
  void set_has_python_pickle_function();
  void set_has_web_assembly_function();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression > arguments_;
  ::substrait::Type* output_type_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* python_pickle_function_;
    ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* web_assembly_function_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_ReferenceSegment_MapKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment.MapKey) */ {
 public:
  inline Expression_ReferenceSegment_MapKey() : Expression_ReferenceSegment_MapKey(nullptr) {}
  ~Expression_ReferenceSegment_MapKey() override;
  explicit constexpr Expression_ReferenceSegment_MapKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_ReferenceSegment_MapKey(const Expression_ReferenceSegment_MapKey& from);
  Expression_ReferenceSegment_MapKey(Expression_ReferenceSegment_MapKey&& from) noexcept
    : Expression_ReferenceSegment_MapKey() {
    *this = ::std::move(from);
  }

  inline Expression_ReferenceSegment_MapKey& operator=(const Expression_ReferenceSegment_MapKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_ReferenceSegment_MapKey& operator=(Expression_ReferenceSegment_MapKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_ReferenceSegment_MapKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_ReferenceSegment_MapKey* internal_default_instance() {
    return reinterpret_cast<const Expression_ReferenceSegment_MapKey*>(
               &_Expression_ReferenceSegment_MapKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Expression_ReferenceSegment_MapKey& a, Expression_ReferenceSegment_MapKey& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_ReferenceSegment_MapKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_ReferenceSegment_MapKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_ReferenceSegment_MapKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_ReferenceSegment_MapKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_ReferenceSegment_MapKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_ReferenceSegment_MapKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_ReferenceSegment_MapKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.ReferenceSegment.MapKey";
  }
  protected:
  explicit Expression_ReferenceSegment_MapKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapKeyFieldNumber = 1,
    kChildFieldNumber = 2,
  };
  // .substrait.Expression.Literal map_key = 1 [json_name = "mapKey"];
  bool has_map_key() const;
  private:
  bool _internal_has_map_key() const;
  public:
  void clear_map_key();
  const ::substrait::Expression_Literal& map_key() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal* release_map_key();
  ::substrait::Expression_Literal* mutable_map_key();
  void set_allocated_map_key(::substrait::Expression_Literal* map_key);
  private:
  const ::substrait::Expression_Literal& _internal_map_key() const;
  ::substrait::Expression_Literal* _internal_mutable_map_key();
  public:
  void unsafe_arena_set_allocated_map_key(
      ::substrait::Expression_Literal* map_key);
  ::substrait::Expression_Literal* unsafe_arena_release_map_key();

  // .substrait.Expression.ReferenceSegment child = 2 [json_name = "child"];
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::substrait::Expression_ReferenceSegment& child() const;
  PROTOBUF_NODISCARD ::substrait::Expression_ReferenceSegment* release_child();
  ::substrait::Expression_ReferenceSegment* mutable_child();
  void set_allocated_child(::substrait::Expression_ReferenceSegment* child);
  private:
  const ::substrait::Expression_ReferenceSegment& _internal_child() const;
  ::substrait::Expression_ReferenceSegment* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::substrait::Expression_ReferenceSegment* child);
  ::substrait::Expression_ReferenceSegment* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment.MapKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Expression_Literal* map_key_;
  ::substrait::Expression_ReferenceSegment* child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_ReferenceSegment_StructField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment.StructField) */ {
 public:
  inline Expression_ReferenceSegment_StructField() : Expression_ReferenceSegment_StructField(nullptr) {}
  ~Expression_ReferenceSegment_StructField() override;
  explicit constexpr Expression_ReferenceSegment_StructField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_ReferenceSegment_StructField(const Expression_ReferenceSegment_StructField& from);
  Expression_ReferenceSegment_StructField(Expression_ReferenceSegment_StructField&& from) noexcept
    : Expression_ReferenceSegment_StructField() {
    *this = ::std::move(from);
  }

  inline Expression_ReferenceSegment_StructField& operator=(const Expression_ReferenceSegment_StructField& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_ReferenceSegment_StructField& operator=(Expression_ReferenceSegment_StructField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_ReferenceSegment_StructField& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_ReferenceSegment_StructField* internal_default_instance() {
    return reinterpret_cast<const Expression_ReferenceSegment_StructField*>(
               &_Expression_ReferenceSegment_StructField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Expression_ReferenceSegment_StructField& a, Expression_ReferenceSegment_StructField& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_ReferenceSegment_StructField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_ReferenceSegment_StructField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_ReferenceSegment_StructField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_ReferenceSegment_StructField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_ReferenceSegment_StructField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_ReferenceSegment_StructField& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_ReferenceSegment_StructField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.ReferenceSegment.StructField";
  }
  protected:
  explicit Expression_ReferenceSegment_StructField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // .substrait.Expression.ReferenceSegment child = 2 [json_name = "child"];
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::substrait::Expression_ReferenceSegment& child() const;
  PROTOBUF_NODISCARD ::substrait::Expression_ReferenceSegment* release_child();
  ::substrait::Expression_ReferenceSegment* mutable_child();
  void set_allocated_child(::substrait::Expression_ReferenceSegment* child);
  private:
  const ::substrait::Expression_ReferenceSegment& _internal_child() const;
  ::substrait::Expression_ReferenceSegment* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::substrait::Expression_ReferenceSegment* child);
  ::substrait::Expression_ReferenceSegment* unsafe_arena_release_child();

  // int32 field = 1 [json_name = "field"];
  void clear_field();
  int32_t field() const;
  void set_field(int32_t value);
  private:
  int32_t _internal_field() const;
  void _internal_set_field(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment.StructField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Expression_ReferenceSegment* child_;
  int32_t field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_ReferenceSegment_ListElement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment.ListElement) */ {
 public:
  inline Expression_ReferenceSegment_ListElement() : Expression_ReferenceSegment_ListElement(nullptr) {}
  ~Expression_ReferenceSegment_ListElement() override;
  explicit constexpr Expression_ReferenceSegment_ListElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_ReferenceSegment_ListElement(const Expression_ReferenceSegment_ListElement& from);
  Expression_ReferenceSegment_ListElement(Expression_ReferenceSegment_ListElement&& from) noexcept
    : Expression_ReferenceSegment_ListElement() {
    *this = ::std::move(from);
  }

  inline Expression_ReferenceSegment_ListElement& operator=(const Expression_ReferenceSegment_ListElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_ReferenceSegment_ListElement& operator=(Expression_ReferenceSegment_ListElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_ReferenceSegment_ListElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_ReferenceSegment_ListElement* internal_default_instance() {
    return reinterpret_cast<const Expression_ReferenceSegment_ListElement*>(
               &_Expression_ReferenceSegment_ListElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Expression_ReferenceSegment_ListElement& a, Expression_ReferenceSegment_ListElement& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_ReferenceSegment_ListElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_ReferenceSegment_ListElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_ReferenceSegment_ListElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_ReferenceSegment_ListElement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_ReferenceSegment_ListElement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_ReferenceSegment_ListElement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_ReferenceSegment_ListElement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.ReferenceSegment.ListElement";
  }
  protected:
  explicit Expression_ReferenceSegment_ListElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 2,
    kOffsetFieldNumber = 1,
  };
  // .substrait.Expression.ReferenceSegment child = 2 [json_name = "child"];
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::substrait::Expression_ReferenceSegment& child() const;
  PROTOBUF_NODISCARD ::substrait::Expression_ReferenceSegment* release_child();
  ::substrait::Expression_ReferenceSegment* mutable_child();
  void set_allocated_child(::substrait::Expression_ReferenceSegment* child);
  private:
  const ::substrait::Expression_ReferenceSegment& _internal_child() const;
  ::substrait::Expression_ReferenceSegment* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::substrait::Expression_ReferenceSegment* child);
  ::substrait::Expression_ReferenceSegment* unsafe_arena_release_child();

  // int32 offset = 1 [json_name = "offset"];
  void clear_offset();
  int32_t offset() const;
  void set_offset(int32_t value);
  private:
  int32_t _internal_offset() const;
  void _internal_set_offset(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment.ListElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Expression_ReferenceSegment* child_;
  int32_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_ReferenceSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment) */ {
 public:
  inline Expression_ReferenceSegment() : Expression_ReferenceSegment(nullptr) {}
  ~Expression_ReferenceSegment() override;
  explicit constexpr Expression_ReferenceSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_ReferenceSegment(const Expression_ReferenceSegment& from);
  Expression_ReferenceSegment(Expression_ReferenceSegment&& from) noexcept
    : Expression_ReferenceSegment() {
    *this = ::std::move(from);
  }

  inline Expression_ReferenceSegment& operator=(const Expression_ReferenceSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_ReferenceSegment& operator=(Expression_ReferenceSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_ReferenceSegment& default_instance() {
    return *internal_default_instance();
  }
  enum ReferenceTypeCase {
    kMapKey = 1,
    kStructField = 2,
    kListElement = 3,
    REFERENCE_TYPE_NOT_SET = 0,
  };

  static inline const Expression_ReferenceSegment* internal_default_instance() {
    return reinterpret_cast<const Expression_ReferenceSegment*>(
               &_Expression_ReferenceSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Expression_ReferenceSegment& a, Expression_ReferenceSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_ReferenceSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_ReferenceSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_ReferenceSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_ReferenceSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_ReferenceSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_ReferenceSegment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_ReferenceSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.ReferenceSegment";
  }
  protected:
  explicit Expression_ReferenceSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_ReferenceSegment_MapKey MapKey;
  typedef Expression_ReferenceSegment_StructField StructField;
  typedef Expression_ReferenceSegment_ListElement ListElement;

  // accessors -------------------------------------------------------

  enum : int {
    kMapKeyFieldNumber = 1,
    kStructFieldFieldNumber = 2,
    kListElementFieldNumber = 3,
  };
  // .substrait.Expression.ReferenceSegment.MapKey map_key = 1 [json_name = "mapKey"];
  bool has_map_key() const;
  private:
  bool _internal_has_map_key() const;
  public:
  void clear_map_key();
  const ::substrait::Expression_ReferenceSegment_MapKey& map_key() const;
  PROTOBUF_NODISCARD ::substrait::Expression_ReferenceSegment_MapKey* release_map_key();
  ::substrait::Expression_ReferenceSegment_MapKey* mutable_map_key();
  void set_allocated_map_key(::substrait::Expression_ReferenceSegment_MapKey* map_key);
  private:
  const ::substrait::Expression_ReferenceSegment_MapKey& _internal_map_key() const;
  ::substrait::Expression_ReferenceSegment_MapKey* _internal_mutable_map_key();
  public:
  void unsafe_arena_set_allocated_map_key(
      ::substrait::Expression_ReferenceSegment_MapKey* map_key);
  ::substrait::Expression_ReferenceSegment_MapKey* unsafe_arena_release_map_key();

  // .substrait.Expression.ReferenceSegment.StructField struct_field = 2 [json_name = "structField"];
  bool has_struct_field() const;
  private:
  bool _internal_has_struct_field() const;
  public:
  void clear_struct_field();
  const ::substrait::Expression_ReferenceSegment_StructField& struct_field() const;
  PROTOBUF_NODISCARD ::substrait::Expression_ReferenceSegment_StructField* release_struct_field();
  ::substrait::Expression_ReferenceSegment_StructField* mutable_struct_field();
  void set_allocated_struct_field(::substrait::Expression_ReferenceSegment_StructField* struct_field);
  private:
  const ::substrait::Expression_ReferenceSegment_StructField& _internal_struct_field() const;
  ::substrait::Expression_ReferenceSegment_StructField* _internal_mutable_struct_field();
  public:
  void unsafe_arena_set_allocated_struct_field(
      ::substrait::Expression_ReferenceSegment_StructField* struct_field);
  ::substrait::Expression_ReferenceSegment_StructField* unsafe_arena_release_struct_field();

  // .substrait.Expression.ReferenceSegment.ListElement list_element = 3 [json_name = "listElement"];
  bool has_list_element() const;
  private:
  bool _internal_has_list_element() const;
  public:
  void clear_list_element();
  const ::substrait::Expression_ReferenceSegment_ListElement& list_element() const;
  PROTOBUF_NODISCARD ::substrait::Expression_ReferenceSegment_ListElement* release_list_element();
  ::substrait::Expression_ReferenceSegment_ListElement* mutable_list_element();
  void set_allocated_list_element(::substrait::Expression_ReferenceSegment_ListElement* list_element);
  private:
  const ::substrait::Expression_ReferenceSegment_ListElement& _internal_list_element() const;
  ::substrait::Expression_ReferenceSegment_ListElement* _internal_mutable_list_element();
  public:
  void unsafe_arena_set_allocated_list_element(
      ::substrait::Expression_ReferenceSegment_ListElement* list_element);
  ::substrait::Expression_ReferenceSegment_ListElement* unsafe_arena_release_list_element();

  void clear_reference_type();
  ReferenceTypeCase reference_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment)
 private:
  class _Internal;
  void set_has_map_key();
  void set_has_struct_field();
  void set_has_list_element();

  inline bool has_reference_type() const;
  inline void clear_has_reference_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ReferenceTypeUnion {
    constexpr ReferenceTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::substrait::Expression_ReferenceSegment_MapKey* map_key_;
    ::substrait::Expression_ReferenceSegment_StructField* struct_field_;
    ::substrait::Expression_ReferenceSegment_ListElement* list_element_;
  } reference_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_Select final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.Select) */ {
 public:
  inline Expression_MaskExpression_Select() : Expression_MaskExpression_Select(nullptr) {}
  ~Expression_MaskExpression_Select() override;
  explicit constexpr Expression_MaskExpression_Select(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression_Select(const Expression_MaskExpression_Select& from);
  Expression_MaskExpression_Select(Expression_MaskExpression_Select&& from) noexcept
    : Expression_MaskExpression_Select() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_Select& operator=(const Expression_MaskExpression_Select& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_Select& operator=(Expression_MaskExpression_Select&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_Select& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kStruct = 1,
    kList = 2,
    kMap = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const Expression_MaskExpression_Select* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_Select*>(
               &_Expression_MaskExpression_Select_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Expression_MaskExpression_Select& a, Expression_MaskExpression_Select& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression_Select* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_Select* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_Select* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression_Select>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_Select& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_Select& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_Select* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression.Select";
  }
  protected:
  explicit Expression_MaskExpression_Select(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStructFieldNumber = 1,
    kListFieldNumber = 2,
    kMapFieldNumber = 3,
  };
  // .substrait.Expression.MaskExpression.StructSelect struct = 1 [json_name = "struct"];
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;
  public:
  void clear_struct_();
  const ::substrait::Expression_MaskExpression_StructSelect& struct_() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_StructSelect* release_struct_();
  ::substrait::Expression_MaskExpression_StructSelect* mutable_struct_();
  void set_allocated_struct_(::substrait::Expression_MaskExpression_StructSelect* struct_);
  private:
  const ::substrait::Expression_MaskExpression_StructSelect& _internal_struct_() const;
  ::substrait::Expression_MaskExpression_StructSelect* _internal_mutable_struct_();
  public:
  void unsafe_arena_set_allocated_struct_(
      ::substrait::Expression_MaskExpression_StructSelect* struct_);
  ::substrait::Expression_MaskExpression_StructSelect* unsafe_arena_release_struct_();

  // .substrait.Expression.MaskExpression.ListSelect list = 2 [json_name = "list"];
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::substrait::Expression_MaskExpression_ListSelect& list() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_ListSelect* release_list();
  ::substrait::Expression_MaskExpression_ListSelect* mutable_list();
  void set_allocated_list(::substrait::Expression_MaskExpression_ListSelect* list);
  private:
  const ::substrait::Expression_MaskExpression_ListSelect& _internal_list() const;
  ::substrait::Expression_MaskExpression_ListSelect* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::substrait::Expression_MaskExpression_ListSelect* list);
  ::substrait::Expression_MaskExpression_ListSelect* unsafe_arena_release_list();

  // .substrait.Expression.MaskExpression.MapSelect map = 3 [json_name = "map"];
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::substrait::Expression_MaskExpression_MapSelect& map() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_MapSelect* release_map();
  ::substrait::Expression_MaskExpression_MapSelect* mutable_map();
  void set_allocated_map(::substrait::Expression_MaskExpression_MapSelect* map);
  private:
  const ::substrait::Expression_MaskExpression_MapSelect& _internal_map() const;
  ::substrait::Expression_MaskExpression_MapSelect* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::substrait::Expression_MaskExpression_MapSelect* map);
  ::substrait::Expression_MaskExpression_MapSelect* unsafe_arena_release_map();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.Select)
 private:
  class _Internal;
  void set_has_struct_();
  void set_has_list();
  void set_has_map();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::substrait::Expression_MaskExpression_StructSelect* struct__;
    ::substrait::Expression_MaskExpression_ListSelect* list_;
    ::substrait::Expression_MaskExpression_MapSelect* map_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_StructSelect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.StructSelect) */ {
 public:
  inline Expression_MaskExpression_StructSelect() : Expression_MaskExpression_StructSelect(nullptr) {}
  ~Expression_MaskExpression_StructSelect() override;
  explicit constexpr Expression_MaskExpression_StructSelect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression_StructSelect(const Expression_MaskExpression_StructSelect& from);
  Expression_MaskExpression_StructSelect(Expression_MaskExpression_StructSelect&& from) noexcept
    : Expression_MaskExpression_StructSelect() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_StructSelect& operator=(const Expression_MaskExpression_StructSelect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_StructSelect& operator=(Expression_MaskExpression_StructSelect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_StructSelect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_MaskExpression_StructSelect* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_StructSelect*>(
               &_Expression_MaskExpression_StructSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Expression_MaskExpression_StructSelect& a, Expression_MaskExpression_StructSelect& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression_StructSelect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_StructSelect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_StructSelect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression_StructSelect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_StructSelect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_StructSelect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_StructSelect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression.StructSelect";
  }
  protected:
  explicit Expression_MaskExpression_StructSelect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStructItemsFieldNumber = 1,
  };
  // repeated .substrait.Expression.MaskExpression.StructItem struct_items = 1 [json_name = "structItems"];
  int struct_items_size() const;
  private:
  int _internal_struct_items_size() const;
  public:
  void clear_struct_items();
  ::substrait::Expression_MaskExpression_StructItem* mutable_struct_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem >*
      mutable_struct_items();
  private:
  const ::substrait::Expression_MaskExpression_StructItem& _internal_struct_items(int index) const;
  ::substrait::Expression_MaskExpression_StructItem* _internal_add_struct_items();
  public:
  const ::substrait::Expression_MaskExpression_StructItem& struct_items(int index) const;
  ::substrait::Expression_MaskExpression_StructItem* add_struct_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem >&
      struct_items() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.StructSelect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem > struct_items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_StructItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.StructItem) */ {
 public:
  inline Expression_MaskExpression_StructItem() : Expression_MaskExpression_StructItem(nullptr) {}
  ~Expression_MaskExpression_StructItem() override;
  explicit constexpr Expression_MaskExpression_StructItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression_StructItem(const Expression_MaskExpression_StructItem& from);
  Expression_MaskExpression_StructItem(Expression_MaskExpression_StructItem&& from) noexcept
    : Expression_MaskExpression_StructItem() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_StructItem& operator=(const Expression_MaskExpression_StructItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_StructItem& operator=(Expression_MaskExpression_StructItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_StructItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_MaskExpression_StructItem* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_StructItem*>(
               &_Expression_MaskExpression_StructItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Expression_MaskExpression_StructItem& a, Expression_MaskExpression_StructItem& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression_StructItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_StructItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_StructItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression_StructItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_StructItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_StructItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_StructItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression.StructItem";
  }
  protected:
  explicit Expression_MaskExpression_StructItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // .substrait.Expression.MaskExpression.Select child = 2 [json_name = "child"];
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::substrait::Expression_MaskExpression_Select& child() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_Select* release_child();
  ::substrait::Expression_MaskExpression_Select* mutable_child();
  void set_allocated_child(::substrait::Expression_MaskExpression_Select* child);
  private:
  const ::substrait::Expression_MaskExpression_Select& _internal_child() const;
  ::substrait::Expression_MaskExpression_Select* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::substrait::Expression_MaskExpression_Select* child);
  ::substrait::Expression_MaskExpression_Select* unsafe_arena_release_child();

  // int32 field = 1 [json_name = "field"];
  void clear_field();
  int32_t field() const;
  void set_field(int32_t value);
  private:
  int32_t _internal_field() const;
  void _internal_set_field(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.StructItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Expression_MaskExpression_Select* child_;
  int32_t field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect_ListSelectItem_ListElement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement) */ {
 public:
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement() : Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(nullptr) {}
  ~Expression_MaskExpression_ListSelect_ListSelectItem_ListElement() override;
  explicit constexpr Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from);
  Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement&& from) noexcept
    : Expression_MaskExpression_ListSelect_ListSelectItem_ListElement() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& operator=(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& operator=(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement*>(
               &_Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& a, Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListElement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement";
  }
  protected:
  explicit Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // int32 field = 1 [json_name = "field"];
  void clear_field();
  int32_t field() const;
  void set_field(int32_t value);
  private:
  int32_t _internal_field() const;
  void _internal_set_field(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice) */ {
 public:
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice() : Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(nullptr) {}
  ~Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice() override;
  explicit constexpr Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from);
  Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice&& from) noexcept
    : Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& operator=(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& operator=(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice*>(
               &_Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& a, Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice";
  }
  protected:
  explicit Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // int32 start = 1 [json_name = "start"];
  void clear_start();
  int32_t start() const;
  void set_start(int32_t value);
  private:
  int32_t _internal_start() const;
  void _internal_set_start(int32_t value);
  public:

  // int32 end = 2 [json_name = "end"];
  void clear_end();
  int32_t end() const;
  void set_end(int32_t value);
  private:
  int32_t _internal_end() const;
  void _internal_set_end(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t start_;
  int32_t end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect_ListSelectItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect.ListSelectItem) */ {
 public:
  inline Expression_MaskExpression_ListSelect_ListSelectItem() : Expression_MaskExpression_ListSelect_ListSelectItem(nullptr) {}
  ~Expression_MaskExpression_ListSelect_ListSelectItem() override;
  explicit constexpr Expression_MaskExpression_ListSelect_ListSelectItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression_ListSelect_ListSelectItem(const Expression_MaskExpression_ListSelect_ListSelectItem& from);
  Expression_MaskExpression_ListSelect_ListSelectItem(Expression_MaskExpression_ListSelect_ListSelectItem&& from) noexcept
    : Expression_MaskExpression_ListSelect_ListSelectItem() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_ListSelect_ListSelectItem& operator=(const Expression_MaskExpression_ListSelect_ListSelectItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_ListSelect_ListSelectItem& operator=(Expression_MaskExpression_ListSelect_ListSelectItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_ListSelect_ListSelectItem& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kItem = 1,
    kSlice = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const Expression_MaskExpression_ListSelect_ListSelectItem* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_ListSelect_ListSelectItem*>(
               &_Expression_MaskExpression_ListSelect_ListSelectItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Expression_MaskExpression_ListSelect_ListSelectItem& a, Expression_MaskExpression_ListSelect_ListSelectItem& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression_ListSelect_ListSelectItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_ListSelect_ListSelectItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_ListSelect_ListSelectItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect_ListSelectItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_ListSelect_ListSelectItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_ListSelect_ListSelectItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_ListSelect_ListSelectItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression.ListSelect.ListSelectItem";
  }
  protected:
  explicit Expression_MaskExpression_ListSelect_ListSelectItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_MaskExpression_ListSelect_ListSelectItem_ListElement ListElement;
  typedef Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice ListSlice;

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kSliceFieldNumber = 2,
  };
  // .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1 [json_name = "item"];
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& item() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* release_item();
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* mutable_item();
  void set_allocated_item(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* item);
  private:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& _internal_item() const;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* item);
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* unsafe_arena_release_item();

  // .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2 [json_name = "slice"];
  bool has_slice() const;
  private:
  bool _internal_has_slice() const;
  public:
  void clear_slice();
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& slice() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* release_slice();
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* mutable_slice();
  void set_allocated_slice(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* slice);
  private:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& _internal_slice() const;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* _internal_mutable_slice();
  public:
  void unsafe_arena_set_allocated_slice(
      ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* slice);
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* unsafe_arena_release_slice();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect.ListSelectItem)
 private:
  class _Internal;
  void set_has_item();
  void set_has_slice();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* item_;
    ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* slice_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect) */ {
 public:
  inline Expression_MaskExpression_ListSelect() : Expression_MaskExpression_ListSelect(nullptr) {}
  ~Expression_MaskExpression_ListSelect() override;
  explicit constexpr Expression_MaskExpression_ListSelect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression_ListSelect(const Expression_MaskExpression_ListSelect& from);
  Expression_MaskExpression_ListSelect(Expression_MaskExpression_ListSelect&& from) noexcept
    : Expression_MaskExpression_ListSelect() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_ListSelect& operator=(const Expression_MaskExpression_ListSelect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_ListSelect& operator=(Expression_MaskExpression_ListSelect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_ListSelect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_MaskExpression_ListSelect* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_ListSelect*>(
               &_Expression_MaskExpression_ListSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Expression_MaskExpression_ListSelect& a, Expression_MaskExpression_ListSelect& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression_ListSelect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_ListSelect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_ListSelect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_ListSelect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_ListSelect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_ListSelect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression.ListSelect";
  }
  protected:
  explicit Expression_MaskExpression_ListSelect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_MaskExpression_ListSelect_ListSelectItem ListSelectItem;

  // accessors -------------------------------------------------------

  enum : int {
    kSelectionFieldNumber = 1,
    kChildFieldNumber = 2,
  };
  // repeated .substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection = 1 [json_name = "selection"];
  int selection_size() const;
  private:
  int _internal_selection_size() const;
  public:
  void clear_selection();
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* mutable_selection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem >*
      mutable_selection();
  private:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem& _internal_selection(int index) const;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* _internal_add_selection();
  public:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem& selection(int index) const;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* add_selection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem >&
      selection() const;

  // .substrait.Expression.MaskExpression.Select child = 2 [json_name = "child"];
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::substrait::Expression_MaskExpression_Select& child() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_Select* release_child();
  ::substrait::Expression_MaskExpression_Select* mutable_child();
  void set_allocated_child(::substrait::Expression_MaskExpression_Select* child);
  private:
  const ::substrait::Expression_MaskExpression_Select& _internal_child() const;
  ::substrait::Expression_MaskExpression_Select* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::substrait::Expression_MaskExpression_Select* child);
  ::substrait::Expression_MaskExpression_Select* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem > selection_;
  ::substrait::Expression_MaskExpression_Select* child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_MapSelect_MapKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.MapSelect.MapKey) */ {
 public:
  inline Expression_MaskExpression_MapSelect_MapKey() : Expression_MaskExpression_MapSelect_MapKey(nullptr) {}
  ~Expression_MaskExpression_MapSelect_MapKey() override;
  explicit constexpr Expression_MaskExpression_MapSelect_MapKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression_MapSelect_MapKey(const Expression_MaskExpression_MapSelect_MapKey& from);
  Expression_MaskExpression_MapSelect_MapKey(Expression_MaskExpression_MapSelect_MapKey&& from) noexcept
    : Expression_MaskExpression_MapSelect_MapKey() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_MapSelect_MapKey& operator=(const Expression_MaskExpression_MapSelect_MapKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_MapSelect_MapKey& operator=(Expression_MaskExpression_MapSelect_MapKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_MapSelect_MapKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_MaskExpression_MapSelect_MapKey* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_MapSelect_MapKey*>(
               &_Expression_MaskExpression_MapSelect_MapKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Expression_MaskExpression_MapSelect_MapKey& a, Expression_MaskExpression_MapSelect_MapKey& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression_MapSelect_MapKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_MapSelect_MapKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_MapSelect_MapKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression_MapSelect_MapKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_MapSelect_MapKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_MapSelect_MapKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_MapSelect_MapKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression.MapSelect.MapKey";
  }
  protected:
  explicit Expression_MaskExpression_MapSelect_MapKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapKeyFieldNumber = 1,
  };
  // string map_key = 1 [json_name = "mapKey"];
  void clear_map_key();
  const std::string& map_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_key();
  PROTOBUF_NODISCARD std::string* release_map_key();
  void set_allocated_map_key(std::string* map_key);
  private:
  const std::string& _internal_map_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_key(const std::string& value);
  std::string* _internal_mutable_map_key();
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.MapSelect.MapKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_MapSelect_MapKeyExpression final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression) */ {
 public:
  inline Expression_MaskExpression_MapSelect_MapKeyExpression() : Expression_MaskExpression_MapSelect_MapKeyExpression(nullptr) {}
  ~Expression_MaskExpression_MapSelect_MapKeyExpression() override;
  explicit constexpr Expression_MaskExpression_MapSelect_MapKeyExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression_MapSelect_MapKeyExpression(const Expression_MaskExpression_MapSelect_MapKeyExpression& from);
  Expression_MaskExpression_MapSelect_MapKeyExpression(Expression_MaskExpression_MapSelect_MapKeyExpression&& from) noexcept
    : Expression_MaskExpression_MapSelect_MapKeyExpression() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_MapSelect_MapKeyExpression& operator=(const Expression_MaskExpression_MapSelect_MapKeyExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_MapSelect_MapKeyExpression& operator=(Expression_MaskExpression_MapSelect_MapKeyExpression&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_MapSelect_MapKeyExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_MaskExpression_MapSelect_MapKeyExpression* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_MapSelect_MapKeyExpression*>(
               &_Expression_MaskExpression_MapSelect_MapKeyExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(Expression_MaskExpression_MapSelect_MapKeyExpression& a, Expression_MaskExpression_MapSelect_MapKeyExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression_MapSelect_MapKeyExpression* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_MapSelect_MapKeyExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_MapSelect_MapKeyExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression_MapSelect_MapKeyExpression>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_MapSelect_MapKeyExpression& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_MapSelect_MapKeyExpression& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_MapSelect_MapKeyExpression* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression.MapSelect.MapKeyExpression";
  }
  protected:
  explicit Expression_MaskExpression_MapSelect_MapKeyExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapKeyExpressionFieldNumber = 1,
  };
  // string map_key_expression = 1 [json_name = "mapKeyExpression"];
  void clear_map_key_expression();
  const std::string& map_key_expression() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_key_expression(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_key_expression();
  PROTOBUF_NODISCARD std::string* release_map_key_expression();
  void set_allocated_map_key_expression(std::string* map_key_expression);
  private:
  const std::string& _internal_map_key_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_key_expression(const std::string& value);
  std::string* _internal_mutable_map_key_expression();
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_key_expression_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_MapSelect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.MapSelect) */ {
 public:
  inline Expression_MaskExpression_MapSelect() : Expression_MaskExpression_MapSelect(nullptr) {}
  ~Expression_MaskExpression_MapSelect() override;
  explicit constexpr Expression_MaskExpression_MapSelect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression_MapSelect(const Expression_MaskExpression_MapSelect& from);
  Expression_MaskExpression_MapSelect(Expression_MaskExpression_MapSelect&& from) noexcept
    : Expression_MaskExpression_MapSelect() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_MapSelect& operator=(const Expression_MaskExpression_MapSelect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_MapSelect& operator=(Expression_MaskExpression_MapSelect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_MapSelect& default_instance() {
    return *internal_default_instance();
  }
  enum SelectCase {
    kKey = 1,
    kExpression = 2,
    SELECT_NOT_SET = 0,
  };

  static inline const Expression_MaskExpression_MapSelect* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_MapSelect*>(
               &_Expression_MaskExpression_MapSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(Expression_MaskExpression_MapSelect& a, Expression_MaskExpression_MapSelect& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression_MapSelect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_MapSelect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_MapSelect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression_MapSelect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_MapSelect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_MapSelect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_MapSelect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression.MapSelect";
  }
  protected:
  explicit Expression_MaskExpression_MapSelect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_MaskExpression_MapSelect_MapKey MapKey;
  typedef Expression_MaskExpression_MapSelect_MapKeyExpression MapKeyExpression;

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 3,
    kKeyFieldNumber = 1,
    kExpressionFieldNumber = 2,
  };
  // .substrait.Expression.MaskExpression.Select child = 3 [json_name = "child"];
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::substrait::Expression_MaskExpression_Select& child() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_Select* release_child();
  ::substrait::Expression_MaskExpression_Select* mutable_child();
  void set_allocated_child(::substrait::Expression_MaskExpression_Select* child);
  private:
  const ::substrait::Expression_MaskExpression_Select& _internal_child() const;
  ::substrait::Expression_MaskExpression_Select* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::substrait::Expression_MaskExpression_Select* child);
  ::substrait::Expression_MaskExpression_Select* unsafe_arena_release_child();

  // .substrait.Expression.MaskExpression.MapSelect.MapKey key = 1 [json_name = "key"];
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::substrait::Expression_MaskExpression_MapSelect_MapKey& key() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_MapSelect_MapKey* release_key();
  ::substrait::Expression_MaskExpression_MapSelect_MapKey* mutable_key();
  void set_allocated_key(::substrait::Expression_MaskExpression_MapSelect_MapKey* key);
  private:
  const ::substrait::Expression_MaskExpression_MapSelect_MapKey& _internal_key() const;
  ::substrait::Expression_MaskExpression_MapSelect_MapKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::substrait::Expression_MaskExpression_MapSelect_MapKey* key);
  ::substrait::Expression_MaskExpression_MapSelect_MapKey* unsafe_arena_release_key();

  // .substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression = 2 [json_name = "expression"];
  bool has_expression() const;
  private:
  bool _internal_has_expression() const;
  public:
  void clear_expression();
  const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& expression() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* release_expression();
  ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* mutable_expression();
  void set_allocated_expression(::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* expression);
  private:
  const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& _internal_expression() const;
  ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* _internal_mutable_expression();
  public:
  void unsafe_arena_set_allocated_expression(
      ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* expression);
  ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* unsafe_arena_release_expression();

  void clear_select();
  SelectCase select_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.MapSelect)
 private:
  class _Internal;
  void set_has_key();
  void set_has_expression();

  inline bool has_select() const;
  inline void clear_has_select();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Expression_MaskExpression_Select* child_;
  union SelectUnion {
    constexpr SelectUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::substrait::Expression_MaskExpression_MapSelect_MapKey* key_;
    ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* expression_;
  } select_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_MaskExpression final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression) */ {
 public:
  inline Expression_MaskExpression() : Expression_MaskExpression(nullptr) {}
  ~Expression_MaskExpression() override;
  explicit constexpr Expression_MaskExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_MaskExpression(const Expression_MaskExpression& from);
  Expression_MaskExpression(Expression_MaskExpression&& from) noexcept
    : Expression_MaskExpression() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression& operator=(const Expression_MaskExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression& operator=(Expression_MaskExpression&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_MaskExpression* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression*>(
               &_Expression_MaskExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(Expression_MaskExpression& a, Expression_MaskExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_MaskExpression* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_MaskExpression>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.MaskExpression";
  }
  protected:
  explicit Expression_MaskExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_MaskExpression_Select Select;
  typedef Expression_MaskExpression_StructSelect StructSelect;
  typedef Expression_MaskExpression_StructItem StructItem;
  typedef Expression_MaskExpression_ListSelect ListSelect;
  typedef Expression_MaskExpression_MapSelect MapSelect;

  // accessors -------------------------------------------------------

  enum : int {
    kSelectFieldNumber = 1,
    kMaintainSingularStructFieldNumber = 2,
  };
  // .substrait.Expression.MaskExpression.StructSelect select = 1 [json_name = "select"];
  bool has_select() const;
  private:
  bool _internal_has_select() const;
  public:
  void clear_select();
  const ::substrait::Expression_MaskExpression_StructSelect& select() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression_StructSelect* release_select();
  ::substrait::Expression_MaskExpression_StructSelect* mutable_select();
  void set_allocated_select(::substrait::Expression_MaskExpression_StructSelect* select);
  private:
  const ::substrait::Expression_MaskExpression_StructSelect& _internal_select() const;
  ::substrait::Expression_MaskExpression_StructSelect* _internal_mutable_select();
  public:
  void unsafe_arena_set_allocated_select(
      ::substrait::Expression_MaskExpression_StructSelect* select);
  ::substrait::Expression_MaskExpression_StructSelect* unsafe_arena_release_select();

  // bool maintain_singular_struct = 2 [json_name = "maintainSingularStruct"];
  void clear_maintain_singular_struct();
  bool maintain_singular_struct() const;
  void set_maintain_singular_struct(bool value);
  private:
  bool _internal_maintain_singular_struct() const;
  void _internal_set_maintain_singular_struct(bool value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Expression_MaskExpression_StructSelect* select_;
  bool maintain_singular_struct_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_FieldReference_RootReference final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:substrait.Expression.FieldReference.RootReference) */ {
 public:
  inline Expression_FieldReference_RootReference() : Expression_FieldReference_RootReference(nullptr) {}
  explicit constexpr Expression_FieldReference_RootReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_FieldReference_RootReference(const Expression_FieldReference_RootReference& from);
  Expression_FieldReference_RootReference(Expression_FieldReference_RootReference&& from) noexcept
    : Expression_FieldReference_RootReference() {
    *this = ::std::move(from);
  }

  inline Expression_FieldReference_RootReference& operator=(const Expression_FieldReference_RootReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_FieldReference_RootReference& operator=(Expression_FieldReference_RootReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_FieldReference_RootReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression_FieldReference_RootReference* internal_default_instance() {
    return reinterpret_cast<const Expression_FieldReference_RootReference*>(
               &_Expression_FieldReference_RootReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(Expression_FieldReference_RootReference& a, Expression_FieldReference_RootReference& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_FieldReference_RootReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_FieldReference_RootReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_FieldReference_RootReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_FieldReference_RootReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Expression_FieldReference_RootReference& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Expression_FieldReference_RootReference& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.FieldReference.RootReference";
  }
  protected:
  explicit Expression_FieldReference_RootReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.Expression.FieldReference.RootReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression_FieldReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.FieldReference) */ {
 public:
  inline Expression_FieldReference() : Expression_FieldReference(nullptr) {}
  ~Expression_FieldReference() override;
  explicit constexpr Expression_FieldReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression_FieldReference(const Expression_FieldReference& from);
  Expression_FieldReference(Expression_FieldReference&& from) noexcept
    : Expression_FieldReference() {
    *this = ::std::move(from);
  }

  inline Expression_FieldReference& operator=(const Expression_FieldReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_FieldReference& operator=(Expression_FieldReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_FieldReference& default_instance() {
    return *internal_default_instance();
  }
  enum ReferenceTypeCase {
    kDirectReference = 1,
    kMaskedReference = 2,
    REFERENCE_TYPE_NOT_SET = 0,
  };

  enum RootTypeCase {
    kExpression = 3,
    kRootReference = 4,
    ROOT_TYPE_NOT_SET = 0,
  };

  static inline const Expression_FieldReference* internal_default_instance() {
    return reinterpret_cast<const Expression_FieldReference*>(
               &_Expression_FieldReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Expression_FieldReference& a, Expression_FieldReference& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression_FieldReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_FieldReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_FieldReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression_FieldReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression_FieldReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression_FieldReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_FieldReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression.FieldReference";
  }
  protected:
  explicit Expression_FieldReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_FieldReference_RootReference RootReference;

  // accessors -------------------------------------------------------

  enum : int {
    kDirectReferenceFieldNumber = 1,
    kMaskedReferenceFieldNumber = 2,
    kExpressionFieldNumber = 3,
    kRootReferenceFieldNumber = 4,
  };
  // .substrait.Expression.ReferenceSegment direct_reference = 1 [json_name = "directReference"];
  bool has_direct_reference() const;
  private:
  bool _internal_has_direct_reference() const;
  public:
  void clear_direct_reference();
  const ::substrait::Expression_ReferenceSegment& direct_reference() const;
  PROTOBUF_NODISCARD ::substrait::Expression_ReferenceSegment* release_direct_reference();
  ::substrait::Expression_ReferenceSegment* mutable_direct_reference();
  void set_allocated_direct_reference(::substrait::Expression_ReferenceSegment* direct_reference);
  private:
  const ::substrait::Expression_ReferenceSegment& _internal_direct_reference() const;
  ::substrait::Expression_ReferenceSegment* _internal_mutable_direct_reference();
  public:
  void unsafe_arena_set_allocated_direct_reference(
      ::substrait::Expression_ReferenceSegment* direct_reference);
  ::substrait::Expression_ReferenceSegment* unsafe_arena_release_direct_reference();

  // .substrait.Expression.MaskExpression masked_reference = 2 [json_name = "maskedReference"];
  bool has_masked_reference() const;
  private:
  bool _internal_has_masked_reference() const;
  public:
  void clear_masked_reference();
  const ::substrait::Expression_MaskExpression& masked_reference() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MaskExpression* release_masked_reference();
  ::substrait::Expression_MaskExpression* mutable_masked_reference();
  void set_allocated_masked_reference(::substrait::Expression_MaskExpression* masked_reference);
  private:
  const ::substrait::Expression_MaskExpression& _internal_masked_reference() const;
  ::substrait::Expression_MaskExpression* _internal_mutable_masked_reference();
  public:
  void unsafe_arena_set_allocated_masked_reference(
      ::substrait::Expression_MaskExpression* masked_reference);
  ::substrait::Expression_MaskExpression* unsafe_arena_release_masked_reference();

  // .substrait.Expression expression = 3 [json_name = "expression"];
  bool has_expression() const;
  private:
  bool _internal_has_expression() const;
  public:
  void clear_expression();
  const ::substrait::Expression& expression() const;
  PROTOBUF_NODISCARD ::substrait::Expression* release_expression();
  ::substrait::Expression* mutable_expression();
  void set_allocated_expression(::substrait::Expression* expression);
  private:
  const ::substrait::Expression& _internal_expression() const;
  ::substrait::Expression* _internal_mutable_expression();
  public:
  void unsafe_arena_set_allocated_expression(
      ::substrait::Expression* expression);
  ::substrait::Expression* unsafe_arena_release_expression();

  // .substrait.Expression.FieldReference.RootReference root_reference = 4 [json_name = "rootReference"];
  bool has_root_reference() const;
  private:
  bool _internal_has_root_reference() const;
  public:
  void clear_root_reference();
  const ::substrait::Expression_FieldReference_RootReference& root_reference() const;
  PROTOBUF_NODISCARD ::substrait::Expression_FieldReference_RootReference* release_root_reference();
  ::substrait::Expression_FieldReference_RootReference* mutable_root_reference();
  void set_allocated_root_reference(::substrait::Expression_FieldReference_RootReference* root_reference);
  private:
  const ::substrait::Expression_FieldReference_RootReference& _internal_root_reference() const;
  ::substrait::Expression_FieldReference_RootReference* _internal_mutable_root_reference();
  public:
  void unsafe_arena_set_allocated_root_reference(
      ::substrait::Expression_FieldReference_RootReference* root_reference);
  ::substrait::Expression_FieldReference_RootReference* unsafe_arena_release_root_reference();

  void clear_reference_type();
  ReferenceTypeCase reference_type_case() const;
  void clear_root_type();
  RootTypeCase root_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.FieldReference)
 private:
  class _Internal;
  void set_has_direct_reference();
  void set_has_masked_reference();
  void set_has_expression();
  void set_has_root_reference();

  inline bool has_reference_type() const;
  inline void clear_has_reference_type();

  inline bool has_root_type() const;
  inline void clear_has_root_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ReferenceTypeUnion {
    constexpr ReferenceTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::substrait::Expression_ReferenceSegment* direct_reference_;
    ::substrait::Expression_MaskExpression* masked_reference_;
  } reference_type_;
  union RootTypeUnion {
    constexpr RootTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::substrait::Expression* expression_;
    ::substrait::Expression_FieldReference_RootReference* root_reference_;
  } root_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class Expression final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Expression) */ {
 public:
  inline Expression() : Expression(nullptr) {}
  ~Expression() override;
  explicit constexpr Expression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression(const Expression& from);
  Expression(Expression&& from) noexcept
    : Expression() {
    *this = ::std::move(from);
  }

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression& operator=(Expression&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression& default_instance() {
    return *internal_default_instance();
  }
  enum RexTypeCase {
    kLiteral = 1,
    kSelection = 2,
    kScalarFunction = 3,
    kWindowFunction = 5,
    kIfThen = 6,
    kSwitchExpression = 7,
    kSingularOrList = 8,
    kMultiOrList = 9,
    kEnum = 10,
    kCast = 11,
    REX_TYPE_NOT_SET = 0,
  };

  static inline const Expression* internal_default_instance() {
    return reinterpret_cast<const Expression*>(
               &_Expression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(Expression& a, Expression& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Expression& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Expression";
  }
  protected:
  explicit Expression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Enum Enum;
  typedef Expression_Literal Literal;
  typedef Expression_ScalarFunction ScalarFunction;
  typedef Expression_WindowFunction WindowFunction;
  typedef Expression_IfThen IfThen;
  typedef Expression_Cast Cast;
  typedef Expression_SwitchExpression SwitchExpression;
  typedef Expression_SingularOrList SingularOrList;
  typedef Expression_MultiOrList MultiOrList;
  typedef Expression_EmbeddedFunction EmbeddedFunction;
  typedef Expression_ReferenceSegment ReferenceSegment;
  typedef Expression_MaskExpression MaskExpression;
  typedef Expression_FieldReference FieldReference;

  // accessors -------------------------------------------------------

  enum : int {
    kLiteralFieldNumber = 1,
    kSelectionFieldNumber = 2,
    kScalarFunctionFieldNumber = 3,
    kWindowFunctionFieldNumber = 5,
    kIfThenFieldNumber = 6,
    kSwitchExpressionFieldNumber = 7,
    kSingularOrListFieldNumber = 8,
    kMultiOrListFieldNumber = 9,
    kEnumFieldNumber = 10,
    kCastFieldNumber = 11,
  };
  // .substrait.Expression.Literal literal = 1 [json_name = "literal"];
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const ::substrait::Expression_Literal& literal() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Literal* release_literal();
  ::substrait::Expression_Literal* mutable_literal();
  void set_allocated_literal(::substrait::Expression_Literal* literal);
  private:
  const ::substrait::Expression_Literal& _internal_literal() const;
  ::substrait::Expression_Literal* _internal_mutable_literal();
  public:
  void unsafe_arena_set_allocated_literal(
      ::substrait::Expression_Literal* literal);
  ::substrait::Expression_Literal* unsafe_arena_release_literal();

  // .substrait.Expression.FieldReference selection = 2 [json_name = "selection"];
  bool has_selection() const;
  private:
  bool _internal_has_selection() const;
  public:
  void clear_selection();
  const ::substrait::Expression_FieldReference& selection() const;
  PROTOBUF_NODISCARD ::substrait::Expression_FieldReference* release_selection();
  ::substrait::Expression_FieldReference* mutable_selection();
  void set_allocated_selection(::substrait::Expression_FieldReference* selection);
  private:
  const ::substrait::Expression_FieldReference& _internal_selection() const;
  ::substrait::Expression_FieldReference* _internal_mutable_selection();
  public:
  void unsafe_arena_set_allocated_selection(
      ::substrait::Expression_FieldReference* selection);
  ::substrait::Expression_FieldReference* unsafe_arena_release_selection();

  // .substrait.Expression.ScalarFunction scalar_function = 3 [json_name = "scalarFunction"];
  bool has_scalar_function() const;
  private:
  bool _internal_has_scalar_function() const;
  public:
  void clear_scalar_function();
  const ::substrait::Expression_ScalarFunction& scalar_function() const;
  PROTOBUF_NODISCARD ::substrait::Expression_ScalarFunction* release_scalar_function();
  ::substrait::Expression_ScalarFunction* mutable_scalar_function();
  void set_allocated_scalar_function(::substrait::Expression_ScalarFunction* scalar_function);
  private:
  const ::substrait::Expression_ScalarFunction& _internal_scalar_function() const;
  ::substrait::Expression_ScalarFunction* _internal_mutable_scalar_function();
  public:
  void unsafe_arena_set_allocated_scalar_function(
      ::substrait::Expression_ScalarFunction* scalar_function);
  ::substrait::Expression_ScalarFunction* unsafe_arena_release_scalar_function();

  // .substrait.Expression.WindowFunction window_function = 5 [json_name = "windowFunction"];
  bool has_window_function() const;
  private:
  bool _internal_has_window_function() const;
  public:
  void clear_window_function();
  const ::substrait::Expression_WindowFunction& window_function() const;
  PROTOBUF_NODISCARD ::substrait::Expression_WindowFunction* release_window_function();
  ::substrait::Expression_WindowFunction* mutable_window_function();
  void set_allocated_window_function(::substrait::Expression_WindowFunction* window_function);
  private:
  const ::substrait::Expression_WindowFunction& _internal_window_function() const;
  ::substrait::Expression_WindowFunction* _internal_mutable_window_function();
  public:
  void unsafe_arena_set_allocated_window_function(
      ::substrait::Expression_WindowFunction* window_function);
  ::substrait::Expression_WindowFunction* unsafe_arena_release_window_function();

  // .substrait.Expression.IfThen if_then = 6 [json_name = "ifThen"];
  bool has_if_then() const;
  private:
  bool _internal_has_if_then() const;
  public:
  void clear_if_then();
  const ::substrait::Expression_IfThen& if_then() const;
  PROTOBUF_NODISCARD ::substrait::Expression_IfThen* release_if_then();
  ::substrait::Expression_IfThen* mutable_if_then();
  void set_allocated_if_then(::substrait::Expression_IfThen* if_then);
  private:
  const ::substrait::Expression_IfThen& _internal_if_then() const;
  ::substrait::Expression_IfThen* _internal_mutable_if_then();
  public:
  void unsafe_arena_set_allocated_if_then(
      ::substrait::Expression_IfThen* if_then);
  ::substrait::Expression_IfThen* unsafe_arena_release_if_then();

  // .substrait.Expression.SwitchExpression switch_expression = 7 [json_name = "switchExpression"];
  bool has_switch_expression() const;
  private:
  bool _internal_has_switch_expression() const;
  public:
  void clear_switch_expression();
  const ::substrait::Expression_SwitchExpression& switch_expression() const;
  PROTOBUF_NODISCARD ::substrait::Expression_SwitchExpression* release_switch_expression();
  ::substrait::Expression_SwitchExpression* mutable_switch_expression();
  void set_allocated_switch_expression(::substrait::Expression_SwitchExpression* switch_expression);
  private:
  const ::substrait::Expression_SwitchExpression& _internal_switch_expression() const;
  ::substrait::Expression_SwitchExpression* _internal_mutable_switch_expression();
  public:
  void unsafe_arena_set_allocated_switch_expression(
      ::substrait::Expression_SwitchExpression* switch_expression);
  ::substrait::Expression_SwitchExpression* unsafe_arena_release_switch_expression();

  // .substrait.Expression.SingularOrList singular_or_list = 8 [json_name = "singularOrList"];
  bool has_singular_or_list() const;
  private:
  bool _internal_has_singular_or_list() const;
  public:
  void clear_singular_or_list();
  const ::substrait::Expression_SingularOrList& singular_or_list() const;
  PROTOBUF_NODISCARD ::substrait::Expression_SingularOrList* release_singular_or_list();
  ::substrait::Expression_SingularOrList* mutable_singular_or_list();
  void set_allocated_singular_or_list(::substrait::Expression_SingularOrList* singular_or_list);
  private:
  const ::substrait::Expression_SingularOrList& _internal_singular_or_list() const;
  ::substrait::Expression_SingularOrList* _internal_mutable_singular_or_list();
  public:
  void unsafe_arena_set_allocated_singular_or_list(
      ::substrait::Expression_SingularOrList* singular_or_list);
  ::substrait::Expression_SingularOrList* unsafe_arena_release_singular_or_list();

  // .substrait.Expression.MultiOrList multi_or_list = 9 [json_name = "multiOrList"];
  bool has_multi_or_list() const;
  private:
  bool _internal_has_multi_or_list() const;
  public:
  void clear_multi_or_list();
  const ::substrait::Expression_MultiOrList& multi_or_list() const;
  PROTOBUF_NODISCARD ::substrait::Expression_MultiOrList* release_multi_or_list();
  ::substrait::Expression_MultiOrList* mutable_multi_or_list();
  void set_allocated_multi_or_list(::substrait::Expression_MultiOrList* multi_or_list);
  private:
  const ::substrait::Expression_MultiOrList& _internal_multi_or_list() const;
  ::substrait::Expression_MultiOrList* _internal_mutable_multi_or_list();
  public:
  void unsafe_arena_set_allocated_multi_or_list(
      ::substrait::Expression_MultiOrList* multi_or_list);
  ::substrait::Expression_MultiOrList* unsafe_arena_release_multi_or_list();

  // .substrait.Expression.Enum enum = 10 [json_name = "enum"];
  bool has_enum_() const;
  private:
  bool _internal_has_enum_() const;
  public:
  void clear_enum_();
  const ::substrait::Expression_Enum& enum_() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Enum* release_enum_();
  ::substrait::Expression_Enum* mutable_enum_();
  void set_allocated_enum_(::substrait::Expression_Enum* enum_);
  private:
  const ::substrait::Expression_Enum& _internal_enum_() const;
  ::substrait::Expression_Enum* _internal_mutable_enum_();
  public:
  void unsafe_arena_set_allocated_enum_(
      ::substrait::Expression_Enum* enum_);
  ::substrait::Expression_Enum* unsafe_arena_release_enum_();

  // .substrait.Expression.Cast cast = 11 [json_name = "cast"];
  bool has_cast() const;
  private:
  bool _internal_has_cast() const;
  public:
  void clear_cast();
  const ::substrait::Expression_Cast& cast() const;
  PROTOBUF_NODISCARD ::substrait::Expression_Cast* release_cast();
  ::substrait::Expression_Cast* mutable_cast();
  void set_allocated_cast(::substrait::Expression_Cast* cast);
  private:
  const ::substrait::Expression_Cast& _internal_cast() const;
  ::substrait::Expression_Cast* _internal_mutable_cast();
  public:
  void unsafe_arena_set_allocated_cast(
      ::substrait::Expression_Cast* cast);
  ::substrait::Expression_Cast* unsafe_arena_release_cast();

  void clear_rex_type();
  RexTypeCase rex_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression)
 private:
  class _Internal;
  void set_has_literal();
  void set_has_selection();
  void set_has_scalar_function();
  void set_has_window_function();
  void set_has_if_then();
  void set_has_switch_expression();
  void set_has_singular_or_list();
  void set_has_multi_or_list();
  void set_has_enum_();
  void set_has_cast();

  inline bool has_rex_type() const;
  inline void clear_has_rex_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RexTypeUnion {
    constexpr RexTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::substrait::Expression_Literal* literal_;
    ::substrait::Expression_FieldReference* selection_;
    ::substrait::Expression_ScalarFunction* scalar_function_;
    ::substrait::Expression_WindowFunction* window_function_;
    ::substrait::Expression_IfThen* if_then_;
    ::substrait::Expression_SwitchExpression* switch_expression_;
    ::substrait::Expression_SingularOrList* singular_or_list_;
    ::substrait::Expression_MultiOrList* multi_or_list_;
    ::substrait::Expression_Enum* enum__;
    ::substrait::Expression_Cast* cast_;
  } rex_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class SortField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.SortField) */ {
 public:
  inline SortField() : SortField(nullptr) {}
  ~SortField() override;
  explicit constexpr SortField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SortField(const SortField& from);
  SortField(SortField&& from) noexcept
    : SortField() {
    *this = ::std::move(from);
  }

  inline SortField& operator=(const SortField& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortField& operator=(SortField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortField& default_instance() {
    return *internal_default_instance();
  }
  enum SortKindCase {
    kDirection = 2,
    kComparisonFunctionReference = 3,
    SORT_KIND_NOT_SET = 0,
  };

  static inline const SortField* internal_default_instance() {
    return reinterpret_cast<const SortField*>(
               &_SortField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(SortField& a, SortField& b) {
    a.Swap(&b);
  }
  inline void Swap(SortField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SortField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SortField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SortField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SortField& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.SortField";
  }
  protected:
  explicit SortField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SortField_SortDirection SortDirection;
  static constexpr SortDirection SORT_DIRECTION_UNSPECIFIED =
    SortField_SortDirection_SORT_DIRECTION_UNSPECIFIED;
  static constexpr SortDirection SORT_DIRECTION_ASC_NULLS_FIRST =
    SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_FIRST;
  static constexpr SortDirection SORT_DIRECTION_ASC_NULLS_LAST =
    SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_LAST;
  static constexpr SortDirection SORT_DIRECTION_DESC_NULLS_FIRST =
    SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_FIRST;
  static constexpr SortDirection SORT_DIRECTION_DESC_NULLS_LAST =
    SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_LAST;
  static constexpr SortDirection SORT_DIRECTION_CLUSTERED =
    SortField_SortDirection_SORT_DIRECTION_CLUSTERED;
  static inline bool SortDirection_IsValid(int value) {
    return SortField_SortDirection_IsValid(value);
  }
  static constexpr SortDirection SortDirection_MIN =
    SortField_SortDirection_SortDirection_MIN;
  static constexpr SortDirection SortDirection_MAX =
    SortField_SortDirection_SortDirection_MAX;
  static constexpr int SortDirection_ARRAYSIZE =
    SortField_SortDirection_SortDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SortDirection_descriptor() {
    return SortField_SortDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& SortDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SortDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SortDirection_Name.");
    return SortField_SortDirection_Name(enum_t_value);
  }
  static inline bool SortDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SortDirection* value) {
    return SortField_SortDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExprFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kComparisonFunctionReferenceFieldNumber = 3,
  };
  // .substrait.Expression expr = 1 [json_name = "expr"];
  bool has_expr() const;
  private:
  bool _internal_has_expr() const;
  public:
  void clear_expr();
  const ::substrait::Expression& expr() const;
  PROTOBUF_NODISCARD ::substrait::Expression* release_expr();
  ::substrait::Expression* mutable_expr();
  void set_allocated_expr(::substrait::Expression* expr);
  private:
  const ::substrait::Expression& _internal_expr() const;
  ::substrait::Expression* _internal_mutable_expr();
  public:
  void unsafe_arena_set_allocated_expr(
      ::substrait::Expression* expr);
  ::substrait::Expression* unsafe_arena_release_expr();

  // .substrait.SortField.SortDirection direction = 2 [json_name = "direction"];
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  ::substrait::SortField_SortDirection direction() const;
  void set_direction(::substrait::SortField_SortDirection value);
  private:
  ::substrait::SortField_SortDirection _internal_direction() const;
  void _internal_set_direction(::substrait::SortField_SortDirection value);
  public:

  // uint32 comparison_function_reference = 3 [json_name = "comparisonFunctionReference"];
  bool has_comparison_function_reference() const;
  private:
  bool _internal_has_comparison_function_reference() const;
  public:
  void clear_comparison_function_reference();
  uint32_t comparison_function_reference() const;
  void set_comparison_function_reference(uint32_t value);
  private:
  uint32_t _internal_comparison_function_reference() const;
  void _internal_set_comparison_function_reference(uint32_t value);
  public:

  void clear_sort_kind();
  SortKindCase sort_kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.SortField)
 private:
  class _Internal;
  void set_has_direction();
  void set_has_comparison_function_reference();

  inline bool has_sort_kind() const;
  inline void clear_has_sort_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Expression* expr_;
  union SortKindUnion {
    constexpr SortKindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int direction_;
    uint32_t comparison_function_reference_;
  } sort_kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// -------------------------------------------------------------------

class AggregateFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.AggregateFunction) */ {
 public:
  inline AggregateFunction() : AggregateFunction(nullptr) {}
  ~AggregateFunction() override;
  explicit constexpr AggregateFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregateFunction(const AggregateFunction& from);
  AggregateFunction(AggregateFunction&& from) noexcept
    : AggregateFunction() {
    *this = ::std::move(from);
  }

  inline AggregateFunction& operator=(const AggregateFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateFunction& operator=(AggregateFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateFunction* internal_default_instance() {
    return reinterpret_cast<const AggregateFunction*>(
               &_AggregateFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(AggregateFunction& a, AggregateFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggregateFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggregateFunction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.AggregateFunction";
  }
  protected:
  explicit AggregateFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kSortsFieldNumber = 3,
    kOutputTypeFieldNumber = 5,
    kFunctionReferenceFieldNumber = 1,
    kPhaseFieldNumber = 4,
  };
  // repeated .substrait.Expression args = 2 [json_name = "args"];
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::substrait::Expression* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
      mutable_args();
  private:
  const ::substrait::Expression& _internal_args(int index) const;
  ::substrait::Expression* _internal_add_args();
  public:
  const ::substrait::Expression& args(int index) const;
  ::substrait::Expression* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
      args() const;

  // repeated .substrait.SortField sorts = 3 [json_name = "sorts"];
  int sorts_size() const;
  private:
  int _internal_sorts_size() const;
  public:
  void clear_sorts();
  ::substrait::SortField* mutable_sorts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::SortField >*
      mutable_sorts();
  private:
  const ::substrait::SortField& _internal_sorts(int index) const;
  ::substrait::SortField* _internal_add_sorts();
  public:
  const ::substrait::SortField& sorts(int index) const;
  ::substrait::SortField* add_sorts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::SortField >&
      sorts() const;

  // .substrait.Type output_type = 5 [json_name = "outputType"];
  bool has_output_type() const;
  private:
  bool _internal_has_output_type() const;
  public:
  void clear_output_type();
  const ::substrait::Type& output_type() const;
  PROTOBUF_NODISCARD ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* output_type);
  private:
  const ::substrait::Type& _internal_output_type() const;
  ::substrait::Type* _internal_mutable_output_type();
  public:
  void unsafe_arena_set_allocated_output_type(
      ::substrait::Type* output_type);
  ::substrait::Type* unsafe_arena_release_output_type();

  // uint32 function_reference = 1 [json_name = "functionReference"];
  void clear_function_reference();
  uint32_t function_reference() const;
  void set_function_reference(uint32_t value);
  private:
  uint32_t _internal_function_reference() const;
  void _internal_set_function_reference(uint32_t value);
  public:

  // .substrait.AggregationPhase phase = 4 [json_name = "phase"];
  void clear_phase();
  ::substrait::AggregationPhase phase() const;
  void set_phase(::substrait::AggregationPhase value);
  private:
  ::substrait::AggregationPhase _internal_phase() const;
  void _internal_set_phase(::substrait::AggregationPhase value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.AggregateFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression > args_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::SortField > sorts_;
  ::substrait::Type* output_type_;
  uint32_t function_reference_;
  int phase_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2fexpression_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Expression_Enum_Empty

// -------------------------------------------------------------------

// Expression_Enum

// string specified = 1 [json_name = "specified"];
inline bool Expression_Enum::_internal_has_specified() const {
  return enum_kind_case() == kSpecified;
}
inline bool Expression_Enum::has_specified() const {
  return _internal_has_specified();
}
inline void Expression_Enum::set_has_specified() {
  _oneof_case_[0] = kSpecified;
}
inline void Expression_Enum::clear_specified() {
  if (_internal_has_specified()) {
    enum_kind_.specified_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_enum_kind();
  }
}
inline const std::string& Expression_Enum::specified() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Enum.specified)
  return _internal_specified();
}
template <typename ArgT0, typename... ArgT>
inline void Expression_Enum::set_specified(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_specified()) {
    clear_enum_kind();
    set_has_specified();
    enum_kind_.specified_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  enum_kind_.specified_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.Enum.specified)
}
inline std::string* Expression_Enum::mutable_specified() {
  std::string* _s = _internal_mutable_specified();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Enum.specified)
  return _s;
}
inline const std::string& Expression_Enum::_internal_specified() const {
  if (_internal_has_specified()) {
    return enum_kind_.specified_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Enum::_internal_set_specified(const std::string& value) {
  if (!_internal_has_specified()) {
    clear_enum_kind();
    set_has_specified();
    enum_kind_.specified_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  enum_kind_.specified_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_Enum::_internal_mutable_specified() {
  if (!_internal_has_specified()) {
    clear_enum_kind();
    set_has_specified();
    enum_kind_.specified_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return enum_kind_.specified_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_Enum::release_specified() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Enum.specified)
  if (_internal_has_specified()) {
    clear_has_enum_kind();
    return enum_kind_.specified_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Expression_Enum::set_allocated_specified(std::string* specified) {
  if (has_enum_kind()) {
    clear_enum_kind();
  }
  if (specified != nullptr) {
    set_has_specified();
    enum_kind_.specified_.UnsafeSetDefault(specified);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(specified);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Enum.specified)
}

// .substrait.Expression.Enum.Empty unspecified = 2 [json_name = "unspecified"];
inline bool Expression_Enum::_internal_has_unspecified() const {
  return enum_kind_case() == kUnspecified;
}
inline bool Expression_Enum::has_unspecified() const {
  return _internal_has_unspecified();
}
inline void Expression_Enum::set_has_unspecified() {
  _oneof_case_[0] = kUnspecified;
}
inline void Expression_Enum::clear_unspecified() {
  if (_internal_has_unspecified()) {
    if (GetArenaForAllocation() == nullptr) {
      delete enum_kind_.unspecified_;
    }
    clear_has_enum_kind();
  }
}
inline ::substrait::Expression_Enum_Empty* Expression_Enum::release_unspecified() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Enum.unspecified)
  if (_internal_has_unspecified()) {
    clear_has_enum_kind();
      ::substrait::Expression_Enum_Empty* temp = enum_kind_.unspecified_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    enum_kind_.unspecified_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Enum_Empty& Expression_Enum::_internal_unspecified() const {
  return _internal_has_unspecified()
      ? *enum_kind_.unspecified_
      : reinterpret_cast< ::substrait::Expression_Enum_Empty&>(::substrait::_Expression_Enum_Empty_default_instance_);
}
inline const ::substrait::Expression_Enum_Empty& Expression_Enum::unspecified() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Enum.unspecified)
  return _internal_unspecified();
}
inline ::substrait::Expression_Enum_Empty* Expression_Enum::unsafe_arena_release_unspecified() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Enum.unspecified)
  if (_internal_has_unspecified()) {
    clear_has_enum_kind();
    ::substrait::Expression_Enum_Empty* temp = enum_kind_.unspecified_;
    enum_kind_.unspecified_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Enum::unsafe_arena_set_allocated_unspecified(::substrait::Expression_Enum_Empty* unspecified) {
  clear_enum_kind();
  if (unspecified) {
    set_has_unspecified();
    enum_kind_.unspecified_ = unspecified;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Enum.unspecified)
}
inline ::substrait::Expression_Enum_Empty* Expression_Enum::_internal_mutable_unspecified() {
  if (!_internal_has_unspecified()) {
    clear_enum_kind();
    set_has_unspecified();
    enum_kind_.unspecified_ = CreateMaybeMessage< ::substrait::Expression_Enum_Empty >(GetArenaForAllocation());
  }
  return enum_kind_.unspecified_;
}
inline ::substrait::Expression_Enum_Empty* Expression_Enum::mutable_unspecified() {
  ::substrait::Expression_Enum_Empty* _msg = _internal_mutable_unspecified();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Enum.unspecified)
  return _msg;
}

inline bool Expression_Enum::has_enum_kind() const {
  return enum_kind_case() != ENUM_KIND_NOT_SET;
}
inline void Expression_Enum::clear_has_enum_kind() {
  _oneof_case_[0] = ENUM_KIND_NOT_SET;
}
inline Expression_Enum::EnumKindCase Expression_Enum::enum_kind_case() const {
  return Expression_Enum::EnumKindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_Literal_VarChar

// string value = 1 [json_name = "value"];
inline void Expression_Literal_VarChar::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Expression_Literal_VarChar::value() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.VarChar.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Expression_Literal_VarChar::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.VarChar.value)
}
inline std::string* Expression_Literal_VarChar::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.VarChar.value)
  return _s;
}
inline const std::string& Expression_Literal_VarChar::_internal_value() const {
  return value_.Get();
}
inline void Expression_Literal_VarChar::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_Literal_VarChar::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_Literal_VarChar::release_value() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.VarChar.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Expression_Literal_VarChar::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.VarChar.value)
}

// uint32 length = 2 [json_name = "length"];
inline void Expression_Literal_VarChar::clear_length() {
  length_ = 0u;
}
inline uint32_t Expression_Literal_VarChar::_internal_length() const {
  return length_;
}
inline uint32_t Expression_Literal_VarChar::length() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.VarChar.length)
  return _internal_length();
}
inline void Expression_Literal_VarChar::_internal_set_length(uint32_t value) {
  
  length_ = value;
}
inline void Expression_Literal_VarChar::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.VarChar.length)
}

// -------------------------------------------------------------------

// Expression_Literal_Decimal

// bytes value = 1 [json_name = "value"];
inline void Expression_Literal_Decimal::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Expression_Literal_Decimal::value() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Decimal.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Expression_Literal_Decimal::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.Decimal.value)
}
inline std::string* Expression_Literal_Decimal::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Decimal.value)
  return _s;
}
inline const std::string& Expression_Literal_Decimal::_internal_value() const {
  return value_.Get();
}
inline void Expression_Literal_Decimal::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_Literal_Decimal::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_Literal_Decimal::release_value() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.Decimal.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Expression_Literal_Decimal::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.Decimal.value)
}

// int32 precision = 2 [json_name = "precision"];
inline void Expression_Literal_Decimal::clear_precision() {
  precision_ = 0;
}
inline int32_t Expression_Literal_Decimal::_internal_precision() const {
  return precision_;
}
inline int32_t Expression_Literal_Decimal::precision() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Decimal.precision)
  return _internal_precision();
}
inline void Expression_Literal_Decimal::_internal_set_precision(int32_t value) {
  
  precision_ = value;
}
inline void Expression_Literal_Decimal::set_precision(int32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.Decimal.precision)
}

// int32 scale = 3 [json_name = "scale"];
inline void Expression_Literal_Decimal::clear_scale() {
  scale_ = 0;
}
inline int32_t Expression_Literal_Decimal::_internal_scale() const {
  return scale_;
}
inline int32_t Expression_Literal_Decimal::scale() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Decimal.scale)
  return _internal_scale();
}
inline void Expression_Literal_Decimal::_internal_set_scale(int32_t value) {
  
  scale_ = value;
}
inline void Expression_Literal_Decimal::set_scale(int32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.Decimal.scale)
}

// -------------------------------------------------------------------

// Expression_Literal_Map_KeyValue

// .substrait.Expression.Literal key = 1 [json_name = "key"];
inline bool Expression_Literal_Map_KeyValue::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool Expression_Literal_Map_KeyValue::has_key() const {
  return _internal_has_key();
}
inline void Expression_Literal_Map_KeyValue::clear_key() {
  if (GetArenaForAllocation() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::_internal_key() const {
  const ::substrait::Expression_Literal* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_Literal&>(
      ::substrait::_Expression_Literal_default_instance_);
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::key() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Map.KeyValue.key)
  return _internal_key();
}
inline void Expression_Literal_Map_KeyValue::unsafe_arena_set_allocated_key(
    ::substrait::Expression_Literal* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.Map.KeyValue.key)
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::release_key() {
  
  ::substrait::Expression_Literal* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.Map.KeyValue.key)
  
  ::substrait::Expression_Literal* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_Literal>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::mutable_key() {
  ::substrait::Expression_Literal* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Map.KeyValue.key)
  return _msg;
}
inline void Expression_Literal_Map_KeyValue::set_allocated_key(::substrait::Expression_Literal* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_Literal>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.Map.KeyValue.key)
}

// .substrait.Expression.Literal value = 2 [json_name = "value"];
inline bool Expression_Literal_Map_KeyValue::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool Expression_Literal_Map_KeyValue::has_value() const {
  return _internal_has_value();
}
inline void Expression_Literal_Map_KeyValue::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::_internal_value() const {
  const ::substrait::Expression_Literal* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_Literal&>(
      ::substrait::_Expression_Literal_default_instance_);
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::value() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Map.KeyValue.value)
  return _internal_value();
}
inline void Expression_Literal_Map_KeyValue::unsafe_arena_set_allocated_value(
    ::substrait::Expression_Literal* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.Map.KeyValue.value)
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::release_value() {
  
  ::substrait::Expression_Literal* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.Map.KeyValue.value)
  
  ::substrait::Expression_Literal* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_Literal>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::mutable_value() {
  ::substrait::Expression_Literal* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Map.KeyValue.value)
  return _msg;
}
inline void Expression_Literal_Map_KeyValue::set_allocated_value(::substrait::Expression_Literal* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_Literal>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.Map.KeyValue.value)
}

// -------------------------------------------------------------------

// Expression_Literal_Map

// repeated .substrait.Expression.Literal.Map.KeyValue key_values = 1 [json_name = "keyValues"];
inline int Expression_Literal_Map::_internal_key_values_size() const {
  return key_values_.size();
}
inline int Expression_Literal_Map::key_values_size() const {
  return _internal_key_values_size();
}
inline void Expression_Literal_Map::clear_key_values() {
  key_values_.Clear();
}
inline ::substrait::Expression_Literal_Map_KeyValue* Expression_Literal_Map::mutable_key_values(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Map.key_values)
  return key_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue >*
Expression_Literal_Map::mutable_key_values() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.Map.key_values)
  return &key_values_;
}
inline const ::substrait::Expression_Literal_Map_KeyValue& Expression_Literal_Map::_internal_key_values(int index) const {
  return key_values_.Get(index);
}
inline const ::substrait::Expression_Literal_Map_KeyValue& Expression_Literal_Map::key_values(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Map.key_values)
  return _internal_key_values(index);
}
inline ::substrait::Expression_Literal_Map_KeyValue* Expression_Literal_Map::_internal_add_key_values() {
  return key_values_.Add();
}
inline ::substrait::Expression_Literal_Map_KeyValue* Expression_Literal_Map::add_key_values() {
  ::substrait::Expression_Literal_Map_KeyValue* _add = _internal_add_key_values();
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.Map.key_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue >&
Expression_Literal_Map::key_values() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.Map.key_values)
  return key_values_;
}

// -------------------------------------------------------------------

// Expression_Literal_IntervalYearToMonth

// int32 years = 1 [json_name = "years"];
inline void Expression_Literal_IntervalYearToMonth::clear_years() {
  years_ = 0;
}
inline int32_t Expression_Literal_IntervalYearToMonth::_internal_years() const {
  return years_;
}
inline int32_t Expression_Literal_IntervalYearToMonth::years() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalYearToMonth.years)
  return _internal_years();
}
inline void Expression_Literal_IntervalYearToMonth::_internal_set_years(int32_t value) {
  
  years_ = value;
}
inline void Expression_Literal_IntervalYearToMonth::set_years(int32_t value) {
  _internal_set_years(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalYearToMonth.years)
}

// int32 months = 2 [json_name = "months"];
inline void Expression_Literal_IntervalYearToMonth::clear_months() {
  months_ = 0;
}
inline int32_t Expression_Literal_IntervalYearToMonth::_internal_months() const {
  return months_;
}
inline int32_t Expression_Literal_IntervalYearToMonth::months() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalYearToMonth.months)
  return _internal_months();
}
inline void Expression_Literal_IntervalYearToMonth::_internal_set_months(int32_t value) {
  
  months_ = value;
}
inline void Expression_Literal_IntervalYearToMonth::set_months(int32_t value) {
  _internal_set_months(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalYearToMonth.months)
}

// -------------------------------------------------------------------

// Expression_Literal_IntervalDayToSecond

// int32 days = 1 [json_name = "days"];
inline void Expression_Literal_IntervalDayToSecond::clear_days() {
  days_ = 0;
}
inline int32_t Expression_Literal_IntervalDayToSecond::_internal_days() const {
  return days_;
}
inline int32_t Expression_Literal_IntervalDayToSecond::days() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalDayToSecond.days)
  return _internal_days();
}
inline void Expression_Literal_IntervalDayToSecond::_internal_set_days(int32_t value) {
  
  days_ = value;
}
inline void Expression_Literal_IntervalDayToSecond::set_days(int32_t value) {
  _internal_set_days(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalDayToSecond.days)
}

// int32 seconds = 2 [json_name = "seconds"];
inline void Expression_Literal_IntervalDayToSecond::clear_seconds() {
  seconds_ = 0;
}
inline int32_t Expression_Literal_IntervalDayToSecond::_internal_seconds() const {
  return seconds_;
}
inline int32_t Expression_Literal_IntervalDayToSecond::seconds() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalDayToSecond.seconds)
  return _internal_seconds();
}
inline void Expression_Literal_IntervalDayToSecond::_internal_set_seconds(int32_t value) {
  
  seconds_ = value;
}
inline void Expression_Literal_IntervalDayToSecond::set_seconds(int32_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalDayToSecond.seconds)
}

// -------------------------------------------------------------------

// Expression_Literal_Struct

// repeated .substrait.Expression.Literal fields = 1 [json_name = "fields"];
inline int Expression_Literal_Struct::_internal_fields_size() const {
  return fields_.size();
}
inline int Expression_Literal_Struct::fields_size() const {
  return _internal_fields_size();
}
inline void Expression_Literal_Struct::clear_fields() {
  fields_.Clear();
}
inline ::substrait::Expression_Literal* Expression_Literal_Struct::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Struct.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal >*
Expression_Literal_Struct::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.Struct.fields)
  return &fields_;
}
inline const ::substrait::Expression_Literal& Expression_Literal_Struct::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::substrait::Expression_Literal& Expression_Literal_Struct::fields(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Struct.fields)
  return _internal_fields(index);
}
inline ::substrait::Expression_Literal* Expression_Literal_Struct::_internal_add_fields() {
  return fields_.Add();
}
inline ::substrait::Expression_Literal* Expression_Literal_Struct::add_fields() {
  ::substrait::Expression_Literal* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.Struct.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal >&
Expression_Literal_Struct::fields() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.Struct.fields)
  return fields_;
}

// -------------------------------------------------------------------

// Expression_Literal_List

// repeated .substrait.Expression.Literal values = 1 [json_name = "values"];
inline int Expression_Literal_List::_internal_values_size() const {
  return values_.size();
}
inline int Expression_Literal_List::values_size() const {
  return _internal_values_size();
}
inline void Expression_Literal_List::clear_values() {
  values_.Clear();
}
inline ::substrait::Expression_Literal* Expression_Literal_List::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.List.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal >*
Expression_Literal_List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.List.values)
  return &values_;
}
inline const ::substrait::Expression_Literal& Expression_Literal_List::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::substrait::Expression_Literal& Expression_Literal_List::values(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.List.values)
  return _internal_values(index);
}
inline ::substrait::Expression_Literal* Expression_Literal_List::_internal_add_values() {
  return values_.Add();
}
inline ::substrait::Expression_Literal* Expression_Literal_List::add_values() {
  ::substrait::Expression_Literal* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.List.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_Literal >&
Expression_Literal_List::values() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.List.values)
  return values_;
}

// -------------------------------------------------------------------

// Expression_Literal

// bool boolean = 1 [json_name = "boolean"];
inline bool Expression_Literal::_internal_has_boolean() const {
  return literal_type_case() == kBoolean;
}
inline bool Expression_Literal::has_boolean() const {
  return _internal_has_boolean();
}
inline void Expression_Literal::set_has_boolean() {
  _oneof_case_[0] = kBoolean;
}
inline void Expression_Literal::clear_boolean() {
  if (_internal_has_boolean()) {
    literal_type_.boolean_ = false;
    clear_has_literal_type();
  }
}
inline bool Expression_Literal::_internal_boolean() const {
  if (_internal_has_boolean()) {
    return literal_type_.boolean_;
  }
  return false;
}
inline void Expression_Literal::_internal_set_boolean(bool value) {
  if (!_internal_has_boolean()) {
    clear_literal_type();
    set_has_boolean();
  }
  literal_type_.boolean_ = value;
}
inline bool Expression_Literal::boolean() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.boolean)
  return _internal_boolean();
}
inline void Expression_Literal::set_boolean(bool value) {
  _internal_set_boolean(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.boolean)
}

// int32 i8 = 2 [json_name = "i8"];
inline bool Expression_Literal::_internal_has_i8() const {
  return literal_type_case() == kI8;
}
inline bool Expression_Literal::has_i8() const {
  return _internal_has_i8();
}
inline void Expression_Literal::set_has_i8() {
  _oneof_case_[0] = kI8;
}
inline void Expression_Literal::clear_i8() {
  if (_internal_has_i8()) {
    literal_type_.i8_ = 0;
    clear_has_literal_type();
  }
}
inline int32_t Expression_Literal::_internal_i8() const {
  if (_internal_has_i8()) {
    return literal_type_.i8_;
  }
  return 0;
}
inline void Expression_Literal::_internal_set_i8(int32_t value) {
  if (!_internal_has_i8()) {
    clear_literal_type();
    set_has_i8();
  }
  literal_type_.i8_ = value;
}
inline int32_t Expression_Literal::i8() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i8)
  return _internal_i8();
}
inline void Expression_Literal::set_i8(int32_t value) {
  _internal_set_i8(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i8)
}

// int32 i16 = 3 [json_name = "i16"];
inline bool Expression_Literal::_internal_has_i16() const {
  return literal_type_case() == kI16;
}
inline bool Expression_Literal::has_i16() const {
  return _internal_has_i16();
}
inline void Expression_Literal::set_has_i16() {
  _oneof_case_[0] = kI16;
}
inline void Expression_Literal::clear_i16() {
  if (_internal_has_i16()) {
    literal_type_.i16_ = 0;
    clear_has_literal_type();
  }
}
inline int32_t Expression_Literal::_internal_i16() const {
  if (_internal_has_i16()) {
    return literal_type_.i16_;
  }
  return 0;
}
inline void Expression_Literal::_internal_set_i16(int32_t value) {
  if (!_internal_has_i16()) {
    clear_literal_type();
    set_has_i16();
  }
  literal_type_.i16_ = value;
}
inline int32_t Expression_Literal::i16() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i16)
  return _internal_i16();
}
inline void Expression_Literal::set_i16(int32_t value) {
  _internal_set_i16(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i16)
}

// int32 i32 = 5 [json_name = "i32"];
inline bool Expression_Literal::_internal_has_i32() const {
  return literal_type_case() == kI32;
}
inline bool Expression_Literal::has_i32() const {
  return _internal_has_i32();
}
inline void Expression_Literal::set_has_i32() {
  _oneof_case_[0] = kI32;
}
inline void Expression_Literal::clear_i32() {
  if (_internal_has_i32()) {
    literal_type_.i32_ = 0;
    clear_has_literal_type();
  }
}
inline int32_t Expression_Literal::_internal_i32() const {
  if (_internal_has_i32()) {
    return literal_type_.i32_;
  }
  return 0;
}
inline void Expression_Literal::_internal_set_i32(int32_t value) {
  if (!_internal_has_i32()) {
    clear_literal_type();
    set_has_i32();
  }
  literal_type_.i32_ = value;
}
inline int32_t Expression_Literal::i32() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i32)
  return _internal_i32();
}
inline void Expression_Literal::set_i32(int32_t value) {
  _internal_set_i32(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i32)
}

// int64 i64 = 7 [json_name = "i64"];
inline bool Expression_Literal::_internal_has_i64() const {
  return literal_type_case() == kI64;
}
inline bool Expression_Literal::has_i64() const {
  return _internal_has_i64();
}
inline void Expression_Literal::set_has_i64() {
  _oneof_case_[0] = kI64;
}
inline void Expression_Literal::clear_i64() {
  if (_internal_has_i64()) {
    literal_type_.i64_ = int64_t{0};
    clear_has_literal_type();
  }
}
inline int64_t Expression_Literal::_internal_i64() const {
  if (_internal_has_i64()) {
    return literal_type_.i64_;
  }
  return int64_t{0};
}
inline void Expression_Literal::_internal_set_i64(int64_t value) {
  if (!_internal_has_i64()) {
    clear_literal_type();
    set_has_i64();
  }
  literal_type_.i64_ = value;
}
inline int64_t Expression_Literal::i64() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i64)
  return _internal_i64();
}
inline void Expression_Literal::set_i64(int64_t value) {
  _internal_set_i64(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i64)
}

// float fp32 = 10 [json_name = "fp32"];
inline bool Expression_Literal::_internal_has_fp32() const {
  return literal_type_case() == kFp32;
}
inline bool Expression_Literal::has_fp32() const {
  return _internal_has_fp32();
}
inline void Expression_Literal::set_has_fp32() {
  _oneof_case_[0] = kFp32;
}
inline void Expression_Literal::clear_fp32() {
  if (_internal_has_fp32()) {
    literal_type_.fp32_ = 0;
    clear_has_literal_type();
  }
}
inline float Expression_Literal::_internal_fp32() const {
  if (_internal_has_fp32()) {
    return literal_type_.fp32_;
  }
  return 0;
}
inline void Expression_Literal::_internal_set_fp32(float value) {
  if (!_internal_has_fp32()) {
    clear_literal_type();
    set_has_fp32();
  }
  literal_type_.fp32_ = value;
}
inline float Expression_Literal::fp32() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fp32)
  return _internal_fp32();
}
inline void Expression_Literal::set_fp32(float value) {
  _internal_set_fp32(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fp32)
}

// double fp64 = 11 [json_name = "fp64"];
inline bool Expression_Literal::_internal_has_fp64() const {
  return literal_type_case() == kFp64;
}
inline bool Expression_Literal::has_fp64() const {
  return _internal_has_fp64();
}
inline void Expression_Literal::set_has_fp64() {
  _oneof_case_[0] = kFp64;
}
inline void Expression_Literal::clear_fp64() {
  if (_internal_has_fp64()) {
    literal_type_.fp64_ = 0;
    clear_has_literal_type();
  }
}
inline double Expression_Literal::_internal_fp64() const {
  if (_internal_has_fp64()) {
    return literal_type_.fp64_;
  }
  return 0;
}
inline void Expression_Literal::_internal_set_fp64(double value) {
  if (!_internal_has_fp64()) {
    clear_literal_type();
    set_has_fp64();
  }
  literal_type_.fp64_ = value;
}
inline double Expression_Literal::fp64() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fp64)
  return _internal_fp64();
}
inline void Expression_Literal::set_fp64(double value) {
  _internal_set_fp64(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fp64)
}

// string string = 12 [json_name = "string"];
inline bool Expression_Literal::_internal_has_string() const {
  return literal_type_case() == kString;
}
inline bool Expression_Literal::has_string() const {
  return _internal_has_string();
}
inline void Expression_Literal::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void Expression_Literal::clear_string() {
  if (_internal_has_string()) {
    literal_type_.string_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_literal_type();
  }
}
inline const std::string& Expression_Literal::string() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.string)
  return _internal_string();
}
template <typename ArgT0, typename... ArgT>
inline void Expression_Literal::set_string(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string()) {
    clear_literal_type();
    set_has_string();
    literal_type_.string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.string)
}
inline std::string* Expression_Literal::mutable_string() {
  std::string* _s = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.string)
  return _s;
}
inline const std::string& Expression_Literal::_internal_string() const {
  if (_internal_has_string()) {
    return literal_type_.string_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Literal::_internal_set_string(const std::string& value) {
  if (!_internal_has_string()) {
    clear_literal_type();
    set_has_string();
    literal_type_.string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_Literal::_internal_mutable_string() {
  if (!_internal_has_string()) {
    clear_literal_type();
    set_has_string();
    literal_type_.string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return literal_type_.string_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_Literal::release_string() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.string)
  if (_internal_has_string()) {
    clear_has_literal_type();
    return literal_type_.string_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::set_allocated_string(std::string* string) {
  if (has_literal_type()) {
    clear_literal_type();
  }
  if (string != nullptr) {
    set_has_string();
    literal_type_.string_.UnsafeSetDefault(string);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(string);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.string)
}

// bytes binary = 13 [json_name = "binary"];
inline bool Expression_Literal::_internal_has_binary() const {
  return literal_type_case() == kBinary;
}
inline bool Expression_Literal::has_binary() const {
  return _internal_has_binary();
}
inline void Expression_Literal::set_has_binary() {
  _oneof_case_[0] = kBinary;
}
inline void Expression_Literal::clear_binary() {
  if (_internal_has_binary()) {
    literal_type_.binary_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_literal_type();
  }
}
inline const std::string& Expression_Literal::binary() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.binary)
  return _internal_binary();
}
template <typename ArgT0, typename... ArgT>
inline void Expression_Literal::set_binary(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_binary()) {
    clear_literal_type();
    set_has_binary();
    literal_type_.binary_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.binary_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.binary)
}
inline std::string* Expression_Literal::mutable_binary() {
  std::string* _s = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.binary)
  return _s;
}
inline const std::string& Expression_Literal::_internal_binary() const {
  if (_internal_has_binary()) {
    return literal_type_.binary_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Literal::_internal_set_binary(const std::string& value) {
  if (!_internal_has_binary()) {
    clear_literal_type();
    set_has_binary();
    literal_type_.binary_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.binary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_Literal::_internal_mutable_binary() {
  if (!_internal_has_binary()) {
    clear_literal_type();
    set_has_binary();
    literal_type_.binary_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return literal_type_.binary_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_Literal::release_binary() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.binary)
  if (_internal_has_binary()) {
    clear_has_literal_type();
    return literal_type_.binary_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::set_allocated_binary(std::string* binary) {
  if (has_literal_type()) {
    clear_literal_type();
  }
  if (binary != nullptr) {
    set_has_binary();
    literal_type_.binary_.UnsafeSetDefault(binary);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(binary);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.binary)
}

// int64 timestamp = 14 [json_name = "timestamp"];
inline bool Expression_Literal::_internal_has_timestamp() const {
  return literal_type_case() == kTimestamp;
}
inline bool Expression_Literal::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Expression_Literal::set_has_timestamp() {
  _oneof_case_[0] = kTimestamp;
}
inline void Expression_Literal::clear_timestamp() {
  if (_internal_has_timestamp()) {
    literal_type_.timestamp_ = int64_t{0};
    clear_has_literal_type();
  }
}
inline int64_t Expression_Literal::_internal_timestamp() const {
  if (_internal_has_timestamp()) {
    return literal_type_.timestamp_;
  }
  return int64_t{0};
}
inline void Expression_Literal::_internal_set_timestamp(int64_t value) {
  if (!_internal_has_timestamp()) {
    clear_literal_type();
    set_has_timestamp();
  }
  literal_type_.timestamp_ = value;
}
inline int64_t Expression_Literal::timestamp() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.timestamp)
  return _internal_timestamp();
}
inline void Expression_Literal::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.timestamp)
}

// int32 date = 16 [json_name = "date"];
inline bool Expression_Literal::_internal_has_date() const {
  return literal_type_case() == kDate;
}
inline bool Expression_Literal::has_date() const {
  return _internal_has_date();
}
inline void Expression_Literal::set_has_date() {
  _oneof_case_[0] = kDate;
}
inline void Expression_Literal::clear_date() {
  if (_internal_has_date()) {
    literal_type_.date_ = 0;
    clear_has_literal_type();
  }
}
inline int32_t Expression_Literal::_internal_date() const {
  if (_internal_has_date()) {
    return literal_type_.date_;
  }
  return 0;
}
inline void Expression_Literal::_internal_set_date(int32_t value) {
  if (!_internal_has_date()) {
    clear_literal_type();
    set_has_date();
  }
  literal_type_.date_ = value;
}
inline int32_t Expression_Literal::date() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.date)
  return _internal_date();
}
inline void Expression_Literal::set_date(int32_t value) {
  _internal_set_date(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.date)
}

// int64 time = 17 [json_name = "time"];
inline bool Expression_Literal::_internal_has_time() const {
  return literal_type_case() == kTime;
}
inline bool Expression_Literal::has_time() const {
  return _internal_has_time();
}
inline void Expression_Literal::set_has_time() {
  _oneof_case_[0] = kTime;
}
inline void Expression_Literal::clear_time() {
  if (_internal_has_time()) {
    literal_type_.time_ = int64_t{0};
    clear_has_literal_type();
  }
}
inline int64_t Expression_Literal::_internal_time() const {
  if (_internal_has_time()) {
    return literal_type_.time_;
  }
  return int64_t{0};
}
inline void Expression_Literal::_internal_set_time(int64_t value) {
  if (!_internal_has_time()) {
    clear_literal_type();
    set_has_time();
  }
  literal_type_.time_ = value;
}
inline int64_t Expression_Literal::time() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.time)
  return _internal_time();
}
inline void Expression_Literal::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.time)
}

// .substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 19 [json_name = "intervalYearToMonth"];
inline bool Expression_Literal::_internal_has_interval_year_to_month() const {
  return literal_type_case() == kIntervalYearToMonth;
}
inline bool Expression_Literal::has_interval_year_to_month() const {
  return _internal_has_interval_year_to_month();
}
inline void Expression_Literal::set_has_interval_year_to_month() {
  _oneof_case_[0] = kIntervalYearToMonth;
}
inline void Expression_Literal::clear_interval_year_to_month() {
  if (_internal_has_interval_year_to_month()) {
    if (GetArenaForAllocation() == nullptr) {
      delete literal_type_.interval_year_to_month_;
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_IntervalYearToMonth* Expression_Literal::release_interval_year_to_month() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.interval_year_to_month)
  if (_internal_has_interval_year_to_month()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_IntervalYearToMonth* temp = literal_type_.interval_year_to_month_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    literal_type_.interval_year_to_month_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_IntervalYearToMonth& Expression_Literal::_internal_interval_year_to_month() const {
  return _internal_has_interval_year_to_month()
      ? *literal_type_.interval_year_to_month_
      : reinterpret_cast< ::substrait::Expression_Literal_IntervalYearToMonth&>(::substrait::_Expression_Literal_IntervalYearToMonth_default_instance_);
}
inline const ::substrait::Expression_Literal_IntervalYearToMonth& Expression_Literal::interval_year_to_month() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.interval_year_to_month)
  return _internal_interval_year_to_month();
}
inline ::substrait::Expression_Literal_IntervalYearToMonth* Expression_Literal::unsafe_arena_release_interval_year_to_month() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.interval_year_to_month)
  if (_internal_has_interval_year_to_month()) {
    clear_has_literal_type();
    ::substrait::Expression_Literal_IntervalYearToMonth* temp = literal_type_.interval_year_to_month_;
    literal_type_.interval_year_to_month_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_interval_year_to_month(::substrait::Expression_Literal_IntervalYearToMonth* interval_year_to_month) {
  clear_literal_type();
  if (interval_year_to_month) {
    set_has_interval_year_to_month();
    literal_type_.interval_year_to_month_ = interval_year_to_month;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.interval_year_to_month)
}
inline ::substrait::Expression_Literal_IntervalYearToMonth* Expression_Literal::_internal_mutable_interval_year_to_month() {
  if (!_internal_has_interval_year_to_month()) {
    clear_literal_type();
    set_has_interval_year_to_month();
    literal_type_.interval_year_to_month_ = CreateMaybeMessage< ::substrait::Expression_Literal_IntervalYearToMonth >(GetArenaForAllocation());
  }
  return literal_type_.interval_year_to_month_;
}
inline ::substrait::Expression_Literal_IntervalYearToMonth* Expression_Literal::mutable_interval_year_to_month() {
  ::substrait::Expression_Literal_IntervalYearToMonth* _msg = _internal_mutable_interval_year_to_month();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.interval_year_to_month)
  return _msg;
}

// .substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 20 [json_name = "intervalDayToSecond"];
inline bool Expression_Literal::_internal_has_interval_day_to_second() const {
  return literal_type_case() == kIntervalDayToSecond;
}
inline bool Expression_Literal::has_interval_day_to_second() const {
  return _internal_has_interval_day_to_second();
}
inline void Expression_Literal::set_has_interval_day_to_second() {
  _oneof_case_[0] = kIntervalDayToSecond;
}
inline void Expression_Literal::clear_interval_day_to_second() {
  if (_internal_has_interval_day_to_second()) {
    if (GetArenaForAllocation() == nullptr) {
      delete literal_type_.interval_day_to_second_;
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_IntervalDayToSecond* Expression_Literal::release_interval_day_to_second() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.interval_day_to_second)
  if (_internal_has_interval_day_to_second()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_IntervalDayToSecond* temp = literal_type_.interval_day_to_second_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    literal_type_.interval_day_to_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_IntervalDayToSecond& Expression_Literal::_internal_interval_day_to_second() const {
  return _internal_has_interval_day_to_second()
      ? *literal_type_.interval_day_to_second_
      : reinterpret_cast< ::substrait::Expression_Literal_IntervalDayToSecond&>(::substrait::_Expression_Literal_IntervalDayToSecond_default_instance_);
}
inline const ::substrait::Expression_Literal_IntervalDayToSecond& Expression_Literal::interval_day_to_second() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.interval_day_to_second)
  return _internal_interval_day_to_second();
}
inline ::substrait::Expression_Literal_IntervalDayToSecond* Expression_Literal::unsafe_arena_release_interval_day_to_second() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.interval_day_to_second)
  if (_internal_has_interval_day_to_second()) {
    clear_has_literal_type();
    ::substrait::Expression_Literal_IntervalDayToSecond* temp = literal_type_.interval_day_to_second_;
    literal_type_.interval_day_to_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_interval_day_to_second(::substrait::Expression_Literal_IntervalDayToSecond* interval_day_to_second) {
  clear_literal_type();
  if (interval_day_to_second) {
    set_has_interval_day_to_second();
    literal_type_.interval_day_to_second_ = interval_day_to_second;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.interval_day_to_second)
}
inline ::substrait::Expression_Literal_IntervalDayToSecond* Expression_Literal::_internal_mutable_interval_day_to_second() {
  if (!_internal_has_interval_day_to_second()) {
    clear_literal_type();
    set_has_interval_day_to_second();
    literal_type_.interval_day_to_second_ = CreateMaybeMessage< ::substrait::Expression_Literal_IntervalDayToSecond >(GetArenaForAllocation());
  }
  return literal_type_.interval_day_to_second_;
}
inline ::substrait::Expression_Literal_IntervalDayToSecond* Expression_Literal::mutable_interval_day_to_second() {
  ::substrait::Expression_Literal_IntervalDayToSecond* _msg = _internal_mutable_interval_day_to_second();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.interval_day_to_second)
  return _msg;
}

// string fixed_char = 21 [json_name = "fixedChar"];
inline bool Expression_Literal::_internal_has_fixed_char() const {
  return literal_type_case() == kFixedChar;
}
inline bool Expression_Literal::has_fixed_char() const {
  return _internal_has_fixed_char();
}
inline void Expression_Literal::set_has_fixed_char() {
  _oneof_case_[0] = kFixedChar;
}
inline void Expression_Literal::clear_fixed_char() {
  if (_internal_has_fixed_char()) {
    literal_type_.fixed_char_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_literal_type();
  }
}
inline const std::string& Expression_Literal::fixed_char() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fixed_char)
  return _internal_fixed_char();
}
template <typename ArgT0, typename... ArgT>
inline void Expression_Literal::set_fixed_char(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_fixed_char()) {
    clear_literal_type();
    set_has_fixed_char();
    literal_type_.fixed_char_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_char_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fixed_char)
}
inline std::string* Expression_Literal::mutable_fixed_char() {
  std::string* _s = _internal_mutable_fixed_char();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.fixed_char)
  return _s;
}
inline const std::string& Expression_Literal::_internal_fixed_char() const {
  if (_internal_has_fixed_char()) {
    return literal_type_.fixed_char_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Literal::_internal_set_fixed_char(const std::string& value) {
  if (!_internal_has_fixed_char()) {
    clear_literal_type();
    set_has_fixed_char();
    literal_type_.fixed_char_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_char_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_Literal::_internal_mutable_fixed_char() {
  if (!_internal_has_fixed_char()) {
    clear_literal_type();
    set_has_fixed_char();
    literal_type_.fixed_char_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return literal_type_.fixed_char_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_Literal::release_fixed_char() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.fixed_char)
  if (_internal_has_fixed_char()) {
    clear_has_literal_type();
    return literal_type_.fixed_char_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::set_allocated_fixed_char(std::string* fixed_char) {
  if (has_literal_type()) {
    clear_literal_type();
  }
  if (fixed_char != nullptr) {
    set_has_fixed_char();
    literal_type_.fixed_char_.UnsafeSetDefault(fixed_char);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(fixed_char);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.fixed_char)
}

// .substrait.Expression.Literal.VarChar var_char = 22 [json_name = "varChar"];
inline bool Expression_Literal::_internal_has_var_char() const {
  return literal_type_case() == kVarChar;
}
inline bool Expression_Literal::has_var_char() const {
  return _internal_has_var_char();
}
inline void Expression_Literal::set_has_var_char() {
  _oneof_case_[0] = kVarChar;
}
inline void Expression_Literal::clear_var_char() {
  if (_internal_has_var_char()) {
    if (GetArenaForAllocation() == nullptr) {
      delete literal_type_.var_char_;
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_VarChar* Expression_Literal::release_var_char() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.var_char)
  if (_internal_has_var_char()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_VarChar* temp = literal_type_.var_char_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    literal_type_.var_char_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_VarChar& Expression_Literal::_internal_var_char() const {
  return _internal_has_var_char()
      ? *literal_type_.var_char_
      : reinterpret_cast< ::substrait::Expression_Literal_VarChar&>(::substrait::_Expression_Literal_VarChar_default_instance_);
}
inline const ::substrait::Expression_Literal_VarChar& Expression_Literal::var_char() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.var_char)
  return _internal_var_char();
}
inline ::substrait::Expression_Literal_VarChar* Expression_Literal::unsafe_arena_release_var_char() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.var_char)
  if (_internal_has_var_char()) {
    clear_has_literal_type();
    ::substrait::Expression_Literal_VarChar* temp = literal_type_.var_char_;
    literal_type_.var_char_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_var_char(::substrait::Expression_Literal_VarChar* var_char) {
  clear_literal_type();
  if (var_char) {
    set_has_var_char();
    literal_type_.var_char_ = var_char;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.var_char)
}
inline ::substrait::Expression_Literal_VarChar* Expression_Literal::_internal_mutable_var_char() {
  if (!_internal_has_var_char()) {
    clear_literal_type();
    set_has_var_char();
    literal_type_.var_char_ = CreateMaybeMessage< ::substrait::Expression_Literal_VarChar >(GetArenaForAllocation());
  }
  return literal_type_.var_char_;
}
inline ::substrait::Expression_Literal_VarChar* Expression_Literal::mutable_var_char() {
  ::substrait::Expression_Literal_VarChar* _msg = _internal_mutable_var_char();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.var_char)
  return _msg;
}

// bytes fixed_binary = 23 [json_name = "fixedBinary"];
inline bool Expression_Literal::_internal_has_fixed_binary() const {
  return literal_type_case() == kFixedBinary;
}
inline bool Expression_Literal::has_fixed_binary() const {
  return _internal_has_fixed_binary();
}
inline void Expression_Literal::set_has_fixed_binary() {
  _oneof_case_[0] = kFixedBinary;
}
inline void Expression_Literal::clear_fixed_binary() {
  if (_internal_has_fixed_binary()) {
    literal_type_.fixed_binary_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_literal_type();
  }
}
inline const std::string& Expression_Literal::fixed_binary() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fixed_binary)
  return _internal_fixed_binary();
}
template <typename ArgT0, typename... ArgT>
inline void Expression_Literal::set_fixed_binary(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_fixed_binary()) {
    clear_literal_type();
    set_has_fixed_binary();
    literal_type_.fixed_binary_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_binary_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fixed_binary)
}
inline std::string* Expression_Literal::mutable_fixed_binary() {
  std::string* _s = _internal_mutable_fixed_binary();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.fixed_binary)
  return _s;
}
inline const std::string& Expression_Literal::_internal_fixed_binary() const {
  if (_internal_has_fixed_binary()) {
    return literal_type_.fixed_binary_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Literal::_internal_set_fixed_binary(const std::string& value) {
  if (!_internal_has_fixed_binary()) {
    clear_literal_type();
    set_has_fixed_binary();
    literal_type_.fixed_binary_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_binary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_Literal::_internal_mutable_fixed_binary() {
  if (!_internal_has_fixed_binary()) {
    clear_literal_type();
    set_has_fixed_binary();
    literal_type_.fixed_binary_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return literal_type_.fixed_binary_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_Literal::release_fixed_binary() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.fixed_binary)
  if (_internal_has_fixed_binary()) {
    clear_has_literal_type();
    return literal_type_.fixed_binary_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::set_allocated_fixed_binary(std::string* fixed_binary) {
  if (has_literal_type()) {
    clear_literal_type();
  }
  if (fixed_binary != nullptr) {
    set_has_fixed_binary();
    literal_type_.fixed_binary_.UnsafeSetDefault(fixed_binary);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(fixed_binary);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.fixed_binary)
}

// .substrait.Expression.Literal.Decimal decimal = 24 [json_name = "decimal"];
inline bool Expression_Literal::_internal_has_decimal() const {
  return literal_type_case() == kDecimal;
}
inline bool Expression_Literal::has_decimal() const {
  return _internal_has_decimal();
}
inline void Expression_Literal::set_has_decimal() {
  _oneof_case_[0] = kDecimal;
}
inline void Expression_Literal::clear_decimal() {
  if (_internal_has_decimal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete literal_type_.decimal_;
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_Decimal* Expression_Literal::release_decimal() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.decimal)
  if (_internal_has_decimal()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_Decimal* temp = literal_type_.decimal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    literal_type_.decimal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_Decimal& Expression_Literal::_internal_decimal() const {
  return _internal_has_decimal()
      ? *literal_type_.decimal_
      : reinterpret_cast< ::substrait::Expression_Literal_Decimal&>(::substrait::_Expression_Literal_Decimal_default_instance_);
}
inline const ::substrait::Expression_Literal_Decimal& Expression_Literal::decimal() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.decimal)
  return _internal_decimal();
}
inline ::substrait::Expression_Literal_Decimal* Expression_Literal::unsafe_arena_release_decimal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.decimal)
  if (_internal_has_decimal()) {
    clear_has_literal_type();
    ::substrait::Expression_Literal_Decimal* temp = literal_type_.decimal_;
    literal_type_.decimal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_decimal(::substrait::Expression_Literal_Decimal* decimal) {
  clear_literal_type();
  if (decimal) {
    set_has_decimal();
    literal_type_.decimal_ = decimal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.decimal)
}
inline ::substrait::Expression_Literal_Decimal* Expression_Literal::_internal_mutable_decimal() {
  if (!_internal_has_decimal()) {
    clear_literal_type();
    set_has_decimal();
    literal_type_.decimal_ = CreateMaybeMessage< ::substrait::Expression_Literal_Decimal >(GetArenaForAllocation());
  }
  return literal_type_.decimal_;
}
inline ::substrait::Expression_Literal_Decimal* Expression_Literal::mutable_decimal() {
  ::substrait::Expression_Literal_Decimal* _msg = _internal_mutable_decimal();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.decimal)
  return _msg;
}

// .substrait.Expression.Literal.Struct struct = 25 [json_name = "struct"];
inline bool Expression_Literal::_internal_has_struct_() const {
  return literal_type_case() == kStruct;
}
inline bool Expression_Literal::has_struct_() const {
  return _internal_has_struct_();
}
inline void Expression_Literal::set_has_struct_() {
  _oneof_case_[0] = kStruct;
}
inline void Expression_Literal::clear_struct_() {
  if (_internal_has_struct_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete literal_type_.struct__;
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_Struct* Expression_Literal::release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.struct)
  if (_internal_has_struct_()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_Struct* temp = literal_type_.struct__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    literal_type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_Struct& Expression_Literal::_internal_struct_() const {
  return _internal_has_struct_()
      ? *literal_type_.struct__
      : reinterpret_cast< ::substrait::Expression_Literal_Struct&>(::substrait::_Expression_Literal_Struct_default_instance_);
}
inline const ::substrait::Expression_Literal_Struct& Expression_Literal::struct_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.struct)
  return _internal_struct_();
}
inline ::substrait::Expression_Literal_Struct* Expression_Literal::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.struct)
  if (_internal_has_struct_()) {
    clear_has_literal_type();
    ::substrait::Expression_Literal_Struct* temp = literal_type_.struct__;
    literal_type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_struct_(::substrait::Expression_Literal_Struct* struct_) {
  clear_literal_type();
  if (struct_) {
    set_has_struct_();
    literal_type_.struct__ = struct_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.struct)
}
inline ::substrait::Expression_Literal_Struct* Expression_Literal::_internal_mutable_struct_() {
  if (!_internal_has_struct_()) {
    clear_literal_type();
    set_has_struct_();
    literal_type_.struct__ = CreateMaybeMessage< ::substrait::Expression_Literal_Struct >(GetArenaForAllocation());
  }
  return literal_type_.struct__;
}
inline ::substrait::Expression_Literal_Struct* Expression_Literal::mutable_struct_() {
  ::substrait::Expression_Literal_Struct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.struct)
  return _msg;
}

// .substrait.Expression.Literal.Map map = 26 [json_name = "map"];
inline bool Expression_Literal::_internal_has_map() const {
  return literal_type_case() == kMap;
}
inline bool Expression_Literal::has_map() const {
  return _internal_has_map();
}
inline void Expression_Literal::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void Expression_Literal::clear_map() {
  if (_internal_has_map()) {
    if (GetArenaForAllocation() == nullptr) {
      delete literal_type_.map_;
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_Map* Expression_Literal::release_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.map)
  if (_internal_has_map()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_Map* temp = literal_type_.map_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    literal_type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_Map& Expression_Literal::_internal_map() const {
  return _internal_has_map()
      ? *literal_type_.map_
      : reinterpret_cast< ::substrait::Expression_Literal_Map&>(::substrait::_Expression_Literal_Map_default_instance_);
}
inline const ::substrait::Expression_Literal_Map& Expression_Literal::map() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.map)
  return _internal_map();
}
inline ::substrait::Expression_Literal_Map* Expression_Literal::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.map)
  if (_internal_has_map()) {
    clear_has_literal_type();
    ::substrait::Expression_Literal_Map* temp = literal_type_.map_;
    literal_type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_map(::substrait::Expression_Literal_Map* map) {
  clear_literal_type();
  if (map) {
    set_has_map();
    literal_type_.map_ = map;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.map)
}
inline ::substrait::Expression_Literal_Map* Expression_Literal::_internal_mutable_map() {
  if (!_internal_has_map()) {
    clear_literal_type();
    set_has_map();
    literal_type_.map_ = CreateMaybeMessage< ::substrait::Expression_Literal_Map >(GetArenaForAllocation());
  }
  return literal_type_.map_;
}
inline ::substrait::Expression_Literal_Map* Expression_Literal::mutable_map() {
  ::substrait::Expression_Literal_Map* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.map)
  return _msg;
}

// int64 timestamp_tz = 27 [json_name = "timestampTz"];
inline bool Expression_Literal::_internal_has_timestamp_tz() const {
  return literal_type_case() == kTimestampTz;
}
inline bool Expression_Literal::has_timestamp_tz() const {
  return _internal_has_timestamp_tz();
}
inline void Expression_Literal::set_has_timestamp_tz() {
  _oneof_case_[0] = kTimestampTz;
}
inline void Expression_Literal::clear_timestamp_tz() {
  if (_internal_has_timestamp_tz()) {
    literal_type_.timestamp_tz_ = int64_t{0};
    clear_has_literal_type();
  }
}
inline int64_t Expression_Literal::_internal_timestamp_tz() const {
  if (_internal_has_timestamp_tz()) {
    return literal_type_.timestamp_tz_;
  }
  return int64_t{0};
}
inline void Expression_Literal::_internal_set_timestamp_tz(int64_t value) {
  if (!_internal_has_timestamp_tz()) {
    clear_literal_type();
    set_has_timestamp_tz();
  }
  literal_type_.timestamp_tz_ = value;
}
inline int64_t Expression_Literal::timestamp_tz() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.timestamp_tz)
  return _internal_timestamp_tz();
}
inline void Expression_Literal::set_timestamp_tz(int64_t value) {
  _internal_set_timestamp_tz(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.timestamp_tz)
}

// bytes uuid = 28 [json_name = "uuid"];
inline bool Expression_Literal::_internal_has_uuid() const {
  return literal_type_case() == kUuid;
}
inline bool Expression_Literal::has_uuid() const {
  return _internal_has_uuid();
}
inline void Expression_Literal::set_has_uuid() {
  _oneof_case_[0] = kUuid;
}
inline void Expression_Literal::clear_uuid() {
  if (_internal_has_uuid()) {
    literal_type_.uuid_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_literal_type();
  }
}
inline const std::string& Expression_Literal::uuid() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline void Expression_Literal::set_uuid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_uuid()) {
    clear_literal_type();
    set_has_uuid();
    literal_type_.uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.uuid)
}
inline std::string* Expression_Literal::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.uuid)
  return _s;
}
inline const std::string& Expression_Literal::_internal_uuid() const {
  if (_internal_has_uuid()) {
    return literal_type_.uuid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Literal::_internal_set_uuid(const std::string& value) {
  if (!_internal_has_uuid()) {
    clear_literal_type();
    set_has_uuid();
    literal_type_.uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_Literal::_internal_mutable_uuid() {
  if (!_internal_has_uuid()) {
    clear_literal_type();
    set_has_uuid();
    literal_type_.uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return literal_type_.uuid_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_Literal::release_uuid() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.uuid)
  if (_internal_has_uuid()) {
    clear_has_literal_type();
    return literal_type_.uuid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::set_allocated_uuid(std::string* uuid) {
  if (has_literal_type()) {
    clear_literal_type();
  }
  if (uuid != nullptr) {
    set_has_uuid();
    literal_type_.uuid_.UnsafeSetDefault(uuid);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(uuid);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.uuid)
}

// .substrait.Type null = 29 [json_name = "null"];
inline bool Expression_Literal::_internal_has_null() const {
  return literal_type_case() == kNull;
}
inline bool Expression_Literal::has_null() const {
  return _internal_has_null();
}
inline void Expression_Literal::set_has_null() {
  _oneof_case_[0] = kNull;
}
inline ::substrait::Type* Expression_Literal::release_null() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.null)
  if (_internal_has_null()) {
    clear_has_literal_type();
      ::substrait::Type* temp = literal_type_.null_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    literal_type_.null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type& Expression_Literal::_internal_null() const {
  return _internal_has_null()
      ? *literal_type_.null_
      : reinterpret_cast< ::substrait::Type&>(::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Expression_Literal::null() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.null)
  return _internal_null();
}
inline ::substrait::Type* Expression_Literal::unsafe_arena_release_null() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.null)
  if (_internal_has_null()) {
    clear_has_literal_type();
    ::substrait::Type* temp = literal_type_.null_;
    literal_type_.null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_null(::substrait::Type* null) {
  clear_literal_type();
  if (null) {
    set_has_null();
    literal_type_.null_ = null;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.null)
}
inline ::substrait::Type* Expression_Literal::_internal_mutable_null() {
  if (!_internal_has_null()) {
    clear_literal_type();
    set_has_null();
    literal_type_.null_ = CreateMaybeMessage< ::substrait::Type >(GetArenaForAllocation());
  }
  return literal_type_.null_;
}
inline ::substrait::Type* Expression_Literal::mutable_null() {
  ::substrait::Type* _msg = _internal_mutable_null();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.null)
  return _msg;
}

// .substrait.Expression.Literal.List list = 30 [json_name = "list"];
inline bool Expression_Literal::_internal_has_list() const {
  return literal_type_case() == kList;
}
inline bool Expression_Literal::has_list() const {
  return _internal_has_list();
}
inline void Expression_Literal::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void Expression_Literal::clear_list() {
  if (_internal_has_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete literal_type_.list_;
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_List* Expression_Literal::release_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.list)
  if (_internal_has_list()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_List* temp = literal_type_.list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    literal_type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_List& Expression_Literal::_internal_list() const {
  return _internal_has_list()
      ? *literal_type_.list_
      : reinterpret_cast< ::substrait::Expression_Literal_List&>(::substrait::_Expression_Literal_List_default_instance_);
}
inline const ::substrait::Expression_Literal_List& Expression_Literal::list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.list)
  return _internal_list();
}
inline ::substrait::Expression_Literal_List* Expression_Literal::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.list)
  if (_internal_has_list()) {
    clear_has_literal_type();
    ::substrait::Expression_Literal_List* temp = literal_type_.list_;
    literal_type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_list(::substrait::Expression_Literal_List* list) {
  clear_literal_type();
  if (list) {
    set_has_list();
    literal_type_.list_ = list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.list)
}
inline ::substrait::Expression_Literal_List* Expression_Literal::_internal_mutable_list() {
  if (!_internal_has_list()) {
    clear_literal_type();
    set_has_list();
    literal_type_.list_ = CreateMaybeMessage< ::substrait::Expression_Literal_List >(GetArenaForAllocation());
  }
  return literal_type_.list_;
}
inline ::substrait::Expression_Literal_List* Expression_Literal::mutable_list() {
  ::substrait::Expression_Literal_List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.list)
  return _msg;
}

// .substrait.Type.List empty_list = 31 [json_name = "emptyList"];
inline bool Expression_Literal::_internal_has_empty_list() const {
  return literal_type_case() == kEmptyList;
}
inline bool Expression_Literal::has_empty_list() const {
  return _internal_has_empty_list();
}
inline void Expression_Literal::set_has_empty_list() {
  _oneof_case_[0] = kEmptyList;
}
inline ::substrait::Type_List* Expression_Literal::release_empty_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.empty_list)
  if (_internal_has_empty_list()) {
    clear_has_literal_type();
      ::substrait::Type_List* temp = literal_type_.empty_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    literal_type_.empty_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_List& Expression_Literal::_internal_empty_list() const {
  return _internal_has_empty_list()
      ? *literal_type_.empty_list_
      : reinterpret_cast< ::substrait::Type_List&>(::substrait::_Type_List_default_instance_);
}
inline const ::substrait::Type_List& Expression_Literal::empty_list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.empty_list)
  return _internal_empty_list();
}
inline ::substrait::Type_List* Expression_Literal::unsafe_arena_release_empty_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.empty_list)
  if (_internal_has_empty_list()) {
    clear_has_literal_type();
    ::substrait::Type_List* temp = literal_type_.empty_list_;
    literal_type_.empty_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_empty_list(::substrait::Type_List* empty_list) {
  clear_literal_type();
  if (empty_list) {
    set_has_empty_list();
    literal_type_.empty_list_ = empty_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.empty_list)
}
inline ::substrait::Type_List* Expression_Literal::_internal_mutable_empty_list() {
  if (!_internal_has_empty_list()) {
    clear_literal_type();
    set_has_empty_list();
    literal_type_.empty_list_ = CreateMaybeMessage< ::substrait::Type_List >(GetArenaForAllocation());
  }
  return literal_type_.empty_list_;
}
inline ::substrait::Type_List* Expression_Literal::mutable_empty_list() {
  ::substrait::Type_List* _msg = _internal_mutable_empty_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.empty_list)
  return _msg;
}

// .substrait.Type.Map empty_map = 32 [json_name = "emptyMap"];
inline bool Expression_Literal::_internal_has_empty_map() const {
  return literal_type_case() == kEmptyMap;
}
inline bool Expression_Literal::has_empty_map() const {
  return _internal_has_empty_map();
}
inline void Expression_Literal::set_has_empty_map() {
  _oneof_case_[0] = kEmptyMap;
}
inline ::substrait::Type_Map* Expression_Literal::release_empty_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.empty_map)
  if (_internal_has_empty_map()) {
    clear_has_literal_type();
      ::substrait::Type_Map* temp = literal_type_.empty_map_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    literal_type_.empty_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Map& Expression_Literal::_internal_empty_map() const {
  return _internal_has_empty_map()
      ? *literal_type_.empty_map_
      : reinterpret_cast< ::substrait::Type_Map&>(::substrait::_Type_Map_default_instance_);
}
inline const ::substrait::Type_Map& Expression_Literal::empty_map() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.empty_map)
  return _internal_empty_map();
}
inline ::substrait::Type_Map* Expression_Literal::unsafe_arena_release_empty_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.empty_map)
  if (_internal_has_empty_map()) {
    clear_has_literal_type();
    ::substrait::Type_Map* temp = literal_type_.empty_map_;
    literal_type_.empty_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_empty_map(::substrait::Type_Map* empty_map) {
  clear_literal_type();
  if (empty_map) {
    set_has_empty_map();
    literal_type_.empty_map_ = empty_map;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.empty_map)
}
inline ::substrait::Type_Map* Expression_Literal::_internal_mutable_empty_map() {
  if (!_internal_has_empty_map()) {
    clear_literal_type();
    set_has_empty_map();
    literal_type_.empty_map_ = CreateMaybeMessage< ::substrait::Type_Map >(GetArenaForAllocation());
  }
  return literal_type_.empty_map_;
}
inline ::substrait::Type_Map* Expression_Literal::mutable_empty_map() {
  ::substrait::Type_Map* _msg = _internal_mutable_empty_map();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.empty_map)
  return _msg;
}

// bool nullable = 50 [json_name = "nullable"];
inline void Expression_Literal::clear_nullable() {
  nullable_ = false;
}
inline bool Expression_Literal::_internal_nullable() const {
  return nullable_;
}
inline bool Expression_Literal::nullable() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.nullable)
  return _internal_nullable();
}
inline void Expression_Literal::_internal_set_nullable(bool value) {
  
  nullable_ = value;
}
inline void Expression_Literal::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.nullable)
}

inline bool Expression_Literal::has_literal_type() const {
  return literal_type_case() != LITERAL_TYPE_NOT_SET;
}
inline void Expression_Literal::clear_has_literal_type() {
  _oneof_case_[0] = LITERAL_TYPE_NOT_SET;
}
inline Expression_Literal::LiteralTypeCase Expression_Literal::literal_type_case() const {
  return Expression_Literal::LiteralTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_ScalarFunction

// uint32 function_reference = 1 [json_name = "functionReference"];
inline void Expression_ScalarFunction::clear_function_reference() {
  function_reference_ = 0u;
}
inline uint32_t Expression_ScalarFunction::_internal_function_reference() const {
  return function_reference_;
}
inline uint32_t Expression_ScalarFunction::function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.function_reference)
  return _internal_function_reference();
}
inline void Expression_ScalarFunction::_internal_set_function_reference(uint32_t value) {
  
  function_reference_ = value;
}
inline void Expression_ScalarFunction::set_function_reference(uint32_t value) {
  _internal_set_function_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.ScalarFunction.function_reference)
}

// repeated .substrait.Expression args = 2 [json_name = "args"];
inline int Expression_ScalarFunction::_internal_args_size() const {
  return args_.size();
}
inline int Expression_ScalarFunction::args_size() const {
  return _internal_args_size();
}
inline void Expression_ScalarFunction::clear_args() {
  args_.Clear();
}
inline ::substrait::Expression* Expression_ScalarFunction::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ScalarFunction.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
Expression_ScalarFunction::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.ScalarFunction.args)
  return &args_;
}
inline const ::substrait::Expression& Expression_ScalarFunction::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::substrait::Expression& Expression_ScalarFunction::args(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.args)
  return _internal_args(index);
}
inline ::substrait::Expression* Expression_ScalarFunction::_internal_add_args() {
  return args_.Add();
}
inline ::substrait::Expression* Expression_ScalarFunction::add_args() {
  ::substrait::Expression* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:substrait.Expression.ScalarFunction.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
Expression_ScalarFunction::args() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.ScalarFunction.args)
  return args_;
}

// .substrait.Type output_type = 3 [json_name = "outputType"];
inline bool Expression_ScalarFunction::_internal_has_output_type() const {
  return this != internal_default_instance() && output_type_ != nullptr;
}
inline bool Expression_ScalarFunction::has_output_type() const {
  return _internal_has_output_type();
}
inline const ::substrait::Type& Expression_ScalarFunction::_internal_output_type() const {
  const ::substrait::Type* p = output_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(
      ::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Expression_ScalarFunction::output_type() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.output_type)
  return _internal_output_type();
}
inline void Expression_ScalarFunction::unsafe_arena_set_allocated_output_type(
    ::substrait::Type* output_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type_);
  }
  output_type_ = output_type;
  if (output_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ScalarFunction.output_type)
}
inline ::substrait::Type* Expression_ScalarFunction::release_output_type() {
  
  ::substrait::Type* temp = output_type_;
  output_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Type* Expression_ScalarFunction::unsafe_arena_release_output_type() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ScalarFunction.output_type)
  
  ::substrait::Type* temp = output_type_;
  output_type_ = nullptr;
  return temp;
}
inline ::substrait::Type* Expression_ScalarFunction::_internal_mutable_output_type() {
  
  if (output_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaForAllocation());
    output_type_ = p;
  }
  return output_type_;
}
inline ::substrait::Type* Expression_ScalarFunction::mutable_output_type() {
  ::substrait::Type* _msg = _internal_mutable_output_type();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ScalarFunction.output_type)
  return _msg;
}
inline void Expression_ScalarFunction::set_allocated_output_type(::substrait::Type* output_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type_);
  }
  if (output_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type));
    if (message_arena != submessage_arena) {
      output_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_type, submessage_arena);
    }
    
  } else {
    
  }
  output_type_ = output_type;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ScalarFunction.output_type)
}

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_Preceding

// int64 offset = 1 [json_name = "offset"];
inline void Expression_WindowFunction_Bound_Preceding::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t Expression_WindowFunction_Bound_Preceding::_internal_offset() const {
  return offset_;
}
inline int64_t Expression_WindowFunction_Bound_Preceding::offset() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.Preceding.offset)
  return _internal_offset();
}
inline void Expression_WindowFunction_Bound_Preceding::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void Expression_WindowFunction_Bound_Preceding::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.Bound.Preceding.offset)
}

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_Following

// int64 offset = 1 [json_name = "offset"];
inline void Expression_WindowFunction_Bound_Following::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t Expression_WindowFunction_Bound_Following::_internal_offset() const {
  return offset_;
}
inline int64_t Expression_WindowFunction_Bound_Following::offset() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.Following.offset)
  return _internal_offset();
}
inline void Expression_WindowFunction_Bound_Following::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void Expression_WindowFunction_Bound_Following::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.Bound.Following.offset)
}

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_CurrentRow

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_Unbounded

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound

// .substrait.Expression.WindowFunction.Bound.Preceding preceding = 1 [json_name = "preceding"];
inline bool Expression_WindowFunction_Bound::_internal_has_preceding() const {
  return kind_case() == kPreceding;
}
inline bool Expression_WindowFunction_Bound::has_preceding() const {
  return _internal_has_preceding();
}
inline void Expression_WindowFunction_Bound::set_has_preceding() {
  _oneof_case_[0] = kPreceding;
}
inline void Expression_WindowFunction_Bound::clear_preceding() {
  if (_internal_has_preceding()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.preceding_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_WindowFunction_Bound_Preceding* Expression_WindowFunction_Bound::release_preceding() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.preceding)
  if (_internal_has_preceding()) {
    clear_has_kind();
      ::substrait::Expression_WindowFunction_Bound_Preceding* temp = kind_.preceding_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.preceding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Preceding& Expression_WindowFunction_Bound::_internal_preceding() const {
  return _internal_has_preceding()
      ? *kind_.preceding_
      : reinterpret_cast< ::substrait::Expression_WindowFunction_Bound_Preceding&>(::substrait::_Expression_WindowFunction_Bound_Preceding_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound_Preceding& Expression_WindowFunction_Bound::preceding() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.preceding)
  return _internal_preceding();
}
inline ::substrait::Expression_WindowFunction_Bound_Preceding* Expression_WindowFunction_Bound::unsafe_arena_release_preceding() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.WindowFunction.Bound.preceding)
  if (_internal_has_preceding()) {
    clear_has_kind();
    ::substrait::Expression_WindowFunction_Bound_Preceding* temp = kind_.preceding_;
    kind_.preceding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_WindowFunction_Bound::unsafe_arena_set_allocated_preceding(::substrait::Expression_WindowFunction_Bound_Preceding* preceding) {
  clear_kind();
  if (preceding) {
    set_has_preceding();
    kind_.preceding_ = preceding;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.Bound.preceding)
}
inline ::substrait::Expression_WindowFunction_Bound_Preceding* Expression_WindowFunction_Bound::_internal_mutable_preceding() {
  if (!_internal_has_preceding()) {
    clear_kind();
    set_has_preceding();
    kind_.preceding_ = CreateMaybeMessage< ::substrait::Expression_WindowFunction_Bound_Preceding >(GetArenaForAllocation());
  }
  return kind_.preceding_;
}
inline ::substrait::Expression_WindowFunction_Bound_Preceding* Expression_WindowFunction_Bound::mutable_preceding() {
  ::substrait::Expression_WindowFunction_Bound_Preceding* _msg = _internal_mutable_preceding();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.preceding)
  return _msg;
}

// .substrait.Expression.WindowFunction.Bound.Following following = 2 [json_name = "following"];
inline bool Expression_WindowFunction_Bound::_internal_has_following() const {
  return kind_case() == kFollowing;
}
inline bool Expression_WindowFunction_Bound::has_following() const {
  return _internal_has_following();
}
inline void Expression_WindowFunction_Bound::set_has_following() {
  _oneof_case_[0] = kFollowing;
}
inline void Expression_WindowFunction_Bound::clear_following() {
  if (_internal_has_following()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.following_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_WindowFunction_Bound_Following* Expression_WindowFunction_Bound::release_following() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.following)
  if (_internal_has_following()) {
    clear_has_kind();
      ::substrait::Expression_WindowFunction_Bound_Following* temp = kind_.following_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.following_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Following& Expression_WindowFunction_Bound::_internal_following() const {
  return _internal_has_following()
      ? *kind_.following_
      : reinterpret_cast< ::substrait::Expression_WindowFunction_Bound_Following&>(::substrait::_Expression_WindowFunction_Bound_Following_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound_Following& Expression_WindowFunction_Bound::following() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.following)
  return _internal_following();
}
inline ::substrait::Expression_WindowFunction_Bound_Following* Expression_WindowFunction_Bound::unsafe_arena_release_following() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.WindowFunction.Bound.following)
  if (_internal_has_following()) {
    clear_has_kind();
    ::substrait::Expression_WindowFunction_Bound_Following* temp = kind_.following_;
    kind_.following_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_WindowFunction_Bound::unsafe_arena_set_allocated_following(::substrait::Expression_WindowFunction_Bound_Following* following) {
  clear_kind();
  if (following) {
    set_has_following();
    kind_.following_ = following;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.Bound.following)
}
inline ::substrait::Expression_WindowFunction_Bound_Following* Expression_WindowFunction_Bound::_internal_mutable_following() {
  if (!_internal_has_following()) {
    clear_kind();
    set_has_following();
    kind_.following_ = CreateMaybeMessage< ::substrait::Expression_WindowFunction_Bound_Following >(GetArenaForAllocation());
  }
  return kind_.following_;
}
inline ::substrait::Expression_WindowFunction_Bound_Following* Expression_WindowFunction_Bound::mutable_following() {
  ::substrait::Expression_WindowFunction_Bound_Following* _msg = _internal_mutable_following();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.following)
  return _msg;
}

// .substrait.Expression.WindowFunction.Bound.CurrentRow current_row = 3 [json_name = "currentRow"];
inline bool Expression_WindowFunction_Bound::_internal_has_current_row() const {
  return kind_case() == kCurrentRow;
}
inline bool Expression_WindowFunction_Bound::has_current_row() const {
  return _internal_has_current_row();
}
inline void Expression_WindowFunction_Bound::set_has_current_row() {
  _oneof_case_[0] = kCurrentRow;
}
inline void Expression_WindowFunction_Bound::clear_current_row() {
  if (_internal_has_current_row()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.current_row_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_WindowFunction_Bound_CurrentRow* Expression_WindowFunction_Bound::release_current_row() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.current_row)
  if (_internal_has_current_row()) {
    clear_has_kind();
      ::substrait::Expression_WindowFunction_Bound_CurrentRow* temp = kind_.current_row_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.current_row_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_CurrentRow& Expression_WindowFunction_Bound::_internal_current_row() const {
  return _internal_has_current_row()
      ? *kind_.current_row_
      : reinterpret_cast< ::substrait::Expression_WindowFunction_Bound_CurrentRow&>(::substrait::_Expression_WindowFunction_Bound_CurrentRow_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound_CurrentRow& Expression_WindowFunction_Bound::current_row() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.current_row)
  return _internal_current_row();
}
inline ::substrait::Expression_WindowFunction_Bound_CurrentRow* Expression_WindowFunction_Bound::unsafe_arena_release_current_row() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.WindowFunction.Bound.current_row)
  if (_internal_has_current_row()) {
    clear_has_kind();
    ::substrait::Expression_WindowFunction_Bound_CurrentRow* temp = kind_.current_row_;
    kind_.current_row_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_WindowFunction_Bound::unsafe_arena_set_allocated_current_row(::substrait::Expression_WindowFunction_Bound_CurrentRow* current_row) {
  clear_kind();
  if (current_row) {
    set_has_current_row();
    kind_.current_row_ = current_row;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.Bound.current_row)
}
inline ::substrait::Expression_WindowFunction_Bound_CurrentRow* Expression_WindowFunction_Bound::_internal_mutable_current_row() {
  if (!_internal_has_current_row()) {
    clear_kind();
    set_has_current_row();
    kind_.current_row_ = CreateMaybeMessage< ::substrait::Expression_WindowFunction_Bound_CurrentRow >(GetArenaForAllocation());
  }
  return kind_.current_row_;
}
inline ::substrait::Expression_WindowFunction_Bound_CurrentRow* Expression_WindowFunction_Bound::mutable_current_row() {
  ::substrait::Expression_WindowFunction_Bound_CurrentRow* _msg = _internal_mutable_current_row();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.current_row)
  return _msg;
}

// .substrait.Expression.WindowFunction.Bound.Unbounded unbounded = 4 [json_name = "unbounded"];
inline bool Expression_WindowFunction_Bound::_internal_has_unbounded() const {
  return kind_case() == kUnbounded;
}
inline bool Expression_WindowFunction_Bound::has_unbounded() const {
  return _internal_has_unbounded();
}
inline void Expression_WindowFunction_Bound::set_has_unbounded() {
  _oneof_case_[0] = kUnbounded;
}
inline void Expression_WindowFunction_Bound::clear_unbounded() {
  if (_internal_has_unbounded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.unbounded_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_WindowFunction_Bound_Unbounded* Expression_WindowFunction_Bound::release_unbounded() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.unbounded)
  if (_internal_has_unbounded()) {
    clear_has_kind();
      ::substrait::Expression_WindowFunction_Bound_Unbounded* temp = kind_.unbounded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.unbounded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Unbounded& Expression_WindowFunction_Bound::_internal_unbounded() const {
  return _internal_has_unbounded()
      ? *kind_.unbounded_
      : reinterpret_cast< ::substrait::Expression_WindowFunction_Bound_Unbounded&>(::substrait::_Expression_WindowFunction_Bound_Unbounded_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound_Unbounded& Expression_WindowFunction_Bound::unbounded() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.unbounded)
  return _internal_unbounded();
}
inline ::substrait::Expression_WindowFunction_Bound_Unbounded* Expression_WindowFunction_Bound::unsafe_arena_release_unbounded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.WindowFunction.Bound.unbounded)
  if (_internal_has_unbounded()) {
    clear_has_kind();
    ::substrait::Expression_WindowFunction_Bound_Unbounded* temp = kind_.unbounded_;
    kind_.unbounded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_WindowFunction_Bound::unsafe_arena_set_allocated_unbounded(::substrait::Expression_WindowFunction_Bound_Unbounded* unbounded) {
  clear_kind();
  if (unbounded) {
    set_has_unbounded();
    kind_.unbounded_ = unbounded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.Bound.unbounded)
}
inline ::substrait::Expression_WindowFunction_Bound_Unbounded* Expression_WindowFunction_Bound::_internal_mutable_unbounded() {
  if (!_internal_has_unbounded()) {
    clear_kind();
    set_has_unbounded();
    kind_.unbounded_ = CreateMaybeMessage< ::substrait::Expression_WindowFunction_Bound_Unbounded >(GetArenaForAllocation());
  }
  return kind_.unbounded_;
}
inline ::substrait::Expression_WindowFunction_Bound_Unbounded* Expression_WindowFunction_Bound::mutable_unbounded() {
  ::substrait::Expression_WindowFunction_Bound_Unbounded* _msg = _internal_mutable_unbounded();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.unbounded)
  return _msg;
}

inline bool Expression_WindowFunction_Bound::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Expression_WindowFunction_Bound::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline Expression_WindowFunction_Bound::KindCase Expression_WindowFunction_Bound::kind_case() const {
  return Expression_WindowFunction_Bound::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_WindowFunction

// uint32 function_reference = 1 [json_name = "functionReference"];
inline void Expression_WindowFunction::clear_function_reference() {
  function_reference_ = 0u;
}
inline uint32_t Expression_WindowFunction::_internal_function_reference() const {
  return function_reference_;
}
inline uint32_t Expression_WindowFunction::function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.function_reference)
  return _internal_function_reference();
}
inline void Expression_WindowFunction::_internal_set_function_reference(uint32_t value) {
  
  function_reference_ = value;
}
inline void Expression_WindowFunction::set_function_reference(uint32_t value) {
  _internal_set_function_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.function_reference)
}

// repeated .substrait.Expression partitions = 2 [json_name = "partitions"];
inline int Expression_WindowFunction::_internal_partitions_size() const {
  return partitions_.size();
}
inline int Expression_WindowFunction::partitions_size() const {
  return _internal_partitions_size();
}
inline void Expression_WindowFunction::clear_partitions() {
  partitions_.Clear();
}
inline ::substrait::Expression* Expression_WindowFunction::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.partitions)
  return partitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
Expression_WindowFunction::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.partitions)
  return &partitions_;
}
inline const ::substrait::Expression& Expression_WindowFunction::_internal_partitions(int index) const {
  return partitions_.Get(index);
}
inline const ::substrait::Expression& Expression_WindowFunction::partitions(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.partitions)
  return _internal_partitions(index);
}
inline ::substrait::Expression* Expression_WindowFunction::_internal_add_partitions() {
  return partitions_.Add();
}
inline ::substrait::Expression* Expression_WindowFunction::add_partitions() {
  ::substrait::Expression* _add = _internal_add_partitions();
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.partitions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
Expression_WindowFunction::partitions() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.partitions)
  return partitions_;
}

// repeated .substrait.SortField sorts = 3 [json_name = "sorts"];
inline int Expression_WindowFunction::_internal_sorts_size() const {
  return sorts_.size();
}
inline int Expression_WindowFunction::sorts_size() const {
  return _internal_sorts_size();
}
inline void Expression_WindowFunction::clear_sorts() {
  sorts_.Clear();
}
inline ::substrait::SortField* Expression_WindowFunction::mutable_sorts(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.sorts)
  return sorts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::SortField >*
Expression_WindowFunction::mutable_sorts() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.sorts)
  return &sorts_;
}
inline const ::substrait::SortField& Expression_WindowFunction::_internal_sorts(int index) const {
  return sorts_.Get(index);
}
inline const ::substrait::SortField& Expression_WindowFunction::sorts(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.sorts)
  return _internal_sorts(index);
}
inline ::substrait::SortField* Expression_WindowFunction::_internal_add_sorts() {
  return sorts_.Add();
}
inline ::substrait::SortField* Expression_WindowFunction::add_sorts() {
  ::substrait::SortField* _add = _internal_add_sorts();
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.sorts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::SortField >&
Expression_WindowFunction::sorts() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.sorts)
  return sorts_;
}

// .substrait.Expression.WindowFunction.Bound upper_bound = 4 [json_name = "upperBound"];
inline bool Expression_WindowFunction::_internal_has_upper_bound() const {
  return this != internal_default_instance() && upper_bound_ != nullptr;
}
inline bool Expression_WindowFunction::has_upper_bound() const {
  return _internal_has_upper_bound();
}
inline void Expression_WindowFunction::clear_upper_bound() {
  if (GetArenaForAllocation() == nullptr && upper_bound_ != nullptr) {
    delete upper_bound_;
  }
  upper_bound_ = nullptr;
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::_internal_upper_bound() const {
  const ::substrait::Expression_WindowFunction_Bound* p = upper_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_WindowFunction_Bound&>(
      ::substrait::_Expression_WindowFunction_Bound_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::upper_bound() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.upper_bound)
  return _internal_upper_bound();
}
inline void Expression_WindowFunction::unsafe_arena_set_allocated_upper_bound(
    ::substrait::Expression_WindowFunction_Bound* upper_bound) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(upper_bound_);
  }
  upper_bound_ = upper_bound;
  if (upper_bound) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.upper_bound)
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::release_upper_bound() {
  
  ::substrait::Expression_WindowFunction_Bound* temp = upper_bound_;
  upper_bound_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::unsafe_arena_release_upper_bound() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.upper_bound)
  
  ::substrait::Expression_WindowFunction_Bound* temp = upper_bound_;
  upper_bound_ = nullptr;
  return temp;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::_internal_mutable_upper_bound() {
  
  if (upper_bound_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound>(GetArenaForAllocation());
    upper_bound_ = p;
  }
  return upper_bound_;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::mutable_upper_bound() {
  ::substrait::Expression_WindowFunction_Bound* _msg = _internal_mutable_upper_bound();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.upper_bound)
  return _msg;
}
inline void Expression_WindowFunction::set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* upper_bound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete upper_bound_;
  }
  if (upper_bound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_WindowFunction_Bound>::GetOwningArena(upper_bound);
    if (message_arena != submessage_arena) {
      upper_bound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upper_bound, submessage_arena);
    }
    
  } else {
    
  }
  upper_bound_ = upper_bound;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.WindowFunction.upper_bound)
}

// .substrait.Expression.WindowFunction.Bound lower_bound = 5 [json_name = "lowerBound"];
inline bool Expression_WindowFunction::_internal_has_lower_bound() const {
  return this != internal_default_instance() && lower_bound_ != nullptr;
}
inline bool Expression_WindowFunction::has_lower_bound() const {
  return _internal_has_lower_bound();
}
inline void Expression_WindowFunction::clear_lower_bound() {
  if (GetArenaForAllocation() == nullptr && lower_bound_ != nullptr) {
    delete lower_bound_;
  }
  lower_bound_ = nullptr;
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::_internal_lower_bound() const {
  const ::substrait::Expression_WindowFunction_Bound* p = lower_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_WindowFunction_Bound&>(
      ::substrait::_Expression_WindowFunction_Bound_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::lower_bound() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.lower_bound)
  return _internal_lower_bound();
}
inline void Expression_WindowFunction::unsafe_arena_set_allocated_lower_bound(
    ::substrait::Expression_WindowFunction_Bound* lower_bound) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lower_bound_);
  }
  lower_bound_ = lower_bound;
  if (lower_bound) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.lower_bound)
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::release_lower_bound() {
  
  ::substrait::Expression_WindowFunction_Bound* temp = lower_bound_;
  lower_bound_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::unsafe_arena_release_lower_bound() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.lower_bound)
  
  ::substrait::Expression_WindowFunction_Bound* temp = lower_bound_;
  lower_bound_ = nullptr;
  return temp;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::_internal_mutable_lower_bound() {
  
  if (lower_bound_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound>(GetArenaForAllocation());
    lower_bound_ = p;
  }
  return lower_bound_;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::mutable_lower_bound() {
  ::substrait::Expression_WindowFunction_Bound* _msg = _internal_mutable_lower_bound();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.lower_bound)
  return _msg;
}
inline void Expression_WindowFunction::set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* lower_bound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lower_bound_;
  }
  if (lower_bound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_WindowFunction_Bound>::GetOwningArena(lower_bound);
    if (message_arena != submessage_arena) {
      lower_bound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lower_bound, submessage_arena);
    }
    
  } else {
    
  }
  lower_bound_ = lower_bound;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.WindowFunction.lower_bound)
}

// .substrait.AggregationPhase phase = 6 [json_name = "phase"];
inline void Expression_WindowFunction::clear_phase() {
  phase_ = 0;
}
inline ::substrait::AggregationPhase Expression_WindowFunction::_internal_phase() const {
  return static_cast< ::substrait::AggregationPhase >(phase_);
}
inline ::substrait::AggregationPhase Expression_WindowFunction::phase() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.phase)
  return _internal_phase();
}
inline void Expression_WindowFunction::_internal_set_phase(::substrait::AggregationPhase value) {
  
  phase_ = value;
}
inline void Expression_WindowFunction::set_phase(::substrait::AggregationPhase value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.phase)
}

// .substrait.Type output_type = 7 [json_name = "outputType"];
inline bool Expression_WindowFunction::_internal_has_output_type() const {
  return this != internal_default_instance() && output_type_ != nullptr;
}
inline bool Expression_WindowFunction::has_output_type() const {
  return _internal_has_output_type();
}
inline const ::substrait::Type& Expression_WindowFunction::_internal_output_type() const {
  const ::substrait::Type* p = output_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(
      ::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Expression_WindowFunction::output_type() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.output_type)
  return _internal_output_type();
}
inline void Expression_WindowFunction::unsafe_arena_set_allocated_output_type(
    ::substrait::Type* output_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type_);
  }
  output_type_ = output_type;
  if (output_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.output_type)
}
inline ::substrait::Type* Expression_WindowFunction::release_output_type() {
  
  ::substrait::Type* temp = output_type_;
  output_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Type* Expression_WindowFunction::unsafe_arena_release_output_type() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.output_type)
  
  ::substrait::Type* temp = output_type_;
  output_type_ = nullptr;
  return temp;
}
inline ::substrait::Type* Expression_WindowFunction::_internal_mutable_output_type() {
  
  if (output_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaForAllocation());
    output_type_ = p;
  }
  return output_type_;
}
inline ::substrait::Type* Expression_WindowFunction::mutable_output_type() {
  ::substrait::Type* _msg = _internal_mutable_output_type();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.output_type)
  return _msg;
}
inline void Expression_WindowFunction::set_allocated_output_type(::substrait::Type* output_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type_);
  }
  if (output_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type));
    if (message_arena != submessage_arena) {
      output_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_type, submessage_arena);
    }
    
  } else {
    
  }
  output_type_ = output_type;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.WindowFunction.output_type)
}

// repeated .substrait.Expression args = 8 [json_name = "args"];
inline int Expression_WindowFunction::_internal_args_size() const {
  return args_.size();
}
inline int Expression_WindowFunction::args_size() const {
  return _internal_args_size();
}
inline void Expression_WindowFunction::clear_args() {
  args_.Clear();
}
inline ::substrait::Expression* Expression_WindowFunction::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
Expression_WindowFunction::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.args)
  return &args_;
}
inline const ::substrait::Expression& Expression_WindowFunction::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::substrait::Expression& Expression_WindowFunction::args(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.args)
  return _internal_args(index);
}
inline ::substrait::Expression* Expression_WindowFunction::_internal_add_args() {
  return args_.Add();
}
inline ::substrait::Expression* Expression_WindowFunction::add_args() {
  ::substrait::Expression* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
Expression_WindowFunction::args() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.args)
  return args_;
}

// -------------------------------------------------------------------

// Expression_IfThen_IfClause

// .substrait.Expression if = 1 [json_name = "if"];
inline bool Expression_IfThen_IfClause::_internal_has_if_() const {
  return this != internal_default_instance() && if__ != nullptr;
}
inline bool Expression_IfThen_IfClause::has_if_() const {
  return _internal_has_if_();
}
inline void Expression_IfThen_IfClause::clear_if_() {
  if (GetArenaForAllocation() == nullptr && if__ != nullptr) {
    delete if__;
  }
  if__ = nullptr;
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::_internal_if_() const {
  const ::substrait::Expression* p = if__;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(
      ::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::if_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.IfClause.if)
  return _internal_if_();
}
inline void Expression_IfThen_IfClause::unsafe_arena_set_allocated_if_(
    ::substrait::Expression* if_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(if__);
  }
  if__ = if_;
  if (if_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.IfThen.IfClause.if)
}
inline ::substrait::Expression* Expression_IfThen_IfClause::release_if_() {
  
  ::substrait::Expression* temp = if__;
  if__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::unsafe_arena_release_if_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.IfThen.IfClause.if)
  
  ::substrait::Expression* temp = if__;
  if__ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::_internal_mutable_if_() {
  
  if (if__ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaForAllocation());
    if__ = p;
  }
  return if__;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::mutable_if_() {
  ::substrait::Expression* _msg = _internal_mutable_if_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.IfClause.if)
  return _msg;
}
inline void Expression_IfThen_IfClause::set_allocated_if_(::substrait::Expression* if_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete if__;
  }
  if (if_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression>::GetOwningArena(if_);
    if (message_arena != submessage_arena) {
      if_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, if_, submessage_arena);
    }
    
  } else {
    
  }
  if__ = if_;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.IfThen.IfClause.if)
}

// .substrait.Expression then = 2 [json_name = "then"];
inline bool Expression_IfThen_IfClause::_internal_has_then() const {
  return this != internal_default_instance() && then_ != nullptr;
}
inline bool Expression_IfThen_IfClause::has_then() const {
  return _internal_has_then();
}
inline void Expression_IfThen_IfClause::clear_then() {
  if (GetArenaForAllocation() == nullptr && then_ != nullptr) {
    delete then_;
  }
  then_ = nullptr;
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::_internal_then() const {
  const ::substrait::Expression* p = then_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(
      ::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::then() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.IfClause.then)
  return _internal_then();
}
inline void Expression_IfThen_IfClause::unsafe_arena_set_allocated_then(
    ::substrait::Expression* then) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(then_);
  }
  then_ = then;
  if (then) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.IfThen.IfClause.then)
}
inline ::substrait::Expression* Expression_IfThen_IfClause::release_then() {
  
  ::substrait::Expression* temp = then_;
  then_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::unsafe_arena_release_then() {
  // @@protoc_insertion_point(field_release:substrait.Expression.IfThen.IfClause.then)
  
  ::substrait::Expression* temp = then_;
  then_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::_internal_mutable_then() {
  
  if (then_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaForAllocation());
    then_ = p;
  }
  return then_;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::mutable_then() {
  ::substrait::Expression* _msg = _internal_mutable_then();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.IfClause.then)
  return _msg;
}
inline void Expression_IfThen_IfClause::set_allocated_then(::substrait::Expression* then) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete then_;
  }
  if (then) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression>::GetOwningArena(then);
    if (message_arena != submessage_arena) {
      then = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, then, submessage_arena);
    }
    
  } else {
    
  }
  then_ = then;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.IfThen.IfClause.then)
}

// -------------------------------------------------------------------

// Expression_IfThen

// repeated .substrait.Expression.IfThen.IfClause ifs = 1 [json_name = "ifs"];
inline int Expression_IfThen::_internal_ifs_size() const {
  return ifs_.size();
}
inline int Expression_IfThen::ifs_size() const {
  return _internal_ifs_size();
}
inline void Expression_IfThen::clear_ifs() {
  ifs_.Clear();
}
inline ::substrait::Expression_IfThen_IfClause* Expression_IfThen::mutable_ifs(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.ifs)
  return ifs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause >*
Expression_IfThen::mutable_ifs() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.IfThen.ifs)
  return &ifs_;
}
inline const ::substrait::Expression_IfThen_IfClause& Expression_IfThen::_internal_ifs(int index) const {
  return ifs_.Get(index);
}
inline const ::substrait::Expression_IfThen_IfClause& Expression_IfThen::ifs(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.ifs)
  return _internal_ifs(index);
}
inline ::substrait::Expression_IfThen_IfClause* Expression_IfThen::_internal_add_ifs() {
  return ifs_.Add();
}
inline ::substrait::Expression_IfThen_IfClause* Expression_IfThen::add_ifs() {
  ::substrait::Expression_IfThen_IfClause* _add = _internal_add_ifs();
  // @@protoc_insertion_point(field_add:substrait.Expression.IfThen.ifs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause >&
Expression_IfThen::ifs() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.IfThen.ifs)
  return ifs_;
}

// .substrait.Expression else = 2 [json_name = "else"];
inline bool Expression_IfThen::_internal_has_else_() const {
  return this != internal_default_instance() && else__ != nullptr;
}
inline bool Expression_IfThen::has_else_() const {
  return _internal_has_else_();
}
inline void Expression_IfThen::clear_else_() {
  if (GetArenaForAllocation() == nullptr && else__ != nullptr) {
    delete else__;
  }
  else__ = nullptr;
}
inline const ::substrait::Expression& Expression_IfThen::_internal_else_() const {
  const ::substrait::Expression* p = else__;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(
      ::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_IfThen::else_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.else)
  return _internal_else_();
}
inline void Expression_IfThen::unsafe_arena_set_allocated_else_(
    ::substrait::Expression* else_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(else__);
  }
  else__ = else_;
  if (else_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.IfThen.else)
}
inline ::substrait::Expression* Expression_IfThen::release_else_() {
  
  ::substrait::Expression* temp = else__;
  else__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression* Expression_IfThen::unsafe_arena_release_else_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.IfThen.else)
  
  ::substrait::Expression* temp = else__;
  else__ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_IfThen::_internal_mutable_else_() {
  
  if (else__ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaForAllocation());
    else__ = p;
  }
  return else__;
}
inline ::substrait::Expression* Expression_IfThen::mutable_else_() {
  ::substrait::Expression* _msg = _internal_mutable_else_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.else)
  return _msg;
}
inline void Expression_IfThen::set_allocated_else_(::substrait::Expression* else_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete else__;
  }
  if (else_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression>::GetOwningArena(else_);
    if (message_arena != submessage_arena) {
      else_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, else_, submessage_arena);
    }
    
  } else {
    
  }
  else__ = else_;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.IfThen.else)
}

// -------------------------------------------------------------------

// Expression_Cast

// .substrait.Type type = 1 [json_name = "type"];
inline bool Expression_Cast::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool Expression_Cast::has_type() const {
  return _internal_has_type();
}
inline const ::substrait::Type& Expression_Cast::_internal_type() const {
  const ::substrait::Type* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(
      ::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Expression_Cast::type() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Cast.type)
  return _internal_type();
}
inline void Expression_Cast::unsafe_arena_set_allocated_type(
    ::substrait::Type* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Cast.type)
}
inline ::substrait::Type* Expression_Cast::release_type() {
  
  ::substrait::Type* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Type* Expression_Cast::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Cast.type)
  
  ::substrait::Type* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::substrait::Type* Expression_Cast::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::substrait::Type* Expression_Cast::mutable_type() {
  ::substrait::Type* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Cast.type)
  return _msg;
}
inline void Expression_Cast::set_allocated_type(::substrait::Type* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type));
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Cast.type)
}

// .substrait.Expression input = 2 [json_name = "input"];
inline bool Expression_Cast::_internal_has_input() const {
  return this != internal_default_instance() && input_ != nullptr;
}
inline bool Expression_Cast::has_input() const {
  return _internal_has_input();
}
inline void Expression_Cast::clear_input() {
  if (GetArenaForAllocation() == nullptr && input_ != nullptr) {
    delete input_;
  }
  input_ = nullptr;
}
inline const ::substrait::Expression& Expression_Cast::_internal_input() const {
  const ::substrait::Expression* p = input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(
      ::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_Cast::input() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Cast.input)
  return _internal_input();
}
inline void Expression_Cast::unsafe_arena_set_allocated_input(
    ::substrait::Expression* input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_);
  }
  input_ = input;
  if (input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Cast.input)
}
inline ::substrait::Expression* Expression_Cast::release_input() {
  
  ::substrait::Expression* temp = input_;
  input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression* Expression_Cast::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Cast.input)
  
  ::substrait::Expression* temp = input_;
  input_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_Cast::_internal_mutable_input() {
  
  if (input_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaForAllocation());
    input_ = p;
  }
  return input_;
}
inline ::substrait::Expression* Expression_Cast::mutable_input() {
  ::substrait::Expression* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Cast.input)
  return _msg;
}
inline void Expression_Cast::set_allocated_input(::substrait::Expression* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression>::GetOwningArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Cast.input)
}

// -------------------------------------------------------------------

// Expression_SwitchExpression_IfValue

// .substrait.Expression.Literal if = 1 [json_name = "if"];
inline bool Expression_SwitchExpression_IfValue::_internal_has_if_() const {
  return this != internal_default_instance() && if__ != nullptr;
}
inline bool Expression_SwitchExpression_IfValue::has_if_() const {
  return _internal_has_if_();
}
inline void Expression_SwitchExpression_IfValue::clear_if_() {
  if (GetArenaForAllocation() == nullptr && if__ != nullptr) {
    delete if__;
  }
  if__ = nullptr;
}
inline const ::substrait::Expression_Literal& Expression_SwitchExpression_IfValue::_internal_if_() const {
  const ::substrait::Expression_Literal* p = if__;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_Literal&>(
      ::substrait::_Expression_Literal_default_instance_);
}
inline const ::substrait::Expression_Literal& Expression_SwitchExpression_IfValue::if_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.IfValue.if)
  return _internal_if_();
}
inline void Expression_SwitchExpression_IfValue::unsafe_arena_set_allocated_if_(
    ::substrait::Expression_Literal* if_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(if__);
  }
  if__ = if_;
  if (if_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.SwitchExpression.IfValue.if)
}
inline ::substrait::Expression_Literal* Expression_SwitchExpression_IfValue::release_if_() {
  
  ::substrait::Expression_Literal* temp = if__;
  if__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_Literal* Expression_SwitchExpression_IfValue::unsafe_arena_release_if_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.IfValue.if)
  
  ::substrait::Expression_Literal* temp = if__;
  if__ = nullptr;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_SwitchExpression_IfValue::_internal_mutable_if_() {
  
  if (if__ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_Literal>(GetArenaForAllocation());
    if__ = p;
  }
  return if__;
}
inline ::substrait::Expression_Literal* Expression_SwitchExpression_IfValue::mutable_if_() {
  ::substrait::Expression_Literal* _msg = _internal_mutable_if_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.IfValue.if)
  return _msg;
}
inline void Expression_SwitchExpression_IfValue::set_allocated_if_(::substrait::Expression_Literal* if_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete if__;
  }
  if (if_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_Literal>::GetOwningArena(if_);
    if (message_arena != submessage_arena) {
      if_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, if_, submessage_arena);
    }
    
  } else {
    
  }
  if__ = if_;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.IfValue.if)
}

// .substrait.Expression then = 2 [json_name = "then"];
inline bool Expression_SwitchExpression_IfValue::_internal_has_then() const {
  return this != internal_default_instance() && then_ != nullptr;
}
inline bool Expression_SwitchExpression_IfValue::has_then() const {
  return _internal_has_then();
}
inline void Expression_SwitchExpression_IfValue::clear_then() {
  if (GetArenaForAllocation() == nullptr && then_ != nullptr) {
    delete then_;
  }
  then_ = nullptr;
}
inline const ::substrait::Expression& Expression_SwitchExpression_IfValue::_internal_then() const {
  const ::substrait::Expression* p = then_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(
      ::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_SwitchExpression_IfValue::then() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.IfValue.then)
  return _internal_then();
}
inline void Expression_SwitchExpression_IfValue::unsafe_arena_set_allocated_then(
    ::substrait::Expression* then) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(then_);
  }
  then_ = then;
  if (then) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.SwitchExpression.IfValue.then)
}
inline ::substrait::Expression* Expression_SwitchExpression_IfValue::release_then() {
  
  ::substrait::Expression* temp = then_;
  then_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression* Expression_SwitchExpression_IfValue::unsafe_arena_release_then() {
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.IfValue.then)
  
  ::substrait::Expression* temp = then_;
  then_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_SwitchExpression_IfValue::_internal_mutable_then() {
  
  if (then_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaForAllocation());
    then_ = p;
  }
  return then_;
}
inline ::substrait::Expression* Expression_SwitchExpression_IfValue::mutable_then() {
  ::substrait::Expression* _msg = _internal_mutable_then();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.IfValue.then)
  return _msg;
}
inline void Expression_SwitchExpression_IfValue::set_allocated_then(::substrait::Expression* then) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete then_;
  }
  if (then) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression>::GetOwningArena(then);
    if (message_arena != submessage_arena) {
      then = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, then, submessage_arena);
    }
    
  } else {
    
  }
  then_ = then;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.IfValue.then)
}

// -------------------------------------------------------------------

// Expression_SwitchExpression

// repeated .substrait.Expression.SwitchExpression.IfValue ifs = 1 [json_name = "ifs"];
inline int Expression_SwitchExpression::_internal_ifs_size() const {
  return ifs_.size();
}
inline int Expression_SwitchExpression::ifs_size() const {
  return _internal_ifs_size();
}
inline void Expression_SwitchExpression::clear_ifs() {
  ifs_.Clear();
}
inline ::substrait::Expression_SwitchExpression_IfValue* Expression_SwitchExpression::mutable_ifs(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.ifs)
  return ifs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue >*
Expression_SwitchExpression::mutable_ifs() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.SwitchExpression.ifs)
  return &ifs_;
}
inline const ::substrait::Expression_SwitchExpression_IfValue& Expression_SwitchExpression::_internal_ifs(int index) const {
  return ifs_.Get(index);
}
inline const ::substrait::Expression_SwitchExpression_IfValue& Expression_SwitchExpression::ifs(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.ifs)
  return _internal_ifs(index);
}
inline ::substrait::Expression_SwitchExpression_IfValue* Expression_SwitchExpression::_internal_add_ifs() {
  return ifs_.Add();
}
inline ::substrait::Expression_SwitchExpression_IfValue* Expression_SwitchExpression::add_ifs() {
  ::substrait::Expression_SwitchExpression_IfValue* _add = _internal_add_ifs();
  // @@protoc_insertion_point(field_add:substrait.Expression.SwitchExpression.ifs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue >&
Expression_SwitchExpression::ifs() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.SwitchExpression.ifs)
  return ifs_;
}

// .substrait.Expression else = 2 [json_name = "else"];
inline bool Expression_SwitchExpression::_internal_has_else_() const {
  return this != internal_default_instance() && else__ != nullptr;
}
inline bool Expression_SwitchExpression::has_else_() const {
  return _internal_has_else_();
}
inline void Expression_SwitchExpression::clear_else_() {
  if (GetArenaForAllocation() == nullptr && else__ != nullptr) {
    delete else__;
  }
  else__ = nullptr;
}
inline const ::substrait::Expression& Expression_SwitchExpression::_internal_else_() const {
  const ::substrait::Expression* p = else__;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(
      ::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_SwitchExpression::else_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.else)
  return _internal_else_();
}
inline void Expression_SwitchExpression::unsafe_arena_set_allocated_else_(
    ::substrait::Expression* else_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(else__);
  }
  else__ = else_;
  if (else_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.SwitchExpression.else)
}
inline ::substrait::Expression* Expression_SwitchExpression::release_else_() {
  
  ::substrait::Expression* temp = else__;
  else__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression* Expression_SwitchExpression::unsafe_arena_release_else_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.else)
  
  ::substrait::Expression* temp = else__;
  else__ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_SwitchExpression::_internal_mutable_else_() {
  
  if (else__ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaForAllocation());
    else__ = p;
  }
  return else__;
}
inline ::substrait::Expression* Expression_SwitchExpression::mutable_else_() {
  ::substrait::Expression* _msg = _internal_mutable_else_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.else)
  return _msg;
}
inline void Expression_SwitchExpression::set_allocated_else_(::substrait::Expression* else_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete else__;
  }
  if (else_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression>::GetOwningArena(else_);
    if (message_arena != submessage_arena) {
      else_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, else_, submessage_arena);
    }
    
  } else {
    
  }
  else__ = else_;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.else)
}

// -------------------------------------------------------------------

// Expression_SingularOrList

// .substrait.Expression value = 1 [json_name = "value"];
inline bool Expression_SingularOrList::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool Expression_SingularOrList::has_value() const {
  return _internal_has_value();
}
inline void Expression_SingularOrList::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::substrait::Expression& Expression_SingularOrList::_internal_value() const {
  const ::substrait::Expression* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(
      ::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_SingularOrList::value() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.SingularOrList.value)
  return _internal_value();
}
inline void Expression_SingularOrList::unsafe_arena_set_allocated_value(
    ::substrait::Expression* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.SingularOrList.value)
}
inline ::substrait::Expression* Expression_SingularOrList::release_value() {
  
  ::substrait::Expression* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression* Expression_SingularOrList::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:substrait.Expression.SingularOrList.value)
  
  ::substrait::Expression* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_SingularOrList::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::substrait::Expression* Expression_SingularOrList::mutable_value() {
  ::substrait::Expression* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SingularOrList.value)
  return _msg;
}
inline void Expression_SingularOrList::set_allocated_value(::substrait::Expression* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SingularOrList.value)
}

// repeated .substrait.Expression options = 2 [json_name = "options"];
inline int Expression_SingularOrList::_internal_options_size() const {
  return options_.size();
}
inline int Expression_SingularOrList::options_size() const {
  return _internal_options_size();
}
inline void Expression_SingularOrList::clear_options() {
  options_.Clear();
}
inline ::substrait::Expression* Expression_SingularOrList::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SingularOrList.options)
  return options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
Expression_SingularOrList::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.SingularOrList.options)
  return &options_;
}
inline const ::substrait::Expression& Expression_SingularOrList::_internal_options(int index) const {
  return options_.Get(index);
}
inline const ::substrait::Expression& Expression_SingularOrList::options(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.SingularOrList.options)
  return _internal_options(index);
}
inline ::substrait::Expression* Expression_SingularOrList::_internal_add_options() {
  return options_.Add();
}
inline ::substrait::Expression* Expression_SingularOrList::add_options() {
  ::substrait::Expression* _add = _internal_add_options();
  // @@protoc_insertion_point(field_add:substrait.Expression.SingularOrList.options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
Expression_SingularOrList::options() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.SingularOrList.options)
  return options_;
}

// -------------------------------------------------------------------

// Expression_MultiOrList_Record

// repeated .substrait.Expression fields = 1 [json_name = "fields"];
inline int Expression_MultiOrList_Record::_internal_fields_size() const {
  return fields_.size();
}
inline int Expression_MultiOrList_Record::fields_size() const {
  return _internal_fields_size();
}
inline void Expression_MultiOrList_Record::clear_fields() {
  fields_.Clear();
}
inline ::substrait::Expression* Expression_MultiOrList_Record::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MultiOrList.Record.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
Expression_MultiOrList_Record::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MultiOrList.Record.fields)
  return &fields_;
}
inline const ::substrait::Expression& Expression_MultiOrList_Record::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::substrait::Expression& Expression_MultiOrList_Record::fields(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MultiOrList.Record.fields)
  return _internal_fields(index);
}
inline ::substrait::Expression* Expression_MultiOrList_Record::_internal_add_fields() {
  return fields_.Add();
}
inline ::substrait::Expression* Expression_MultiOrList_Record::add_fields() {
  ::substrait::Expression* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:substrait.Expression.MultiOrList.Record.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
Expression_MultiOrList_Record::fields() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.MultiOrList.Record.fields)
  return fields_;
}

// -------------------------------------------------------------------

// Expression_MultiOrList

// repeated .substrait.Expression value = 1 [json_name = "value"];
inline int Expression_MultiOrList::_internal_value_size() const {
  return value_.size();
}
inline int Expression_MultiOrList::value_size() const {
  return _internal_value_size();
}
inline void Expression_MultiOrList::clear_value() {
  value_.Clear();
}
inline ::substrait::Expression* Expression_MultiOrList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MultiOrList.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
Expression_MultiOrList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MultiOrList.value)
  return &value_;
}
inline const ::substrait::Expression& Expression_MultiOrList::_internal_value(int index) const {
  return value_.Get(index);
}
inline const ::substrait::Expression& Expression_MultiOrList::value(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MultiOrList.value)
  return _internal_value(index);
}
inline ::substrait::Expression* Expression_MultiOrList::_internal_add_value() {
  return value_.Add();
}
inline ::substrait::Expression* Expression_MultiOrList::add_value() {
  ::substrait::Expression* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:substrait.Expression.MultiOrList.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
Expression_MultiOrList::value() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.MultiOrList.value)
  return value_;
}

// repeated .substrait.Expression.MultiOrList.Record options = 2 [json_name = "options"];
inline int Expression_MultiOrList::_internal_options_size() const {
  return options_.size();
}
inline int Expression_MultiOrList::options_size() const {
  return _internal_options_size();
}
inline void Expression_MultiOrList::clear_options() {
  options_.Clear();
}
inline ::substrait::Expression_MultiOrList_Record* Expression_MultiOrList::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MultiOrList.options)
  return options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record >*
Expression_MultiOrList::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MultiOrList.options)
  return &options_;
}
inline const ::substrait::Expression_MultiOrList_Record& Expression_MultiOrList::_internal_options(int index) const {
  return options_.Get(index);
}
inline const ::substrait::Expression_MultiOrList_Record& Expression_MultiOrList::options(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MultiOrList.options)
  return _internal_options(index);
}
inline ::substrait::Expression_MultiOrList_Record* Expression_MultiOrList::_internal_add_options() {
  return options_.Add();
}
inline ::substrait::Expression_MultiOrList_Record* Expression_MultiOrList::add_options() {
  ::substrait::Expression_MultiOrList_Record* _add = _internal_add_options();
  // @@protoc_insertion_point(field_add:substrait.Expression.MultiOrList.options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record >&
Expression_MultiOrList::options() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.MultiOrList.options)
  return options_;
}

// -------------------------------------------------------------------

// Expression_EmbeddedFunction_PythonPickleFunction

// bytes function = 1 [json_name = "function"];
inline void Expression_EmbeddedFunction_PythonPickleFunction::clear_function() {
  function_.ClearToEmpty();
}
inline const std::string& Expression_EmbeddedFunction_PythonPickleFunction::function() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
  return _internal_function();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Expression_EmbeddedFunction_PythonPickleFunction::set_function(ArgT0&& arg0, ArgT... args) {
 
 function_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::mutable_function() {
  std::string* _s = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
  return _s;
}
inline const std::string& Expression_EmbeddedFunction_PythonPickleFunction::_internal_function() const {
  return function_.Get();
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::_internal_set_function(const std::string& value) {
  
  function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::_internal_mutable_function() {
  
  return function_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::release_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
  return function_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    
  } else {
    
  }
  function_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (function_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
}

// repeated string prerequisite = 2 [json_name = "prerequisite"];
inline int Expression_EmbeddedFunction_PythonPickleFunction::_internal_prerequisite_size() const {
  return prerequisite_.size();
}
inline int Expression_EmbeddedFunction_PythonPickleFunction::prerequisite_size() const {
  return _internal_prerequisite_size();
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::clear_prerequisite() {
  prerequisite_.Clear();
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite() {
  std::string* _s = _internal_add_prerequisite();
  // @@protoc_insertion_point(field_add_mutable:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return _s;
}
inline const std::string& Expression_EmbeddedFunction_PythonPickleFunction::_internal_prerequisite(int index) const {
  return prerequisite_.Get(index);
}
inline const std::string& Expression_EmbeddedFunction_PythonPickleFunction::prerequisite(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return _internal_prerequisite(index);
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::mutable_prerequisite(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return prerequisite_.Mutable(index);
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_prerequisite(int index, const std::string& value) {
  prerequisite_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_prerequisite(int index, std::string&& value) {
  prerequisite_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_prerequisite(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  prerequisite_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_prerequisite(int index, const char* value, size_t size) {
  prerequisite_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::_internal_add_prerequisite() {
  return prerequisite_.Add();
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite(const std::string& value) {
  prerequisite_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite(std::string&& value) {
  prerequisite_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  prerequisite_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite(const char* value, size_t size) {
  prerequisite_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Expression_EmbeddedFunction_PythonPickleFunction::prerequisite() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return prerequisite_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Expression_EmbeddedFunction_PythonPickleFunction::mutable_prerequisite() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return &prerequisite_;
}

// -------------------------------------------------------------------

// Expression_EmbeddedFunction_WebAssemblyFunction

// bytes script = 1 [json_name = "script"];
inline void Expression_EmbeddedFunction_WebAssemblyFunction::clear_script() {
  script_.ClearToEmpty();
}
inline const std::string& Expression_EmbeddedFunction_WebAssemblyFunction::script() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Expression_EmbeddedFunction_WebAssemblyFunction::set_script(ArgT0&& arg0, ArgT... args) {
 
 script_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
  return _s;
}
inline const std::string& Expression_EmbeddedFunction_WebAssemblyFunction::_internal_script() const {
  return script_.Get();
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::_internal_set_script(const std::string& value) {
  
  script_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::_internal_mutable_script() {
  
  return script_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::release_script() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
  return script_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (script_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    script_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
}

// repeated string prerequisite = 2 [json_name = "prerequisite"];
inline int Expression_EmbeddedFunction_WebAssemblyFunction::_internal_prerequisite_size() const {
  return prerequisite_.size();
}
inline int Expression_EmbeddedFunction_WebAssemblyFunction::prerequisite_size() const {
  return _internal_prerequisite_size();
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::clear_prerequisite() {
  prerequisite_.Clear();
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite() {
  std::string* _s = _internal_add_prerequisite();
  // @@protoc_insertion_point(field_add_mutable:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return _s;
}
inline const std::string& Expression_EmbeddedFunction_WebAssemblyFunction::_internal_prerequisite(int index) const {
  return prerequisite_.Get(index);
}
inline const std::string& Expression_EmbeddedFunction_WebAssemblyFunction::prerequisite(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return _internal_prerequisite(index);
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::mutable_prerequisite(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return prerequisite_.Mutable(index);
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_prerequisite(int index, const std::string& value) {
  prerequisite_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_prerequisite(int index, std::string&& value) {
  prerequisite_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_prerequisite(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  prerequisite_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_prerequisite(int index, const char* value, size_t size) {
  prerequisite_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::_internal_add_prerequisite() {
  return prerequisite_.Add();
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite(const std::string& value) {
  prerequisite_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite(std::string&& value) {
  prerequisite_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  prerequisite_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite(const char* value, size_t size) {
  prerequisite_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Expression_EmbeddedFunction_WebAssemblyFunction::prerequisite() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return prerequisite_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Expression_EmbeddedFunction_WebAssemblyFunction::mutable_prerequisite() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return &prerequisite_;
}

// -------------------------------------------------------------------

// Expression_EmbeddedFunction

// repeated .substrait.Expression arguments = 1 [json_name = "arguments"];
inline int Expression_EmbeddedFunction::_internal_arguments_size() const {
  return arguments_.size();
}
inline int Expression_EmbeddedFunction::arguments_size() const {
  return _internal_arguments_size();
}
inline void Expression_EmbeddedFunction::clear_arguments() {
  arguments_.Clear();
}
inline ::substrait::Expression* Expression_EmbeddedFunction::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.arguments)
  return arguments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
Expression_EmbeddedFunction::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.EmbeddedFunction.arguments)
  return &arguments_;
}
inline const ::substrait::Expression& Expression_EmbeddedFunction::_internal_arguments(int index) const {
  return arguments_.Get(index);
}
inline const ::substrait::Expression& Expression_EmbeddedFunction::arguments(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.arguments)
  return _internal_arguments(index);
}
inline ::substrait::Expression* Expression_EmbeddedFunction::_internal_add_arguments() {
  return arguments_.Add();
}
inline ::substrait::Expression* Expression_EmbeddedFunction::add_arguments() {
  ::substrait::Expression* _add = _internal_add_arguments();
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.arguments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
Expression_EmbeddedFunction::arguments() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.EmbeddedFunction.arguments)
  return arguments_;
}

// .substrait.Type output_type = 2 [json_name = "outputType"];
inline bool Expression_EmbeddedFunction::_internal_has_output_type() const {
  return this != internal_default_instance() && output_type_ != nullptr;
}
inline bool Expression_EmbeddedFunction::has_output_type() const {
  return _internal_has_output_type();
}
inline const ::substrait::Type& Expression_EmbeddedFunction::_internal_output_type() const {
  const ::substrait::Type* p = output_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(
      ::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Expression_EmbeddedFunction::output_type() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.output_type)
  return _internal_output_type();
}
inline void Expression_EmbeddedFunction::unsafe_arena_set_allocated_output_type(
    ::substrait::Type* output_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type_);
  }
  output_type_ = output_type;
  if (output_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.EmbeddedFunction.output_type)
}
inline ::substrait::Type* Expression_EmbeddedFunction::release_output_type() {
  
  ::substrait::Type* temp = output_type_;
  output_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Type* Expression_EmbeddedFunction::unsafe_arena_release_output_type() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.output_type)
  
  ::substrait::Type* temp = output_type_;
  output_type_ = nullptr;
  return temp;
}
inline ::substrait::Type* Expression_EmbeddedFunction::_internal_mutable_output_type() {
  
  if (output_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaForAllocation());
    output_type_ = p;
  }
  return output_type_;
}
inline ::substrait::Type* Expression_EmbeddedFunction::mutable_output_type() {
  ::substrait::Type* _msg = _internal_mutable_output_type();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.output_type)
  return _msg;
}
inline void Expression_EmbeddedFunction::set_allocated_output_type(::substrait::Type* output_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type_);
  }
  if (output_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type));
    if (message_arena != submessage_arena) {
      output_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_type, submessage_arena);
    }
    
  } else {
    
  }
  output_type_ = output_type;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.EmbeddedFunction.output_type)
}

// .substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function = 3 [json_name = "pythonPickleFunction"];
inline bool Expression_EmbeddedFunction::_internal_has_python_pickle_function() const {
  return kind_case() == kPythonPickleFunction;
}
inline bool Expression_EmbeddedFunction::has_python_pickle_function() const {
  return _internal_has_python_pickle_function();
}
inline void Expression_EmbeddedFunction::set_has_python_pickle_function() {
  _oneof_case_[0] = kPythonPickleFunction;
}
inline void Expression_EmbeddedFunction::clear_python_pickle_function() {
  if (_internal_has_python_pickle_function()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.python_pickle_function_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Expression_EmbeddedFunction::release_python_pickle_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.python_pickle_function)
  if (_internal_has_python_pickle_function()) {
    clear_has_kind();
      ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* temp = kind_.python_pickle_function_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.python_pickle_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& Expression_EmbeddedFunction::_internal_python_pickle_function() const {
  return _internal_has_python_pickle_function()
      ? *kind_.python_pickle_function_
      : reinterpret_cast< ::substrait::Expression_EmbeddedFunction_PythonPickleFunction&>(::substrait::_Expression_EmbeddedFunction_PythonPickleFunction_default_instance_);
}
inline const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& Expression_EmbeddedFunction::python_pickle_function() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.python_pickle_function)
  return _internal_python_pickle_function();
}
inline ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Expression_EmbeddedFunction::unsafe_arena_release_python_pickle_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.EmbeddedFunction.python_pickle_function)
  if (_internal_has_python_pickle_function()) {
    clear_has_kind();
    ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* temp = kind_.python_pickle_function_;
    kind_.python_pickle_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_EmbeddedFunction::unsafe_arena_set_allocated_python_pickle_function(::substrait::Expression_EmbeddedFunction_PythonPickleFunction* python_pickle_function) {
  clear_kind();
  if (python_pickle_function) {
    set_has_python_pickle_function();
    kind_.python_pickle_function_ = python_pickle_function;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.EmbeddedFunction.python_pickle_function)
}
inline ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Expression_EmbeddedFunction::_internal_mutable_python_pickle_function() {
  if (!_internal_has_python_pickle_function()) {
    clear_kind();
    set_has_python_pickle_function();
    kind_.python_pickle_function_ = CreateMaybeMessage< ::substrait::Expression_EmbeddedFunction_PythonPickleFunction >(GetArenaForAllocation());
  }
  return kind_.python_pickle_function_;
}
inline ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Expression_EmbeddedFunction::mutable_python_pickle_function() {
  ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* _msg = _internal_mutable_python_pickle_function();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.python_pickle_function)
  return _msg;
}

// .substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function = 4 [json_name = "webAssemblyFunction"];
inline bool Expression_EmbeddedFunction::_internal_has_web_assembly_function() const {
  return kind_case() == kWebAssemblyFunction;
}
inline bool Expression_EmbeddedFunction::has_web_assembly_function() const {
  return _internal_has_web_assembly_function();
}
inline void Expression_EmbeddedFunction::set_has_web_assembly_function() {
  _oneof_case_[0] = kWebAssemblyFunction;
}
inline void Expression_EmbeddedFunction::clear_web_assembly_function() {
  if (_internal_has_web_assembly_function()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.web_assembly_function_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Expression_EmbeddedFunction::release_web_assembly_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.web_assembly_function)
  if (_internal_has_web_assembly_function()) {
    clear_has_kind();
      ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* temp = kind_.web_assembly_function_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.web_assembly_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& Expression_EmbeddedFunction::_internal_web_assembly_function() const {
  return _internal_has_web_assembly_function()
      ? *kind_.web_assembly_function_
      : reinterpret_cast< ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction&>(::substrait::_Expression_EmbeddedFunction_WebAssemblyFunction_default_instance_);
}
inline const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& Expression_EmbeddedFunction::web_assembly_function() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.web_assembly_function)
  return _internal_web_assembly_function();
}
inline ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Expression_EmbeddedFunction::unsafe_arena_release_web_assembly_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.EmbeddedFunction.web_assembly_function)
  if (_internal_has_web_assembly_function()) {
    clear_has_kind();
    ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* temp = kind_.web_assembly_function_;
    kind_.web_assembly_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_EmbeddedFunction::unsafe_arena_set_allocated_web_assembly_function(::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* web_assembly_function) {
  clear_kind();
  if (web_assembly_function) {
    set_has_web_assembly_function();
    kind_.web_assembly_function_ = web_assembly_function;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.EmbeddedFunction.web_assembly_function)
}
inline ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Expression_EmbeddedFunction::_internal_mutable_web_assembly_function() {
  if (!_internal_has_web_assembly_function()) {
    clear_kind();
    set_has_web_assembly_function();
    kind_.web_assembly_function_ = CreateMaybeMessage< ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction >(GetArenaForAllocation());
  }
  return kind_.web_assembly_function_;
}
inline ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Expression_EmbeddedFunction::mutable_web_assembly_function() {
  ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* _msg = _internal_mutable_web_assembly_function();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.web_assembly_function)
  return _msg;
}

inline bool Expression_EmbeddedFunction::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Expression_EmbeddedFunction::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline Expression_EmbeddedFunction::KindCase Expression_EmbeddedFunction::kind_case() const {
  return Expression_EmbeddedFunction::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_ReferenceSegment_MapKey

// .substrait.Expression.Literal map_key = 1 [json_name = "mapKey"];
inline bool Expression_ReferenceSegment_MapKey::_internal_has_map_key() const {
  return this != internal_default_instance() && map_key_ != nullptr;
}
inline bool Expression_ReferenceSegment_MapKey::has_map_key() const {
  return _internal_has_map_key();
}
inline void Expression_ReferenceSegment_MapKey::clear_map_key() {
  if (GetArenaForAllocation() == nullptr && map_key_ != nullptr) {
    delete map_key_;
  }
  map_key_ = nullptr;
}
inline const ::substrait::Expression_Literal& Expression_ReferenceSegment_MapKey::_internal_map_key() const {
  const ::substrait::Expression_Literal* p = map_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_Literal&>(
      ::substrait::_Expression_Literal_default_instance_);
}
inline const ::substrait::Expression_Literal& Expression_ReferenceSegment_MapKey::map_key() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.MapKey.map_key)
  return _internal_map_key();
}
inline void Expression_ReferenceSegment_MapKey::unsafe_arena_set_allocated_map_key(
    ::substrait::Expression_Literal* map_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(map_key_);
  }
  map_key_ = map_key;
  if (map_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.MapKey.map_key)
}
inline ::substrait::Expression_Literal* Expression_ReferenceSegment_MapKey::release_map_key() {
  
  ::substrait::Expression_Literal* temp = map_key_;
  map_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_Literal* Expression_ReferenceSegment_MapKey::unsafe_arena_release_map_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.MapKey.map_key)
  
  ::substrait::Expression_Literal* temp = map_key_;
  map_key_ = nullptr;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_ReferenceSegment_MapKey::_internal_mutable_map_key() {
  
  if (map_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_Literal>(GetArenaForAllocation());
    map_key_ = p;
  }
  return map_key_;
}
inline ::substrait::Expression_Literal* Expression_ReferenceSegment_MapKey::mutable_map_key() {
  ::substrait::Expression_Literal* _msg = _internal_mutable_map_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.MapKey.map_key)
  return _msg;
}
inline void Expression_ReferenceSegment_MapKey::set_allocated_map_key(::substrait::Expression_Literal* map_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete map_key_;
  }
  if (map_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_Literal>::GetOwningArena(map_key);
    if (message_arena != submessage_arena) {
      map_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_key, submessage_arena);
    }
    
  } else {
    
  }
  map_key_ = map_key;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.MapKey.map_key)
}

// .substrait.Expression.ReferenceSegment child = 2 [json_name = "child"];
inline bool Expression_ReferenceSegment_MapKey::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool Expression_ReferenceSegment_MapKey::has_child() const {
  return _internal_has_child();
}
inline void Expression_ReferenceSegment_MapKey::clear_child() {
  if (GetArenaForAllocation() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_MapKey::_internal_child() const {
  const ::substrait::Expression_ReferenceSegment* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_ReferenceSegment&>(
      ::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_MapKey::child() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.MapKey.child)
  return _internal_child();
}
inline void Expression_ReferenceSegment_MapKey::unsafe_arena_set_allocated_child(
    ::substrait::Expression_ReferenceSegment* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.MapKey.child)
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_MapKey::release_child() {
  
  ::substrait::Expression_ReferenceSegment* temp = child_;
  child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_MapKey::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.MapKey.child)
  
  ::substrait::Expression_ReferenceSegment* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_MapKey::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_ReferenceSegment>(GetArenaForAllocation());
    child_ = p;
  }
  return child_;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_MapKey::mutable_child() {
  ::substrait::Expression_ReferenceSegment* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.MapKey.child)
  return _msg;
}
inline void Expression_ReferenceSegment_MapKey::set_allocated_child(::substrait::Expression_ReferenceSegment* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_ReferenceSegment>::GetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.MapKey.child)
}

// -------------------------------------------------------------------

// Expression_ReferenceSegment_StructField

// int32 field = 1 [json_name = "field"];
inline void Expression_ReferenceSegment_StructField::clear_field() {
  field_ = 0;
}
inline int32_t Expression_ReferenceSegment_StructField::_internal_field() const {
  return field_;
}
inline int32_t Expression_ReferenceSegment_StructField::field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.StructField.field)
  return _internal_field();
}
inline void Expression_ReferenceSegment_StructField::_internal_set_field(int32_t value) {
  
  field_ = value;
}
inline void Expression_ReferenceSegment_StructField::set_field(int32_t value) {
  _internal_set_field(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.ReferenceSegment.StructField.field)
}

// .substrait.Expression.ReferenceSegment child = 2 [json_name = "child"];
inline bool Expression_ReferenceSegment_StructField::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool Expression_ReferenceSegment_StructField::has_child() const {
  return _internal_has_child();
}
inline void Expression_ReferenceSegment_StructField::clear_child() {
  if (GetArenaForAllocation() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_StructField::_internal_child() const {
  const ::substrait::Expression_ReferenceSegment* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_ReferenceSegment&>(
      ::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_StructField::child() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.StructField.child)
  return _internal_child();
}
inline void Expression_ReferenceSegment_StructField::unsafe_arena_set_allocated_child(
    ::substrait::Expression_ReferenceSegment* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.StructField.child)
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_StructField::release_child() {
  
  ::substrait::Expression_ReferenceSegment* temp = child_;
  child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_StructField::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.StructField.child)
  
  ::substrait::Expression_ReferenceSegment* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_StructField::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_ReferenceSegment>(GetArenaForAllocation());
    child_ = p;
  }
  return child_;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_StructField::mutable_child() {
  ::substrait::Expression_ReferenceSegment* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.StructField.child)
  return _msg;
}
inline void Expression_ReferenceSegment_StructField::set_allocated_child(::substrait::Expression_ReferenceSegment* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_ReferenceSegment>::GetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.StructField.child)
}

// -------------------------------------------------------------------

// Expression_ReferenceSegment_ListElement

// int32 offset = 1 [json_name = "offset"];
inline void Expression_ReferenceSegment_ListElement::clear_offset() {
  offset_ = 0;
}
inline int32_t Expression_ReferenceSegment_ListElement::_internal_offset() const {
  return offset_;
}
inline int32_t Expression_ReferenceSegment_ListElement::offset() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.ListElement.offset)
  return _internal_offset();
}
inline void Expression_ReferenceSegment_ListElement::_internal_set_offset(int32_t value) {
  
  offset_ = value;
}
inline void Expression_ReferenceSegment_ListElement::set_offset(int32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.ReferenceSegment.ListElement.offset)
}

// .substrait.Expression.ReferenceSegment child = 2 [json_name = "child"];
inline bool Expression_ReferenceSegment_ListElement::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool Expression_ReferenceSegment_ListElement::has_child() const {
  return _internal_has_child();
}
inline void Expression_ReferenceSegment_ListElement::clear_child() {
  if (GetArenaForAllocation() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_ListElement::_internal_child() const {
  const ::substrait::Expression_ReferenceSegment* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_ReferenceSegment&>(
      ::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_ListElement::child() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.ListElement.child)
  return _internal_child();
}
inline void Expression_ReferenceSegment_ListElement::unsafe_arena_set_allocated_child(
    ::substrait::Expression_ReferenceSegment* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.ListElement.child)
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_ListElement::release_child() {
  
  ::substrait::Expression_ReferenceSegment* temp = child_;
  child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_ListElement::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.ListElement.child)
  
  ::substrait::Expression_ReferenceSegment* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_ListElement::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_ReferenceSegment>(GetArenaForAllocation());
    child_ = p;
  }
  return child_;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_ListElement::mutable_child() {
  ::substrait::Expression_ReferenceSegment* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.ListElement.child)
  return _msg;
}
inline void Expression_ReferenceSegment_ListElement::set_allocated_child(::substrait::Expression_ReferenceSegment* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_ReferenceSegment>::GetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.ListElement.child)
}

// -------------------------------------------------------------------

// Expression_ReferenceSegment

// .substrait.Expression.ReferenceSegment.MapKey map_key = 1 [json_name = "mapKey"];
inline bool Expression_ReferenceSegment::_internal_has_map_key() const {
  return reference_type_case() == kMapKey;
}
inline bool Expression_ReferenceSegment::has_map_key() const {
  return _internal_has_map_key();
}
inline void Expression_ReferenceSegment::set_has_map_key() {
  _oneof_case_[0] = kMapKey;
}
inline void Expression_ReferenceSegment::clear_map_key() {
  if (_internal_has_map_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete reference_type_.map_key_;
    }
    clear_has_reference_type();
  }
}
inline ::substrait::Expression_ReferenceSegment_MapKey* Expression_ReferenceSegment::release_map_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.map_key)
  if (_internal_has_map_key()) {
    clear_has_reference_type();
      ::substrait::Expression_ReferenceSegment_MapKey* temp = reference_type_.map_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.map_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_ReferenceSegment_MapKey& Expression_ReferenceSegment::_internal_map_key() const {
  return _internal_has_map_key()
      ? *reference_type_.map_key_
      : reinterpret_cast< ::substrait::Expression_ReferenceSegment_MapKey&>(::substrait::_Expression_ReferenceSegment_MapKey_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment_MapKey& Expression_ReferenceSegment::map_key() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.map_key)
  return _internal_map_key();
}
inline ::substrait::Expression_ReferenceSegment_MapKey* Expression_ReferenceSegment::unsafe_arena_release_map_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.ReferenceSegment.map_key)
  if (_internal_has_map_key()) {
    clear_has_reference_type();
    ::substrait::Expression_ReferenceSegment_MapKey* temp = reference_type_.map_key_;
    reference_type_.map_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_ReferenceSegment::unsafe_arena_set_allocated_map_key(::substrait::Expression_ReferenceSegment_MapKey* map_key) {
  clear_reference_type();
  if (map_key) {
    set_has_map_key();
    reference_type_.map_key_ = map_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.map_key)
}
inline ::substrait::Expression_ReferenceSegment_MapKey* Expression_ReferenceSegment::_internal_mutable_map_key() {
  if (!_internal_has_map_key()) {
    clear_reference_type();
    set_has_map_key();
    reference_type_.map_key_ = CreateMaybeMessage< ::substrait::Expression_ReferenceSegment_MapKey >(GetArenaForAllocation());
  }
  return reference_type_.map_key_;
}
inline ::substrait::Expression_ReferenceSegment_MapKey* Expression_ReferenceSegment::mutable_map_key() {
  ::substrait::Expression_ReferenceSegment_MapKey* _msg = _internal_mutable_map_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.map_key)
  return _msg;
}

// .substrait.Expression.ReferenceSegment.StructField struct_field = 2 [json_name = "structField"];
inline bool Expression_ReferenceSegment::_internal_has_struct_field() const {
  return reference_type_case() == kStructField;
}
inline bool Expression_ReferenceSegment::has_struct_field() const {
  return _internal_has_struct_field();
}
inline void Expression_ReferenceSegment::set_has_struct_field() {
  _oneof_case_[0] = kStructField;
}
inline void Expression_ReferenceSegment::clear_struct_field() {
  if (_internal_has_struct_field()) {
    if (GetArenaForAllocation() == nullptr) {
      delete reference_type_.struct_field_;
    }
    clear_has_reference_type();
  }
}
inline ::substrait::Expression_ReferenceSegment_StructField* Expression_ReferenceSegment::release_struct_field() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.struct_field)
  if (_internal_has_struct_field()) {
    clear_has_reference_type();
      ::substrait::Expression_ReferenceSegment_StructField* temp = reference_type_.struct_field_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.struct_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_ReferenceSegment_StructField& Expression_ReferenceSegment::_internal_struct_field() const {
  return _internal_has_struct_field()
      ? *reference_type_.struct_field_
      : reinterpret_cast< ::substrait::Expression_ReferenceSegment_StructField&>(::substrait::_Expression_ReferenceSegment_StructField_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment_StructField& Expression_ReferenceSegment::struct_field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.struct_field)
  return _internal_struct_field();
}
inline ::substrait::Expression_ReferenceSegment_StructField* Expression_ReferenceSegment::unsafe_arena_release_struct_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.ReferenceSegment.struct_field)
  if (_internal_has_struct_field()) {
    clear_has_reference_type();
    ::substrait::Expression_ReferenceSegment_StructField* temp = reference_type_.struct_field_;
    reference_type_.struct_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_ReferenceSegment::unsafe_arena_set_allocated_struct_field(::substrait::Expression_ReferenceSegment_StructField* struct_field) {
  clear_reference_type();
  if (struct_field) {
    set_has_struct_field();
    reference_type_.struct_field_ = struct_field;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.struct_field)
}
inline ::substrait::Expression_ReferenceSegment_StructField* Expression_ReferenceSegment::_internal_mutable_struct_field() {
  if (!_internal_has_struct_field()) {
    clear_reference_type();
    set_has_struct_field();
    reference_type_.struct_field_ = CreateMaybeMessage< ::substrait::Expression_ReferenceSegment_StructField >(GetArenaForAllocation());
  }
  return reference_type_.struct_field_;
}
inline ::substrait::Expression_ReferenceSegment_StructField* Expression_ReferenceSegment::mutable_struct_field() {
  ::substrait::Expression_ReferenceSegment_StructField* _msg = _internal_mutable_struct_field();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.struct_field)
  return _msg;
}

// .substrait.Expression.ReferenceSegment.ListElement list_element = 3 [json_name = "listElement"];
inline bool Expression_ReferenceSegment::_internal_has_list_element() const {
  return reference_type_case() == kListElement;
}
inline bool Expression_ReferenceSegment::has_list_element() const {
  return _internal_has_list_element();
}
inline void Expression_ReferenceSegment::set_has_list_element() {
  _oneof_case_[0] = kListElement;
}
inline void Expression_ReferenceSegment::clear_list_element() {
  if (_internal_has_list_element()) {
    if (GetArenaForAllocation() == nullptr) {
      delete reference_type_.list_element_;
    }
    clear_has_reference_type();
  }
}
inline ::substrait::Expression_ReferenceSegment_ListElement* Expression_ReferenceSegment::release_list_element() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.list_element)
  if (_internal_has_list_element()) {
    clear_has_reference_type();
      ::substrait::Expression_ReferenceSegment_ListElement* temp = reference_type_.list_element_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.list_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_ReferenceSegment_ListElement& Expression_ReferenceSegment::_internal_list_element() const {
  return _internal_has_list_element()
      ? *reference_type_.list_element_
      : reinterpret_cast< ::substrait::Expression_ReferenceSegment_ListElement&>(::substrait::_Expression_ReferenceSegment_ListElement_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment_ListElement& Expression_ReferenceSegment::list_element() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.list_element)
  return _internal_list_element();
}
inline ::substrait::Expression_ReferenceSegment_ListElement* Expression_ReferenceSegment::unsafe_arena_release_list_element() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.ReferenceSegment.list_element)
  if (_internal_has_list_element()) {
    clear_has_reference_type();
    ::substrait::Expression_ReferenceSegment_ListElement* temp = reference_type_.list_element_;
    reference_type_.list_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_ReferenceSegment::unsafe_arena_set_allocated_list_element(::substrait::Expression_ReferenceSegment_ListElement* list_element) {
  clear_reference_type();
  if (list_element) {
    set_has_list_element();
    reference_type_.list_element_ = list_element;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.list_element)
}
inline ::substrait::Expression_ReferenceSegment_ListElement* Expression_ReferenceSegment::_internal_mutable_list_element() {
  if (!_internal_has_list_element()) {
    clear_reference_type();
    set_has_list_element();
    reference_type_.list_element_ = CreateMaybeMessage< ::substrait::Expression_ReferenceSegment_ListElement >(GetArenaForAllocation());
  }
  return reference_type_.list_element_;
}
inline ::substrait::Expression_ReferenceSegment_ListElement* Expression_ReferenceSegment::mutable_list_element() {
  ::substrait::Expression_ReferenceSegment_ListElement* _msg = _internal_mutable_list_element();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.list_element)
  return _msg;
}

inline bool Expression_ReferenceSegment::has_reference_type() const {
  return reference_type_case() != REFERENCE_TYPE_NOT_SET;
}
inline void Expression_ReferenceSegment::clear_has_reference_type() {
  _oneof_case_[0] = REFERENCE_TYPE_NOT_SET;
}
inline Expression_ReferenceSegment::ReferenceTypeCase Expression_ReferenceSegment::reference_type_case() const {
  return Expression_ReferenceSegment::ReferenceTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression_Select

// .substrait.Expression.MaskExpression.StructSelect struct = 1 [json_name = "struct"];
inline bool Expression_MaskExpression_Select::_internal_has_struct_() const {
  return type_case() == kStruct;
}
inline bool Expression_MaskExpression_Select::has_struct_() const {
  return _internal_has_struct_();
}
inline void Expression_MaskExpression_Select::set_has_struct_() {
  _oneof_case_[0] = kStruct;
}
inline void Expression_MaskExpression_Select::clear_struct_() {
  if (_internal_has_struct_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.struct__;
    }
    clear_has_type();
  }
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression_Select::release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.Select.struct)
  if (_internal_has_struct_()) {
    clear_has_type();
      ::substrait::Expression_MaskExpression_StructSelect* temp = type_.struct__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression_Select::_internal_struct_() const {
  return _internal_has_struct_()
      ? *type_.struct__
      : reinterpret_cast< ::substrait::Expression_MaskExpression_StructSelect&>(::substrait::_Expression_MaskExpression_StructSelect_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression_Select::struct_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.Select.struct)
  return _internal_struct_();
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression_Select::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.Select.struct)
  if (_internal_has_struct_()) {
    clear_has_type();
    ::substrait::Expression_MaskExpression_StructSelect* temp = type_.struct__;
    type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_Select::unsafe_arena_set_allocated_struct_(::substrait::Expression_MaskExpression_StructSelect* struct_) {
  clear_type();
  if (struct_) {
    set_has_struct_();
    type_.struct__ = struct_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.Select.struct)
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression_Select::_internal_mutable_struct_() {
  if (!_internal_has_struct_()) {
    clear_type();
    set_has_struct_();
    type_.struct__ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_StructSelect >(GetArenaForAllocation());
  }
  return type_.struct__;
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression_Select::mutable_struct_() {
  ::substrait::Expression_MaskExpression_StructSelect* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.Select.struct)
  return _msg;
}

// .substrait.Expression.MaskExpression.ListSelect list = 2 [json_name = "list"];
inline bool Expression_MaskExpression_Select::_internal_has_list() const {
  return type_case() == kList;
}
inline bool Expression_MaskExpression_Select::has_list() const {
  return _internal_has_list();
}
inline void Expression_MaskExpression_Select::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void Expression_MaskExpression_Select::clear_list() {
  if (_internal_has_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.list_;
    }
    clear_has_type();
  }
}
inline ::substrait::Expression_MaskExpression_ListSelect* Expression_MaskExpression_Select::release_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.Select.list)
  if (_internal_has_list()) {
    clear_has_type();
      ::substrait::Expression_MaskExpression_ListSelect* temp = type_.list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect& Expression_MaskExpression_Select::_internal_list() const {
  return _internal_has_list()
      ? *type_.list_
      : reinterpret_cast< ::substrait::Expression_MaskExpression_ListSelect&>(::substrait::_Expression_MaskExpression_ListSelect_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_ListSelect& Expression_MaskExpression_Select::list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.Select.list)
  return _internal_list();
}
inline ::substrait::Expression_MaskExpression_ListSelect* Expression_MaskExpression_Select::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.Select.list)
  if (_internal_has_list()) {
    clear_has_type();
    ::substrait::Expression_MaskExpression_ListSelect* temp = type_.list_;
    type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_Select::unsafe_arena_set_allocated_list(::substrait::Expression_MaskExpression_ListSelect* list) {
  clear_type();
  if (list) {
    set_has_list();
    type_.list_ = list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.Select.list)
}
inline ::substrait::Expression_MaskExpression_ListSelect* Expression_MaskExpression_Select::_internal_mutable_list() {
  if (!_internal_has_list()) {
    clear_type();
    set_has_list();
    type_.list_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_ListSelect >(GetArenaForAllocation());
  }
  return type_.list_;
}
inline ::substrait::Expression_MaskExpression_ListSelect* Expression_MaskExpression_Select::mutable_list() {
  ::substrait::Expression_MaskExpression_ListSelect* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.Select.list)
  return _msg;
}

// .substrait.Expression.MaskExpression.MapSelect map = 3 [json_name = "map"];
inline bool Expression_MaskExpression_Select::_internal_has_map() const {
  return type_case() == kMap;
}
inline bool Expression_MaskExpression_Select::has_map() const {
  return _internal_has_map();
}
inline void Expression_MaskExpression_Select::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void Expression_MaskExpression_Select::clear_map() {
  if (_internal_has_map()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.map_;
    }
    clear_has_type();
  }
}
inline ::substrait::Expression_MaskExpression_MapSelect* Expression_MaskExpression_Select::release_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.Select.map)
  if (_internal_has_map()) {
    clear_has_type();
      ::substrait::Expression_MaskExpression_MapSelect* temp = type_.map_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect& Expression_MaskExpression_Select::_internal_map() const {
  return _internal_has_map()
      ? *type_.map_
      : reinterpret_cast< ::substrait::Expression_MaskExpression_MapSelect&>(::substrait::_Expression_MaskExpression_MapSelect_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_MapSelect& Expression_MaskExpression_Select::map() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.Select.map)
  return _internal_map();
}
inline ::substrait::Expression_MaskExpression_MapSelect* Expression_MaskExpression_Select::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.Select.map)
  if (_internal_has_map()) {
    clear_has_type();
    ::substrait::Expression_MaskExpression_MapSelect* temp = type_.map_;
    type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_Select::unsafe_arena_set_allocated_map(::substrait::Expression_MaskExpression_MapSelect* map) {
  clear_type();
  if (map) {
    set_has_map();
    type_.map_ = map;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.Select.map)
}
inline ::substrait::Expression_MaskExpression_MapSelect* Expression_MaskExpression_Select::_internal_mutable_map() {
  if (!_internal_has_map()) {
    clear_type();
    set_has_map();
    type_.map_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_MapSelect >(GetArenaForAllocation());
  }
  return type_.map_;
}
inline ::substrait::Expression_MaskExpression_MapSelect* Expression_MaskExpression_Select::mutable_map() {
  ::substrait::Expression_MaskExpression_MapSelect* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.Select.map)
  return _msg;
}

inline bool Expression_MaskExpression_Select::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Expression_MaskExpression_Select::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Expression_MaskExpression_Select::TypeCase Expression_MaskExpression_Select::type_case() const {
  return Expression_MaskExpression_Select::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression_StructSelect

// repeated .substrait.Expression.MaskExpression.StructItem struct_items = 1 [json_name = "structItems"];
inline int Expression_MaskExpression_StructSelect::_internal_struct_items_size() const {
  return struct_items_.size();
}
inline int Expression_MaskExpression_StructSelect::struct_items_size() const {
  return _internal_struct_items_size();
}
inline void Expression_MaskExpression_StructSelect::clear_struct_items() {
  struct_items_.Clear();
}
inline ::substrait::Expression_MaskExpression_StructItem* Expression_MaskExpression_StructSelect::mutable_struct_items(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return struct_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem >*
Expression_MaskExpression_StructSelect::mutable_struct_items() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return &struct_items_;
}
inline const ::substrait::Expression_MaskExpression_StructItem& Expression_MaskExpression_StructSelect::_internal_struct_items(int index) const {
  return struct_items_.Get(index);
}
inline const ::substrait::Expression_MaskExpression_StructItem& Expression_MaskExpression_StructSelect::struct_items(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return _internal_struct_items(index);
}
inline ::substrait::Expression_MaskExpression_StructItem* Expression_MaskExpression_StructSelect::_internal_add_struct_items() {
  return struct_items_.Add();
}
inline ::substrait::Expression_MaskExpression_StructItem* Expression_MaskExpression_StructSelect::add_struct_items() {
  ::substrait::Expression_MaskExpression_StructItem* _add = _internal_add_struct_items();
  // @@protoc_insertion_point(field_add:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem >&
Expression_MaskExpression_StructSelect::struct_items() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return struct_items_;
}

// -------------------------------------------------------------------

// Expression_MaskExpression_StructItem

// int32 field = 1 [json_name = "field"];
inline void Expression_MaskExpression_StructItem::clear_field() {
  field_ = 0;
}
inline int32_t Expression_MaskExpression_StructItem::_internal_field() const {
  return field_;
}
inline int32_t Expression_MaskExpression_StructItem::field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.StructItem.field)
  return _internal_field();
}
inline void Expression_MaskExpression_StructItem::_internal_set_field(int32_t value) {
  
  field_ = value;
}
inline void Expression_MaskExpression_StructItem::set_field(int32_t value) {
  _internal_set_field(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.StructItem.field)
}

// .substrait.Expression.MaskExpression.Select child = 2 [json_name = "child"];
inline bool Expression_MaskExpression_StructItem::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool Expression_MaskExpression_StructItem::has_child() const {
  return _internal_has_child();
}
inline void Expression_MaskExpression_StructItem::clear_child() {
  if (GetArenaForAllocation() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_StructItem::_internal_child() const {
  const ::substrait::Expression_MaskExpression_Select* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_MaskExpression_Select&>(
      ::substrait::_Expression_MaskExpression_Select_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_StructItem::child() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.StructItem.child)
  return _internal_child();
}
inline void Expression_MaskExpression_StructItem::unsafe_arena_set_allocated_child(
    ::substrait::Expression_MaskExpression_Select* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.StructItem.child)
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_StructItem::release_child() {
  
  ::substrait::Expression_MaskExpression_Select* temp = child_;
  child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_StructItem::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.StructItem.child)
  
  ::substrait::Expression_MaskExpression_Select* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_StructItem::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_MaskExpression_Select>(GetArenaForAllocation());
    child_ = p;
  }
  return child_;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_StructItem::mutable_child() {
  ::substrait::Expression_MaskExpression_Select* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.StructItem.child)
  return _msg;
}
inline void Expression_MaskExpression_StructItem::set_allocated_child(::substrait::Expression_MaskExpression_Select* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_MaskExpression_Select>::GetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.StructItem.child)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect_ListSelectItem_ListElement

// int32 field = 1 [json_name = "field"];
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::clear_field() {
  field_ = 0;
}
inline int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::_internal_field() const {
  return field_;
}
inline int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement.field)
  return _internal_field();
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::_internal_set_field(int32_t value) {
  
  field_ = value;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::set_field(int32_t value) {
  _internal_set_field(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement.field)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice

// int32 start = 1 [json_name = "start"];
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::clear_start() {
  start_ = 0;
}
inline int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_start() const {
  return start_;
}
inline int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::start() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.start)
  return _internal_start();
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_set_start(int32_t value) {
  
  start_ = value;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::set_start(int32_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.start)
}

// int32 end = 2 [json_name = "end"];
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::clear_end() {
  end_ = 0;
}
inline int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_end() const {
  return end_;
}
inline int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::end() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.end)
  return _internal_end();
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_set_end(int32_t value) {
  
  end_ = value;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::set_end(int32_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.end)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect_ListSelectItem

// .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1 [json_name = "item"];
inline bool Expression_MaskExpression_ListSelect_ListSelectItem::_internal_has_item() const {
  return type_case() == kItem;
}
inline bool Expression_MaskExpression_ListSelect_ListSelectItem::has_item() const {
  return _internal_has_item();
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::set_has_item() {
  _oneof_case_[0] = kItem;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::clear_item() {
  if (_internal_has_item()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.item_;
    }
    clear_has_type();
  }
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Expression_MaskExpression_ListSelect_ListSelectItem::release_item() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  if (_internal_has_item()) {
    clear_has_type();
      ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* temp = type_.item_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& Expression_MaskExpression_ListSelect_ListSelectItem::_internal_item() const {
  return _internal_has_item()
      ? *type_.item_
      : reinterpret_cast< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement&>(::substrait::_Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& Expression_MaskExpression_ListSelect_ListSelectItem::item() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  return _internal_item();
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Expression_MaskExpression_ListSelect_ListSelectItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  if (_internal_has_item()) {
    clear_has_type();
    ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* temp = type_.item_;
    type_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::unsafe_arena_set_allocated_item(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* item) {
  clear_type();
  if (item) {
    set_has_item();
    type_.item_ = item;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Expression_MaskExpression_ListSelect_ListSelectItem::_internal_mutable_item() {
  if (!_internal_has_item()) {
    clear_type();
    set_has_item();
    type_.item_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement >(GetArenaForAllocation());
  }
  return type_.item_;
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Expression_MaskExpression_ListSelect_ListSelectItem::mutable_item() {
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  return _msg;
}

// .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2 [json_name = "slice"];
inline bool Expression_MaskExpression_ListSelect_ListSelectItem::_internal_has_slice() const {
  return type_case() == kSlice;
}
inline bool Expression_MaskExpression_ListSelect_ListSelectItem::has_slice() const {
  return _internal_has_slice();
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::set_has_slice() {
  _oneof_case_[0] = kSlice;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::clear_slice() {
  if (_internal_has_slice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.slice_;
    }
    clear_has_type();
  }
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Expression_MaskExpression_ListSelect_ListSelectItem::release_slice() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  if (_internal_has_slice()) {
    clear_has_type();
      ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* temp = type_.slice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& Expression_MaskExpression_ListSelect_ListSelectItem::_internal_slice() const {
  return _internal_has_slice()
      ? *type_.slice_
      : reinterpret_cast< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice&>(::substrait::_Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& Expression_MaskExpression_ListSelect_ListSelectItem::slice() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  return _internal_slice();
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Expression_MaskExpression_ListSelect_ListSelectItem::unsafe_arena_release_slice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  if (_internal_has_slice()) {
    clear_has_type();
    ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* temp = type_.slice_;
    type_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::unsafe_arena_set_allocated_slice(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* slice) {
  clear_type();
  if (slice) {
    set_has_slice();
    type_.slice_ = slice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Expression_MaskExpression_ListSelect_ListSelectItem::_internal_mutable_slice() {
  if (!_internal_has_slice()) {
    clear_type();
    set_has_slice();
    type_.slice_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice >(GetArenaForAllocation());
  }
  return type_.slice_;
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Expression_MaskExpression_ListSelect_ListSelectItem::mutable_slice() {
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* _msg = _internal_mutable_slice();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  return _msg;
}

inline bool Expression_MaskExpression_ListSelect_ListSelectItem::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Expression_MaskExpression_ListSelect_ListSelectItem::TypeCase Expression_MaskExpression_ListSelect_ListSelectItem::type_case() const {
  return Expression_MaskExpression_ListSelect_ListSelectItem::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect

// repeated .substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection = 1 [json_name = "selection"];
inline int Expression_MaskExpression_ListSelect::_internal_selection_size() const {
  return selection_.size();
}
inline int Expression_MaskExpression_ListSelect::selection_size() const {
  return _internal_selection_size();
}
inline void Expression_MaskExpression_ListSelect::clear_selection() {
  selection_.Clear();
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* Expression_MaskExpression_ListSelect::mutable_selection(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.selection)
  return selection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem >*
Expression_MaskExpression_ListSelect::mutable_selection() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MaskExpression.ListSelect.selection)
  return &selection_;
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem& Expression_MaskExpression_ListSelect::_internal_selection(int index) const {
  return selection_.Get(index);
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem& Expression_MaskExpression_ListSelect::selection(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.selection)
  return _internal_selection(index);
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* Expression_MaskExpression_ListSelect::_internal_add_selection() {
  return selection_.Add();
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* Expression_MaskExpression_ListSelect::add_selection() {
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* _add = _internal_add_selection();
  // @@protoc_insertion_point(field_add:substrait.Expression.MaskExpression.ListSelect.selection)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem >&
Expression_MaskExpression_ListSelect::selection() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.MaskExpression.ListSelect.selection)
  return selection_;
}

// .substrait.Expression.MaskExpression.Select child = 2 [json_name = "child"];
inline bool Expression_MaskExpression_ListSelect::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool Expression_MaskExpression_ListSelect::has_child() const {
  return _internal_has_child();
}
inline void Expression_MaskExpression_ListSelect::clear_child() {
  if (GetArenaForAllocation() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_ListSelect::_internal_child() const {
  const ::substrait::Expression_MaskExpression_Select* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_MaskExpression_Select&>(
      ::substrait::_Expression_MaskExpression_Select_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_ListSelect::child() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.child)
  return _internal_child();
}
inline void Expression_MaskExpression_ListSelect::unsafe_arena_set_allocated_child(
    ::substrait::Expression_MaskExpression_Select* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.ListSelect.child)
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_ListSelect::release_child() {
  
  ::substrait::Expression_MaskExpression_Select* temp = child_;
  child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_ListSelect::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.ListSelect.child)
  
  ::substrait::Expression_MaskExpression_Select* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_ListSelect::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_MaskExpression_Select>(GetArenaForAllocation());
    child_ = p;
  }
  return child_;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_ListSelect::mutable_child() {
  ::substrait::Expression_MaskExpression_Select* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.child)
  return _msg;
}
inline void Expression_MaskExpression_ListSelect::set_allocated_child(::substrait::Expression_MaskExpression_Select* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_MaskExpression_Select>::GetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.ListSelect.child)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_MapSelect_MapKey

// string map_key = 1 [json_name = "mapKey"];
inline void Expression_MaskExpression_MapSelect_MapKey::clear_map_key() {
  map_key_.ClearToEmpty();
}
inline const std::string& Expression_MaskExpression_MapSelect_MapKey::map_key() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
  return _internal_map_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Expression_MaskExpression_MapSelect_MapKey::set_map_key(ArgT0&& arg0, ArgT... args) {
 
 map_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
}
inline std::string* Expression_MaskExpression_MapSelect_MapKey::mutable_map_key() {
  std::string* _s = _internal_mutable_map_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
  return _s;
}
inline const std::string& Expression_MaskExpression_MapSelect_MapKey::_internal_map_key() const {
  return map_key_.Get();
}
inline void Expression_MaskExpression_MapSelect_MapKey::_internal_set_map_key(const std::string& value) {
  
  map_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_MaskExpression_MapSelect_MapKey::_internal_mutable_map_key() {
  
  return map_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_MaskExpression_MapSelect_MapKey::release_map_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
  return map_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Expression_MaskExpression_MapSelect_MapKey::set_allocated_map_key(std::string* map_key) {
  if (map_key != nullptr) {
    
  } else {
    
  }
  map_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (map_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    map_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_MapSelect_MapKeyExpression

// string map_key_expression = 1 [json_name = "mapKeyExpression"];
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::clear_map_key_expression() {
  map_key_expression_.ClearToEmpty();
}
inline const std::string& Expression_MaskExpression_MapSelect_MapKeyExpression::map_key_expression() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  return _internal_map_key_expression();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Expression_MaskExpression_MapSelect_MapKeyExpression::set_map_key_expression(ArgT0&& arg0, ArgT... args) {
 
 map_key_expression_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}
inline std::string* Expression_MaskExpression_MapSelect_MapKeyExpression::mutable_map_key_expression() {
  std::string* _s = _internal_mutable_map_key_expression();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  return _s;
}
inline const std::string& Expression_MaskExpression_MapSelect_MapKeyExpression::_internal_map_key_expression() const {
  return map_key_expression_.Get();
}
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::_internal_set_map_key_expression(const std::string& value) {
  
  map_key_expression_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expression_MaskExpression_MapSelect_MapKeyExpression::_internal_mutable_map_key_expression() {
  
  return map_key_expression_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expression_MaskExpression_MapSelect_MapKeyExpression::release_map_key_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  return map_key_expression_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::set_allocated_map_key_expression(std::string* map_key_expression) {
  if (map_key_expression != nullptr) {
    
  } else {
    
  }
  map_key_expression_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_key_expression,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (map_key_expression_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    map_key_expression_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_MapSelect

// .substrait.Expression.MaskExpression.MapSelect.MapKey key = 1 [json_name = "key"];
inline bool Expression_MaskExpression_MapSelect::_internal_has_key() const {
  return select_case() == kKey;
}
inline bool Expression_MaskExpression_MapSelect::has_key() const {
  return _internal_has_key();
}
inline void Expression_MaskExpression_MapSelect::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void Expression_MaskExpression_MapSelect::clear_key() {
  if (_internal_has_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete select_.key_;
    }
    clear_has_select();
  }
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKey* Expression_MaskExpression_MapSelect::release_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.key)
  if (_internal_has_key()) {
    clear_has_select();
      ::substrait::Expression_MaskExpression_MapSelect_MapKey* temp = select_.key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    select_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKey& Expression_MaskExpression_MapSelect::_internal_key() const {
  return _internal_has_key()
      ? *select_.key_
      : reinterpret_cast< ::substrait::Expression_MaskExpression_MapSelect_MapKey&>(::substrait::_Expression_MaskExpression_MapSelect_MapKey_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKey& Expression_MaskExpression_MapSelect::key() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.key)
  return _internal_key();
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKey* Expression_MaskExpression_MapSelect::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.MapSelect.key)
  if (_internal_has_key()) {
    clear_has_select();
    ::substrait::Expression_MaskExpression_MapSelect_MapKey* temp = select_.key_;
    select_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_MapSelect::unsafe_arena_set_allocated_key(::substrait::Expression_MaskExpression_MapSelect_MapKey* key) {
  clear_select();
  if (key) {
    set_has_key();
    select_.key_ = key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.MapSelect.key)
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKey* Expression_MaskExpression_MapSelect::_internal_mutable_key() {
  if (!_internal_has_key()) {
    clear_select();
    set_has_key();
    select_.key_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_MapSelect_MapKey >(GetArenaForAllocation());
  }
  return select_.key_;
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKey* Expression_MaskExpression_MapSelect::mutable_key() {
  ::substrait::Expression_MaskExpression_MapSelect_MapKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.key)
  return _msg;
}

// .substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression = 2 [json_name = "expression"];
inline bool Expression_MaskExpression_MapSelect::_internal_has_expression() const {
  return select_case() == kExpression;
}
inline bool Expression_MaskExpression_MapSelect::has_expression() const {
  return _internal_has_expression();
}
inline void Expression_MaskExpression_MapSelect::set_has_expression() {
  _oneof_case_[0] = kExpression;
}
inline void Expression_MaskExpression_MapSelect::clear_expression() {
  if (_internal_has_expression()) {
    if (GetArenaForAllocation() == nullptr) {
      delete select_.expression_;
    }
    clear_has_select();
  }
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Expression_MaskExpression_MapSelect::release_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.expression)
  if (_internal_has_expression()) {
    clear_has_select();
      ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* temp = select_.expression_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    select_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& Expression_MaskExpression_MapSelect::_internal_expression() const {
  return _internal_has_expression()
      ? *select_.expression_
      : reinterpret_cast< ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression&>(::substrait::_Expression_MaskExpression_MapSelect_MapKeyExpression_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& Expression_MaskExpression_MapSelect::expression() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.expression)
  return _internal_expression();
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Expression_MaskExpression_MapSelect::unsafe_arena_release_expression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.MapSelect.expression)
  if (_internal_has_expression()) {
    clear_has_select();
    ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* temp = select_.expression_;
    select_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_MapSelect::unsafe_arena_set_allocated_expression(::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* expression) {
  clear_select();
  if (expression) {
    set_has_expression();
    select_.expression_ = expression;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.MapSelect.expression)
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Expression_MaskExpression_MapSelect::_internal_mutable_expression() {
  if (!_internal_has_expression()) {
    clear_select();
    set_has_expression();
    select_.expression_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression >(GetArenaForAllocation());
  }
  return select_.expression_;
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Expression_MaskExpression_MapSelect::mutable_expression() {
  ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.expression)
  return _msg;
}

// .substrait.Expression.MaskExpression.Select child = 3 [json_name = "child"];
inline bool Expression_MaskExpression_MapSelect::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool Expression_MaskExpression_MapSelect::has_child() const {
  return _internal_has_child();
}
inline void Expression_MaskExpression_MapSelect::clear_child() {
  if (GetArenaForAllocation() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_MapSelect::_internal_child() const {
  const ::substrait::Expression_MaskExpression_Select* p = child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_MaskExpression_Select&>(
      ::substrait::_Expression_MaskExpression_Select_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_MapSelect::child() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.child)
  return _internal_child();
}
inline void Expression_MaskExpression_MapSelect::unsafe_arena_set_allocated_child(
    ::substrait::Expression_MaskExpression_Select* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.MapSelect.child)
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_MapSelect::release_child() {
  
  ::substrait::Expression_MaskExpression_Select* temp = child_;
  child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_MapSelect::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.child)
  
  ::substrait::Expression_MaskExpression_Select* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_MapSelect::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_MaskExpression_Select>(GetArenaForAllocation());
    child_ = p;
  }
  return child_;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_MapSelect::mutable_child() {
  ::substrait::Expression_MaskExpression_Select* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.child)
  return _msg;
}
inline void Expression_MaskExpression_MapSelect::set_allocated_child(::substrait::Expression_MaskExpression_Select* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_MaskExpression_Select>::GetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.MapSelect.child)
}

inline bool Expression_MaskExpression_MapSelect::has_select() const {
  return select_case() != SELECT_NOT_SET;
}
inline void Expression_MaskExpression_MapSelect::clear_has_select() {
  _oneof_case_[0] = SELECT_NOT_SET;
}
inline Expression_MaskExpression_MapSelect::SelectCase Expression_MaskExpression_MapSelect::select_case() const {
  return Expression_MaskExpression_MapSelect::SelectCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression

// .substrait.Expression.MaskExpression.StructSelect select = 1 [json_name = "select"];
inline bool Expression_MaskExpression::_internal_has_select() const {
  return this != internal_default_instance() && select_ != nullptr;
}
inline bool Expression_MaskExpression::has_select() const {
  return _internal_has_select();
}
inline void Expression_MaskExpression::clear_select() {
  if (GetArenaForAllocation() == nullptr && select_ != nullptr) {
    delete select_;
  }
  select_ = nullptr;
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression::_internal_select() const {
  const ::substrait::Expression_MaskExpression_StructSelect* p = select_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_MaskExpression_StructSelect&>(
      ::substrait::_Expression_MaskExpression_StructSelect_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression::select() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.select)
  return _internal_select();
}
inline void Expression_MaskExpression::unsafe_arena_set_allocated_select(
    ::substrait::Expression_MaskExpression_StructSelect* select) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(select_);
  }
  select_ = select;
  if (select) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.select)
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression::release_select() {
  
  ::substrait::Expression_MaskExpression_StructSelect* temp = select_;
  select_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression::unsafe_arena_release_select() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.select)
  
  ::substrait::Expression_MaskExpression_StructSelect* temp = select_;
  select_ = nullptr;
  return temp;
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression::_internal_mutable_select() {
  
  if (select_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression_MaskExpression_StructSelect>(GetArenaForAllocation());
    select_ = p;
  }
  return select_;
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression::mutable_select() {
  ::substrait::Expression_MaskExpression_StructSelect* _msg = _internal_mutable_select();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.select)
  return _msg;
}
inline void Expression_MaskExpression::set_allocated_select(::substrait::Expression_MaskExpression_StructSelect* select) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete select_;
  }
  if (select) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression_MaskExpression_StructSelect>::GetOwningArena(select);
    if (message_arena != submessage_arena) {
      select = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, select, submessage_arena);
    }
    
  } else {
    
  }
  select_ = select;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.select)
}

// bool maintain_singular_struct = 2 [json_name = "maintainSingularStruct"];
inline void Expression_MaskExpression::clear_maintain_singular_struct() {
  maintain_singular_struct_ = false;
}
inline bool Expression_MaskExpression::_internal_maintain_singular_struct() const {
  return maintain_singular_struct_;
}
inline bool Expression_MaskExpression::maintain_singular_struct() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.maintain_singular_struct)
  return _internal_maintain_singular_struct();
}
inline void Expression_MaskExpression::_internal_set_maintain_singular_struct(bool value) {
  
  maintain_singular_struct_ = value;
}
inline void Expression_MaskExpression::set_maintain_singular_struct(bool value) {
  _internal_set_maintain_singular_struct(value);
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.maintain_singular_struct)
}

// -------------------------------------------------------------------

// Expression_FieldReference_RootReference

// -------------------------------------------------------------------

// Expression_FieldReference

// .substrait.Expression.ReferenceSegment direct_reference = 1 [json_name = "directReference"];
inline bool Expression_FieldReference::_internal_has_direct_reference() const {
  return reference_type_case() == kDirectReference;
}
inline bool Expression_FieldReference::has_direct_reference() const {
  return _internal_has_direct_reference();
}
inline void Expression_FieldReference::set_has_direct_reference() {
  _oneof_case_[0] = kDirectReference;
}
inline void Expression_FieldReference::clear_direct_reference() {
  if (_internal_has_direct_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete reference_type_.direct_reference_;
    }
    clear_has_reference_type();
  }
}
inline ::substrait::Expression_ReferenceSegment* Expression_FieldReference::release_direct_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.direct_reference)
  if (_internal_has_direct_reference()) {
    clear_has_reference_type();
      ::substrait::Expression_ReferenceSegment* temp = reference_type_.direct_reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.direct_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_ReferenceSegment& Expression_FieldReference::_internal_direct_reference() const {
  return _internal_has_direct_reference()
      ? *reference_type_.direct_reference_
      : reinterpret_cast< ::substrait::Expression_ReferenceSegment&>(::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment& Expression_FieldReference::direct_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.direct_reference)
  return _internal_direct_reference();
}
inline ::substrait::Expression_ReferenceSegment* Expression_FieldReference::unsafe_arena_release_direct_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.FieldReference.direct_reference)
  if (_internal_has_direct_reference()) {
    clear_has_reference_type();
    ::substrait::Expression_ReferenceSegment* temp = reference_type_.direct_reference_;
    reference_type_.direct_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_FieldReference::unsafe_arena_set_allocated_direct_reference(::substrait::Expression_ReferenceSegment* direct_reference) {
  clear_reference_type();
  if (direct_reference) {
    set_has_direct_reference();
    reference_type_.direct_reference_ = direct_reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.FieldReference.direct_reference)
}
inline ::substrait::Expression_ReferenceSegment* Expression_FieldReference::_internal_mutable_direct_reference() {
  if (!_internal_has_direct_reference()) {
    clear_reference_type();
    set_has_direct_reference();
    reference_type_.direct_reference_ = CreateMaybeMessage< ::substrait::Expression_ReferenceSegment >(GetArenaForAllocation());
  }
  return reference_type_.direct_reference_;
}
inline ::substrait::Expression_ReferenceSegment* Expression_FieldReference::mutable_direct_reference() {
  ::substrait::Expression_ReferenceSegment* _msg = _internal_mutable_direct_reference();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.direct_reference)
  return _msg;
}

// .substrait.Expression.MaskExpression masked_reference = 2 [json_name = "maskedReference"];
inline bool Expression_FieldReference::_internal_has_masked_reference() const {
  return reference_type_case() == kMaskedReference;
}
inline bool Expression_FieldReference::has_masked_reference() const {
  return _internal_has_masked_reference();
}
inline void Expression_FieldReference::set_has_masked_reference() {
  _oneof_case_[0] = kMaskedReference;
}
inline void Expression_FieldReference::clear_masked_reference() {
  if (_internal_has_masked_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete reference_type_.masked_reference_;
    }
    clear_has_reference_type();
  }
}
inline ::substrait::Expression_MaskExpression* Expression_FieldReference::release_masked_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.masked_reference)
  if (_internal_has_masked_reference()) {
    clear_has_reference_type();
      ::substrait::Expression_MaskExpression* temp = reference_type_.masked_reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    reference_type_.masked_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression& Expression_FieldReference::_internal_masked_reference() const {
  return _internal_has_masked_reference()
      ? *reference_type_.masked_reference_
      : reinterpret_cast< ::substrait::Expression_MaskExpression&>(::substrait::_Expression_MaskExpression_default_instance_);
}
inline const ::substrait::Expression_MaskExpression& Expression_FieldReference::masked_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.masked_reference)
  return _internal_masked_reference();
}
inline ::substrait::Expression_MaskExpression* Expression_FieldReference::unsafe_arena_release_masked_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.FieldReference.masked_reference)
  if (_internal_has_masked_reference()) {
    clear_has_reference_type();
    ::substrait::Expression_MaskExpression* temp = reference_type_.masked_reference_;
    reference_type_.masked_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_FieldReference::unsafe_arena_set_allocated_masked_reference(::substrait::Expression_MaskExpression* masked_reference) {
  clear_reference_type();
  if (masked_reference) {
    set_has_masked_reference();
    reference_type_.masked_reference_ = masked_reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.FieldReference.masked_reference)
}
inline ::substrait::Expression_MaskExpression* Expression_FieldReference::_internal_mutable_masked_reference() {
  if (!_internal_has_masked_reference()) {
    clear_reference_type();
    set_has_masked_reference();
    reference_type_.masked_reference_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression >(GetArenaForAllocation());
  }
  return reference_type_.masked_reference_;
}
inline ::substrait::Expression_MaskExpression* Expression_FieldReference::mutable_masked_reference() {
  ::substrait::Expression_MaskExpression* _msg = _internal_mutable_masked_reference();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.masked_reference)
  return _msg;
}

// .substrait.Expression expression = 3 [json_name = "expression"];
inline bool Expression_FieldReference::_internal_has_expression() const {
  return root_type_case() == kExpression;
}
inline bool Expression_FieldReference::has_expression() const {
  return _internal_has_expression();
}
inline void Expression_FieldReference::set_has_expression() {
  _oneof_case_[1] = kExpression;
}
inline void Expression_FieldReference::clear_expression() {
  if (_internal_has_expression()) {
    if (GetArenaForAllocation() == nullptr) {
      delete root_type_.expression_;
    }
    clear_has_root_type();
  }
}
inline ::substrait::Expression* Expression_FieldReference::release_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.expression)
  if (_internal_has_expression()) {
    clear_has_root_type();
      ::substrait::Expression* temp = root_type_.expression_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    root_type_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression& Expression_FieldReference::_internal_expression() const {
  return _internal_has_expression()
      ? *root_type_.expression_
      : reinterpret_cast< ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_FieldReference::expression() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.expression)
  return _internal_expression();
}
inline ::substrait::Expression* Expression_FieldReference::unsafe_arena_release_expression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.FieldReference.expression)
  if (_internal_has_expression()) {
    clear_has_root_type();
    ::substrait::Expression* temp = root_type_.expression_;
    root_type_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_FieldReference::unsafe_arena_set_allocated_expression(::substrait::Expression* expression) {
  clear_root_type();
  if (expression) {
    set_has_expression();
    root_type_.expression_ = expression;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.FieldReference.expression)
}
inline ::substrait::Expression* Expression_FieldReference::_internal_mutable_expression() {
  if (!_internal_has_expression()) {
    clear_root_type();
    set_has_expression();
    root_type_.expression_ = CreateMaybeMessage< ::substrait::Expression >(GetArenaForAllocation());
  }
  return root_type_.expression_;
}
inline ::substrait::Expression* Expression_FieldReference::mutable_expression() {
  ::substrait::Expression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.expression)
  return _msg;
}

// .substrait.Expression.FieldReference.RootReference root_reference = 4 [json_name = "rootReference"];
inline bool Expression_FieldReference::_internal_has_root_reference() const {
  return root_type_case() == kRootReference;
}
inline bool Expression_FieldReference::has_root_reference() const {
  return _internal_has_root_reference();
}
inline void Expression_FieldReference::set_has_root_reference() {
  _oneof_case_[1] = kRootReference;
}
inline void Expression_FieldReference::clear_root_reference() {
  if (_internal_has_root_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete root_type_.root_reference_;
    }
    clear_has_root_type();
  }
}
inline ::substrait::Expression_FieldReference_RootReference* Expression_FieldReference::release_root_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.root_reference)
  if (_internal_has_root_reference()) {
    clear_has_root_type();
      ::substrait::Expression_FieldReference_RootReference* temp = root_type_.root_reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    root_type_.root_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_FieldReference_RootReference& Expression_FieldReference::_internal_root_reference() const {
  return _internal_has_root_reference()
      ? *root_type_.root_reference_
      : reinterpret_cast< ::substrait::Expression_FieldReference_RootReference&>(::substrait::_Expression_FieldReference_RootReference_default_instance_);
}
inline const ::substrait::Expression_FieldReference_RootReference& Expression_FieldReference::root_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.root_reference)
  return _internal_root_reference();
}
inline ::substrait::Expression_FieldReference_RootReference* Expression_FieldReference::unsafe_arena_release_root_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.FieldReference.root_reference)
  if (_internal_has_root_reference()) {
    clear_has_root_type();
    ::substrait::Expression_FieldReference_RootReference* temp = root_type_.root_reference_;
    root_type_.root_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_FieldReference::unsafe_arena_set_allocated_root_reference(::substrait::Expression_FieldReference_RootReference* root_reference) {
  clear_root_type();
  if (root_reference) {
    set_has_root_reference();
    root_type_.root_reference_ = root_reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.FieldReference.root_reference)
}
inline ::substrait::Expression_FieldReference_RootReference* Expression_FieldReference::_internal_mutable_root_reference() {
  if (!_internal_has_root_reference()) {
    clear_root_type();
    set_has_root_reference();
    root_type_.root_reference_ = CreateMaybeMessage< ::substrait::Expression_FieldReference_RootReference >(GetArenaForAllocation());
  }
  return root_type_.root_reference_;
}
inline ::substrait::Expression_FieldReference_RootReference* Expression_FieldReference::mutable_root_reference() {
  ::substrait::Expression_FieldReference_RootReference* _msg = _internal_mutable_root_reference();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.root_reference)
  return _msg;
}

inline bool Expression_FieldReference::has_reference_type() const {
  return reference_type_case() != REFERENCE_TYPE_NOT_SET;
}
inline void Expression_FieldReference::clear_has_reference_type() {
  _oneof_case_[0] = REFERENCE_TYPE_NOT_SET;
}
inline bool Expression_FieldReference::has_root_type() const {
  return root_type_case() != ROOT_TYPE_NOT_SET;
}
inline void Expression_FieldReference::clear_has_root_type() {
  _oneof_case_[1] = ROOT_TYPE_NOT_SET;
}
inline Expression_FieldReference::ReferenceTypeCase Expression_FieldReference::reference_type_case() const {
  return Expression_FieldReference::ReferenceTypeCase(_oneof_case_[0]);
}
inline Expression_FieldReference::RootTypeCase Expression_FieldReference::root_type_case() const {
  return Expression_FieldReference::RootTypeCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// Expression

// .substrait.Expression.Literal literal = 1 [json_name = "literal"];
inline bool Expression::_internal_has_literal() const {
  return rex_type_case() == kLiteral;
}
inline bool Expression::has_literal() const {
  return _internal_has_literal();
}
inline void Expression::set_has_literal() {
  _oneof_case_[0] = kLiteral;
}
inline void Expression::clear_literal() {
  if (_internal_has_literal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rex_type_.literal_;
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_Literal* Expression::release_literal() {
  // @@protoc_insertion_point(field_release:substrait.Expression.literal)
  if (_internal_has_literal()) {
    clear_has_rex_type();
      ::substrait::Expression_Literal* temp = rex_type_.literal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rex_type_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal& Expression::_internal_literal() const {
  return _internal_has_literal()
      ? *rex_type_.literal_
      : reinterpret_cast< ::substrait::Expression_Literal&>(::substrait::_Expression_Literal_default_instance_);
}
inline const ::substrait::Expression_Literal& Expression::literal() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.literal)
  return _internal_literal();
}
inline ::substrait::Expression_Literal* Expression::unsafe_arena_release_literal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.literal)
  if (_internal_has_literal()) {
    clear_has_rex_type();
    ::substrait::Expression_Literal* temp = rex_type_.literal_;
    rex_type_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_literal(::substrait::Expression_Literal* literal) {
  clear_rex_type();
  if (literal) {
    set_has_literal();
    rex_type_.literal_ = literal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.literal)
}
inline ::substrait::Expression_Literal* Expression::_internal_mutable_literal() {
  if (!_internal_has_literal()) {
    clear_rex_type();
    set_has_literal();
    rex_type_.literal_ = CreateMaybeMessage< ::substrait::Expression_Literal >(GetArenaForAllocation());
  }
  return rex_type_.literal_;
}
inline ::substrait::Expression_Literal* Expression::mutable_literal() {
  ::substrait::Expression_Literal* _msg = _internal_mutable_literal();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.literal)
  return _msg;
}

// .substrait.Expression.FieldReference selection = 2 [json_name = "selection"];
inline bool Expression::_internal_has_selection() const {
  return rex_type_case() == kSelection;
}
inline bool Expression::has_selection() const {
  return _internal_has_selection();
}
inline void Expression::set_has_selection() {
  _oneof_case_[0] = kSelection;
}
inline void Expression::clear_selection() {
  if (_internal_has_selection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rex_type_.selection_;
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_FieldReference* Expression::release_selection() {
  // @@protoc_insertion_point(field_release:substrait.Expression.selection)
  if (_internal_has_selection()) {
    clear_has_rex_type();
      ::substrait::Expression_FieldReference* temp = rex_type_.selection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rex_type_.selection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_FieldReference& Expression::_internal_selection() const {
  return _internal_has_selection()
      ? *rex_type_.selection_
      : reinterpret_cast< ::substrait::Expression_FieldReference&>(::substrait::_Expression_FieldReference_default_instance_);
}
inline const ::substrait::Expression_FieldReference& Expression::selection() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.selection)
  return _internal_selection();
}
inline ::substrait::Expression_FieldReference* Expression::unsafe_arena_release_selection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.selection)
  if (_internal_has_selection()) {
    clear_has_rex_type();
    ::substrait::Expression_FieldReference* temp = rex_type_.selection_;
    rex_type_.selection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_selection(::substrait::Expression_FieldReference* selection) {
  clear_rex_type();
  if (selection) {
    set_has_selection();
    rex_type_.selection_ = selection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.selection)
}
inline ::substrait::Expression_FieldReference* Expression::_internal_mutable_selection() {
  if (!_internal_has_selection()) {
    clear_rex_type();
    set_has_selection();
    rex_type_.selection_ = CreateMaybeMessage< ::substrait::Expression_FieldReference >(GetArenaForAllocation());
  }
  return rex_type_.selection_;
}
inline ::substrait::Expression_FieldReference* Expression::mutable_selection() {
  ::substrait::Expression_FieldReference* _msg = _internal_mutable_selection();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.selection)
  return _msg;
}

// .substrait.Expression.ScalarFunction scalar_function = 3 [json_name = "scalarFunction"];
inline bool Expression::_internal_has_scalar_function() const {
  return rex_type_case() == kScalarFunction;
}
inline bool Expression::has_scalar_function() const {
  return _internal_has_scalar_function();
}
inline void Expression::set_has_scalar_function() {
  _oneof_case_[0] = kScalarFunction;
}
inline void Expression::clear_scalar_function() {
  if (_internal_has_scalar_function()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rex_type_.scalar_function_;
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_ScalarFunction* Expression::release_scalar_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.scalar_function)
  if (_internal_has_scalar_function()) {
    clear_has_rex_type();
      ::substrait::Expression_ScalarFunction* temp = rex_type_.scalar_function_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rex_type_.scalar_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_ScalarFunction& Expression::_internal_scalar_function() const {
  return _internal_has_scalar_function()
      ? *rex_type_.scalar_function_
      : reinterpret_cast< ::substrait::Expression_ScalarFunction&>(::substrait::_Expression_ScalarFunction_default_instance_);
}
inline const ::substrait::Expression_ScalarFunction& Expression::scalar_function() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.scalar_function)
  return _internal_scalar_function();
}
inline ::substrait::Expression_ScalarFunction* Expression::unsafe_arena_release_scalar_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.scalar_function)
  if (_internal_has_scalar_function()) {
    clear_has_rex_type();
    ::substrait::Expression_ScalarFunction* temp = rex_type_.scalar_function_;
    rex_type_.scalar_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_scalar_function(::substrait::Expression_ScalarFunction* scalar_function) {
  clear_rex_type();
  if (scalar_function) {
    set_has_scalar_function();
    rex_type_.scalar_function_ = scalar_function;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.scalar_function)
}
inline ::substrait::Expression_ScalarFunction* Expression::_internal_mutable_scalar_function() {
  if (!_internal_has_scalar_function()) {
    clear_rex_type();
    set_has_scalar_function();
    rex_type_.scalar_function_ = CreateMaybeMessage< ::substrait::Expression_ScalarFunction >(GetArenaForAllocation());
  }
  return rex_type_.scalar_function_;
}
inline ::substrait::Expression_ScalarFunction* Expression::mutable_scalar_function() {
  ::substrait::Expression_ScalarFunction* _msg = _internal_mutable_scalar_function();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.scalar_function)
  return _msg;
}

// .substrait.Expression.WindowFunction window_function = 5 [json_name = "windowFunction"];
inline bool Expression::_internal_has_window_function() const {
  return rex_type_case() == kWindowFunction;
}
inline bool Expression::has_window_function() const {
  return _internal_has_window_function();
}
inline void Expression::set_has_window_function() {
  _oneof_case_[0] = kWindowFunction;
}
inline void Expression::clear_window_function() {
  if (_internal_has_window_function()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rex_type_.window_function_;
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_WindowFunction* Expression::release_window_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.window_function)
  if (_internal_has_window_function()) {
    clear_has_rex_type();
      ::substrait::Expression_WindowFunction* temp = rex_type_.window_function_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rex_type_.window_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_WindowFunction& Expression::_internal_window_function() const {
  return _internal_has_window_function()
      ? *rex_type_.window_function_
      : reinterpret_cast< ::substrait::Expression_WindowFunction&>(::substrait::_Expression_WindowFunction_default_instance_);
}
inline const ::substrait::Expression_WindowFunction& Expression::window_function() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.window_function)
  return _internal_window_function();
}
inline ::substrait::Expression_WindowFunction* Expression::unsafe_arena_release_window_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.window_function)
  if (_internal_has_window_function()) {
    clear_has_rex_type();
    ::substrait::Expression_WindowFunction* temp = rex_type_.window_function_;
    rex_type_.window_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_window_function(::substrait::Expression_WindowFunction* window_function) {
  clear_rex_type();
  if (window_function) {
    set_has_window_function();
    rex_type_.window_function_ = window_function;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.window_function)
}
inline ::substrait::Expression_WindowFunction* Expression::_internal_mutable_window_function() {
  if (!_internal_has_window_function()) {
    clear_rex_type();
    set_has_window_function();
    rex_type_.window_function_ = CreateMaybeMessage< ::substrait::Expression_WindowFunction >(GetArenaForAllocation());
  }
  return rex_type_.window_function_;
}
inline ::substrait::Expression_WindowFunction* Expression::mutable_window_function() {
  ::substrait::Expression_WindowFunction* _msg = _internal_mutable_window_function();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.window_function)
  return _msg;
}

// .substrait.Expression.IfThen if_then = 6 [json_name = "ifThen"];
inline bool Expression::_internal_has_if_then() const {
  return rex_type_case() == kIfThen;
}
inline bool Expression::has_if_then() const {
  return _internal_has_if_then();
}
inline void Expression::set_has_if_then() {
  _oneof_case_[0] = kIfThen;
}
inline void Expression::clear_if_then() {
  if (_internal_has_if_then()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rex_type_.if_then_;
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_IfThen* Expression::release_if_then() {
  // @@protoc_insertion_point(field_release:substrait.Expression.if_then)
  if (_internal_has_if_then()) {
    clear_has_rex_type();
      ::substrait::Expression_IfThen* temp = rex_type_.if_then_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rex_type_.if_then_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_IfThen& Expression::_internal_if_then() const {
  return _internal_has_if_then()
      ? *rex_type_.if_then_
      : reinterpret_cast< ::substrait::Expression_IfThen&>(::substrait::_Expression_IfThen_default_instance_);
}
inline const ::substrait::Expression_IfThen& Expression::if_then() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.if_then)
  return _internal_if_then();
}
inline ::substrait::Expression_IfThen* Expression::unsafe_arena_release_if_then() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.if_then)
  if (_internal_has_if_then()) {
    clear_has_rex_type();
    ::substrait::Expression_IfThen* temp = rex_type_.if_then_;
    rex_type_.if_then_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_if_then(::substrait::Expression_IfThen* if_then) {
  clear_rex_type();
  if (if_then) {
    set_has_if_then();
    rex_type_.if_then_ = if_then;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.if_then)
}
inline ::substrait::Expression_IfThen* Expression::_internal_mutable_if_then() {
  if (!_internal_has_if_then()) {
    clear_rex_type();
    set_has_if_then();
    rex_type_.if_then_ = CreateMaybeMessage< ::substrait::Expression_IfThen >(GetArenaForAllocation());
  }
  return rex_type_.if_then_;
}
inline ::substrait::Expression_IfThen* Expression::mutable_if_then() {
  ::substrait::Expression_IfThen* _msg = _internal_mutable_if_then();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.if_then)
  return _msg;
}

// .substrait.Expression.SwitchExpression switch_expression = 7 [json_name = "switchExpression"];
inline bool Expression::_internal_has_switch_expression() const {
  return rex_type_case() == kSwitchExpression;
}
inline bool Expression::has_switch_expression() const {
  return _internal_has_switch_expression();
}
inline void Expression::set_has_switch_expression() {
  _oneof_case_[0] = kSwitchExpression;
}
inline void Expression::clear_switch_expression() {
  if (_internal_has_switch_expression()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rex_type_.switch_expression_;
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_SwitchExpression* Expression::release_switch_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.switch_expression)
  if (_internal_has_switch_expression()) {
    clear_has_rex_type();
      ::substrait::Expression_SwitchExpression* temp = rex_type_.switch_expression_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rex_type_.switch_expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_SwitchExpression& Expression::_internal_switch_expression() const {
  return _internal_has_switch_expression()
      ? *rex_type_.switch_expression_
      : reinterpret_cast< ::substrait::Expression_SwitchExpression&>(::substrait::_Expression_SwitchExpression_default_instance_);
}
inline const ::substrait::Expression_SwitchExpression& Expression::switch_expression() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.switch_expression)
  return _internal_switch_expression();
}
inline ::substrait::Expression_SwitchExpression* Expression::unsafe_arena_release_switch_expression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.switch_expression)
  if (_internal_has_switch_expression()) {
    clear_has_rex_type();
    ::substrait::Expression_SwitchExpression* temp = rex_type_.switch_expression_;
    rex_type_.switch_expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_switch_expression(::substrait::Expression_SwitchExpression* switch_expression) {
  clear_rex_type();
  if (switch_expression) {
    set_has_switch_expression();
    rex_type_.switch_expression_ = switch_expression;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.switch_expression)
}
inline ::substrait::Expression_SwitchExpression* Expression::_internal_mutable_switch_expression() {
  if (!_internal_has_switch_expression()) {
    clear_rex_type();
    set_has_switch_expression();
    rex_type_.switch_expression_ = CreateMaybeMessage< ::substrait::Expression_SwitchExpression >(GetArenaForAllocation());
  }
  return rex_type_.switch_expression_;
}
inline ::substrait::Expression_SwitchExpression* Expression::mutable_switch_expression() {
  ::substrait::Expression_SwitchExpression* _msg = _internal_mutable_switch_expression();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.switch_expression)
  return _msg;
}

// .substrait.Expression.SingularOrList singular_or_list = 8 [json_name = "singularOrList"];
inline bool Expression::_internal_has_singular_or_list() const {
  return rex_type_case() == kSingularOrList;
}
inline bool Expression::has_singular_or_list() const {
  return _internal_has_singular_or_list();
}
inline void Expression::set_has_singular_or_list() {
  _oneof_case_[0] = kSingularOrList;
}
inline void Expression::clear_singular_or_list() {
  if (_internal_has_singular_or_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rex_type_.singular_or_list_;
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_SingularOrList* Expression::release_singular_or_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.singular_or_list)
  if (_internal_has_singular_or_list()) {
    clear_has_rex_type();
      ::substrait::Expression_SingularOrList* temp = rex_type_.singular_or_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rex_type_.singular_or_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_SingularOrList& Expression::_internal_singular_or_list() const {
  return _internal_has_singular_or_list()
      ? *rex_type_.singular_or_list_
      : reinterpret_cast< ::substrait::Expression_SingularOrList&>(::substrait::_Expression_SingularOrList_default_instance_);
}
inline const ::substrait::Expression_SingularOrList& Expression::singular_or_list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.singular_or_list)
  return _internal_singular_or_list();
}
inline ::substrait::Expression_SingularOrList* Expression::unsafe_arena_release_singular_or_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.singular_or_list)
  if (_internal_has_singular_or_list()) {
    clear_has_rex_type();
    ::substrait::Expression_SingularOrList* temp = rex_type_.singular_or_list_;
    rex_type_.singular_or_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_singular_or_list(::substrait::Expression_SingularOrList* singular_or_list) {
  clear_rex_type();
  if (singular_or_list) {
    set_has_singular_or_list();
    rex_type_.singular_or_list_ = singular_or_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.singular_or_list)
}
inline ::substrait::Expression_SingularOrList* Expression::_internal_mutable_singular_or_list() {
  if (!_internal_has_singular_or_list()) {
    clear_rex_type();
    set_has_singular_or_list();
    rex_type_.singular_or_list_ = CreateMaybeMessage< ::substrait::Expression_SingularOrList >(GetArenaForAllocation());
  }
  return rex_type_.singular_or_list_;
}
inline ::substrait::Expression_SingularOrList* Expression::mutable_singular_or_list() {
  ::substrait::Expression_SingularOrList* _msg = _internal_mutable_singular_or_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.singular_or_list)
  return _msg;
}

// .substrait.Expression.MultiOrList multi_or_list = 9 [json_name = "multiOrList"];
inline bool Expression::_internal_has_multi_or_list() const {
  return rex_type_case() == kMultiOrList;
}
inline bool Expression::has_multi_or_list() const {
  return _internal_has_multi_or_list();
}
inline void Expression::set_has_multi_or_list() {
  _oneof_case_[0] = kMultiOrList;
}
inline void Expression::clear_multi_or_list() {
  if (_internal_has_multi_or_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rex_type_.multi_or_list_;
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_MultiOrList* Expression::release_multi_or_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.multi_or_list)
  if (_internal_has_multi_or_list()) {
    clear_has_rex_type();
      ::substrait::Expression_MultiOrList* temp = rex_type_.multi_or_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rex_type_.multi_or_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MultiOrList& Expression::_internal_multi_or_list() const {
  return _internal_has_multi_or_list()
      ? *rex_type_.multi_or_list_
      : reinterpret_cast< ::substrait::Expression_MultiOrList&>(::substrait::_Expression_MultiOrList_default_instance_);
}
inline const ::substrait::Expression_MultiOrList& Expression::multi_or_list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.multi_or_list)
  return _internal_multi_or_list();
}
inline ::substrait::Expression_MultiOrList* Expression::unsafe_arena_release_multi_or_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.multi_or_list)
  if (_internal_has_multi_or_list()) {
    clear_has_rex_type();
    ::substrait::Expression_MultiOrList* temp = rex_type_.multi_or_list_;
    rex_type_.multi_or_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_multi_or_list(::substrait::Expression_MultiOrList* multi_or_list) {
  clear_rex_type();
  if (multi_or_list) {
    set_has_multi_or_list();
    rex_type_.multi_or_list_ = multi_or_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.multi_or_list)
}
inline ::substrait::Expression_MultiOrList* Expression::_internal_mutable_multi_or_list() {
  if (!_internal_has_multi_or_list()) {
    clear_rex_type();
    set_has_multi_or_list();
    rex_type_.multi_or_list_ = CreateMaybeMessage< ::substrait::Expression_MultiOrList >(GetArenaForAllocation());
  }
  return rex_type_.multi_or_list_;
}
inline ::substrait::Expression_MultiOrList* Expression::mutable_multi_or_list() {
  ::substrait::Expression_MultiOrList* _msg = _internal_mutable_multi_or_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.multi_or_list)
  return _msg;
}

// .substrait.Expression.Enum enum = 10 [json_name = "enum"];
inline bool Expression::_internal_has_enum_() const {
  return rex_type_case() == kEnum;
}
inline bool Expression::has_enum_() const {
  return _internal_has_enum_();
}
inline void Expression::set_has_enum_() {
  _oneof_case_[0] = kEnum;
}
inline void Expression::clear_enum_() {
  if (_internal_has_enum_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rex_type_.enum__;
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_Enum* Expression::release_enum_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.enum)
  if (_internal_has_enum_()) {
    clear_has_rex_type();
      ::substrait::Expression_Enum* temp = rex_type_.enum__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rex_type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Enum& Expression::_internal_enum_() const {
  return _internal_has_enum_()
      ? *rex_type_.enum__
      : reinterpret_cast< ::substrait::Expression_Enum&>(::substrait::_Expression_Enum_default_instance_);
}
inline const ::substrait::Expression_Enum& Expression::enum_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.enum)
  return _internal_enum_();
}
inline ::substrait::Expression_Enum* Expression::unsafe_arena_release_enum_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.enum)
  if (_internal_has_enum_()) {
    clear_has_rex_type();
    ::substrait::Expression_Enum* temp = rex_type_.enum__;
    rex_type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_enum_(::substrait::Expression_Enum* enum_) {
  clear_rex_type();
  if (enum_) {
    set_has_enum_();
    rex_type_.enum__ = enum_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.enum)
}
inline ::substrait::Expression_Enum* Expression::_internal_mutable_enum_() {
  if (!_internal_has_enum_()) {
    clear_rex_type();
    set_has_enum_();
    rex_type_.enum__ = CreateMaybeMessage< ::substrait::Expression_Enum >(GetArenaForAllocation());
  }
  return rex_type_.enum__;
}
inline ::substrait::Expression_Enum* Expression::mutable_enum_() {
  ::substrait::Expression_Enum* _msg = _internal_mutable_enum_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.enum)
  return _msg;
}

// .substrait.Expression.Cast cast = 11 [json_name = "cast"];
inline bool Expression::_internal_has_cast() const {
  return rex_type_case() == kCast;
}
inline bool Expression::has_cast() const {
  return _internal_has_cast();
}
inline void Expression::set_has_cast() {
  _oneof_case_[0] = kCast;
}
inline void Expression::clear_cast() {
  if (_internal_has_cast()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rex_type_.cast_;
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_Cast* Expression::release_cast() {
  // @@protoc_insertion_point(field_release:substrait.Expression.cast)
  if (_internal_has_cast()) {
    clear_has_rex_type();
      ::substrait::Expression_Cast* temp = rex_type_.cast_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rex_type_.cast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Cast& Expression::_internal_cast() const {
  return _internal_has_cast()
      ? *rex_type_.cast_
      : reinterpret_cast< ::substrait::Expression_Cast&>(::substrait::_Expression_Cast_default_instance_);
}
inline const ::substrait::Expression_Cast& Expression::cast() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.cast)
  return _internal_cast();
}
inline ::substrait::Expression_Cast* Expression::unsafe_arena_release_cast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.cast)
  if (_internal_has_cast()) {
    clear_has_rex_type();
    ::substrait::Expression_Cast* temp = rex_type_.cast_;
    rex_type_.cast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_cast(::substrait::Expression_Cast* cast) {
  clear_rex_type();
  if (cast) {
    set_has_cast();
    rex_type_.cast_ = cast;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.cast)
}
inline ::substrait::Expression_Cast* Expression::_internal_mutable_cast() {
  if (!_internal_has_cast()) {
    clear_rex_type();
    set_has_cast();
    rex_type_.cast_ = CreateMaybeMessage< ::substrait::Expression_Cast >(GetArenaForAllocation());
  }
  return rex_type_.cast_;
}
inline ::substrait::Expression_Cast* Expression::mutable_cast() {
  ::substrait::Expression_Cast* _msg = _internal_mutable_cast();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.cast)
  return _msg;
}

inline bool Expression::has_rex_type() const {
  return rex_type_case() != REX_TYPE_NOT_SET;
}
inline void Expression::clear_has_rex_type() {
  _oneof_case_[0] = REX_TYPE_NOT_SET;
}
inline Expression::RexTypeCase Expression::rex_type_case() const {
  return Expression::RexTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SortField

// .substrait.Expression expr = 1 [json_name = "expr"];
inline bool SortField::_internal_has_expr() const {
  return this != internal_default_instance() && expr_ != nullptr;
}
inline bool SortField::has_expr() const {
  return _internal_has_expr();
}
inline void SortField::clear_expr() {
  if (GetArenaForAllocation() == nullptr && expr_ != nullptr) {
    delete expr_;
  }
  expr_ = nullptr;
}
inline const ::substrait::Expression& SortField::_internal_expr() const {
  const ::substrait::Expression* p = expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(
      ::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& SortField::expr() const {
  // @@protoc_insertion_point(field_get:substrait.SortField.expr)
  return _internal_expr();
}
inline void SortField::unsafe_arena_set_allocated_expr(
    ::substrait::Expression* expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr_);
  }
  expr_ = expr;
  if (expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.SortField.expr)
}
inline ::substrait::Expression* SortField::release_expr() {
  
  ::substrait::Expression* temp = expr_;
  expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Expression* SortField::unsafe_arena_release_expr() {
  // @@protoc_insertion_point(field_release:substrait.SortField.expr)
  
  ::substrait::Expression* temp = expr_;
  expr_ = nullptr;
  return temp;
}
inline ::substrait::Expression* SortField::_internal_mutable_expr() {
  
  if (expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaForAllocation());
    expr_ = p;
  }
  return expr_;
}
inline ::substrait::Expression* SortField::mutable_expr() {
  ::substrait::Expression* _msg = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:substrait.SortField.expr)
  return _msg;
}
inline void SortField::set_allocated_expr(::substrait::Expression* expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete expr_;
  }
  if (expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Expression>::GetOwningArena(expr);
    if (message_arena != submessage_arena) {
      expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    
  } else {
    
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:substrait.SortField.expr)
}

// .substrait.SortField.SortDirection direction = 2 [json_name = "direction"];
inline bool SortField::_internal_has_direction() const {
  return sort_kind_case() == kDirection;
}
inline bool SortField::has_direction() const {
  return _internal_has_direction();
}
inline void SortField::set_has_direction() {
  _oneof_case_[0] = kDirection;
}
inline void SortField::clear_direction() {
  if (_internal_has_direction()) {
    sort_kind_.direction_ = 0;
    clear_has_sort_kind();
  }
}
inline ::substrait::SortField_SortDirection SortField::_internal_direction() const {
  if (_internal_has_direction()) {
    return static_cast< ::substrait::SortField_SortDirection >(sort_kind_.direction_);
  }
  return static_cast< ::substrait::SortField_SortDirection >(0);
}
inline ::substrait::SortField_SortDirection SortField::direction() const {
  // @@protoc_insertion_point(field_get:substrait.SortField.direction)
  return _internal_direction();
}
inline void SortField::_internal_set_direction(::substrait::SortField_SortDirection value) {
  if (!_internal_has_direction()) {
    clear_sort_kind();
    set_has_direction();
  }
  sort_kind_.direction_ = value;
}
inline void SortField::set_direction(::substrait::SortField_SortDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:substrait.SortField.direction)
}

// uint32 comparison_function_reference = 3 [json_name = "comparisonFunctionReference"];
inline bool SortField::_internal_has_comparison_function_reference() const {
  return sort_kind_case() == kComparisonFunctionReference;
}
inline bool SortField::has_comparison_function_reference() const {
  return _internal_has_comparison_function_reference();
}
inline void SortField::set_has_comparison_function_reference() {
  _oneof_case_[0] = kComparisonFunctionReference;
}
inline void SortField::clear_comparison_function_reference() {
  if (_internal_has_comparison_function_reference()) {
    sort_kind_.comparison_function_reference_ = 0u;
    clear_has_sort_kind();
  }
}
inline uint32_t SortField::_internal_comparison_function_reference() const {
  if (_internal_has_comparison_function_reference()) {
    return sort_kind_.comparison_function_reference_;
  }
  return 0u;
}
inline void SortField::_internal_set_comparison_function_reference(uint32_t value) {
  if (!_internal_has_comparison_function_reference()) {
    clear_sort_kind();
    set_has_comparison_function_reference();
  }
  sort_kind_.comparison_function_reference_ = value;
}
inline uint32_t SortField::comparison_function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.SortField.comparison_function_reference)
  return _internal_comparison_function_reference();
}
inline void SortField::set_comparison_function_reference(uint32_t value) {
  _internal_set_comparison_function_reference(value);
  // @@protoc_insertion_point(field_set:substrait.SortField.comparison_function_reference)
}

inline bool SortField::has_sort_kind() const {
  return sort_kind_case() != SORT_KIND_NOT_SET;
}
inline void SortField::clear_has_sort_kind() {
  _oneof_case_[0] = SORT_KIND_NOT_SET;
}
inline SortField::SortKindCase SortField::sort_kind_case() const {
  return SortField::SortKindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AggregateFunction

// uint32 function_reference = 1 [json_name = "functionReference"];
inline void AggregateFunction::clear_function_reference() {
  function_reference_ = 0u;
}
inline uint32_t AggregateFunction::_internal_function_reference() const {
  return function_reference_;
}
inline uint32_t AggregateFunction::function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.function_reference)
  return _internal_function_reference();
}
inline void AggregateFunction::_internal_set_function_reference(uint32_t value) {
  
  function_reference_ = value;
}
inline void AggregateFunction::set_function_reference(uint32_t value) {
  _internal_set_function_reference(value);
  // @@protoc_insertion_point(field_set:substrait.AggregateFunction.function_reference)
}

// repeated .substrait.Expression args = 2 [json_name = "args"];
inline int AggregateFunction::_internal_args_size() const {
  return args_.size();
}
inline int AggregateFunction::args_size() const {
  return _internal_args_size();
}
inline void AggregateFunction::clear_args() {
  args_.Clear();
}
inline ::substrait::Expression* AggregateFunction::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >*
AggregateFunction::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateFunction.args)
  return &args_;
}
inline const ::substrait::Expression& AggregateFunction::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::substrait::Expression& AggregateFunction::args(int index) const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.args)
  return _internal_args(index);
}
inline ::substrait::Expression* AggregateFunction::_internal_add_args() {
  return args_.Add();
}
inline ::substrait::Expression* AggregateFunction::add_args() {
  ::substrait::Expression* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:substrait.AggregateFunction.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Expression >&
AggregateFunction::args() const {
  // @@protoc_insertion_point(field_list:substrait.AggregateFunction.args)
  return args_;
}

// repeated .substrait.SortField sorts = 3 [json_name = "sorts"];
inline int AggregateFunction::_internal_sorts_size() const {
  return sorts_.size();
}
inline int AggregateFunction::sorts_size() const {
  return _internal_sorts_size();
}
inline void AggregateFunction::clear_sorts() {
  sorts_.Clear();
}
inline ::substrait::SortField* AggregateFunction::mutable_sorts(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.sorts)
  return sorts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::SortField >*
AggregateFunction::mutable_sorts() {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateFunction.sorts)
  return &sorts_;
}
inline const ::substrait::SortField& AggregateFunction::_internal_sorts(int index) const {
  return sorts_.Get(index);
}
inline const ::substrait::SortField& AggregateFunction::sorts(int index) const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.sorts)
  return _internal_sorts(index);
}
inline ::substrait::SortField* AggregateFunction::_internal_add_sorts() {
  return sorts_.Add();
}
inline ::substrait::SortField* AggregateFunction::add_sorts() {
  ::substrait::SortField* _add = _internal_add_sorts();
  // @@protoc_insertion_point(field_add:substrait.AggregateFunction.sorts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::SortField >&
AggregateFunction::sorts() const {
  // @@protoc_insertion_point(field_list:substrait.AggregateFunction.sorts)
  return sorts_;
}

// .substrait.AggregationPhase phase = 4 [json_name = "phase"];
inline void AggregateFunction::clear_phase() {
  phase_ = 0;
}
inline ::substrait::AggregationPhase AggregateFunction::_internal_phase() const {
  return static_cast< ::substrait::AggregationPhase >(phase_);
}
inline ::substrait::AggregationPhase AggregateFunction::phase() const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.phase)
  return _internal_phase();
}
inline void AggregateFunction::_internal_set_phase(::substrait::AggregationPhase value) {
  
  phase_ = value;
}
inline void AggregateFunction::set_phase(::substrait::AggregationPhase value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:substrait.AggregateFunction.phase)
}

// .substrait.Type output_type = 5 [json_name = "outputType"];
inline bool AggregateFunction::_internal_has_output_type() const {
  return this != internal_default_instance() && output_type_ != nullptr;
}
inline bool AggregateFunction::has_output_type() const {
  return _internal_has_output_type();
}
inline const ::substrait::Type& AggregateFunction::_internal_output_type() const {
  const ::substrait::Type* p = output_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(
      ::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& AggregateFunction::output_type() const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.output_type)
  return _internal_output_type();
}
inline void AggregateFunction::unsafe_arena_set_allocated_output_type(
    ::substrait::Type* output_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type_);
  }
  output_type_ = output_type;
  if (output_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.AggregateFunction.output_type)
}
inline ::substrait::Type* AggregateFunction::release_output_type() {
  
  ::substrait::Type* temp = output_type_;
  output_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Type* AggregateFunction::unsafe_arena_release_output_type() {
  // @@protoc_insertion_point(field_release:substrait.AggregateFunction.output_type)
  
  ::substrait::Type* temp = output_type_;
  output_type_ = nullptr;
  return temp;
}
inline ::substrait::Type* AggregateFunction::_internal_mutable_output_type() {
  
  if (output_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaForAllocation());
    output_type_ = p;
  }
  return output_type_;
}
inline ::substrait::Type* AggregateFunction::mutable_output_type() {
  ::substrait::Type* _msg = _internal_mutable_output_type();
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.output_type)
  return _msg;
}
inline void AggregateFunction::set_allocated_output_type(::substrait::Type* output_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type_);
  }
  if (output_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_type));
    if (message_arena != submessage_arena) {
      output_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_type, submessage_arena);
    }
    
  } else {
    
  }
  output_type_ = output_type;
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateFunction.output_type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace substrait

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::substrait::SortField_SortDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::SortField_SortDirection>() {
  return ::substrait::SortField_SortDirection_descriptor();
}
template <> struct is_proto_enum< ::substrait::AggregationPhase> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::AggregationPhase>() {
  return ::substrait::AggregationPhase_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_substrait_2fexpression_2eproto
