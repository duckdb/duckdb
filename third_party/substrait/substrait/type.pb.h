// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: substrait/type.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_substrait_2ftype_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_substrait_2ftype_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_substrait_2ftype_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_substrait_2ftype_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_substrait_2ftype_2eproto;
namespace substrait {
class NamedStruct;
struct NamedStructDefaultTypeInternal;
extern NamedStructDefaultTypeInternal _NamedStruct_default_instance_;
class Type;
struct TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class Type_Binary;
struct Type_BinaryDefaultTypeInternal;
extern Type_BinaryDefaultTypeInternal _Type_Binary_default_instance_;
class Type_Boolean;
struct Type_BooleanDefaultTypeInternal;
extern Type_BooleanDefaultTypeInternal _Type_Boolean_default_instance_;
class Type_Date;
struct Type_DateDefaultTypeInternal;
extern Type_DateDefaultTypeInternal _Type_Date_default_instance_;
class Type_Decimal;
struct Type_DecimalDefaultTypeInternal;
extern Type_DecimalDefaultTypeInternal _Type_Decimal_default_instance_;
class Type_FP32;
struct Type_FP32DefaultTypeInternal;
extern Type_FP32DefaultTypeInternal _Type_FP32_default_instance_;
class Type_FP64;
struct Type_FP64DefaultTypeInternal;
extern Type_FP64DefaultTypeInternal _Type_FP64_default_instance_;
class Type_FixedBinary;
struct Type_FixedBinaryDefaultTypeInternal;
extern Type_FixedBinaryDefaultTypeInternal _Type_FixedBinary_default_instance_;
class Type_FixedChar;
struct Type_FixedCharDefaultTypeInternal;
extern Type_FixedCharDefaultTypeInternal _Type_FixedChar_default_instance_;
class Type_I16;
struct Type_I16DefaultTypeInternal;
extern Type_I16DefaultTypeInternal _Type_I16_default_instance_;
class Type_I32;
struct Type_I32DefaultTypeInternal;
extern Type_I32DefaultTypeInternal _Type_I32_default_instance_;
class Type_I64;
struct Type_I64DefaultTypeInternal;
extern Type_I64DefaultTypeInternal _Type_I64_default_instance_;
class Type_I8;
struct Type_I8DefaultTypeInternal;
extern Type_I8DefaultTypeInternal _Type_I8_default_instance_;
class Type_IntervalDay;
struct Type_IntervalDayDefaultTypeInternal;
extern Type_IntervalDayDefaultTypeInternal _Type_IntervalDay_default_instance_;
class Type_IntervalYear;
struct Type_IntervalYearDefaultTypeInternal;
extern Type_IntervalYearDefaultTypeInternal _Type_IntervalYear_default_instance_;
class Type_List;
struct Type_ListDefaultTypeInternal;
extern Type_ListDefaultTypeInternal _Type_List_default_instance_;
class Type_Map;
struct Type_MapDefaultTypeInternal;
extern Type_MapDefaultTypeInternal _Type_Map_default_instance_;
class Type_String;
struct Type_StringDefaultTypeInternal;
extern Type_StringDefaultTypeInternal _Type_String_default_instance_;
class Type_Struct;
struct Type_StructDefaultTypeInternal;
extern Type_StructDefaultTypeInternal _Type_Struct_default_instance_;
class Type_Time;
struct Type_TimeDefaultTypeInternal;
extern Type_TimeDefaultTypeInternal _Type_Time_default_instance_;
class Type_Timestamp;
struct Type_TimestampDefaultTypeInternal;
extern Type_TimestampDefaultTypeInternal _Type_Timestamp_default_instance_;
class Type_TimestampTZ;
struct Type_TimestampTZDefaultTypeInternal;
extern Type_TimestampTZDefaultTypeInternal _Type_TimestampTZ_default_instance_;
class Type_UUID;
struct Type_UUIDDefaultTypeInternal;
extern Type_UUIDDefaultTypeInternal _Type_UUID_default_instance_;
class Type_VarChar;
struct Type_VarCharDefaultTypeInternal;
extern Type_VarCharDefaultTypeInternal _Type_VarChar_default_instance_;
}  // namespace substrait
PROTOBUF_NAMESPACE_OPEN
template<> ::substrait::NamedStruct* Arena::CreateMaybeMessage<::substrait::NamedStruct>(Arena*);
template<> ::substrait::Type* Arena::CreateMaybeMessage<::substrait::Type>(Arena*);
template<> ::substrait::Type_Binary* Arena::CreateMaybeMessage<::substrait::Type_Binary>(Arena*);
template<> ::substrait::Type_Boolean* Arena::CreateMaybeMessage<::substrait::Type_Boolean>(Arena*);
template<> ::substrait::Type_Date* Arena::CreateMaybeMessage<::substrait::Type_Date>(Arena*);
template<> ::substrait::Type_Decimal* Arena::CreateMaybeMessage<::substrait::Type_Decimal>(Arena*);
template<> ::substrait::Type_FP32* Arena::CreateMaybeMessage<::substrait::Type_FP32>(Arena*);
template<> ::substrait::Type_FP64* Arena::CreateMaybeMessage<::substrait::Type_FP64>(Arena*);
template<> ::substrait::Type_FixedBinary* Arena::CreateMaybeMessage<::substrait::Type_FixedBinary>(Arena*);
template<> ::substrait::Type_FixedChar* Arena::CreateMaybeMessage<::substrait::Type_FixedChar>(Arena*);
template<> ::substrait::Type_I16* Arena::CreateMaybeMessage<::substrait::Type_I16>(Arena*);
template<> ::substrait::Type_I32* Arena::CreateMaybeMessage<::substrait::Type_I32>(Arena*);
template<> ::substrait::Type_I64* Arena::CreateMaybeMessage<::substrait::Type_I64>(Arena*);
template<> ::substrait::Type_I8* Arena::CreateMaybeMessage<::substrait::Type_I8>(Arena*);
template<> ::substrait::Type_IntervalDay* Arena::CreateMaybeMessage<::substrait::Type_IntervalDay>(Arena*);
template<> ::substrait::Type_IntervalYear* Arena::CreateMaybeMessage<::substrait::Type_IntervalYear>(Arena*);
template<> ::substrait::Type_List* Arena::CreateMaybeMessage<::substrait::Type_List>(Arena*);
template<> ::substrait::Type_Map* Arena::CreateMaybeMessage<::substrait::Type_Map>(Arena*);
template<> ::substrait::Type_String* Arena::CreateMaybeMessage<::substrait::Type_String>(Arena*);
template<> ::substrait::Type_Struct* Arena::CreateMaybeMessage<::substrait::Type_Struct>(Arena*);
template<> ::substrait::Type_Time* Arena::CreateMaybeMessage<::substrait::Type_Time>(Arena*);
template<> ::substrait::Type_Timestamp* Arena::CreateMaybeMessage<::substrait::Type_Timestamp>(Arena*);
template<> ::substrait::Type_TimestampTZ* Arena::CreateMaybeMessage<::substrait::Type_TimestampTZ>(Arena*);
template<> ::substrait::Type_UUID* Arena::CreateMaybeMessage<::substrait::Type_UUID>(Arena*);
template<> ::substrait::Type_VarChar* Arena::CreateMaybeMessage<::substrait::Type_VarChar>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace substrait {

enum Type_Nullability : int {
  Type_Nullability_NULLABILITY_UNSPECIFIED = 0,
  Type_Nullability_NULLABILITY_NULLABLE = 1,
  Type_Nullability_NULLABILITY_REQUIRED = 2,
  Type_Nullability_Type_Nullability_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Type_Nullability_Type_Nullability_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Type_Nullability_IsValid(int value);
constexpr Type_Nullability Type_Nullability_Nullability_MIN = Type_Nullability_NULLABILITY_UNSPECIFIED;
constexpr Type_Nullability Type_Nullability_Nullability_MAX = Type_Nullability_NULLABILITY_REQUIRED;
constexpr int Type_Nullability_Nullability_ARRAYSIZE = Type_Nullability_Nullability_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_Nullability_descriptor();
template<typename T>
inline const std::string& Type_Nullability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type_Nullability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Nullability_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_Nullability_descriptor(), enum_t_value);
}
inline bool Type_Nullability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type_Nullability* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type_Nullability>(
    Type_Nullability_descriptor(), name, value);
}
// ===================================================================

class Type_Boolean final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.Boolean) */ {
 public:
  inline Type_Boolean() : Type_Boolean(nullptr) {}
  ~Type_Boolean() override;
  explicit constexpr Type_Boolean(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Boolean(const Type_Boolean& from);
  Type_Boolean(Type_Boolean&& from) noexcept
    : Type_Boolean() {
    *this = ::std::move(from);
  }

  inline Type_Boolean& operator=(const Type_Boolean& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Boolean& operator=(Type_Boolean&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Boolean& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Boolean* internal_default_instance() {
    return reinterpret_cast<const Type_Boolean*>(
               &_Type_Boolean_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Type_Boolean& a, Type_Boolean& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Boolean* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Boolean* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Boolean* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Boolean>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Boolean& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Boolean& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Boolean* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.Boolean";
  }
  protected:
  explicit Type_Boolean(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.Boolean)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_I8 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.I8) */ {
 public:
  inline Type_I8() : Type_I8(nullptr) {}
  ~Type_I8() override;
  explicit constexpr Type_I8(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_I8(const Type_I8& from);
  Type_I8(Type_I8&& from) noexcept
    : Type_I8() {
    *this = ::std::move(from);
  }

  inline Type_I8& operator=(const Type_I8& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_I8& operator=(Type_I8&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_I8& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_I8* internal_default_instance() {
    return reinterpret_cast<const Type_I8*>(
               &_Type_I8_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Type_I8& a, Type_I8& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_I8* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_I8* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_I8* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_I8>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_I8& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_I8& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_I8* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.I8";
  }
  protected:
  explicit Type_I8(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.I8)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_I16 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.I16) */ {
 public:
  inline Type_I16() : Type_I16(nullptr) {}
  ~Type_I16() override;
  explicit constexpr Type_I16(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_I16(const Type_I16& from);
  Type_I16(Type_I16&& from) noexcept
    : Type_I16() {
    *this = ::std::move(from);
  }

  inline Type_I16& operator=(const Type_I16& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_I16& operator=(Type_I16&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_I16& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_I16* internal_default_instance() {
    return reinterpret_cast<const Type_I16*>(
               &_Type_I16_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Type_I16& a, Type_I16& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_I16* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_I16* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_I16* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_I16>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_I16& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_I16& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_I16* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.I16";
  }
  protected:
  explicit Type_I16(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.I16)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_I32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.I32) */ {
 public:
  inline Type_I32() : Type_I32(nullptr) {}
  ~Type_I32() override;
  explicit constexpr Type_I32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_I32(const Type_I32& from);
  Type_I32(Type_I32&& from) noexcept
    : Type_I32() {
    *this = ::std::move(from);
  }

  inline Type_I32& operator=(const Type_I32& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_I32& operator=(Type_I32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_I32& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_I32* internal_default_instance() {
    return reinterpret_cast<const Type_I32*>(
               &_Type_I32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Type_I32& a, Type_I32& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_I32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_I32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_I32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_I32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_I32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_I32& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_I32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.I32";
  }
  protected:
  explicit Type_I32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.I32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_I64 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.I64) */ {
 public:
  inline Type_I64() : Type_I64(nullptr) {}
  ~Type_I64() override;
  explicit constexpr Type_I64(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_I64(const Type_I64& from);
  Type_I64(Type_I64&& from) noexcept
    : Type_I64() {
    *this = ::std::move(from);
  }

  inline Type_I64& operator=(const Type_I64& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_I64& operator=(Type_I64&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_I64& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_I64* internal_default_instance() {
    return reinterpret_cast<const Type_I64*>(
               &_Type_I64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Type_I64& a, Type_I64& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_I64* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_I64* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_I64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_I64>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_I64& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_I64& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_I64* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.I64";
  }
  protected:
  explicit Type_I64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.I64)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_FP32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.FP32) */ {
 public:
  inline Type_FP32() : Type_FP32(nullptr) {}
  ~Type_FP32() override;
  explicit constexpr Type_FP32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_FP32(const Type_FP32& from);
  Type_FP32(Type_FP32&& from) noexcept
    : Type_FP32() {
    *this = ::std::move(from);
  }

  inline Type_FP32& operator=(const Type_FP32& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_FP32& operator=(Type_FP32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_FP32& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_FP32* internal_default_instance() {
    return reinterpret_cast<const Type_FP32*>(
               &_Type_FP32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Type_FP32& a, Type_FP32& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_FP32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_FP32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_FP32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_FP32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_FP32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_FP32& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_FP32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.FP32";
  }
  protected:
  explicit Type_FP32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.FP32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_FP64 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.FP64) */ {
 public:
  inline Type_FP64() : Type_FP64(nullptr) {}
  ~Type_FP64() override;
  explicit constexpr Type_FP64(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_FP64(const Type_FP64& from);
  Type_FP64(Type_FP64&& from) noexcept
    : Type_FP64() {
    *this = ::std::move(from);
  }

  inline Type_FP64& operator=(const Type_FP64& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_FP64& operator=(Type_FP64&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_FP64& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_FP64* internal_default_instance() {
    return reinterpret_cast<const Type_FP64*>(
               &_Type_FP64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Type_FP64& a, Type_FP64& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_FP64* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_FP64* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_FP64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_FP64>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_FP64& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_FP64& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_FP64* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.FP64";
  }
  protected:
  explicit Type_FP64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.FP64)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_String final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.String) */ {
 public:
  inline Type_String() : Type_String(nullptr) {}
  ~Type_String() override;
  explicit constexpr Type_String(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_String(const Type_String& from);
  Type_String(Type_String&& from) noexcept
    : Type_String() {
    *this = ::std::move(from);
  }

  inline Type_String& operator=(const Type_String& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_String& operator=(Type_String&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_String& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_String* internal_default_instance() {
    return reinterpret_cast<const Type_String*>(
               &_Type_String_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Type_String& a, Type_String& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_String* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_String* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_String* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_String>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_String& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_String& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_String* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.String";
  }
  protected:
  explicit Type_String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.String)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Binary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.Binary) */ {
 public:
  inline Type_Binary() : Type_Binary(nullptr) {}
  ~Type_Binary() override;
  explicit constexpr Type_Binary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Binary(const Type_Binary& from);
  Type_Binary(Type_Binary&& from) noexcept
    : Type_Binary() {
    *this = ::std::move(from);
  }

  inline Type_Binary& operator=(const Type_Binary& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Binary& operator=(Type_Binary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Binary& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Binary* internal_default_instance() {
    return reinterpret_cast<const Type_Binary*>(
               &_Type_Binary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Type_Binary& a, Type_Binary& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Binary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Binary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Binary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Binary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Binary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Binary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Binary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.Binary";
  }
  protected:
  explicit Type_Binary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.Binary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Timestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.Timestamp) */ {
 public:
  inline Type_Timestamp() : Type_Timestamp(nullptr) {}
  ~Type_Timestamp() override;
  explicit constexpr Type_Timestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Timestamp(const Type_Timestamp& from);
  Type_Timestamp(Type_Timestamp&& from) noexcept
    : Type_Timestamp() {
    *this = ::std::move(from);
  }

  inline Type_Timestamp& operator=(const Type_Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Timestamp& operator=(Type_Timestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Timestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Timestamp* internal_default_instance() {
    return reinterpret_cast<const Type_Timestamp*>(
               &_Type_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Type_Timestamp& a, Type_Timestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Timestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Timestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Timestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Timestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Timestamp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Timestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.Timestamp";
  }
  protected:
  explicit Type_Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.Timestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Date final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.Date) */ {
 public:
  inline Type_Date() : Type_Date(nullptr) {}
  ~Type_Date() override;
  explicit constexpr Type_Date(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Date(const Type_Date& from);
  Type_Date(Type_Date&& from) noexcept
    : Type_Date() {
    *this = ::std::move(from);
  }

  inline Type_Date& operator=(const Type_Date& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Date& operator=(Type_Date&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Date& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Date* internal_default_instance() {
    return reinterpret_cast<const Type_Date*>(
               &_Type_Date_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Type_Date& a, Type_Date& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Date* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Date* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Date* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Date>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Date& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Date& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Date* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.Date";
  }
  protected:
  explicit Type_Date(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.Date)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Time final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.Time) */ {
 public:
  inline Type_Time() : Type_Time(nullptr) {}
  ~Type_Time() override;
  explicit constexpr Type_Time(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Time(const Type_Time& from);
  Type_Time(Type_Time&& from) noexcept
    : Type_Time() {
    *this = ::std::move(from);
  }

  inline Type_Time& operator=(const Type_Time& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Time& operator=(Type_Time&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Time& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Time* internal_default_instance() {
    return reinterpret_cast<const Type_Time*>(
               &_Type_Time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Type_Time& a, Type_Time& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Time* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Time* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Time* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Time>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Time& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Time& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Time* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.Time";
  }
  protected:
  explicit Type_Time(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.Time)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_TimestampTZ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.TimestampTZ) */ {
 public:
  inline Type_TimestampTZ() : Type_TimestampTZ(nullptr) {}
  ~Type_TimestampTZ() override;
  explicit constexpr Type_TimestampTZ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_TimestampTZ(const Type_TimestampTZ& from);
  Type_TimestampTZ(Type_TimestampTZ&& from) noexcept
    : Type_TimestampTZ() {
    *this = ::std::move(from);
  }

  inline Type_TimestampTZ& operator=(const Type_TimestampTZ& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_TimestampTZ& operator=(Type_TimestampTZ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_TimestampTZ& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_TimestampTZ* internal_default_instance() {
    return reinterpret_cast<const Type_TimestampTZ*>(
               &_Type_TimestampTZ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Type_TimestampTZ& a, Type_TimestampTZ& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_TimestampTZ* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_TimestampTZ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_TimestampTZ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_TimestampTZ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_TimestampTZ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_TimestampTZ& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_TimestampTZ* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.TimestampTZ";
  }
  protected:
  explicit Type_TimestampTZ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.TimestampTZ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_IntervalYear final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.IntervalYear) */ {
 public:
  inline Type_IntervalYear() : Type_IntervalYear(nullptr) {}
  ~Type_IntervalYear() override;
  explicit constexpr Type_IntervalYear(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_IntervalYear(const Type_IntervalYear& from);
  Type_IntervalYear(Type_IntervalYear&& from) noexcept
    : Type_IntervalYear() {
    *this = ::std::move(from);
  }

  inline Type_IntervalYear& operator=(const Type_IntervalYear& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_IntervalYear& operator=(Type_IntervalYear&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_IntervalYear& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_IntervalYear* internal_default_instance() {
    return reinterpret_cast<const Type_IntervalYear*>(
               &_Type_IntervalYear_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Type_IntervalYear& a, Type_IntervalYear& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_IntervalYear* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_IntervalYear* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_IntervalYear* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_IntervalYear>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_IntervalYear& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_IntervalYear& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_IntervalYear* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.IntervalYear";
  }
  protected:
  explicit Type_IntervalYear(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.IntervalYear)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_IntervalDay final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.IntervalDay) */ {
 public:
  inline Type_IntervalDay() : Type_IntervalDay(nullptr) {}
  ~Type_IntervalDay() override;
  explicit constexpr Type_IntervalDay(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_IntervalDay(const Type_IntervalDay& from);
  Type_IntervalDay(Type_IntervalDay&& from) noexcept
    : Type_IntervalDay() {
    *this = ::std::move(from);
  }

  inline Type_IntervalDay& operator=(const Type_IntervalDay& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_IntervalDay& operator=(Type_IntervalDay&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_IntervalDay& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_IntervalDay* internal_default_instance() {
    return reinterpret_cast<const Type_IntervalDay*>(
               &_Type_IntervalDay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Type_IntervalDay& a, Type_IntervalDay& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_IntervalDay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_IntervalDay* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_IntervalDay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_IntervalDay>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_IntervalDay& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_IntervalDay& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_IntervalDay* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.IntervalDay";
  }
  protected:
  explicit Type_IntervalDay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.IntervalDay)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_UUID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.UUID) */ {
 public:
  inline Type_UUID() : Type_UUID(nullptr) {}
  ~Type_UUID() override;
  explicit constexpr Type_UUID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_UUID(const Type_UUID& from);
  Type_UUID(Type_UUID&& from) noexcept
    : Type_UUID() {
    *this = ::std::move(from);
  }

  inline Type_UUID& operator=(const Type_UUID& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_UUID& operator=(Type_UUID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_UUID& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_UUID* internal_default_instance() {
    return reinterpret_cast<const Type_UUID*>(
               &_Type_UUID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Type_UUID& a, Type_UUID& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_UUID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_UUID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_UUID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_UUID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_UUID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_UUID& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_UUID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.UUID";
  }
  protected:
  explicit Type_UUID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeVariationReferenceFieldNumber = 1,
    kNullabilityFieldNumber = 2,
  };
  // uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.UUID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_FixedChar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.FixedChar) */ {
 public:
  inline Type_FixedChar() : Type_FixedChar(nullptr) {}
  ~Type_FixedChar() override;
  explicit constexpr Type_FixedChar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_FixedChar(const Type_FixedChar& from);
  Type_FixedChar(Type_FixedChar&& from) noexcept
    : Type_FixedChar() {
    *this = ::std::move(from);
  }

  inline Type_FixedChar& operator=(const Type_FixedChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_FixedChar& operator=(Type_FixedChar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_FixedChar& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_FixedChar* internal_default_instance() {
    return reinterpret_cast<const Type_FixedChar*>(
               &_Type_FixedChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Type_FixedChar& a, Type_FixedChar& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_FixedChar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_FixedChar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_FixedChar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_FixedChar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_FixedChar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_FixedChar& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_FixedChar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.FixedChar";
  }
  protected:
  explicit Type_FixedChar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kTypeVariationReferenceFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // int32 length = 1 [json_name = "length"];
  void clear_length();
  int32_t length() const;
  void set_length(int32_t value);
  private:
  int32_t _internal_length() const;
  void _internal_set_length(int32_t value);
  public:

  // uint32 type_variation_reference = 2 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.FixedChar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t length_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_VarChar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.VarChar) */ {
 public:
  inline Type_VarChar() : Type_VarChar(nullptr) {}
  ~Type_VarChar() override;
  explicit constexpr Type_VarChar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_VarChar(const Type_VarChar& from);
  Type_VarChar(Type_VarChar&& from) noexcept
    : Type_VarChar() {
    *this = ::std::move(from);
  }

  inline Type_VarChar& operator=(const Type_VarChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_VarChar& operator=(Type_VarChar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_VarChar& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_VarChar* internal_default_instance() {
    return reinterpret_cast<const Type_VarChar*>(
               &_Type_VarChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Type_VarChar& a, Type_VarChar& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_VarChar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_VarChar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_VarChar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_VarChar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_VarChar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_VarChar& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_VarChar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.VarChar";
  }
  protected:
  explicit Type_VarChar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kTypeVariationReferenceFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // int32 length = 1 [json_name = "length"];
  void clear_length();
  int32_t length() const;
  void set_length(int32_t value);
  private:
  int32_t _internal_length() const;
  void _internal_set_length(int32_t value);
  public:

  // uint32 type_variation_reference = 2 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.VarChar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t length_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_FixedBinary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.FixedBinary) */ {
 public:
  inline Type_FixedBinary() : Type_FixedBinary(nullptr) {}
  ~Type_FixedBinary() override;
  explicit constexpr Type_FixedBinary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_FixedBinary(const Type_FixedBinary& from);
  Type_FixedBinary(Type_FixedBinary&& from) noexcept
    : Type_FixedBinary() {
    *this = ::std::move(from);
  }

  inline Type_FixedBinary& operator=(const Type_FixedBinary& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_FixedBinary& operator=(Type_FixedBinary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_FixedBinary& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_FixedBinary* internal_default_instance() {
    return reinterpret_cast<const Type_FixedBinary*>(
               &_Type_FixedBinary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Type_FixedBinary& a, Type_FixedBinary& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_FixedBinary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_FixedBinary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_FixedBinary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_FixedBinary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_FixedBinary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_FixedBinary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_FixedBinary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.FixedBinary";
  }
  protected:
  explicit Type_FixedBinary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kTypeVariationReferenceFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // int32 length = 1 [json_name = "length"];
  void clear_length();
  int32_t length() const;
  void set_length(int32_t value);
  private:
  int32_t _internal_length() const;
  void _internal_set_length(int32_t value);
  public:

  // uint32 type_variation_reference = 2 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.FixedBinary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t length_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Decimal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.Decimal) */ {
 public:
  inline Type_Decimal() : Type_Decimal(nullptr) {}
  ~Type_Decimal() override;
  explicit constexpr Type_Decimal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Decimal(const Type_Decimal& from);
  Type_Decimal(Type_Decimal&& from) noexcept
    : Type_Decimal() {
    *this = ::std::move(from);
  }

  inline Type_Decimal& operator=(const Type_Decimal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Decimal& operator=(Type_Decimal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Decimal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Decimal* internal_default_instance() {
    return reinterpret_cast<const Type_Decimal*>(
               &_Type_Decimal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Type_Decimal& a, Type_Decimal& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Decimal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Decimal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Decimal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Decimal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Decimal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Decimal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Decimal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.Decimal";
  }
  protected:
  explicit Type_Decimal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScaleFieldNumber = 1,
    kPrecisionFieldNumber = 2,
    kTypeVariationReferenceFieldNumber = 3,
    kNullabilityFieldNumber = 4,
  };
  // int32 scale = 1 [json_name = "scale"];
  void clear_scale();
  int32_t scale() const;
  void set_scale(int32_t value);
  private:
  int32_t _internal_scale() const;
  void _internal_set_scale(int32_t value);
  public:

  // int32 precision = 2 [json_name = "precision"];
  void clear_precision();
  int32_t precision() const;
  void set_precision(int32_t value);
  private:
  int32_t _internal_precision() const;
  void _internal_set_precision(int32_t value);
  public:

  // uint32 type_variation_reference = 3 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 4 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.Decimal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t scale_;
  int32_t precision_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Struct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.Struct) */ {
 public:
  inline Type_Struct() : Type_Struct(nullptr) {}
  ~Type_Struct() override;
  explicit constexpr Type_Struct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Struct(const Type_Struct& from);
  Type_Struct(Type_Struct&& from) noexcept
    : Type_Struct() {
    *this = ::std::move(from);
  }

  inline Type_Struct& operator=(const Type_Struct& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Struct& operator=(Type_Struct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Struct& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Struct* internal_default_instance() {
    return reinterpret_cast<const Type_Struct*>(
               &_Type_Struct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Type_Struct& a, Type_Struct& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Struct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Struct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Struct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Struct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Struct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Struct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Struct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.Struct";
  }
  protected:
  explicit Type_Struct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
    kTypeVariationReferenceFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // repeated .substrait.Type types = 1 [json_name = "types"];
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  ::substrait::Type* mutable_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Type >*
      mutable_types();
  private:
  const ::substrait::Type& _internal_types(int index) const;
  ::substrait::Type* _internal_add_types();
  public:
  const ::substrait::Type& types(int index) const;
  ::substrait::Type* add_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Type >&
      types() const;

  // uint32 type_variation_reference = 2 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.Struct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Type > types_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.List) */ {
 public:
  inline Type_List() : Type_List(nullptr) {}
  ~Type_List() override;
  explicit constexpr Type_List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_List(const Type_List& from);
  Type_List(Type_List&& from) noexcept
    : Type_List() {
    *this = ::std::move(from);
  }

  inline Type_List& operator=(const Type_List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_List& operator=(Type_List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_List* internal_default_instance() {
    return reinterpret_cast<const Type_List*>(
               &_Type_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Type_List& a, Type_List& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_List& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.List";
  }
  protected:
  explicit Type_List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kTypeVariationReferenceFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // .substrait.Type type = 1 [json_name = "type"];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::substrait::Type& type() const;
  PROTOBUF_NODISCARD ::substrait::Type* release_type();
  ::substrait::Type* mutable_type();
  void set_allocated_type(::substrait::Type* type);
  private:
  const ::substrait::Type& _internal_type() const;
  ::substrait::Type* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::substrait::Type* type);
  ::substrait::Type* unsafe_arena_release_type();

  // uint32 type_variation_reference = 2 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Type* type_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Map final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type.Map) */ {
 public:
  inline Type_Map() : Type_Map(nullptr) {}
  ~Type_Map() override;
  explicit constexpr Type_Map(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Map(const Type_Map& from);
  Type_Map(Type_Map&& from) noexcept
    : Type_Map() {
    *this = ::std::move(from);
  }

  inline Type_Map& operator=(const Type_Map& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Map& operator=(Type_Map&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Map& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Map* internal_default_instance() {
    return reinterpret_cast<const Type_Map*>(
               &_Type_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Type_Map& a, Type_Map& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Map* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Map* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Map* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Map>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Map& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Map& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Map* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type.Map";
  }
  protected:
  explicit Type_Map(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kTypeVariationReferenceFieldNumber = 3,
    kNullabilityFieldNumber = 4,
  };
  // .substrait.Type key = 1 [json_name = "key"];
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::substrait::Type& key() const;
  PROTOBUF_NODISCARD ::substrait::Type* release_key();
  ::substrait::Type* mutable_key();
  void set_allocated_key(::substrait::Type* key);
  private:
  const ::substrait::Type& _internal_key() const;
  ::substrait::Type* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::substrait::Type* key);
  ::substrait::Type* unsafe_arena_release_key();

  // .substrait.Type value = 2 [json_name = "value"];
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::substrait::Type& value() const;
  PROTOBUF_NODISCARD ::substrait::Type* release_value();
  ::substrait::Type* mutable_value();
  void set_allocated_value(::substrait::Type* value);
  private:
  const ::substrait::Type& _internal_value() const;
  ::substrait::Type* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::substrait::Type* value);
  ::substrait::Type* unsafe_arena_release_value();

  // uint32 type_variation_reference = 3 [json_name = "typeVariationReference"];
  void clear_type_variation_reference();
  uint32_t type_variation_reference() const;
  void set_type_variation_reference(uint32_t value);
  private:
  uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(uint32_t value);
  public:

  // .substrait.Type.Nullability nullability = 4 [json_name = "nullability"];
  void clear_nullability();
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);
  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);
  public:

  // @@protoc_insertion_point(class_scope:substrait.Type.Map)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::substrait::Type* key_;
  ::substrait::Type* value_;
  uint32_t type_variation_reference_;
  int nullability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.Type) */ {
 public:
  inline Type() : Type(nullptr) {}
  ~Type() override;
  explicit constexpr Type(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kBool = 1,
    kI8 = 2,
    kI16 = 3,
    kI32 = 5,
    kI64 = 7,
    kFp32 = 10,
    kFp64 = 11,
    kString = 12,
    kBinary = 13,
    kTimestamp = 14,
    kDate = 16,
    kTime = 17,
    kIntervalYear = 19,
    kIntervalDay = 20,
    kTimestampTz = 29,
    kUuid = 32,
    kFixedChar = 21,
    kVarchar = 22,
    kFixedBinary = 23,
    kDecimal = 24,
    kStruct = 25,
    kList = 27,
    kMap = 28,
    kUserDefinedTypeReference = 31,
    KIND_NOT_SET = 0,
  };

  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.Type";
  }
  protected:
  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Type_Boolean Boolean;
  typedef Type_I8 I8;
  typedef Type_I16 I16;
  typedef Type_I32 I32;
  typedef Type_I64 I64;
  typedef Type_FP32 FP32;
  typedef Type_FP64 FP64;
  typedef Type_String String;
  typedef Type_Binary Binary;
  typedef Type_Timestamp Timestamp;
  typedef Type_Date Date;
  typedef Type_Time Time;
  typedef Type_TimestampTZ TimestampTZ;
  typedef Type_IntervalYear IntervalYear;
  typedef Type_IntervalDay IntervalDay;
  typedef Type_UUID UUID;
  typedef Type_FixedChar FixedChar;
  typedef Type_VarChar VarChar;
  typedef Type_FixedBinary FixedBinary;
  typedef Type_Decimal Decimal;
  typedef Type_Struct Struct;
  typedef Type_List List;
  typedef Type_Map Map;

  typedef Type_Nullability Nullability;
  static constexpr Nullability NULLABILITY_UNSPECIFIED =
    Type_Nullability_NULLABILITY_UNSPECIFIED;
  static constexpr Nullability NULLABILITY_NULLABLE =
    Type_Nullability_NULLABILITY_NULLABLE;
  static constexpr Nullability NULLABILITY_REQUIRED =
    Type_Nullability_NULLABILITY_REQUIRED;
  static inline bool Nullability_IsValid(int value) {
    return Type_Nullability_IsValid(value);
  }
  static constexpr Nullability Nullability_MIN =
    Type_Nullability_Nullability_MIN;
  static constexpr Nullability Nullability_MAX =
    Type_Nullability_Nullability_MAX;
  static constexpr int Nullability_ARRAYSIZE =
    Type_Nullability_Nullability_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Nullability_descriptor() {
    return Type_Nullability_descriptor();
  }
  template<typename T>
  static inline const std::string& Nullability_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Nullability>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Nullability_Name.");
    return Type_Nullability_Name(enum_t_value);
  }
  static inline bool Nullability_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Nullability* value) {
    return Type_Nullability_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBoolFieldNumber = 1,
    kI8FieldNumber = 2,
    kI16FieldNumber = 3,
    kI32FieldNumber = 5,
    kI64FieldNumber = 7,
    kFp32FieldNumber = 10,
    kFp64FieldNumber = 11,
    kStringFieldNumber = 12,
    kBinaryFieldNumber = 13,
    kTimestampFieldNumber = 14,
    kDateFieldNumber = 16,
    kTimeFieldNumber = 17,
    kIntervalYearFieldNumber = 19,
    kIntervalDayFieldNumber = 20,
    kTimestampTzFieldNumber = 29,
    kUuidFieldNumber = 32,
    kFixedCharFieldNumber = 21,
    kVarcharFieldNumber = 22,
    kFixedBinaryFieldNumber = 23,
    kDecimalFieldNumber = 24,
    kStructFieldNumber = 25,
    kListFieldNumber = 27,
    kMapFieldNumber = 28,
    kUserDefinedTypeReferenceFieldNumber = 31,
  };
  // .substrait.Type.Boolean bool = 1 [json_name = "bool"];
  bool has_bool_() const;
  private:
  bool _internal_has_bool_() const;
  public:
  void clear_bool_();
  const ::substrait::Type_Boolean& bool_() const;
  PROTOBUF_NODISCARD ::substrait::Type_Boolean* release_bool_();
  ::substrait::Type_Boolean* mutable_bool_();
  void set_allocated_bool_(::substrait::Type_Boolean* bool_);
  private:
  const ::substrait::Type_Boolean& _internal_bool_() const;
  ::substrait::Type_Boolean* _internal_mutable_bool_();
  public:
  void unsafe_arena_set_allocated_bool_(
      ::substrait::Type_Boolean* bool_);
  ::substrait::Type_Boolean* unsafe_arena_release_bool_();

  // .substrait.Type.I8 i8 = 2 [json_name = "i8"];
  bool has_i8() const;
  private:
  bool _internal_has_i8() const;
  public:
  void clear_i8();
  const ::substrait::Type_I8& i8() const;
  PROTOBUF_NODISCARD ::substrait::Type_I8* release_i8();
  ::substrait::Type_I8* mutable_i8();
  void set_allocated_i8(::substrait::Type_I8* i8);
  private:
  const ::substrait::Type_I8& _internal_i8() const;
  ::substrait::Type_I8* _internal_mutable_i8();
  public:
  void unsafe_arena_set_allocated_i8(
      ::substrait::Type_I8* i8);
  ::substrait::Type_I8* unsafe_arena_release_i8();

  // .substrait.Type.I16 i16 = 3 [json_name = "i16"];
  bool has_i16() const;
  private:
  bool _internal_has_i16() const;
  public:
  void clear_i16();
  const ::substrait::Type_I16& i16() const;
  PROTOBUF_NODISCARD ::substrait::Type_I16* release_i16();
  ::substrait::Type_I16* mutable_i16();
  void set_allocated_i16(::substrait::Type_I16* i16);
  private:
  const ::substrait::Type_I16& _internal_i16() const;
  ::substrait::Type_I16* _internal_mutable_i16();
  public:
  void unsafe_arena_set_allocated_i16(
      ::substrait::Type_I16* i16);
  ::substrait::Type_I16* unsafe_arena_release_i16();

  // .substrait.Type.I32 i32 = 5 [json_name = "i32"];
  bool has_i32() const;
  private:
  bool _internal_has_i32() const;
  public:
  void clear_i32();
  const ::substrait::Type_I32& i32() const;
  PROTOBUF_NODISCARD ::substrait::Type_I32* release_i32();
  ::substrait::Type_I32* mutable_i32();
  void set_allocated_i32(::substrait::Type_I32* i32);
  private:
  const ::substrait::Type_I32& _internal_i32() const;
  ::substrait::Type_I32* _internal_mutable_i32();
  public:
  void unsafe_arena_set_allocated_i32(
      ::substrait::Type_I32* i32);
  ::substrait::Type_I32* unsafe_arena_release_i32();

  // .substrait.Type.I64 i64 = 7 [json_name = "i64"];
  bool has_i64() const;
  private:
  bool _internal_has_i64() const;
  public:
  void clear_i64();
  const ::substrait::Type_I64& i64() const;
  PROTOBUF_NODISCARD ::substrait::Type_I64* release_i64();
  ::substrait::Type_I64* mutable_i64();
  void set_allocated_i64(::substrait::Type_I64* i64);
  private:
  const ::substrait::Type_I64& _internal_i64() const;
  ::substrait::Type_I64* _internal_mutable_i64();
  public:
  void unsafe_arena_set_allocated_i64(
      ::substrait::Type_I64* i64);
  ::substrait::Type_I64* unsafe_arena_release_i64();

  // .substrait.Type.FP32 fp32 = 10 [json_name = "fp32"];
  bool has_fp32() const;
  private:
  bool _internal_has_fp32() const;
  public:
  void clear_fp32();
  const ::substrait::Type_FP32& fp32() const;
  PROTOBUF_NODISCARD ::substrait::Type_FP32* release_fp32();
  ::substrait::Type_FP32* mutable_fp32();
  void set_allocated_fp32(::substrait::Type_FP32* fp32);
  private:
  const ::substrait::Type_FP32& _internal_fp32() const;
  ::substrait::Type_FP32* _internal_mutable_fp32();
  public:
  void unsafe_arena_set_allocated_fp32(
      ::substrait::Type_FP32* fp32);
  ::substrait::Type_FP32* unsafe_arena_release_fp32();

  // .substrait.Type.FP64 fp64 = 11 [json_name = "fp64"];
  bool has_fp64() const;
  private:
  bool _internal_has_fp64() const;
  public:
  void clear_fp64();
  const ::substrait::Type_FP64& fp64() const;
  PROTOBUF_NODISCARD ::substrait::Type_FP64* release_fp64();
  ::substrait::Type_FP64* mutable_fp64();
  void set_allocated_fp64(::substrait::Type_FP64* fp64);
  private:
  const ::substrait::Type_FP64& _internal_fp64() const;
  ::substrait::Type_FP64* _internal_mutable_fp64();
  public:
  void unsafe_arena_set_allocated_fp64(
      ::substrait::Type_FP64* fp64);
  ::substrait::Type_FP64* unsafe_arena_release_fp64();

  // .substrait.Type.String string = 12 [json_name = "string"];
  bool has_string() const;
  private:
  bool _internal_has_string() const;
  public:
  void clear_string();
  const ::substrait::Type_String& string() const;
  PROTOBUF_NODISCARD ::substrait::Type_String* release_string();
  ::substrait::Type_String* mutable_string();
  void set_allocated_string(::substrait::Type_String* string);
  private:
  const ::substrait::Type_String& _internal_string() const;
  ::substrait::Type_String* _internal_mutable_string();
  public:
  void unsafe_arena_set_allocated_string(
      ::substrait::Type_String* string);
  ::substrait::Type_String* unsafe_arena_release_string();

  // .substrait.Type.Binary binary = 13 [json_name = "binary"];
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;
  public:
  void clear_binary();
  const ::substrait::Type_Binary& binary() const;
  PROTOBUF_NODISCARD ::substrait::Type_Binary* release_binary();
  ::substrait::Type_Binary* mutable_binary();
  void set_allocated_binary(::substrait::Type_Binary* binary);
  private:
  const ::substrait::Type_Binary& _internal_binary() const;
  ::substrait::Type_Binary* _internal_mutable_binary();
  public:
  void unsafe_arena_set_allocated_binary(
      ::substrait::Type_Binary* binary);
  ::substrait::Type_Binary* unsafe_arena_release_binary();

  // .substrait.Type.Timestamp timestamp = 14 [json_name = "timestamp"];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::substrait::Type_Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::substrait::Type_Timestamp* release_timestamp();
  ::substrait::Type_Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::substrait::Type_Timestamp* timestamp);
  private:
  const ::substrait::Type_Timestamp& _internal_timestamp() const;
  ::substrait::Type_Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::substrait::Type_Timestamp* timestamp);
  ::substrait::Type_Timestamp* unsafe_arena_release_timestamp();

  // .substrait.Type.Date date = 16 [json_name = "date"];
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const ::substrait::Type_Date& date() const;
  PROTOBUF_NODISCARD ::substrait::Type_Date* release_date();
  ::substrait::Type_Date* mutable_date();
  void set_allocated_date(::substrait::Type_Date* date);
  private:
  const ::substrait::Type_Date& _internal_date() const;
  ::substrait::Type_Date* _internal_mutable_date();
  public:
  void unsafe_arena_set_allocated_date(
      ::substrait::Type_Date* date);
  ::substrait::Type_Date* unsafe_arena_release_date();

  // .substrait.Type.Time time = 17 [json_name = "time"];
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::substrait::Type_Time& time() const;
  PROTOBUF_NODISCARD ::substrait::Type_Time* release_time();
  ::substrait::Type_Time* mutable_time();
  void set_allocated_time(::substrait::Type_Time* time);
  private:
  const ::substrait::Type_Time& _internal_time() const;
  ::substrait::Type_Time* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::substrait::Type_Time* time);
  ::substrait::Type_Time* unsafe_arena_release_time();

  // .substrait.Type.IntervalYear interval_year = 19 [json_name = "intervalYear"];
  bool has_interval_year() const;
  private:
  bool _internal_has_interval_year() const;
  public:
  void clear_interval_year();
  const ::substrait::Type_IntervalYear& interval_year() const;
  PROTOBUF_NODISCARD ::substrait::Type_IntervalYear* release_interval_year();
  ::substrait::Type_IntervalYear* mutable_interval_year();
  void set_allocated_interval_year(::substrait::Type_IntervalYear* interval_year);
  private:
  const ::substrait::Type_IntervalYear& _internal_interval_year() const;
  ::substrait::Type_IntervalYear* _internal_mutable_interval_year();
  public:
  void unsafe_arena_set_allocated_interval_year(
      ::substrait::Type_IntervalYear* interval_year);
  ::substrait::Type_IntervalYear* unsafe_arena_release_interval_year();

  // .substrait.Type.IntervalDay interval_day = 20 [json_name = "intervalDay"];
  bool has_interval_day() const;
  private:
  bool _internal_has_interval_day() const;
  public:
  void clear_interval_day();
  const ::substrait::Type_IntervalDay& interval_day() const;
  PROTOBUF_NODISCARD ::substrait::Type_IntervalDay* release_interval_day();
  ::substrait::Type_IntervalDay* mutable_interval_day();
  void set_allocated_interval_day(::substrait::Type_IntervalDay* interval_day);
  private:
  const ::substrait::Type_IntervalDay& _internal_interval_day() const;
  ::substrait::Type_IntervalDay* _internal_mutable_interval_day();
  public:
  void unsafe_arena_set_allocated_interval_day(
      ::substrait::Type_IntervalDay* interval_day);
  ::substrait::Type_IntervalDay* unsafe_arena_release_interval_day();

  // .substrait.Type.TimestampTZ timestamp_tz = 29 [json_name = "timestampTz"];
  bool has_timestamp_tz() const;
  private:
  bool _internal_has_timestamp_tz() const;
  public:
  void clear_timestamp_tz();
  const ::substrait::Type_TimestampTZ& timestamp_tz() const;
  PROTOBUF_NODISCARD ::substrait::Type_TimestampTZ* release_timestamp_tz();
  ::substrait::Type_TimestampTZ* mutable_timestamp_tz();
  void set_allocated_timestamp_tz(::substrait::Type_TimestampTZ* timestamp_tz);
  private:
  const ::substrait::Type_TimestampTZ& _internal_timestamp_tz() const;
  ::substrait::Type_TimestampTZ* _internal_mutable_timestamp_tz();
  public:
  void unsafe_arena_set_allocated_timestamp_tz(
      ::substrait::Type_TimestampTZ* timestamp_tz);
  ::substrait::Type_TimestampTZ* unsafe_arena_release_timestamp_tz();

  // .substrait.Type.UUID uuid = 32 [json_name = "uuid"];
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const ::substrait::Type_UUID& uuid() const;
  PROTOBUF_NODISCARD ::substrait::Type_UUID* release_uuid();
  ::substrait::Type_UUID* mutable_uuid();
  void set_allocated_uuid(::substrait::Type_UUID* uuid);
  private:
  const ::substrait::Type_UUID& _internal_uuid() const;
  ::substrait::Type_UUID* _internal_mutable_uuid();
  public:
  void unsafe_arena_set_allocated_uuid(
      ::substrait::Type_UUID* uuid);
  ::substrait::Type_UUID* unsafe_arena_release_uuid();

  // .substrait.Type.FixedChar fixed_char = 21 [json_name = "fixedChar"];
  bool has_fixed_char() const;
  private:
  bool _internal_has_fixed_char() const;
  public:
  void clear_fixed_char();
  const ::substrait::Type_FixedChar& fixed_char() const;
  PROTOBUF_NODISCARD ::substrait::Type_FixedChar* release_fixed_char();
  ::substrait::Type_FixedChar* mutable_fixed_char();
  void set_allocated_fixed_char(::substrait::Type_FixedChar* fixed_char);
  private:
  const ::substrait::Type_FixedChar& _internal_fixed_char() const;
  ::substrait::Type_FixedChar* _internal_mutable_fixed_char();
  public:
  void unsafe_arena_set_allocated_fixed_char(
      ::substrait::Type_FixedChar* fixed_char);
  ::substrait::Type_FixedChar* unsafe_arena_release_fixed_char();

  // .substrait.Type.VarChar varchar = 22 [json_name = "varchar"];
  bool has_varchar() const;
  private:
  bool _internal_has_varchar() const;
  public:
  void clear_varchar();
  const ::substrait::Type_VarChar& varchar() const;
  PROTOBUF_NODISCARD ::substrait::Type_VarChar* release_varchar();
  ::substrait::Type_VarChar* mutable_varchar();
  void set_allocated_varchar(::substrait::Type_VarChar* varchar);
  private:
  const ::substrait::Type_VarChar& _internal_varchar() const;
  ::substrait::Type_VarChar* _internal_mutable_varchar();
  public:
  void unsafe_arena_set_allocated_varchar(
      ::substrait::Type_VarChar* varchar);
  ::substrait::Type_VarChar* unsafe_arena_release_varchar();

  // .substrait.Type.FixedBinary fixed_binary = 23 [json_name = "fixedBinary"];
  bool has_fixed_binary() const;
  private:
  bool _internal_has_fixed_binary() const;
  public:
  void clear_fixed_binary();
  const ::substrait::Type_FixedBinary& fixed_binary() const;
  PROTOBUF_NODISCARD ::substrait::Type_FixedBinary* release_fixed_binary();
  ::substrait::Type_FixedBinary* mutable_fixed_binary();
  void set_allocated_fixed_binary(::substrait::Type_FixedBinary* fixed_binary);
  private:
  const ::substrait::Type_FixedBinary& _internal_fixed_binary() const;
  ::substrait::Type_FixedBinary* _internal_mutable_fixed_binary();
  public:
  void unsafe_arena_set_allocated_fixed_binary(
      ::substrait::Type_FixedBinary* fixed_binary);
  ::substrait::Type_FixedBinary* unsafe_arena_release_fixed_binary();

  // .substrait.Type.Decimal decimal = 24 [json_name = "decimal"];
  bool has_decimal() const;
  private:
  bool _internal_has_decimal() const;
  public:
  void clear_decimal();
  const ::substrait::Type_Decimal& decimal() const;
  PROTOBUF_NODISCARD ::substrait::Type_Decimal* release_decimal();
  ::substrait::Type_Decimal* mutable_decimal();
  void set_allocated_decimal(::substrait::Type_Decimal* decimal);
  private:
  const ::substrait::Type_Decimal& _internal_decimal() const;
  ::substrait::Type_Decimal* _internal_mutable_decimal();
  public:
  void unsafe_arena_set_allocated_decimal(
      ::substrait::Type_Decimal* decimal);
  ::substrait::Type_Decimal* unsafe_arena_release_decimal();

  // .substrait.Type.Struct struct = 25 [json_name = "struct"];
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;
  public:
  void clear_struct_();
  const ::substrait::Type_Struct& struct_() const;
  PROTOBUF_NODISCARD ::substrait::Type_Struct* release_struct_();
  ::substrait::Type_Struct* mutable_struct_();
  void set_allocated_struct_(::substrait::Type_Struct* struct_);
  private:
  const ::substrait::Type_Struct& _internal_struct_() const;
  ::substrait::Type_Struct* _internal_mutable_struct_();
  public:
  void unsafe_arena_set_allocated_struct_(
      ::substrait::Type_Struct* struct_);
  ::substrait::Type_Struct* unsafe_arena_release_struct_();

  // .substrait.Type.List list = 27 [json_name = "list"];
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::substrait::Type_List& list() const;
  PROTOBUF_NODISCARD ::substrait::Type_List* release_list();
  ::substrait::Type_List* mutable_list();
  void set_allocated_list(::substrait::Type_List* list);
  private:
  const ::substrait::Type_List& _internal_list() const;
  ::substrait::Type_List* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::substrait::Type_List* list);
  ::substrait::Type_List* unsafe_arena_release_list();

  // .substrait.Type.Map map = 28 [json_name = "map"];
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::substrait::Type_Map& map() const;
  PROTOBUF_NODISCARD ::substrait::Type_Map* release_map();
  ::substrait::Type_Map* mutable_map();
  void set_allocated_map(::substrait::Type_Map* map);
  private:
  const ::substrait::Type_Map& _internal_map() const;
  ::substrait::Type_Map* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::substrait::Type_Map* map);
  ::substrait::Type_Map* unsafe_arena_release_map();

  // uint32 user_defined_type_reference = 31 [json_name = "userDefinedTypeReference"];
  bool has_user_defined_type_reference() const;
  private:
  bool _internal_has_user_defined_type_reference() const;
  public:
  void clear_user_defined_type_reference();
  uint32_t user_defined_type_reference() const;
  void set_user_defined_type_reference(uint32_t value);
  private:
  uint32_t _internal_user_defined_type_reference() const;
  void _internal_set_user_defined_type_reference(uint32_t value);
  public:

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Type)
 private:
  class _Internal;
  void set_has_bool_();
  void set_has_i8();
  void set_has_i16();
  void set_has_i32();
  void set_has_i64();
  void set_has_fp32();
  void set_has_fp64();
  void set_has_string();
  void set_has_binary();
  void set_has_timestamp();
  void set_has_date();
  void set_has_time();
  void set_has_interval_year();
  void set_has_interval_day();
  void set_has_timestamp_tz();
  void set_has_uuid();
  void set_has_fixed_char();
  void set_has_varchar();
  void set_has_fixed_binary();
  void set_has_decimal();
  void set_has_struct_();
  void set_has_list();
  void set_has_map();
  void set_has_user_defined_type_reference();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::substrait::Type_Boolean* bool__;
    ::substrait::Type_I8* i8_;
    ::substrait::Type_I16* i16_;
    ::substrait::Type_I32* i32_;
    ::substrait::Type_I64* i64_;
    ::substrait::Type_FP32* fp32_;
    ::substrait::Type_FP64* fp64_;
    ::substrait::Type_String* string_;
    ::substrait::Type_Binary* binary_;
    ::substrait::Type_Timestamp* timestamp_;
    ::substrait::Type_Date* date_;
    ::substrait::Type_Time* time_;
    ::substrait::Type_IntervalYear* interval_year_;
    ::substrait::Type_IntervalDay* interval_day_;
    ::substrait::Type_TimestampTZ* timestamp_tz_;
    ::substrait::Type_UUID* uuid_;
    ::substrait::Type_FixedChar* fixed_char_;
    ::substrait::Type_VarChar* varchar_;
    ::substrait::Type_FixedBinary* fixed_binary_;
    ::substrait::Type_Decimal* decimal_;
    ::substrait::Type_Struct* struct__;
    ::substrait::Type_List* list_;
    ::substrait::Type_Map* map_;
    uint32_t user_defined_type_reference_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// -------------------------------------------------------------------

class NamedStruct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:substrait.NamedStruct) */ {
 public:
  inline NamedStruct() : NamedStruct(nullptr) {}
  ~NamedStruct() override;
  explicit constexpr NamedStruct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedStruct(const NamedStruct& from);
  NamedStruct(NamedStruct&& from) noexcept
    : NamedStruct() {
    *this = ::std::move(from);
  }

  inline NamedStruct& operator=(const NamedStruct& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedStruct& operator=(NamedStruct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedStruct& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedStruct* internal_default_instance() {
    return reinterpret_cast<const NamedStruct*>(
               &_NamedStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(NamedStruct& a, NamedStruct& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedStruct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedStruct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedStruct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedStruct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedStruct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NamedStruct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedStruct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "substrait.NamedStruct";
  }
  protected:
  explicit NamedStruct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 1,
    kStructFieldNumber = 2,
  };
  // repeated string names = 1 [json_name = "names"];
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // .substrait.Type.Struct struct = 2 [json_name = "struct"];
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;
  public:
  void clear_struct_();
  const ::substrait::Type_Struct& struct_() const;
  PROTOBUF_NODISCARD ::substrait::Type_Struct* release_struct_();
  ::substrait::Type_Struct* mutable_struct_();
  void set_allocated_struct_(::substrait::Type_Struct* struct_);
  private:
  const ::substrait::Type_Struct& _internal_struct_() const;
  ::substrait::Type_Struct* _internal_mutable_struct_();
  public:
  void unsafe_arena_set_allocated_struct_(
      ::substrait::Type_Struct* struct_);
  ::substrait::Type_Struct* unsafe_arena_release_struct_();

  // @@protoc_insertion_point(class_scope:substrait.NamedStruct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
  ::substrait::Type_Struct* struct__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_substrait_2ftype_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Type_Boolean

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_Boolean::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_Boolean::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_Boolean::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Boolean.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_Boolean::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_Boolean::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Boolean.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_Boolean::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_Boolean::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_Boolean::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Boolean.nullability)
  return _internal_nullability();
}
inline void Type_Boolean::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_Boolean::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Boolean.nullability)
}

// -------------------------------------------------------------------

// Type_I8

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_I8::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_I8::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_I8::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.I8.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_I8::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_I8::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.I8.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_I8::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_I8::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_I8::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.I8.nullability)
  return _internal_nullability();
}
inline void Type_I8::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_I8::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.I8.nullability)
}

// -------------------------------------------------------------------

// Type_I16

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_I16::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_I16::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_I16::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.I16.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_I16::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_I16::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.I16.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_I16::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_I16::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_I16::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.I16.nullability)
  return _internal_nullability();
}
inline void Type_I16::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_I16::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.I16.nullability)
}

// -------------------------------------------------------------------

// Type_I32

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_I32::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_I32::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_I32::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.I32.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_I32::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_I32::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.I32.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_I32::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_I32::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_I32::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.I32.nullability)
  return _internal_nullability();
}
inline void Type_I32::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_I32::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.I32.nullability)
}

// -------------------------------------------------------------------

// Type_I64

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_I64::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_I64::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_I64::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.I64.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_I64::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_I64::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.I64.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_I64::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_I64::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_I64::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.I64.nullability)
  return _internal_nullability();
}
inline void Type_I64::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_I64::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.I64.nullability)
}

// -------------------------------------------------------------------

// Type_FP32

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_FP32::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_FP32::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_FP32::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.FP32.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_FP32::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_FP32::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.FP32.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_FP32::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_FP32::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_FP32::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.FP32.nullability)
  return _internal_nullability();
}
inline void Type_FP32::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_FP32::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.FP32.nullability)
}

// -------------------------------------------------------------------

// Type_FP64

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_FP64::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_FP64::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_FP64::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.FP64.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_FP64::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_FP64::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.FP64.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_FP64::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_FP64::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_FP64::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.FP64.nullability)
  return _internal_nullability();
}
inline void Type_FP64::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_FP64::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.FP64.nullability)
}

// -------------------------------------------------------------------

// Type_String

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_String::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_String::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_String::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.String.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_String::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_String::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.String.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_String::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_String::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_String::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.String.nullability)
  return _internal_nullability();
}
inline void Type_String::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_String::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.String.nullability)
}

// -------------------------------------------------------------------

// Type_Binary

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_Binary::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_Binary::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_Binary::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Binary.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_Binary::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_Binary::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Binary.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_Binary::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_Binary::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_Binary::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Binary.nullability)
  return _internal_nullability();
}
inline void Type_Binary::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_Binary::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Binary.nullability)
}

// -------------------------------------------------------------------

// Type_Timestamp

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_Timestamp::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_Timestamp::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_Timestamp::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Timestamp.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_Timestamp::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_Timestamp::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Timestamp.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_Timestamp::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_Timestamp::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_Timestamp::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Timestamp.nullability)
  return _internal_nullability();
}
inline void Type_Timestamp::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_Timestamp::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Timestamp.nullability)
}

// -------------------------------------------------------------------

// Type_Date

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_Date::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_Date::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_Date::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Date.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_Date::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_Date::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Date.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_Date::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_Date::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_Date::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Date.nullability)
  return _internal_nullability();
}
inline void Type_Date::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_Date::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Date.nullability)
}

// -------------------------------------------------------------------

// Type_Time

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_Time::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_Time::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_Time::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Time.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_Time::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_Time::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Time.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_Time::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_Time::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_Time::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Time.nullability)
  return _internal_nullability();
}
inline void Type_Time::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_Time::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Time.nullability)
}

// -------------------------------------------------------------------

// Type_TimestampTZ

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_TimestampTZ::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_TimestampTZ::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_TimestampTZ::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.TimestampTZ.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_TimestampTZ::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_TimestampTZ::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.TimestampTZ.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_TimestampTZ::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_TimestampTZ::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_TimestampTZ::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.TimestampTZ.nullability)
  return _internal_nullability();
}
inline void Type_TimestampTZ::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_TimestampTZ::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.TimestampTZ.nullability)
}

// -------------------------------------------------------------------

// Type_IntervalYear

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_IntervalYear::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_IntervalYear::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_IntervalYear::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.IntervalYear.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_IntervalYear::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_IntervalYear::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.IntervalYear.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_IntervalYear::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_IntervalYear::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_IntervalYear::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.IntervalYear.nullability)
  return _internal_nullability();
}
inline void Type_IntervalYear::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_IntervalYear::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.IntervalYear.nullability)
}

// -------------------------------------------------------------------

// Type_IntervalDay

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_IntervalDay::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_IntervalDay::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_IntervalDay::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.IntervalDay.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_IntervalDay::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_IntervalDay::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.IntervalDay.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_IntervalDay::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_IntervalDay::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_IntervalDay::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.IntervalDay.nullability)
  return _internal_nullability();
}
inline void Type_IntervalDay::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_IntervalDay::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.IntervalDay.nullability)
}

// -------------------------------------------------------------------

// Type_UUID

// uint32 type_variation_reference = 1 [json_name = "typeVariationReference"];
inline void Type_UUID::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_UUID::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_UUID::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.UUID.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_UUID::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_UUID::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.UUID.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 2 [json_name = "nullability"];
inline void Type_UUID::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_UUID::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_UUID::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.UUID.nullability)
  return _internal_nullability();
}
inline void Type_UUID::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_UUID::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.UUID.nullability)
}

// -------------------------------------------------------------------

// Type_FixedChar

// int32 length = 1 [json_name = "length"];
inline void Type_FixedChar::clear_length() {
  length_ = 0;
}
inline int32_t Type_FixedChar::_internal_length() const {
  return length_;
}
inline int32_t Type_FixedChar::length() const {
  // @@protoc_insertion_point(field_get:substrait.Type.FixedChar.length)
  return _internal_length();
}
inline void Type_FixedChar::_internal_set_length(int32_t value) {
  
  length_ = value;
}
inline void Type_FixedChar::set_length(int32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:substrait.Type.FixedChar.length)
}

// uint32 type_variation_reference = 2 [json_name = "typeVariationReference"];
inline void Type_FixedChar::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_FixedChar::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_FixedChar::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.FixedChar.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_FixedChar::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_FixedChar::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.FixedChar.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void Type_FixedChar::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_FixedChar::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_FixedChar::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.FixedChar.nullability)
  return _internal_nullability();
}
inline void Type_FixedChar::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_FixedChar::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.FixedChar.nullability)
}

// -------------------------------------------------------------------

// Type_VarChar

// int32 length = 1 [json_name = "length"];
inline void Type_VarChar::clear_length() {
  length_ = 0;
}
inline int32_t Type_VarChar::_internal_length() const {
  return length_;
}
inline int32_t Type_VarChar::length() const {
  // @@protoc_insertion_point(field_get:substrait.Type.VarChar.length)
  return _internal_length();
}
inline void Type_VarChar::_internal_set_length(int32_t value) {
  
  length_ = value;
}
inline void Type_VarChar::set_length(int32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:substrait.Type.VarChar.length)
}

// uint32 type_variation_reference = 2 [json_name = "typeVariationReference"];
inline void Type_VarChar::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_VarChar::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_VarChar::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.VarChar.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_VarChar::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_VarChar::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.VarChar.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void Type_VarChar::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_VarChar::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_VarChar::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.VarChar.nullability)
  return _internal_nullability();
}
inline void Type_VarChar::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_VarChar::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.VarChar.nullability)
}

// -------------------------------------------------------------------

// Type_FixedBinary

// int32 length = 1 [json_name = "length"];
inline void Type_FixedBinary::clear_length() {
  length_ = 0;
}
inline int32_t Type_FixedBinary::_internal_length() const {
  return length_;
}
inline int32_t Type_FixedBinary::length() const {
  // @@protoc_insertion_point(field_get:substrait.Type.FixedBinary.length)
  return _internal_length();
}
inline void Type_FixedBinary::_internal_set_length(int32_t value) {
  
  length_ = value;
}
inline void Type_FixedBinary::set_length(int32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:substrait.Type.FixedBinary.length)
}

// uint32 type_variation_reference = 2 [json_name = "typeVariationReference"];
inline void Type_FixedBinary::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_FixedBinary::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_FixedBinary::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.FixedBinary.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_FixedBinary::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_FixedBinary::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.FixedBinary.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void Type_FixedBinary::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_FixedBinary::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_FixedBinary::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.FixedBinary.nullability)
  return _internal_nullability();
}
inline void Type_FixedBinary::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_FixedBinary::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.FixedBinary.nullability)
}

// -------------------------------------------------------------------

// Type_Decimal

// int32 scale = 1 [json_name = "scale"];
inline void Type_Decimal::clear_scale() {
  scale_ = 0;
}
inline int32_t Type_Decimal::_internal_scale() const {
  return scale_;
}
inline int32_t Type_Decimal::scale() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Decimal.scale)
  return _internal_scale();
}
inline void Type_Decimal::_internal_set_scale(int32_t value) {
  
  scale_ = value;
}
inline void Type_Decimal::set_scale(int32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Decimal.scale)
}

// int32 precision = 2 [json_name = "precision"];
inline void Type_Decimal::clear_precision() {
  precision_ = 0;
}
inline int32_t Type_Decimal::_internal_precision() const {
  return precision_;
}
inline int32_t Type_Decimal::precision() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Decimal.precision)
  return _internal_precision();
}
inline void Type_Decimal::_internal_set_precision(int32_t value) {
  
  precision_ = value;
}
inline void Type_Decimal::set_precision(int32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Decimal.precision)
}

// uint32 type_variation_reference = 3 [json_name = "typeVariationReference"];
inline void Type_Decimal::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_Decimal::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_Decimal::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Decimal.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_Decimal::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_Decimal::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Decimal.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 4 [json_name = "nullability"];
inline void Type_Decimal::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_Decimal::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_Decimal::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Decimal.nullability)
  return _internal_nullability();
}
inline void Type_Decimal::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_Decimal::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Decimal.nullability)
}

// -------------------------------------------------------------------

// Type_Struct

// repeated .substrait.Type types = 1 [json_name = "types"];
inline int Type_Struct::_internal_types_size() const {
  return types_.size();
}
inline int Type_Struct::types_size() const {
  return _internal_types_size();
}
inline void Type_Struct::clear_types() {
  types_.Clear();
}
inline ::substrait::Type* Type_Struct::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Type.Struct.types)
  return types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Type >*
Type_Struct::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Type.Struct.types)
  return &types_;
}
inline const ::substrait::Type& Type_Struct::_internal_types(int index) const {
  return types_.Get(index);
}
inline const ::substrait::Type& Type_Struct::types(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Type.Struct.types)
  return _internal_types(index);
}
inline ::substrait::Type* Type_Struct::_internal_add_types() {
  return types_.Add();
}
inline ::substrait::Type* Type_Struct::add_types() {
  ::substrait::Type* _add = _internal_add_types();
  // @@protoc_insertion_point(field_add:substrait.Type.Struct.types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::substrait::Type >&
Type_Struct::types() const {
  // @@protoc_insertion_point(field_list:substrait.Type.Struct.types)
  return types_;
}

// uint32 type_variation_reference = 2 [json_name = "typeVariationReference"];
inline void Type_Struct::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_Struct::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_Struct::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Struct.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_Struct::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_Struct::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Struct.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void Type_Struct::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_Struct::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_Struct::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Struct.nullability)
  return _internal_nullability();
}
inline void Type_Struct::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_Struct::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Struct.nullability)
}

// -------------------------------------------------------------------

// Type_List

// .substrait.Type type = 1 [json_name = "type"];
inline bool Type_List::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool Type_List::has_type() const {
  return _internal_has_type();
}
inline void Type_List::clear_type() {
  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
inline const ::substrait::Type& Type_List::_internal_type() const {
  const ::substrait::Type* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(
      ::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Type_List::type() const {
  // @@protoc_insertion_point(field_get:substrait.Type.List.type)
  return _internal_type();
}
inline void Type_List::unsafe_arena_set_allocated_type(
    ::substrait::Type* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.List.type)
}
inline ::substrait::Type* Type_List::release_type() {
  
  ::substrait::Type* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Type* Type_List::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:substrait.Type.List.type)
  
  ::substrait::Type* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::substrait::Type* Type_List::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::substrait::Type* Type_List::mutable_type() {
  ::substrait::Type* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:substrait.Type.List.type)
  return _msg;
}
inline void Type_List::set_allocated_type(::substrait::Type* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Type>::GetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:substrait.Type.List.type)
}

// uint32 type_variation_reference = 2 [json_name = "typeVariationReference"];
inline void Type_List::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_List::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_List::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.List.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_List::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_List::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.List.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void Type_List::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_List::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_List::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.List.nullability)
  return _internal_nullability();
}
inline void Type_List::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_List::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.List.nullability)
}

// -------------------------------------------------------------------

// Type_Map

// .substrait.Type key = 1 [json_name = "key"];
inline bool Type_Map::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool Type_Map::has_key() const {
  return _internal_has_key();
}
inline void Type_Map::clear_key() {
  if (GetArenaForAllocation() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::substrait::Type& Type_Map::_internal_key() const {
  const ::substrait::Type* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(
      ::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Type_Map::key() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Map.key)
  return _internal_key();
}
inline void Type_Map::unsafe_arena_set_allocated_key(
    ::substrait::Type* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.Map.key)
}
inline ::substrait::Type* Type_Map::release_key() {
  
  ::substrait::Type* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Type* Type_Map::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:substrait.Type.Map.key)
  
  ::substrait::Type* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::substrait::Type* Type_Map::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::substrait::Type* Type_Map::mutable_key() {
  ::substrait::Type* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:substrait.Type.Map.key)
  return _msg;
}
inline void Type_Map::set_allocated_key(::substrait::Type* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Type>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:substrait.Type.Map.key)
}

// .substrait.Type value = 2 [json_name = "value"];
inline bool Type_Map::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool Type_Map::has_value() const {
  return _internal_has_value();
}
inline void Type_Map::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::substrait::Type& Type_Map::_internal_value() const {
  const ::substrait::Type* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(
      ::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Type_Map::value() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Map.value)
  return _internal_value();
}
inline void Type_Map::unsafe_arena_set_allocated_value(
    ::substrait::Type* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.Map.value)
}
inline ::substrait::Type* Type_Map::release_value() {
  
  ::substrait::Type* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Type* Type_Map::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:substrait.Type.Map.value)
  
  ::substrait::Type* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::substrait::Type* Type_Map::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::substrait::Type* Type_Map::mutable_value() {
  ::substrait::Type* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Type.Map.value)
  return _msg;
}
inline void Type_Map::set_allocated_value(::substrait::Type* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Type>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:substrait.Type.Map.value)
}

// uint32 type_variation_reference = 3 [json_name = "typeVariationReference"];
inline void Type_Map::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline uint32_t Type_Map::_internal_type_variation_reference() const {
  return type_variation_reference_;
}
inline uint32_t Type_Map::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Map.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Type_Map::_internal_set_type_variation_reference(uint32_t value) {
  
  type_variation_reference_ = value;
}
inline void Type_Map::set_type_variation_reference(uint32_t value) {
  _internal_set_type_variation_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Map.type_variation_reference)
}

// .substrait.Type.Nullability nullability = 4 [json_name = "nullability"];
inline void Type_Map::clear_nullability() {
  nullability_ = 0;
}
inline ::substrait::Type_Nullability Type_Map::_internal_nullability() const {
  return static_cast< ::substrait::Type_Nullability >(nullability_);
}
inline ::substrait::Type_Nullability Type_Map::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.Type.Map.nullability)
  return _internal_nullability();
}
inline void Type_Map::_internal_set_nullability(::substrait::Type_Nullability value) {
  
  nullability_ = value;
}
inline void Type_Map::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.Type.Map.nullability)
}

// -------------------------------------------------------------------

// Type

// .substrait.Type.Boolean bool = 1 [json_name = "bool"];
inline bool Type::_internal_has_bool_() const {
  return kind_case() == kBool;
}
inline bool Type::has_bool_() const {
  return _internal_has_bool_();
}
inline void Type::set_has_bool_() {
  _oneof_case_[0] = kBool;
}
inline void Type::clear_bool_() {
  if (_internal_has_bool_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.bool__;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_Boolean* Type::release_bool_() {
  // @@protoc_insertion_point(field_release:substrait.Type.bool)
  if (_internal_has_bool_()) {
    clear_has_kind();
      ::substrait::Type_Boolean* temp = kind_.bool__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Boolean& Type::_internal_bool_() const {
  return _internal_has_bool_()
      ? *kind_.bool__
      : reinterpret_cast< ::substrait::Type_Boolean&>(::substrait::_Type_Boolean_default_instance_);
}
inline const ::substrait::Type_Boolean& Type::bool_() const {
  // @@protoc_insertion_point(field_get:substrait.Type.bool)
  return _internal_bool_();
}
inline ::substrait::Type_Boolean* Type::unsafe_arena_release_bool_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.bool)
  if (_internal_has_bool_()) {
    clear_has_kind();
    ::substrait::Type_Boolean* temp = kind_.bool__;
    kind_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_bool_(::substrait::Type_Boolean* bool_) {
  clear_kind();
  if (bool_) {
    set_has_bool_();
    kind_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.bool)
}
inline ::substrait::Type_Boolean* Type::_internal_mutable_bool_() {
  if (!_internal_has_bool_()) {
    clear_kind();
    set_has_bool_();
    kind_.bool__ = CreateMaybeMessage< ::substrait::Type_Boolean >(GetArenaForAllocation());
  }
  return kind_.bool__;
}
inline ::substrait::Type_Boolean* Type::mutable_bool_() {
  ::substrait::Type_Boolean* _msg = _internal_mutable_bool_();
  // @@protoc_insertion_point(field_mutable:substrait.Type.bool)
  return _msg;
}

// .substrait.Type.I8 i8 = 2 [json_name = "i8"];
inline bool Type::_internal_has_i8() const {
  return kind_case() == kI8;
}
inline bool Type::has_i8() const {
  return _internal_has_i8();
}
inline void Type::set_has_i8() {
  _oneof_case_[0] = kI8;
}
inline void Type::clear_i8() {
  if (_internal_has_i8()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.i8_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_I8* Type::release_i8() {
  // @@protoc_insertion_point(field_release:substrait.Type.i8)
  if (_internal_has_i8()) {
    clear_has_kind();
      ::substrait::Type_I8* temp = kind_.i8_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.i8_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_I8& Type::_internal_i8() const {
  return _internal_has_i8()
      ? *kind_.i8_
      : reinterpret_cast< ::substrait::Type_I8&>(::substrait::_Type_I8_default_instance_);
}
inline const ::substrait::Type_I8& Type::i8() const {
  // @@protoc_insertion_point(field_get:substrait.Type.i8)
  return _internal_i8();
}
inline ::substrait::Type_I8* Type::unsafe_arena_release_i8() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.i8)
  if (_internal_has_i8()) {
    clear_has_kind();
    ::substrait::Type_I8* temp = kind_.i8_;
    kind_.i8_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_i8(::substrait::Type_I8* i8) {
  clear_kind();
  if (i8) {
    set_has_i8();
    kind_.i8_ = i8;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.i8)
}
inline ::substrait::Type_I8* Type::_internal_mutable_i8() {
  if (!_internal_has_i8()) {
    clear_kind();
    set_has_i8();
    kind_.i8_ = CreateMaybeMessage< ::substrait::Type_I8 >(GetArenaForAllocation());
  }
  return kind_.i8_;
}
inline ::substrait::Type_I8* Type::mutable_i8() {
  ::substrait::Type_I8* _msg = _internal_mutable_i8();
  // @@protoc_insertion_point(field_mutable:substrait.Type.i8)
  return _msg;
}

// .substrait.Type.I16 i16 = 3 [json_name = "i16"];
inline bool Type::_internal_has_i16() const {
  return kind_case() == kI16;
}
inline bool Type::has_i16() const {
  return _internal_has_i16();
}
inline void Type::set_has_i16() {
  _oneof_case_[0] = kI16;
}
inline void Type::clear_i16() {
  if (_internal_has_i16()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.i16_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_I16* Type::release_i16() {
  // @@protoc_insertion_point(field_release:substrait.Type.i16)
  if (_internal_has_i16()) {
    clear_has_kind();
      ::substrait::Type_I16* temp = kind_.i16_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.i16_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_I16& Type::_internal_i16() const {
  return _internal_has_i16()
      ? *kind_.i16_
      : reinterpret_cast< ::substrait::Type_I16&>(::substrait::_Type_I16_default_instance_);
}
inline const ::substrait::Type_I16& Type::i16() const {
  // @@protoc_insertion_point(field_get:substrait.Type.i16)
  return _internal_i16();
}
inline ::substrait::Type_I16* Type::unsafe_arena_release_i16() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.i16)
  if (_internal_has_i16()) {
    clear_has_kind();
    ::substrait::Type_I16* temp = kind_.i16_;
    kind_.i16_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_i16(::substrait::Type_I16* i16) {
  clear_kind();
  if (i16) {
    set_has_i16();
    kind_.i16_ = i16;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.i16)
}
inline ::substrait::Type_I16* Type::_internal_mutable_i16() {
  if (!_internal_has_i16()) {
    clear_kind();
    set_has_i16();
    kind_.i16_ = CreateMaybeMessage< ::substrait::Type_I16 >(GetArenaForAllocation());
  }
  return kind_.i16_;
}
inline ::substrait::Type_I16* Type::mutable_i16() {
  ::substrait::Type_I16* _msg = _internal_mutable_i16();
  // @@protoc_insertion_point(field_mutable:substrait.Type.i16)
  return _msg;
}

// .substrait.Type.I32 i32 = 5 [json_name = "i32"];
inline bool Type::_internal_has_i32() const {
  return kind_case() == kI32;
}
inline bool Type::has_i32() const {
  return _internal_has_i32();
}
inline void Type::set_has_i32() {
  _oneof_case_[0] = kI32;
}
inline void Type::clear_i32() {
  if (_internal_has_i32()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.i32_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_I32* Type::release_i32() {
  // @@protoc_insertion_point(field_release:substrait.Type.i32)
  if (_internal_has_i32()) {
    clear_has_kind();
      ::substrait::Type_I32* temp = kind_.i32_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.i32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_I32& Type::_internal_i32() const {
  return _internal_has_i32()
      ? *kind_.i32_
      : reinterpret_cast< ::substrait::Type_I32&>(::substrait::_Type_I32_default_instance_);
}
inline const ::substrait::Type_I32& Type::i32() const {
  // @@protoc_insertion_point(field_get:substrait.Type.i32)
  return _internal_i32();
}
inline ::substrait::Type_I32* Type::unsafe_arena_release_i32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.i32)
  if (_internal_has_i32()) {
    clear_has_kind();
    ::substrait::Type_I32* temp = kind_.i32_;
    kind_.i32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_i32(::substrait::Type_I32* i32) {
  clear_kind();
  if (i32) {
    set_has_i32();
    kind_.i32_ = i32;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.i32)
}
inline ::substrait::Type_I32* Type::_internal_mutable_i32() {
  if (!_internal_has_i32()) {
    clear_kind();
    set_has_i32();
    kind_.i32_ = CreateMaybeMessage< ::substrait::Type_I32 >(GetArenaForAllocation());
  }
  return kind_.i32_;
}
inline ::substrait::Type_I32* Type::mutable_i32() {
  ::substrait::Type_I32* _msg = _internal_mutable_i32();
  // @@protoc_insertion_point(field_mutable:substrait.Type.i32)
  return _msg;
}

// .substrait.Type.I64 i64 = 7 [json_name = "i64"];
inline bool Type::_internal_has_i64() const {
  return kind_case() == kI64;
}
inline bool Type::has_i64() const {
  return _internal_has_i64();
}
inline void Type::set_has_i64() {
  _oneof_case_[0] = kI64;
}
inline void Type::clear_i64() {
  if (_internal_has_i64()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.i64_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_I64* Type::release_i64() {
  // @@protoc_insertion_point(field_release:substrait.Type.i64)
  if (_internal_has_i64()) {
    clear_has_kind();
      ::substrait::Type_I64* temp = kind_.i64_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.i64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_I64& Type::_internal_i64() const {
  return _internal_has_i64()
      ? *kind_.i64_
      : reinterpret_cast< ::substrait::Type_I64&>(::substrait::_Type_I64_default_instance_);
}
inline const ::substrait::Type_I64& Type::i64() const {
  // @@protoc_insertion_point(field_get:substrait.Type.i64)
  return _internal_i64();
}
inline ::substrait::Type_I64* Type::unsafe_arena_release_i64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.i64)
  if (_internal_has_i64()) {
    clear_has_kind();
    ::substrait::Type_I64* temp = kind_.i64_;
    kind_.i64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_i64(::substrait::Type_I64* i64) {
  clear_kind();
  if (i64) {
    set_has_i64();
    kind_.i64_ = i64;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.i64)
}
inline ::substrait::Type_I64* Type::_internal_mutable_i64() {
  if (!_internal_has_i64()) {
    clear_kind();
    set_has_i64();
    kind_.i64_ = CreateMaybeMessage< ::substrait::Type_I64 >(GetArenaForAllocation());
  }
  return kind_.i64_;
}
inline ::substrait::Type_I64* Type::mutable_i64() {
  ::substrait::Type_I64* _msg = _internal_mutable_i64();
  // @@protoc_insertion_point(field_mutable:substrait.Type.i64)
  return _msg;
}

// .substrait.Type.FP32 fp32 = 10 [json_name = "fp32"];
inline bool Type::_internal_has_fp32() const {
  return kind_case() == kFp32;
}
inline bool Type::has_fp32() const {
  return _internal_has_fp32();
}
inline void Type::set_has_fp32() {
  _oneof_case_[0] = kFp32;
}
inline void Type::clear_fp32() {
  if (_internal_has_fp32()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.fp32_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_FP32* Type::release_fp32() {
  // @@protoc_insertion_point(field_release:substrait.Type.fp32)
  if (_internal_has_fp32()) {
    clear_has_kind();
      ::substrait::Type_FP32* temp = kind_.fp32_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.fp32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_FP32& Type::_internal_fp32() const {
  return _internal_has_fp32()
      ? *kind_.fp32_
      : reinterpret_cast< ::substrait::Type_FP32&>(::substrait::_Type_FP32_default_instance_);
}
inline const ::substrait::Type_FP32& Type::fp32() const {
  // @@protoc_insertion_point(field_get:substrait.Type.fp32)
  return _internal_fp32();
}
inline ::substrait::Type_FP32* Type::unsafe_arena_release_fp32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.fp32)
  if (_internal_has_fp32()) {
    clear_has_kind();
    ::substrait::Type_FP32* temp = kind_.fp32_;
    kind_.fp32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_fp32(::substrait::Type_FP32* fp32) {
  clear_kind();
  if (fp32) {
    set_has_fp32();
    kind_.fp32_ = fp32;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.fp32)
}
inline ::substrait::Type_FP32* Type::_internal_mutable_fp32() {
  if (!_internal_has_fp32()) {
    clear_kind();
    set_has_fp32();
    kind_.fp32_ = CreateMaybeMessage< ::substrait::Type_FP32 >(GetArenaForAllocation());
  }
  return kind_.fp32_;
}
inline ::substrait::Type_FP32* Type::mutable_fp32() {
  ::substrait::Type_FP32* _msg = _internal_mutable_fp32();
  // @@protoc_insertion_point(field_mutable:substrait.Type.fp32)
  return _msg;
}

// .substrait.Type.FP64 fp64 = 11 [json_name = "fp64"];
inline bool Type::_internal_has_fp64() const {
  return kind_case() == kFp64;
}
inline bool Type::has_fp64() const {
  return _internal_has_fp64();
}
inline void Type::set_has_fp64() {
  _oneof_case_[0] = kFp64;
}
inline void Type::clear_fp64() {
  if (_internal_has_fp64()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.fp64_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_FP64* Type::release_fp64() {
  // @@protoc_insertion_point(field_release:substrait.Type.fp64)
  if (_internal_has_fp64()) {
    clear_has_kind();
      ::substrait::Type_FP64* temp = kind_.fp64_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.fp64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_FP64& Type::_internal_fp64() const {
  return _internal_has_fp64()
      ? *kind_.fp64_
      : reinterpret_cast< ::substrait::Type_FP64&>(::substrait::_Type_FP64_default_instance_);
}
inline const ::substrait::Type_FP64& Type::fp64() const {
  // @@protoc_insertion_point(field_get:substrait.Type.fp64)
  return _internal_fp64();
}
inline ::substrait::Type_FP64* Type::unsafe_arena_release_fp64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.fp64)
  if (_internal_has_fp64()) {
    clear_has_kind();
    ::substrait::Type_FP64* temp = kind_.fp64_;
    kind_.fp64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_fp64(::substrait::Type_FP64* fp64) {
  clear_kind();
  if (fp64) {
    set_has_fp64();
    kind_.fp64_ = fp64;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.fp64)
}
inline ::substrait::Type_FP64* Type::_internal_mutable_fp64() {
  if (!_internal_has_fp64()) {
    clear_kind();
    set_has_fp64();
    kind_.fp64_ = CreateMaybeMessage< ::substrait::Type_FP64 >(GetArenaForAllocation());
  }
  return kind_.fp64_;
}
inline ::substrait::Type_FP64* Type::mutable_fp64() {
  ::substrait::Type_FP64* _msg = _internal_mutable_fp64();
  // @@protoc_insertion_point(field_mutable:substrait.Type.fp64)
  return _msg;
}

// .substrait.Type.String string = 12 [json_name = "string"];
inline bool Type::_internal_has_string() const {
  return kind_case() == kString;
}
inline bool Type::has_string() const {
  return _internal_has_string();
}
inline void Type::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void Type::clear_string() {
  if (_internal_has_string()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.string_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_String* Type::release_string() {
  // @@protoc_insertion_point(field_release:substrait.Type.string)
  if (_internal_has_string()) {
    clear_has_kind();
      ::substrait::Type_String* temp = kind_.string_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_String& Type::_internal_string() const {
  return _internal_has_string()
      ? *kind_.string_
      : reinterpret_cast< ::substrait::Type_String&>(::substrait::_Type_String_default_instance_);
}
inline const ::substrait::Type_String& Type::string() const {
  // @@protoc_insertion_point(field_get:substrait.Type.string)
  return _internal_string();
}
inline ::substrait::Type_String* Type::unsafe_arena_release_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.string)
  if (_internal_has_string()) {
    clear_has_kind();
    ::substrait::Type_String* temp = kind_.string_;
    kind_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_string(::substrait::Type_String* string) {
  clear_kind();
  if (string) {
    set_has_string();
    kind_.string_ = string;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.string)
}
inline ::substrait::Type_String* Type::_internal_mutable_string() {
  if (!_internal_has_string()) {
    clear_kind();
    set_has_string();
    kind_.string_ = CreateMaybeMessage< ::substrait::Type_String >(GetArenaForAllocation());
  }
  return kind_.string_;
}
inline ::substrait::Type_String* Type::mutable_string() {
  ::substrait::Type_String* _msg = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:substrait.Type.string)
  return _msg;
}

// .substrait.Type.Binary binary = 13 [json_name = "binary"];
inline bool Type::_internal_has_binary() const {
  return kind_case() == kBinary;
}
inline bool Type::has_binary() const {
  return _internal_has_binary();
}
inline void Type::set_has_binary() {
  _oneof_case_[0] = kBinary;
}
inline void Type::clear_binary() {
  if (_internal_has_binary()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.binary_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_Binary* Type::release_binary() {
  // @@protoc_insertion_point(field_release:substrait.Type.binary)
  if (_internal_has_binary()) {
    clear_has_kind();
      ::substrait::Type_Binary* temp = kind_.binary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Binary& Type::_internal_binary() const {
  return _internal_has_binary()
      ? *kind_.binary_
      : reinterpret_cast< ::substrait::Type_Binary&>(::substrait::_Type_Binary_default_instance_);
}
inline const ::substrait::Type_Binary& Type::binary() const {
  // @@protoc_insertion_point(field_get:substrait.Type.binary)
  return _internal_binary();
}
inline ::substrait::Type_Binary* Type::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.binary)
  if (_internal_has_binary()) {
    clear_has_kind();
    ::substrait::Type_Binary* temp = kind_.binary_;
    kind_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_binary(::substrait::Type_Binary* binary) {
  clear_kind();
  if (binary) {
    set_has_binary();
    kind_.binary_ = binary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.binary)
}
inline ::substrait::Type_Binary* Type::_internal_mutable_binary() {
  if (!_internal_has_binary()) {
    clear_kind();
    set_has_binary();
    kind_.binary_ = CreateMaybeMessage< ::substrait::Type_Binary >(GetArenaForAllocation());
  }
  return kind_.binary_;
}
inline ::substrait::Type_Binary* Type::mutable_binary() {
  ::substrait::Type_Binary* _msg = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:substrait.Type.binary)
  return _msg;
}

// .substrait.Type.Timestamp timestamp = 14 [json_name = "timestamp"];
inline bool Type::_internal_has_timestamp() const {
  return kind_case() == kTimestamp;
}
inline bool Type::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Type::set_has_timestamp() {
  _oneof_case_[0] = kTimestamp;
}
inline void Type::clear_timestamp() {
  if (_internal_has_timestamp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.timestamp_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_Timestamp* Type::release_timestamp() {
  // @@protoc_insertion_point(field_release:substrait.Type.timestamp)
  if (_internal_has_timestamp()) {
    clear_has_kind();
      ::substrait::Type_Timestamp* temp = kind_.timestamp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Timestamp& Type::_internal_timestamp() const {
  return _internal_has_timestamp()
      ? *kind_.timestamp_
      : reinterpret_cast< ::substrait::Type_Timestamp&>(::substrait::_Type_Timestamp_default_instance_);
}
inline const ::substrait::Type_Timestamp& Type::timestamp() const {
  // @@protoc_insertion_point(field_get:substrait.Type.timestamp)
  return _internal_timestamp();
}
inline ::substrait::Type_Timestamp* Type::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.timestamp)
  if (_internal_has_timestamp()) {
    clear_has_kind();
    ::substrait::Type_Timestamp* temp = kind_.timestamp_;
    kind_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_timestamp(::substrait::Type_Timestamp* timestamp) {
  clear_kind();
  if (timestamp) {
    set_has_timestamp();
    kind_.timestamp_ = timestamp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.timestamp)
}
inline ::substrait::Type_Timestamp* Type::_internal_mutable_timestamp() {
  if (!_internal_has_timestamp()) {
    clear_kind();
    set_has_timestamp();
    kind_.timestamp_ = CreateMaybeMessage< ::substrait::Type_Timestamp >(GetArenaForAllocation());
  }
  return kind_.timestamp_;
}
inline ::substrait::Type_Timestamp* Type::mutable_timestamp() {
  ::substrait::Type_Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:substrait.Type.timestamp)
  return _msg;
}

// .substrait.Type.Date date = 16 [json_name = "date"];
inline bool Type::_internal_has_date() const {
  return kind_case() == kDate;
}
inline bool Type::has_date() const {
  return _internal_has_date();
}
inline void Type::set_has_date() {
  _oneof_case_[0] = kDate;
}
inline void Type::clear_date() {
  if (_internal_has_date()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.date_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_Date* Type::release_date() {
  // @@protoc_insertion_point(field_release:substrait.Type.date)
  if (_internal_has_date()) {
    clear_has_kind();
      ::substrait::Type_Date* temp = kind_.date_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.date_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Date& Type::_internal_date() const {
  return _internal_has_date()
      ? *kind_.date_
      : reinterpret_cast< ::substrait::Type_Date&>(::substrait::_Type_Date_default_instance_);
}
inline const ::substrait::Type_Date& Type::date() const {
  // @@protoc_insertion_point(field_get:substrait.Type.date)
  return _internal_date();
}
inline ::substrait::Type_Date* Type::unsafe_arena_release_date() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.date)
  if (_internal_has_date()) {
    clear_has_kind();
    ::substrait::Type_Date* temp = kind_.date_;
    kind_.date_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_date(::substrait::Type_Date* date) {
  clear_kind();
  if (date) {
    set_has_date();
    kind_.date_ = date;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.date)
}
inline ::substrait::Type_Date* Type::_internal_mutable_date() {
  if (!_internal_has_date()) {
    clear_kind();
    set_has_date();
    kind_.date_ = CreateMaybeMessage< ::substrait::Type_Date >(GetArenaForAllocation());
  }
  return kind_.date_;
}
inline ::substrait::Type_Date* Type::mutable_date() {
  ::substrait::Type_Date* _msg = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:substrait.Type.date)
  return _msg;
}

// .substrait.Type.Time time = 17 [json_name = "time"];
inline bool Type::_internal_has_time() const {
  return kind_case() == kTime;
}
inline bool Type::has_time() const {
  return _internal_has_time();
}
inline void Type::set_has_time() {
  _oneof_case_[0] = kTime;
}
inline void Type::clear_time() {
  if (_internal_has_time()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.time_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_Time* Type::release_time() {
  // @@protoc_insertion_point(field_release:substrait.Type.time)
  if (_internal_has_time()) {
    clear_has_kind();
      ::substrait::Type_Time* temp = kind_.time_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Time& Type::_internal_time() const {
  return _internal_has_time()
      ? *kind_.time_
      : reinterpret_cast< ::substrait::Type_Time&>(::substrait::_Type_Time_default_instance_);
}
inline const ::substrait::Type_Time& Type::time() const {
  // @@protoc_insertion_point(field_get:substrait.Type.time)
  return _internal_time();
}
inline ::substrait::Type_Time* Type::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.time)
  if (_internal_has_time()) {
    clear_has_kind();
    ::substrait::Type_Time* temp = kind_.time_;
    kind_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_time(::substrait::Type_Time* time) {
  clear_kind();
  if (time) {
    set_has_time();
    kind_.time_ = time;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.time)
}
inline ::substrait::Type_Time* Type::_internal_mutable_time() {
  if (!_internal_has_time()) {
    clear_kind();
    set_has_time();
    kind_.time_ = CreateMaybeMessage< ::substrait::Type_Time >(GetArenaForAllocation());
  }
  return kind_.time_;
}
inline ::substrait::Type_Time* Type::mutable_time() {
  ::substrait::Type_Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:substrait.Type.time)
  return _msg;
}

// .substrait.Type.IntervalYear interval_year = 19 [json_name = "intervalYear"];
inline bool Type::_internal_has_interval_year() const {
  return kind_case() == kIntervalYear;
}
inline bool Type::has_interval_year() const {
  return _internal_has_interval_year();
}
inline void Type::set_has_interval_year() {
  _oneof_case_[0] = kIntervalYear;
}
inline void Type::clear_interval_year() {
  if (_internal_has_interval_year()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.interval_year_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_IntervalYear* Type::release_interval_year() {
  // @@protoc_insertion_point(field_release:substrait.Type.interval_year)
  if (_internal_has_interval_year()) {
    clear_has_kind();
      ::substrait::Type_IntervalYear* temp = kind_.interval_year_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.interval_year_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_IntervalYear& Type::_internal_interval_year() const {
  return _internal_has_interval_year()
      ? *kind_.interval_year_
      : reinterpret_cast< ::substrait::Type_IntervalYear&>(::substrait::_Type_IntervalYear_default_instance_);
}
inline const ::substrait::Type_IntervalYear& Type::interval_year() const {
  // @@protoc_insertion_point(field_get:substrait.Type.interval_year)
  return _internal_interval_year();
}
inline ::substrait::Type_IntervalYear* Type::unsafe_arena_release_interval_year() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.interval_year)
  if (_internal_has_interval_year()) {
    clear_has_kind();
    ::substrait::Type_IntervalYear* temp = kind_.interval_year_;
    kind_.interval_year_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_interval_year(::substrait::Type_IntervalYear* interval_year) {
  clear_kind();
  if (interval_year) {
    set_has_interval_year();
    kind_.interval_year_ = interval_year;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.interval_year)
}
inline ::substrait::Type_IntervalYear* Type::_internal_mutable_interval_year() {
  if (!_internal_has_interval_year()) {
    clear_kind();
    set_has_interval_year();
    kind_.interval_year_ = CreateMaybeMessage< ::substrait::Type_IntervalYear >(GetArenaForAllocation());
  }
  return kind_.interval_year_;
}
inline ::substrait::Type_IntervalYear* Type::mutable_interval_year() {
  ::substrait::Type_IntervalYear* _msg = _internal_mutable_interval_year();
  // @@protoc_insertion_point(field_mutable:substrait.Type.interval_year)
  return _msg;
}

// .substrait.Type.IntervalDay interval_day = 20 [json_name = "intervalDay"];
inline bool Type::_internal_has_interval_day() const {
  return kind_case() == kIntervalDay;
}
inline bool Type::has_interval_day() const {
  return _internal_has_interval_day();
}
inline void Type::set_has_interval_day() {
  _oneof_case_[0] = kIntervalDay;
}
inline void Type::clear_interval_day() {
  if (_internal_has_interval_day()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.interval_day_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_IntervalDay* Type::release_interval_day() {
  // @@protoc_insertion_point(field_release:substrait.Type.interval_day)
  if (_internal_has_interval_day()) {
    clear_has_kind();
      ::substrait::Type_IntervalDay* temp = kind_.interval_day_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.interval_day_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_IntervalDay& Type::_internal_interval_day() const {
  return _internal_has_interval_day()
      ? *kind_.interval_day_
      : reinterpret_cast< ::substrait::Type_IntervalDay&>(::substrait::_Type_IntervalDay_default_instance_);
}
inline const ::substrait::Type_IntervalDay& Type::interval_day() const {
  // @@protoc_insertion_point(field_get:substrait.Type.interval_day)
  return _internal_interval_day();
}
inline ::substrait::Type_IntervalDay* Type::unsafe_arena_release_interval_day() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.interval_day)
  if (_internal_has_interval_day()) {
    clear_has_kind();
    ::substrait::Type_IntervalDay* temp = kind_.interval_day_;
    kind_.interval_day_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_interval_day(::substrait::Type_IntervalDay* interval_day) {
  clear_kind();
  if (interval_day) {
    set_has_interval_day();
    kind_.interval_day_ = interval_day;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.interval_day)
}
inline ::substrait::Type_IntervalDay* Type::_internal_mutable_interval_day() {
  if (!_internal_has_interval_day()) {
    clear_kind();
    set_has_interval_day();
    kind_.interval_day_ = CreateMaybeMessage< ::substrait::Type_IntervalDay >(GetArenaForAllocation());
  }
  return kind_.interval_day_;
}
inline ::substrait::Type_IntervalDay* Type::mutable_interval_day() {
  ::substrait::Type_IntervalDay* _msg = _internal_mutable_interval_day();
  // @@protoc_insertion_point(field_mutable:substrait.Type.interval_day)
  return _msg;
}

// .substrait.Type.TimestampTZ timestamp_tz = 29 [json_name = "timestampTz"];
inline bool Type::_internal_has_timestamp_tz() const {
  return kind_case() == kTimestampTz;
}
inline bool Type::has_timestamp_tz() const {
  return _internal_has_timestamp_tz();
}
inline void Type::set_has_timestamp_tz() {
  _oneof_case_[0] = kTimestampTz;
}
inline void Type::clear_timestamp_tz() {
  if (_internal_has_timestamp_tz()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.timestamp_tz_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_TimestampTZ* Type::release_timestamp_tz() {
  // @@protoc_insertion_point(field_release:substrait.Type.timestamp_tz)
  if (_internal_has_timestamp_tz()) {
    clear_has_kind();
      ::substrait::Type_TimestampTZ* temp = kind_.timestamp_tz_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.timestamp_tz_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_TimestampTZ& Type::_internal_timestamp_tz() const {
  return _internal_has_timestamp_tz()
      ? *kind_.timestamp_tz_
      : reinterpret_cast< ::substrait::Type_TimestampTZ&>(::substrait::_Type_TimestampTZ_default_instance_);
}
inline const ::substrait::Type_TimestampTZ& Type::timestamp_tz() const {
  // @@protoc_insertion_point(field_get:substrait.Type.timestamp_tz)
  return _internal_timestamp_tz();
}
inline ::substrait::Type_TimestampTZ* Type::unsafe_arena_release_timestamp_tz() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.timestamp_tz)
  if (_internal_has_timestamp_tz()) {
    clear_has_kind();
    ::substrait::Type_TimestampTZ* temp = kind_.timestamp_tz_;
    kind_.timestamp_tz_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_timestamp_tz(::substrait::Type_TimestampTZ* timestamp_tz) {
  clear_kind();
  if (timestamp_tz) {
    set_has_timestamp_tz();
    kind_.timestamp_tz_ = timestamp_tz;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.timestamp_tz)
}
inline ::substrait::Type_TimestampTZ* Type::_internal_mutable_timestamp_tz() {
  if (!_internal_has_timestamp_tz()) {
    clear_kind();
    set_has_timestamp_tz();
    kind_.timestamp_tz_ = CreateMaybeMessage< ::substrait::Type_TimestampTZ >(GetArenaForAllocation());
  }
  return kind_.timestamp_tz_;
}
inline ::substrait::Type_TimestampTZ* Type::mutable_timestamp_tz() {
  ::substrait::Type_TimestampTZ* _msg = _internal_mutable_timestamp_tz();
  // @@protoc_insertion_point(field_mutable:substrait.Type.timestamp_tz)
  return _msg;
}

// .substrait.Type.UUID uuid = 32 [json_name = "uuid"];
inline bool Type::_internal_has_uuid() const {
  return kind_case() == kUuid;
}
inline bool Type::has_uuid() const {
  return _internal_has_uuid();
}
inline void Type::set_has_uuid() {
  _oneof_case_[0] = kUuid;
}
inline void Type::clear_uuid() {
  if (_internal_has_uuid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.uuid_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_UUID* Type::release_uuid() {
  // @@protoc_insertion_point(field_release:substrait.Type.uuid)
  if (_internal_has_uuid()) {
    clear_has_kind();
      ::substrait::Type_UUID* temp = kind_.uuid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.uuid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_UUID& Type::_internal_uuid() const {
  return _internal_has_uuid()
      ? *kind_.uuid_
      : reinterpret_cast< ::substrait::Type_UUID&>(::substrait::_Type_UUID_default_instance_);
}
inline const ::substrait::Type_UUID& Type::uuid() const {
  // @@protoc_insertion_point(field_get:substrait.Type.uuid)
  return _internal_uuid();
}
inline ::substrait::Type_UUID* Type::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.uuid)
  if (_internal_has_uuid()) {
    clear_has_kind();
    ::substrait::Type_UUID* temp = kind_.uuid_;
    kind_.uuid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_uuid(::substrait::Type_UUID* uuid) {
  clear_kind();
  if (uuid) {
    set_has_uuid();
    kind_.uuid_ = uuid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.uuid)
}
inline ::substrait::Type_UUID* Type::_internal_mutable_uuid() {
  if (!_internal_has_uuid()) {
    clear_kind();
    set_has_uuid();
    kind_.uuid_ = CreateMaybeMessage< ::substrait::Type_UUID >(GetArenaForAllocation());
  }
  return kind_.uuid_;
}
inline ::substrait::Type_UUID* Type::mutable_uuid() {
  ::substrait::Type_UUID* _msg = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:substrait.Type.uuid)
  return _msg;
}

// .substrait.Type.FixedChar fixed_char = 21 [json_name = "fixedChar"];
inline bool Type::_internal_has_fixed_char() const {
  return kind_case() == kFixedChar;
}
inline bool Type::has_fixed_char() const {
  return _internal_has_fixed_char();
}
inline void Type::set_has_fixed_char() {
  _oneof_case_[0] = kFixedChar;
}
inline void Type::clear_fixed_char() {
  if (_internal_has_fixed_char()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.fixed_char_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_FixedChar* Type::release_fixed_char() {
  // @@protoc_insertion_point(field_release:substrait.Type.fixed_char)
  if (_internal_has_fixed_char()) {
    clear_has_kind();
      ::substrait::Type_FixedChar* temp = kind_.fixed_char_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.fixed_char_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_FixedChar& Type::_internal_fixed_char() const {
  return _internal_has_fixed_char()
      ? *kind_.fixed_char_
      : reinterpret_cast< ::substrait::Type_FixedChar&>(::substrait::_Type_FixedChar_default_instance_);
}
inline const ::substrait::Type_FixedChar& Type::fixed_char() const {
  // @@protoc_insertion_point(field_get:substrait.Type.fixed_char)
  return _internal_fixed_char();
}
inline ::substrait::Type_FixedChar* Type::unsafe_arena_release_fixed_char() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.fixed_char)
  if (_internal_has_fixed_char()) {
    clear_has_kind();
    ::substrait::Type_FixedChar* temp = kind_.fixed_char_;
    kind_.fixed_char_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_fixed_char(::substrait::Type_FixedChar* fixed_char) {
  clear_kind();
  if (fixed_char) {
    set_has_fixed_char();
    kind_.fixed_char_ = fixed_char;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.fixed_char)
}
inline ::substrait::Type_FixedChar* Type::_internal_mutable_fixed_char() {
  if (!_internal_has_fixed_char()) {
    clear_kind();
    set_has_fixed_char();
    kind_.fixed_char_ = CreateMaybeMessage< ::substrait::Type_FixedChar >(GetArenaForAllocation());
  }
  return kind_.fixed_char_;
}
inline ::substrait::Type_FixedChar* Type::mutable_fixed_char() {
  ::substrait::Type_FixedChar* _msg = _internal_mutable_fixed_char();
  // @@protoc_insertion_point(field_mutable:substrait.Type.fixed_char)
  return _msg;
}

// .substrait.Type.VarChar varchar = 22 [json_name = "varchar"];
inline bool Type::_internal_has_varchar() const {
  return kind_case() == kVarchar;
}
inline bool Type::has_varchar() const {
  return _internal_has_varchar();
}
inline void Type::set_has_varchar() {
  _oneof_case_[0] = kVarchar;
}
inline void Type::clear_varchar() {
  if (_internal_has_varchar()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.varchar_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_VarChar* Type::release_varchar() {
  // @@protoc_insertion_point(field_release:substrait.Type.varchar)
  if (_internal_has_varchar()) {
    clear_has_kind();
      ::substrait::Type_VarChar* temp = kind_.varchar_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.varchar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_VarChar& Type::_internal_varchar() const {
  return _internal_has_varchar()
      ? *kind_.varchar_
      : reinterpret_cast< ::substrait::Type_VarChar&>(::substrait::_Type_VarChar_default_instance_);
}
inline const ::substrait::Type_VarChar& Type::varchar() const {
  // @@protoc_insertion_point(field_get:substrait.Type.varchar)
  return _internal_varchar();
}
inline ::substrait::Type_VarChar* Type::unsafe_arena_release_varchar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.varchar)
  if (_internal_has_varchar()) {
    clear_has_kind();
    ::substrait::Type_VarChar* temp = kind_.varchar_;
    kind_.varchar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_varchar(::substrait::Type_VarChar* varchar) {
  clear_kind();
  if (varchar) {
    set_has_varchar();
    kind_.varchar_ = varchar;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.varchar)
}
inline ::substrait::Type_VarChar* Type::_internal_mutable_varchar() {
  if (!_internal_has_varchar()) {
    clear_kind();
    set_has_varchar();
    kind_.varchar_ = CreateMaybeMessage< ::substrait::Type_VarChar >(GetArenaForAllocation());
  }
  return kind_.varchar_;
}
inline ::substrait::Type_VarChar* Type::mutable_varchar() {
  ::substrait::Type_VarChar* _msg = _internal_mutable_varchar();
  // @@protoc_insertion_point(field_mutable:substrait.Type.varchar)
  return _msg;
}

// .substrait.Type.FixedBinary fixed_binary = 23 [json_name = "fixedBinary"];
inline bool Type::_internal_has_fixed_binary() const {
  return kind_case() == kFixedBinary;
}
inline bool Type::has_fixed_binary() const {
  return _internal_has_fixed_binary();
}
inline void Type::set_has_fixed_binary() {
  _oneof_case_[0] = kFixedBinary;
}
inline void Type::clear_fixed_binary() {
  if (_internal_has_fixed_binary()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.fixed_binary_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_FixedBinary* Type::release_fixed_binary() {
  // @@protoc_insertion_point(field_release:substrait.Type.fixed_binary)
  if (_internal_has_fixed_binary()) {
    clear_has_kind();
      ::substrait::Type_FixedBinary* temp = kind_.fixed_binary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.fixed_binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_FixedBinary& Type::_internal_fixed_binary() const {
  return _internal_has_fixed_binary()
      ? *kind_.fixed_binary_
      : reinterpret_cast< ::substrait::Type_FixedBinary&>(::substrait::_Type_FixedBinary_default_instance_);
}
inline const ::substrait::Type_FixedBinary& Type::fixed_binary() const {
  // @@protoc_insertion_point(field_get:substrait.Type.fixed_binary)
  return _internal_fixed_binary();
}
inline ::substrait::Type_FixedBinary* Type::unsafe_arena_release_fixed_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.fixed_binary)
  if (_internal_has_fixed_binary()) {
    clear_has_kind();
    ::substrait::Type_FixedBinary* temp = kind_.fixed_binary_;
    kind_.fixed_binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_fixed_binary(::substrait::Type_FixedBinary* fixed_binary) {
  clear_kind();
  if (fixed_binary) {
    set_has_fixed_binary();
    kind_.fixed_binary_ = fixed_binary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.fixed_binary)
}
inline ::substrait::Type_FixedBinary* Type::_internal_mutable_fixed_binary() {
  if (!_internal_has_fixed_binary()) {
    clear_kind();
    set_has_fixed_binary();
    kind_.fixed_binary_ = CreateMaybeMessage< ::substrait::Type_FixedBinary >(GetArenaForAllocation());
  }
  return kind_.fixed_binary_;
}
inline ::substrait::Type_FixedBinary* Type::mutable_fixed_binary() {
  ::substrait::Type_FixedBinary* _msg = _internal_mutable_fixed_binary();
  // @@protoc_insertion_point(field_mutable:substrait.Type.fixed_binary)
  return _msg;
}

// .substrait.Type.Decimal decimal = 24 [json_name = "decimal"];
inline bool Type::_internal_has_decimal() const {
  return kind_case() == kDecimal;
}
inline bool Type::has_decimal() const {
  return _internal_has_decimal();
}
inline void Type::set_has_decimal() {
  _oneof_case_[0] = kDecimal;
}
inline void Type::clear_decimal() {
  if (_internal_has_decimal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.decimal_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_Decimal* Type::release_decimal() {
  // @@protoc_insertion_point(field_release:substrait.Type.decimal)
  if (_internal_has_decimal()) {
    clear_has_kind();
      ::substrait::Type_Decimal* temp = kind_.decimal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.decimal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Decimal& Type::_internal_decimal() const {
  return _internal_has_decimal()
      ? *kind_.decimal_
      : reinterpret_cast< ::substrait::Type_Decimal&>(::substrait::_Type_Decimal_default_instance_);
}
inline const ::substrait::Type_Decimal& Type::decimal() const {
  // @@protoc_insertion_point(field_get:substrait.Type.decimal)
  return _internal_decimal();
}
inline ::substrait::Type_Decimal* Type::unsafe_arena_release_decimal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.decimal)
  if (_internal_has_decimal()) {
    clear_has_kind();
    ::substrait::Type_Decimal* temp = kind_.decimal_;
    kind_.decimal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_decimal(::substrait::Type_Decimal* decimal) {
  clear_kind();
  if (decimal) {
    set_has_decimal();
    kind_.decimal_ = decimal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.decimal)
}
inline ::substrait::Type_Decimal* Type::_internal_mutable_decimal() {
  if (!_internal_has_decimal()) {
    clear_kind();
    set_has_decimal();
    kind_.decimal_ = CreateMaybeMessage< ::substrait::Type_Decimal >(GetArenaForAllocation());
  }
  return kind_.decimal_;
}
inline ::substrait::Type_Decimal* Type::mutable_decimal() {
  ::substrait::Type_Decimal* _msg = _internal_mutable_decimal();
  // @@protoc_insertion_point(field_mutable:substrait.Type.decimal)
  return _msg;
}

// .substrait.Type.Struct struct = 25 [json_name = "struct"];
inline bool Type::_internal_has_struct_() const {
  return kind_case() == kStruct;
}
inline bool Type::has_struct_() const {
  return _internal_has_struct_();
}
inline void Type::set_has_struct_() {
  _oneof_case_[0] = kStruct;
}
inline void Type::clear_struct_() {
  if (_internal_has_struct_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.struct__;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_Struct* Type::release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.Type.struct)
  if (_internal_has_struct_()) {
    clear_has_kind();
      ::substrait::Type_Struct* temp = kind_.struct__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Struct& Type::_internal_struct_() const {
  return _internal_has_struct_()
      ? *kind_.struct__
      : reinterpret_cast< ::substrait::Type_Struct&>(::substrait::_Type_Struct_default_instance_);
}
inline const ::substrait::Type_Struct& Type::struct_() const {
  // @@protoc_insertion_point(field_get:substrait.Type.struct)
  return _internal_struct_();
}
inline ::substrait::Type_Struct* Type::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.struct)
  if (_internal_has_struct_()) {
    clear_has_kind();
    ::substrait::Type_Struct* temp = kind_.struct__;
    kind_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_struct_(::substrait::Type_Struct* struct_) {
  clear_kind();
  if (struct_) {
    set_has_struct_();
    kind_.struct__ = struct_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.struct)
}
inline ::substrait::Type_Struct* Type::_internal_mutable_struct_() {
  if (!_internal_has_struct_()) {
    clear_kind();
    set_has_struct_();
    kind_.struct__ = CreateMaybeMessage< ::substrait::Type_Struct >(GetArenaForAllocation());
  }
  return kind_.struct__;
}
inline ::substrait::Type_Struct* Type::mutable_struct_() {
  ::substrait::Type_Struct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:substrait.Type.struct)
  return _msg;
}

// .substrait.Type.List list = 27 [json_name = "list"];
inline bool Type::_internal_has_list() const {
  return kind_case() == kList;
}
inline bool Type::has_list() const {
  return _internal_has_list();
}
inline void Type::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void Type::clear_list() {
  if (_internal_has_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.list_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_List* Type::release_list() {
  // @@protoc_insertion_point(field_release:substrait.Type.list)
  if (_internal_has_list()) {
    clear_has_kind();
      ::substrait::Type_List* temp = kind_.list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_List& Type::_internal_list() const {
  return _internal_has_list()
      ? *kind_.list_
      : reinterpret_cast< ::substrait::Type_List&>(::substrait::_Type_List_default_instance_);
}
inline const ::substrait::Type_List& Type::list() const {
  // @@protoc_insertion_point(field_get:substrait.Type.list)
  return _internal_list();
}
inline ::substrait::Type_List* Type::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.list)
  if (_internal_has_list()) {
    clear_has_kind();
    ::substrait::Type_List* temp = kind_.list_;
    kind_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_list(::substrait::Type_List* list) {
  clear_kind();
  if (list) {
    set_has_list();
    kind_.list_ = list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.list)
}
inline ::substrait::Type_List* Type::_internal_mutable_list() {
  if (!_internal_has_list()) {
    clear_kind();
    set_has_list();
    kind_.list_ = CreateMaybeMessage< ::substrait::Type_List >(GetArenaForAllocation());
  }
  return kind_.list_;
}
inline ::substrait::Type_List* Type::mutable_list() {
  ::substrait::Type_List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:substrait.Type.list)
  return _msg;
}

// .substrait.Type.Map map = 28 [json_name = "map"];
inline bool Type::_internal_has_map() const {
  return kind_case() == kMap;
}
inline bool Type::has_map() const {
  return _internal_has_map();
}
inline void Type::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void Type::clear_map() {
  if (_internal_has_map()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.map_;
    }
    clear_has_kind();
  }
}
inline ::substrait::Type_Map* Type::release_map() {
  // @@protoc_insertion_point(field_release:substrait.Type.map)
  if (_internal_has_map()) {
    clear_has_kind();
      ::substrait::Type_Map* temp = kind_.map_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Map& Type::_internal_map() const {
  return _internal_has_map()
      ? *kind_.map_
      : reinterpret_cast< ::substrait::Type_Map&>(::substrait::_Type_Map_default_instance_);
}
inline const ::substrait::Type_Map& Type::map() const {
  // @@protoc_insertion_point(field_get:substrait.Type.map)
  return _internal_map();
}
inline ::substrait::Type_Map* Type::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Type.map)
  if (_internal_has_map()) {
    clear_has_kind();
    ::substrait::Type_Map* temp = kind_.map_;
    kind_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_map(::substrait::Type_Map* map) {
  clear_kind();
  if (map) {
    set_has_map();
    kind_.map_ = map;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Type.map)
}
inline ::substrait::Type_Map* Type::_internal_mutable_map() {
  if (!_internal_has_map()) {
    clear_kind();
    set_has_map();
    kind_.map_ = CreateMaybeMessage< ::substrait::Type_Map >(GetArenaForAllocation());
  }
  return kind_.map_;
}
inline ::substrait::Type_Map* Type::mutable_map() {
  ::substrait::Type_Map* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:substrait.Type.map)
  return _msg;
}

// uint32 user_defined_type_reference = 31 [json_name = "userDefinedTypeReference"];
inline bool Type::_internal_has_user_defined_type_reference() const {
  return kind_case() == kUserDefinedTypeReference;
}
inline bool Type::has_user_defined_type_reference() const {
  return _internal_has_user_defined_type_reference();
}
inline void Type::set_has_user_defined_type_reference() {
  _oneof_case_[0] = kUserDefinedTypeReference;
}
inline void Type::clear_user_defined_type_reference() {
  if (_internal_has_user_defined_type_reference()) {
    kind_.user_defined_type_reference_ = 0u;
    clear_has_kind();
  }
}
inline uint32_t Type::_internal_user_defined_type_reference() const {
  if (_internal_has_user_defined_type_reference()) {
    return kind_.user_defined_type_reference_;
  }
  return 0u;
}
inline void Type::_internal_set_user_defined_type_reference(uint32_t value) {
  if (!_internal_has_user_defined_type_reference()) {
    clear_kind();
    set_has_user_defined_type_reference();
  }
  kind_.user_defined_type_reference_ = value;
}
inline uint32_t Type::user_defined_type_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Type.user_defined_type_reference)
  return _internal_user_defined_type_reference();
}
inline void Type::set_user_defined_type_reference(uint32_t value) {
  _internal_set_user_defined_type_reference(value);
  // @@protoc_insertion_point(field_set:substrait.Type.user_defined_type_reference)
}

inline bool Type::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Type::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline Type::KindCase Type::kind_case() const {
  return Type::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NamedStruct

// repeated string names = 1 [json_name = "names"];
inline int NamedStruct::_internal_names_size() const {
  return names_.size();
}
inline int NamedStruct::names_size() const {
  return _internal_names_size();
}
inline void NamedStruct::clear_names() {
  names_.Clear();
}
inline std::string* NamedStruct::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:substrait.NamedStruct.names)
  return _s;
}
inline const std::string& NamedStruct::_internal_names(int index) const {
  return names_.Get(index);
}
inline const std::string& NamedStruct::names(int index) const {
  // @@protoc_insertion_point(field_get:substrait.NamedStruct.names)
  return _internal_names(index);
}
inline std::string* NamedStruct::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.NamedStruct.names)
  return names_.Mutable(index);
}
inline void NamedStruct::set_names(int index, const std::string& value) {
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:substrait.NamedStruct.names)
}
inline void NamedStruct::set_names(int index, std::string&& value) {
  names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:substrait.NamedStruct.names)
}
inline void NamedStruct::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:substrait.NamedStruct.names)
}
inline void NamedStruct::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:substrait.NamedStruct.names)
}
inline std::string* NamedStruct::_internal_add_names() {
  return names_.Add();
}
inline void NamedStruct::add_names(const std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:substrait.NamedStruct.names)
}
inline void NamedStruct::add_names(std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:substrait.NamedStruct.names)
}
inline void NamedStruct::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:substrait.NamedStruct.names)
}
inline void NamedStruct::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:substrait.NamedStruct.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NamedStruct::names() const {
  // @@protoc_insertion_point(field_list:substrait.NamedStruct.names)
  return names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NamedStruct::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:substrait.NamedStruct.names)
  return &names_;
}

// .substrait.Type.Struct struct = 2 [json_name = "struct"];
inline bool NamedStruct::_internal_has_struct_() const {
  return this != internal_default_instance() && struct__ != nullptr;
}
inline bool NamedStruct::has_struct_() const {
  return _internal_has_struct_();
}
inline void NamedStruct::clear_struct_() {
  if (GetArenaForAllocation() == nullptr && struct__ != nullptr) {
    delete struct__;
  }
  struct__ = nullptr;
}
inline const ::substrait::Type_Struct& NamedStruct::_internal_struct_() const {
  const ::substrait::Type_Struct* p = struct__;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type_Struct&>(
      ::substrait::_Type_Struct_default_instance_);
}
inline const ::substrait::Type_Struct& NamedStruct::struct_() const {
  // @@protoc_insertion_point(field_get:substrait.NamedStruct.struct)
  return _internal_struct_();
}
inline void NamedStruct::unsafe_arena_set_allocated_struct_(
    ::substrait::Type_Struct* struct_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(struct__);
  }
  struct__ = struct_;
  if (struct_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.NamedStruct.struct)
}
inline ::substrait::Type_Struct* NamedStruct::release_struct_() {
  
  ::substrait::Type_Struct* temp = struct__;
  struct__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::substrait::Type_Struct* NamedStruct::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.NamedStruct.struct)
  
  ::substrait::Type_Struct* temp = struct__;
  struct__ = nullptr;
  return temp;
}
inline ::substrait::Type_Struct* NamedStruct::_internal_mutable_struct_() {
  
  if (struct__ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::Type_Struct>(GetArenaForAllocation());
    struct__ = p;
  }
  return struct__;
}
inline ::substrait::Type_Struct* NamedStruct::mutable_struct_() {
  ::substrait::Type_Struct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:substrait.NamedStruct.struct)
  return _msg;
}
inline void NamedStruct::set_allocated_struct_(::substrait::Type_Struct* struct_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete struct__;
  }
  if (struct_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::substrait::Type_Struct>::GetOwningArena(struct_);
    if (message_arena != submessage_arena) {
      struct_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, struct_, submessage_arena);
    }
    
  } else {
    
  }
  struct__ = struct_;
  // @@protoc_insertion_point(field_set_allocated:substrait.NamedStruct.struct)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace substrait

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::substrait::Type_Nullability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::Type_Nullability>() {
  return ::substrait::Type_Nullability_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_substrait_2ftype_2eproto
