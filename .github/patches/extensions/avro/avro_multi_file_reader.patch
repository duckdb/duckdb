diff --git a/.clang-format b/.clang-format
new file mode 100644
index 0000000..77d3fbb
--- /dev/null
+++ b/.clang-format
@@ -0,0 +1,33 @@
+---
+BasedOnStyle: LLVM
+SortIncludes: false
+TabWidth: 4
+IndentWidth: 4
+ColumnLimit: 120
+AllowShortFunctionsOnASingleLine: false
+---
+UseTab: ForIndentation
+DerivePointerAlignment: false
+PointerAlignment: Right
+AlignConsecutiveMacros: true
+AlignTrailingComments: true
+AllowAllArgumentsOnNextLine: true
+AllowAllConstructorInitializersOnNextLine: true
+AllowAllParametersOfDeclarationOnNextLine: true
+AlignAfterOpenBracket: Align
+SpaceBeforeCpp11BracedList: true
+SpaceBeforeCtorInitializerColon: true
+SpaceBeforeInheritanceColon: true
+SpacesInAngles: false
+SpacesInCStyleCastParentheses: false
+SpacesInConditionalStatement: false
+AllowShortLambdasOnASingleLine: Inline
+AllowShortLoopsOnASingleLine: false
+AlwaysBreakTemplateDeclarations: Yes
+IncludeBlocks: Regroup
+Language: Cpp
+AccessModifierOffset: -4
+---
+Language: Java
+SpaceAfterCStyleCast: true
+---
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 61d64b6..ab64998 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -3,7 +3,11 @@ cmake_minimum_required(VERSION 3.10)
 # Set extension name here
 set(TARGET_NAME avro)
 
-find_path(AVRO_INCLUDE_DIR NAMES avro.h PATHS "${_VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/include" PATH_SUFFIXES avro REQUIRED)
+find_path(
+  AVRO_INCLUDE_DIR
+  NAMES avro.h
+  PATHS "${_VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/include"
+  PATH_SUFFIXES avro REQUIRED)
 
 if(MSVC) # endless screaming
   find_library(AVRO_LIBRARY avro.lib REQUIRED)
@@ -34,13 +38,19 @@ set(LOADABLE_EXTENSION_NAME ${TARGET_NAME}_loadable_extension)
 project(${TARGET_NAME})
 include_directories(src/include)
 
-set(EXTENSION_SOURCES src/avro_extension.cpp)
+set(
+	EXTENSION_SOURCES
+	src/avro_extension.cpp
+	src/avro_reader.cpp
+	src/avro_multi_file_info.cpp
+)
 
 build_static_extension(${TARGET_NAME} ${EXTENSION_SOURCES})
 build_loadable_extension(${TARGET_NAME} " " ${EXTENSION_SOURCES})
 
 target_include_directories(${EXTENSION_NAME} PRIVATE ${AVRO_INCLUDE_DIR})
-target_include_directories(${LOADABLE_EXTENSION_NAME} PRIVATE ${AVRO_INCLUDE_DIR})
+target_include_directories(${LOADABLE_EXTENSION_NAME}
+                           PRIVATE ${AVRO_INCLUDE_DIR})
 target_link_libraries(${EXTENSION_NAME} ${ALL_AVRO_LIBRARIES})
 target_link_libraries(${LOADABLE_EXTENSION_NAME} ${ALL_AVRO_LIBRARIES})
 
diff --git a/src/avro_extension.cpp b/src/avro_extension.cpp
index 65cd5f9..875149b 100644
--- a/src/avro_extension.cpp
+++ b/src/avro_extension.cpp
@@ -5,742 +5,37 @@
 #include "duckdb.hpp"
 #include "duckdb/common/exception.hpp"
 #include "duckdb/common/string_util.hpp"
-#include "duckdb/common/multi_file_reader.hpp"
 #include "duckdb/function/scalar_function.hpp"
-#include "duckdb/main/extension_util.hpp"
-#include "duckdb/parser/parsed_data/create_scalar_function_info.hpp"
 
-#include "utf8proc_wrapper.hpp"
+#include "duckdb/main/extension_util.hpp"
+#include "include/avro_reader.hpp"
+#include "duckdb/common/multi_file/multi_file_reader.hpp"
+#include "avro_multi_file_info.hpp"
+#include "duckdb/common/multi_file/multi_file_function.hpp"
 
 #include <avro.h>
 
 namespace duckdb {
 
-struct AvroType {
-  AvroType() : duckdb_type(LogicalType::INVALID) {}
-
-  AvroType(avro_type_t avro_type_p, LogicalType duckdb_type_p,
-           child_list_t<AvroType> children_p = {},
-           unordered_map<idx_t, optional_idx> union_child_map_p = {})
-      : duckdb_type(duckdb_type_p), avro_type(avro_type_p),
-        children(children_p), union_child_map(union_child_map_p) {}
-  LogicalType duckdb_type;
-  avro_type_t avro_type;
-  child_list_t<AvroType> children;
-  unordered_map<idx_t, optional_idx> union_child_map;
-
-  bool operator==(const AvroType &other) const {
-    return duckdb_type == other.duckdb_type && avro_type == other.avro_type &&
-           children == other.children &&
-           union_child_map == other.union_child_map;
-  }
-};
-
-struct AvroOptions {
-
-  explicit AvroOptions() {}
-
-  void Serialize(Serializer &serializer) const {
-    file_options.Serialize(serializer);
-  }
-  static AvroOptions Deserialize(Deserializer &deserializer) {
-    AvroOptions options;
-    options.file_options = MultiFileReaderOptions::Deserialize(deserializer);
-    return options;
-  }
-
-  MultiFileReaderOptions file_options;
-};
-
-struct AvroReader;
-
-// we use special transformation rules for unions with null:
-// 1) the null does not become a union entry and
-// 2) if there is only one entry the union disappears and is repaced by its
-// child
-static LogicalType TransformAvroType(const AvroType &avro_type) {
-  child_list_t<LogicalType> children;
-
-  switch (avro_type.duckdb_type.id()) {
-  case LogicalTypeId::STRUCT: {
-    for (auto &child : avro_type.children) {
-      children.push_back(std::pair<std::string, LogicalType>(
-          child.first, TransformAvroType(child.second)));
-    }
-    D_ASSERT(!children.empty());
-    return LogicalType::STRUCT(std::move(children));
-  }
-  case LogicalTypeId::LIST:
-    return LogicalType::LIST(TransformAvroType(avro_type.children[0].second));
-  case LogicalTypeId::MAP: {
-    child_list_t<LogicalType> children;
-    children.push_back(
-        std::pair<std::string, LogicalType>("key", LogicalType::VARCHAR));
-    children.push_back(std::pair<std::string, LogicalType>(
-        "value", TransformAvroType(avro_type.children[0].second)));
-    return LogicalType::MAP(LogicalType::STRUCT(std::move(children)));
-  }
-  case LogicalTypeId::UNION: {
-    for (auto &child : avro_type.children) {
-      if (child.second.duckdb_type == LogicalTypeId::SQLNULL) {
-        continue;
-      }
-      children.push_back(std::pair<std::string, LogicalType>(
-          child.first, TransformAvroType(child.second)));
-    }
-    if (children.size() == 1) {
-      return children[0].second;
-    }
-    if (children.empty()) {
-      throw InvalidInputException("Empty union type");
-    }
-    return LogicalType::UNION(std::move(children));
-  }
-  default:
-    return LogicalType(avro_type.duckdb_type);
-  }
-}
-
-static AvroType TransformSchema(avro_schema_t &avro_schema,
-                                unordered_set<string> parent_schema_names) {
-  switch (avro_typeof(avro_schema)) {
-  case AVRO_NULL:
-    return AvroType(AVRO_NULL, LogicalType::SQLNULL);
-  case AVRO_BOOLEAN:
-    return AvroType(AVRO_BOOLEAN, LogicalType::BOOLEAN);
-  case AVRO_INT32:
-    return AvroType(AVRO_INT32, LogicalType::INTEGER);
-  case AVRO_INT64:
-    return AvroType(AVRO_INT64, LogicalType::BIGINT);
-  case AVRO_FLOAT:
-    return AvroType(AVRO_FLOAT, LogicalType::FLOAT);
-  case AVRO_DOUBLE:
-    return AvroType(AVRO_DOUBLE, LogicalType::DOUBLE);
-  case AVRO_BYTES:
-    return AvroType(AVRO_BYTES, LogicalType::BLOB);
-  case AVRO_STRING:
-    return AvroType(AVRO_STRING, LogicalType::VARCHAR);
-  case AVRO_UNION: {
-    auto num_children = avro_schema_union_size(avro_schema);
-    child_list_t<AvroType> union_children;
-    idx_t non_null_child_idx = 0;
-    unordered_map<idx_t, optional_idx> union_child_map;
-    for (idx_t child_idx = 0; child_idx < num_children; child_idx++) {
-      auto child_schema = avro_schema_union_branch(avro_schema, child_idx);
-      auto child_type = TransformSchema(child_schema, parent_schema_names);
-      union_children.push_back(std::pair<std::string, AvroType>(
-          StringUtil::Format("u%llu", child_idx), std::move(child_type)));
-      if (child_type.duckdb_type.id() != LogicalTypeId::SQLNULL) {
-        union_child_map[child_idx] = non_null_child_idx++;
-      }
-    }
-    return AvroType(AVRO_UNION, LogicalTypeId::UNION, std::move(union_children),
-                    union_child_map);
-  }
-  case AVRO_RECORD: {
-    auto schema_name = string(avro_schema_name(avro_schema));
-    if (parent_schema_names.find(schema_name) != parent_schema_names.end()) {
-      throw InvalidInputException("Recursive Avro types not supported: %s",
-                                  schema_name);
-    }
-    parent_schema_names.insert(schema_name);
-
-    auto num_children = avro_schema_record_size(avro_schema);
-    if (num_children == 0) {
-      // this we just ignore but we need a marker so we don't get our offsets
-      // wrong
-      return AvroType(AVRO_RECORD, LogicalTypeId::SQLNULL);
-    }
-    child_list_t<AvroType> struct_children;
-    for (idx_t child_idx = 0; child_idx < num_children; child_idx++) {
-      auto child_schema =
-          avro_schema_record_field_get_by_index(avro_schema, child_idx);
-      auto child_type = TransformSchema(child_schema, parent_schema_names);
-      auto child_name = avro_schema_record_field_name(avro_schema, child_idx);
-      if (!child_name || strlen(child_name) == 0) {
-        throw InvalidInputException("Empty avro field name");
-      }
-
-      struct_children.push_back(
-          std::pair<std::string, AvroType>(child_name, std::move(child_type)));
-    }
-
-    return AvroType(AVRO_RECORD, LogicalTypeId::STRUCT,
-                    std::move(struct_children));
-  }
-  case AVRO_ENUM: {
-    auto size = avro_schema_enum_number_of_symbols(avro_schema);
-    Vector levels(LogicalType::VARCHAR, size);
-    auto levels_data = FlatVector::GetData<string_t>(levels);
-    for (idx_t enum_idx = 0; enum_idx < size; enum_idx++) {
-      levels_data[enum_idx] = StringVector::AddString(
-          levels, avro_schema_enum_get(avro_schema, enum_idx));
-    }
-    levels.Verify(size);
-    return AvroType(AVRO_ENUM, LogicalType::ENUM(levels, size));
-  }
-  case AVRO_FIXED: {
-    return AvroType(AVRO_FIXED, LogicalType::BLOB);
-  }
-  case AVRO_ARRAY: {
-    auto child_schema = avro_schema_array_items(avro_schema);
-    auto child_type = TransformSchema(child_schema, parent_schema_names);
-    child_list_t<AvroType> list_children;
-    list_children.push_back(
-        std::pair<std::string, AvroType>("list_entry", std::move(child_type)));
-    return AvroType(AVRO_ARRAY, LogicalTypeId::LIST, std::move(list_children));
-  }
-  case AVRO_MAP: {
-    auto child_schema = avro_schema_map_values(avro_schema);
-    auto child_type = TransformSchema(child_schema, parent_schema_names);
-    child_list_t<AvroType> map_children;
-    map_children.push_back(
-        std::pair<std::string, AvroType>("list_entry", std::move(child_type)));
-    return AvroType(AVRO_MAP, LogicalTypeId::MAP, std::move(map_children));
-  }
-  case AVRO_LINK: {
-    auto target = avro_schema_link_target(avro_schema);
-    return TransformSchema(target, parent_schema_names);
-  }
-  default:
-    throw NotImplementedException("Unknown Avro Type %s",
-                                  avro_schema_type_name(avro_schema));
-  }
-}
-
-static void TransformValue(avro_value *avro_val, const AvroType &avro_type,
-                           Vector &target, idx_t out_idx) {
-
-  switch (avro_type.duckdb_type.id()) {
-  case LogicalTypeId::SQLNULL: {
-    FlatVector::SetNull(target, out_idx, true);
-    break;
-  }
-  case LogicalTypeId::BOOLEAN: {
-    int bool_val;
-    if (avro_value_get_boolean(avro_val, &bool_val)) {
-      throw InvalidInputException(avro_strerror());
-    }
-    FlatVector::GetData<uint8_t>(target)[out_idx] = bool_val != 0;
-    break;
-  }
-  case LogicalTypeId::INTEGER: {
-    if (avro_value_get_int(avro_val,
-                           &FlatVector::GetData<int32_t>(target)[out_idx])) {
-      throw InvalidInputException(avro_strerror());
-    }
-    break;
-  }
-  case LogicalTypeId::BIGINT: {
-    if (avro_value_get_long(avro_val,
-                            &FlatVector::GetData<int64_t>(target)[out_idx])) {
-      throw InvalidInputException(avro_strerror());
-    }
-    break;
-  }
-  case LogicalTypeId::FLOAT: {
-    if (avro_value_get_float(avro_val,
-                             &FlatVector::GetData<float>(target)[out_idx])) {
-      throw InvalidInputException(avro_strerror());
-    }
-    break;
-  }
-  case LogicalTypeId::DOUBLE: {
-    if (avro_value_get_double(avro_val,
-                              &FlatVector::GetData<double>(target)[out_idx])) {
-      throw InvalidInputException(avro_strerror());
-    }
-    break;
-  }
-  case LogicalTypeId::BLOB:
-    switch (avro_type.avro_type) {
-    case AVRO_FIXED: {
-      size_t fixed_size;
-      const void *fixed_data;
-      if (avro_value_get_fixed(avro_val, &fixed_data, &fixed_size)) {
-        throw InvalidInputException(avro_strerror());
-      }
-      FlatVector::GetData<string_t>(target)[out_idx] =
-          StringVector::AddStringOrBlob(target, const_char_ptr_cast(fixed_data),
-                                        fixed_size);
-      break;
-    }
-    case AVRO_BYTES: {
-      avro_wrapped_buffer blob_buf = AVRO_WRAPPED_BUFFER_EMPTY;
-      if (avro_value_grab_bytes(avro_val, &blob_buf)) {
-        throw InvalidInputException(avro_strerror());
-      }
-      FlatVector::GetData<string_t>(target)[out_idx] =
-          StringVector::AddStringOrBlob(
-              target, const_char_ptr_cast(blob_buf.buf), blob_buf.size);
-      blob_buf.free(&blob_buf);
-      break;
-    }
-    default:
-      throw NotImplementedException("Unknown Avro blob type %s");
-    }
-    break;
-
-  case LogicalTypeId::VARCHAR: {
-    avro_wrapped_buffer str_buf = AVRO_WRAPPED_BUFFER_EMPTY;
-    if (avro_value_grab_string(avro_val, &str_buf)) {
-      throw InvalidInputException(avro_strerror());
-    }
-    // avro strings are null-terminated
-    D_ASSERT(const_char_ptr_cast(str_buf.buf)[str_buf.size - 1] == '\0');
-    if (Utf8Proc::Analyze(const_char_ptr_cast(str_buf.buf), str_buf.size - 1) ==
-        UnicodeType::INVALID) {
-      throw InvalidInputException("Avro file contains invalid unicode string");
-    }
-    FlatVector::GetData<string_t>(target)[out_idx] = StringVector::AddString(
-        target, const_char_ptr_cast(str_buf.buf), str_buf.size - 1);
-    str_buf.free(&str_buf);
-    break;
-  }
-  case LogicalTypeId::STRUCT: {
-    size_t child_count;
-    if (avro_value_get_size(avro_val, &child_count)) {
-      throw InvalidInputException(avro_strerror());
-    }
-    D_ASSERT(child_count == StructType::GetChildCount(target.GetType()));
-    D_ASSERT(child_count == avro_type.children.size());
-
-    for (idx_t child_idx = 0; child_idx < child_count; child_idx++) {
-      avro_value child_value;
-      if (avro_value_get_by_index(avro_val, child_idx, &child_value, nullptr)) {
-        throw InvalidInputException(avro_strerror());
-      }
-      TransformValue(&child_value, avro_type.children[child_idx].second,
-                     *StructVector::GetEntries(target)[child_idx], out_idx);
-    }
-    break;
-  }
-
-  case LogicalTypeId::MAP: {
-    size_t entry_count;
-    if (avro_value_get_size(avro_val, &entry_count)) {
-      throw InvalidInputException(avro_strerror());
-    }
-
-    D_ASSERT(avro_type.children.size() == 1);
-    auto child_offset = ListVector::GetListSize(target);
-    ListVector::Reserve(target, child_offset + entry_count);
-
-    auto &key_vector = MapVector::GetKeys(target);
-    auto &value_vector = MapVector::GetValues(target);
-
-    D_ASSERT(key_vector.GetType().id() == LogicalTypeId::VARCHAR);
-    auto string_ptr = FlatVector::GetData<string_t>(key_vector);
-    for (idx_t entry_idx = 0; entry_idx < entry_count; entry_idx++) {
-      avro_value child_value;
-      const char *map_key;
-      if (avro_value_get_by_index(avro_val, entry_idx, &child_value,
-                                  &map_key)) {
-        throw InvalidInputException(avro_strerror());
-      }
-      D_ASSERT(map_key);
-      string_ptr[child_offset + entry_idx] =
-          StringVector::AddString(key_vector, map_key);
-      TransformValue(&child_value, avro_type.children[0].second, value_vector,
-                     child_offset + entry_idx);
-    }
-    auto list_vector = ListVector::GetData(target);
-
-    list_vector[out_idx].offset = child_offset;
-    list_vector[out_idx].length = entry_count;
-    ListVector::SetListSize(target, child_offset + entry_count);
-    break;
-  }
-
-  case LogicalTypeId::UNION: {
-    int discriminant;
-    avro_value union_value;
-    if (avro_value_get_discriminant(avro_val, &discriminant) ||
-        avro_value_get_current_branch(avro_val, &union_value)) {
-      throw InvalidInputException(avro_strerror());
-    }
-    if (discriminant >= avro_type.children.size()) {
-      throw InvalidInputException("Invalid union tag");
-    }
-
-    if (avro_type.children[discriminant].second.duckdb_type ==
-        LogicalTypeId::SQLNULL) {
-      FlatVector::SetNull(target, out_idx, true);
-      break;
-    }
-
-    if (target.GetType().id() == LogicalTypeId::UNION) {
-      auto duckdb_child_index =
-          avro_type.union_child_map.at(discriminant).GetIndex();
-      auto &tags = UnionVector::GetTags(target);
-      FlatVector::GetData<union_tag_t>(tags)[out_idx] = duckdb_child_index;
-      auto &union_vector = UnionVector::GetMember(target, duckdb_child_index);
-
-      // orrrrrrrrrrrrr
-      for (idx_t child_idx = 1;
-           child_idx < StructVector::GetEntries(target).size(); child_idx++) {
-        if (child_idx !=
-            duckdb_child_index +
-                1) { // duckdb child index is bigger because of the tag
-          FlatVector::SetNull(*StructVector::GetEntries(target)[child_idx],
-                              out_idx, true);
-        }
-      }
-
-      TransformValue(&union_value, avro_type.children[discriminant].second,
-                     union_vector, out_idx);
-    } else { // directly recurse, we have dissolved the union
-      TransformValue(&union_value, avro_type.children[discriminant].second,
-                     target, out_idx);
-    }
-
-    break;
-  }
-  case LogicalTypeId::ENUM: {
-    auto enum_type = EnumType::GetPhysicalType(target.GetType());
-    int enum_val;
-
-    if (avro_value_get_enum(avro_val, &enum_val)) {
-      throw InvalidInputException(avro_strerror());
-    }
-    if (enum_val < 0 || enum_val >= EnumType::GetSize(target.GetType())) {
-      throw InvalidInputException("Enum value out of range");
-    }
-
-    switch (enum_type) {
-    case PhysicalType::UINT8:
-      FlatVector::GetData<uint8_t>(target)[out_idx] = enum_val;
-      break;
-    case PhysicalType::UINT16:
-      FlatVector::GetData<uint16_t>(target)[out_idx] = enum_val;
-      break;
-    case PhysicalType::UINT32:
-      FlatVector::GetData<uint32_t>(target)[out_idx] = enum_val;
-      break;
-    default:
-      throw InternalException("Unsupported Enum Internal Type");
-    }
-    break;
-  }
-
-  case LogicalTypeId::LIST: {
-    size_t list_len;
-
-    if (avro_value_get_size(avro_val, &list_len)) {
-      throw InvalidInputException(avro_strerror());
-    }
-    auto &child_vector = ListVector::GetEntry(target);
-    auto child_offset = ListVector::GetListSize(target);
-    ListVector::Reserve(target, child_offset + list_len);
-
-    for (idx_t child_idx = 0; child_idx < list_len; child_idx++) {
-      avro_value_t child_value;
-      if (avro_value_get_by_index(avro_val, child_idx, &child_value, nullptr)) {
-        throw InvalidInputException(avro_strerror());
-      }
-      TransformValue(&child_value, avro_type.children[0].second, child_vector,
-                     child_offset + child_idx);
-    }
-    auto list_vector_data = ListVector::GetData(target);
-    list_vector_data[out_idx].length = list_len;
-    list_vector_data[out_idx].offset = child_offset;
-    ListVector::SetListSize(target, child_offset + list_len);
-
-    break;
-  }
-
-  default:
-    throw NotImplementedException(avro_type.duckdb_type.ToString());
-  }
-}
-
-// this is just a dummy to make the multi file reader compile
-struct AvroUnionData {
-  AvroUnionData() { throw InternalException("union_by_name not supported"); }
-  string file_name;
-  vector<string> names;
-  vector<LogicalType> types;
-  AvroOptions options;
-  unique_ptr<AvroReader> reader;
-
-  const string &GetFileName() { return file_name; }
-};
-
-struct AvroReader {
-
-  using UNION_READER_DATA = unique_ptr<AvroUnionData>;
-
-  static unique_ptr<AvroUnionData>
-  StoreUnionReader(unique_ptr<AvroReader> scan_p, idx_t file_idx) {
-    throw InternalException("union_by_name not supported");
-  }
-
-  ~AvroReader() {
-    avro_value_decref(&value);
-    avro_file_reader_close(reader);
-  }
-
-  void Read(DataChunk &output, const vector<ColumnIndex> &column_indexes) {
-    idx_t out_idx = 0;
-
-    while (avro_file_reader_read_value(reader, &value) == 0) {
-      TransformValue(&value, avro_type, *read_vec, out_idx++);
-      if (out_idx == STANDARD_VECTOR_SIZE) {
-        break;
-      }
-    }
-    // pull up root struct into output chunk
-    if (duckdb_type.id() == LogicalTypeId::STRUCT) {
-      for (idx_t col_idx = 0; col_idx < column_indexes.size(); col_idx++) {
-        if (column_indexes[col_idx].GetPrimaryIndex() >= columns.size()) {
-          continue; // to be filled in later
-        }
-        output.data[col_idx].Reference(
-            *StructVector::GetEntries(*read_vec)[column_indexes[col_idx].GetPrimaryIndex()]);
-      }
-    } else {
-      output.data[column_indexes[0].GetPrimaryIndex()].Reference(*read_vec);
-    }
-    output.SetCardinality(out_idx);
-  }
-
-  const string &GetFileName() { return filename; }
-
-  const vector<MultiFileReaderColumnDefinition> &GetColumns() {
-    return columns;
-  }
-
-  AvroReader(ClientContext &context, const string filename_p,
-             const AvroOptions &options_p) {
-    filename = filename_p;
-    options = options_p;
-    auto &fs = FileSystem::GetFileSystem(context);
-    if (!fs.FileExists(filename)) {
-      throw InvalidInputException("Avro file %s not found", filename);
-    }
-
-    auto file = fs.OpenFile(filename, FileOpenFlags::FILE_FLAGS_READ);
-    allocated_data = Allocator::Get(context).Allocate(file->GetFileSize());
-    auto n_read = 0ll;
-    while (n_read < file->GetFileSize()) {
-	auto len = file->Read(allocated_data.get() + n_read, allocated_data.GetSize() - n_read);
-	n_read += len;
-        if (len == 0) {
-            throw InvalidInputException("Could not read from file '%s'", filename);
-        }
-    }
-    D_ASSERT(n_read == file->GetFileSize());
-    auto avro_reader = avro_reader_memory(
-        const_char_ptr_cast(allocated_data.get()), allocated_data.GetSize());
-
-    if (avro_reader_reader(avro_reader, &reader)) {
-      throw InvalidInputException(avro_strerror());
-    }
-
-    auto avro_schema = avro_file_reader_get_writer_schema(reader);
-    avro_type = TransformSchema(avro_schema, {});
-    duckdb_type = TransformAvroType(avro_type);
-    read_vec = make_uniq<Vector>(duckdb_type);
-
-    auto interface = avro_generic_class_from_schema(avro_schema);
-    avro_generic_value_new(interface, &value);
-    avro_value_iface_decref(interface);
-
-    // special handling for root structs, we pull up the entries
-    if (duckdb_type.id() == LogicalTypeId::STRUCT) {
-      for (idx_t child_idx = 0;
-           child_idx < StructType::GetChildCount(duckdb_type); child_idx++) {
-        columns.push_back(MultiFileReaderColumnDefinition(StructType::GetChildName(duckdb_type, child_idx), StructType::GetChildType(duckdb_type, child_idx)));
-      }
-    } else {
-      auto schema_name = avro_schema_name(avro_schema);
-      columns.push_back(MultiFileReaderColumnDefinition(schema_name ? schema_name : "avro_schema", duckdb_type));
-    }
-    avro_schema_decref(avro_schema);
-  }
-
-  avro_file_reader_t reader;
-  avro_value_t value;
-  unique_ptr<Vector> read_vec;
-
-  AllocatedData allocated_data;
-  AvroType avro_type;
-  LogicalType duckdb_type;
-  vector<MultiFileReaderColumnDefinition> columns;
-  AvroOptions options;
-  MultiFileReaderData reader_data;
-  string filename;
-};
-
-struct AvroBindData : FunctionData {
-  shared_ptr<MultiFileList> file_list;
-  unique_ptr<MultiFileReader> multi_file_reader;
-  MultiFileReaderBindData reader_bind;
-  vector<string> names;
-  vector<LogicalType> types;
-  AvroOptions avro_options;
-  shared_ptr<AvroReader> initial_reader;
-
-  // unused
-  vector<unique_ptr<AvroUnionData>> union_readers;
-
-  void Initialize(shared_ptr<AvroReader> reader) {
-    initial_reader = std::move(reader);
-    avro_options = initial_reader->options;
-  }
-
-  void Initialize(ClientContext &, unique_ptr<AvroUnionData> &union_data) {
-    throw InternalException("union_by_name not supported");
-  }
-
-  void Initialize(ClientContext &, shared_ptr<AvroReader> reader) {
-    Initialize(reader);
-  }
-
-  bool Equals(const FunctionData &other_p) const override {
-    throw NotImplementedException("AvroBindData::Equals");
-  }
-
-  unique_ptr<FunctionData> Copy() const override {
-    throw NotImplementedException("AvroBindData::Copy");
-  }
-};
-
-static unique_ptr<FunctionData>
-AvroBindFunction(ClientContext &context, TableFunctionBindInput &input,
-                 vector<LogicalType> &return_types, vector<string> &names) {
-
-  auto &filename = input.inputs[0];
-  auto result = make_uniq<AvroBindData>();
-  result->multi_file_reader = MultiFileReader::Create(input.table_function);
-
-  for (auto &kv : input.named_parameters) {
-    if (kv.second.IsNull()) {
-      throw BinderException("Cannot use NULL as function argument");
-    }
-    auto loption = StringUtil::Lower(kv.first);
-    if (result->multi_file_reader->ParseOption(
-            kv.first, kv.second, result->avro_options.file_options, context)) {
-      continue;
-    }
-    throw InternalException("Unrecognized option %s", loption.c_str());
-  }
-
-  if (result->avro_options.file_options.union_by_name) {
-    throw NotImplementedException("union_by_name for Avro reads");
-  }
-  result->file_list =
-      result->multi_file_reader->CreateFileList(context, filename);
-
-  result->reader_bind = result->multi_file_reader->BindReader<AvroReader>(
-      context, result->types, result->names, *result->file_list, *result,
-      result->avro_options);
-
-  return_types = result->types;
-  names = result->names;
-
-  return result;
-}
-
-struct AvroGlobalState : GlobalTableFunctionState {
-  mutex lock;
-
-  MultiFileListScanData scan_data;
-  shared_ptr<AvroReader> reader;
-
-  vector<ColumnIndex> column_indexes;
-  optional_ptr<TableFilterSet> filters;
-};
-
-static bool AvroNextFile(ClientContext &context, const AvroBindData &bind_data,
-                         AvroGlobalState &global_state,
-                         shared_ptr<AvroReader> initial_reader) {
-  unique_lock<mutex> parallel_lock(global_state.lock);
-
-  string file;
-  if (!bind_data.file_list->Scan(global_state.scan_data, file)) {
-    return false;
-  }
-
-  // re-use initial reader for first file, no need to parse metadata again
-  if (initial_reader) {
-    D_ASSERT(file == initial_reader->filename);
-    global_state.reader = initial_reader;
-  } else {
-    auto new_reader =
-        make_shared_ptr<AvroReader>(context, file, bind_data.avro_options);
-    if (new_reader->duckdb_type != global_state.reader->duckdb_type) {
-      throw InvalidInputException(
-          "Schema of file %s (%s) differs from first file %s (%s)",
-          new_reader->filename, new_reader->duckdb_type.ToString(),
-          global_state.reader->filename,
-          global_state.reader->duckdb_type.ToString());
-    }
-    global_state.reader = std::move(new_reader);
-  }
-
-  auto columns = MultiFileReaderColumnDefinition::ColumnsFromNamesAndTypes(bind_data.names, bind_data.types);
-  bind_data.multi_file_reader->InitializeReader(
-      *global_state.reader, bind_data.avro_options.file_options, bind_data.reader_bind,
-      columns, global_state.column_indexes, global_state.filters, file, context, nullptr);
-  return true;
+static void LoadInternal(DatabaseInstance &instance) {
+	// Register a scalar function
+	auto table_function = MultiFileFunction<AvroMultiFileInfo>("read_avro");
+	table_function.projection_pushdown = true;
+	ExtensionUtil::RegisterFunction(instance, MultiFileReader::CreateFunctionSet(table_function));
 }
 
-static void AvroTableFunction(ClientContext &context, TableFunctionInput &data,
-                              DataChunk &output) {
-  auto &bind_data = data.bind_data->Cast<AvroBindData>();
-  auto &global_state = data.global_state->Cast<AvroGlobalState>();
-  do {
-    output.Reset();
-    global_state.reader->Read(output, global_state.column_indexes);
-    bind_data.multi_file_reader->FinalizeChunk(context, bind_data.reader_bind,
-                                               global_state.reader->reader_data,
-                                               output, nullptr);
-    if (output.size() > 0) {
-      return;
-    }
-    if (!AvroNextFile(context, bind_data, global_state, nullptr)) {
-      return;
-    }
-  } while (true);
+void AvroExtension::Load(DuckDB &db) {
+	LoadInternal(*db.instance);
 }
-
-unique_ptr<GlobalTableFunctionState>
-AvroGlobalInit(ClientContext &context, TableFunctionInitInput &input) {
-  auto global_state_result = make_uniq<AvroGlobalState>();
-  auto &global_state = *global_state_result;
-  auto &bind_data = input.bind_data->Cast<AvroBindData>();
-
-  global_state.column_indexes = input.column_indexes;
-  global_state.filters = input.filters;
-
-  bind_data.file_list->InitializeScan(global_state.scan_data);
-  if (!AvroNextFile(context, bind_data, global_state,
-                    bind_data.initial_reader)) {
-    throw InternalException("Cannot scan files");
-  }
-  return global_state_result;
+std::string AvroExtension::Name() {
+	return "avro";
 }
 
-static void LoadInternal(DatabaseInstance &instance) {
-  // Register a scalar function
-  auto table_function =
-      TableFunction("read_avro", {LogicalType::VARCHAR}, AvroTableFunction,
-                    AvroBindFunction, AvroGlobalInit);
-  table_function.projection_pushdown = true;
-  MultiFileReader::AddParameters(table_function);
-  ExtensionUtil::RegisterFunction(
-      instance, MultiFileReader::CreateFunctionSet(table_function));
-}
-
-void AvroExtension::Load(DuckDB &db) { LoadInternal(*db.instance); }
-std::string AvroExtension::Name() { return "avro"; }
-
 std::string AvroExtension::Version() const {
 #ifdef EXT_VERSION_AVRO
-  return EXT_VERSION_AVRO;
+	return EXT_VERSION_AVRO;
 #else
-  return "";
+	return "";
 #endif
 }
 
@@ -749,12 +44,12 @@ std::string AvroExtension::Version() const {
 extern "C" {
 
 DUCKDB_EXTENSION_API void avro_init(duckdb::DatabaseInstance &db) {
-  duckdb::DuckDB db_wrapper(db);
-  db_wrapper.LoadExtension<duckdb::AvroExtension>();
+	duckdb::DuckDB db_wrapper(db);
+	db_wrapper.LoadExtension<duckdb::AvroExtension>();
 }
 
 DUCKDB_EXTENSION_API const char *avro_version() {
-  return duckdb::DuckDB::LibraryVersion();
+	return duckdb::DuckDB::LibraryVersion();
 }
 }
 
diff --git a/src/avro_multi_file_info.cpp b/src/avro_multi_file_info.cpp
new file mode 100644
index 0000000..b8b358c
--- /dev/null
+++ b/src/avro_multi_file_info.cpp
@@ -0,0 +1,170 @@
+#include "avro_multi_file_info.hpp"
+#include "avro_reader.hpp"
+
+namespace duckdb {
+
+unique_ptr<BaseFileReaderOptions> AvroMultiFileInfo::InitializeOptions(ClientContext &context,
+                                                                       optional_ptr<TableFunctionInfo> info) {
+	return make_uniq<AvroFileReaderOptions>();
+}
+
+bool AvroMultiFileInfo::ParseCopyOption(ClientContext &context, const string &key, const vector<Value> &values,
+                                        BaseFileReaderOptions &options_p, vector<string> &expected_names,
+                                        vector<LogicalType> &expected_types) {
+	// We currently do not have any options for the scanner, so we always return false
+	return false;
+}
+
+bool AvroMultiFileInfo::ParseOption(ClientContext &context, const string &key, const Value &val,
+                                    MultiFileOptions &file_options, BaseFileReaderOptions &options) {
+	// We currently do not have any options for the scanner, so we always return false
+	return false;
+}
+
+void AvroMultiFileInfo::FinalizeCopyBind(ClientContext &context, BaseFileReaderOptions &options_p,
+                                         const vector<string> &expected_names,
+                                         const vector<LogicalType> &expected_types) {
+}
+
+struct AvroMultiFileData final : public TableFunctionData {
+public:
+	AvroMultiFileData() = default;
+};
+
+unique_ptr<TableFunctionData> AvroMultiFileInfo::InitializeBindData(MultiFileBindData &multi_file_data,
+                                                                    unique_ptr<BaseFileReaderOptions> options_p) {
+	return make_uniq<AvroMultiFileData>();
+}
+
+void AvroMultiFileInfo::BindReader(ClientContext &context, vector<LogicalType> &return_types, vector<string> &names,
+                                   MultiFileBindData &bind_data) {
+	AvroFileReaderOptions options;
+	if (bind_data.file_options.union_by_name) {
+		throw NotImplementedException("'union_by_name' not implemented for Avro reader yet");
+	}
+	bind_data.reader_bind = bind_data.multi_file_reader->BindReader<AvroMultiFileInfo>( context, return_types, names, *bind_data.file_list, bind_data, options, bind_data.file_options);
+	D_ASSERT(names.size() == return_types.size());
+}
+
+void AvroMultiFileInfo::FinalizeBindData(MultiFileBindData &multi_file_data) {
+}
+
+void AvroMultiFileInfo::GetBindInfo(const TableFunctionData &bind_data, BindInfo &info) {
+}
+
+optional_idx AvroMultiFileInfo::MaxThreads(const MultiFileBindData &bind_data_p,
+                                           const MultiFileGlobalState &global_state, FileExpandResult expand_result) {
+	if (expand_result == FileExpandResult::MULTIPLE_FILES) {
+		// always launch max threads if we are reading multiple files
+		return {};
+	}
+	// Otherwise, only one thread
+	return 1;
+}
+
+struct AvroFileGlobalState : public GlobalTableFunctionState {
+public:
+	AvroFileGlobalState() = default;
+	~AvroFileGlobalState() override = default;
+public:
+	//! TODO: this should contain the state of the current file being scanned
+	//! so we can parallelize over a single file
+	set<idx_t> files;
+};
+
+unique_ptr<GlobalTableFunctionState> AvroMultiFileInfo::InitializeGlobalState(ClientContext &context,
+                                                                              MultiFileBindData &bind_data,
+                                                                              MultiFileGlobalState &global_state) {
+	return make_uniq<AvroFileGlobalState>();
+}
+
+//! The Avro Local File State, basically refers to the Scan of one Avro File
+//! This is done by calling the Avro Scan directly on one file.
+struct AvroFileLocalState : public LocalTableFunctionState {
+public:
+	explicit AvroFileLocalState(ExecutionContext &execution_context) : execution_context(execution_context) {};
+public:
+	shared_ptr<AvroReader> file_scan;
+	ExecutionContext &execution_context;
+};
+
+unique_ptr<LocalTableFunctionState> AvroMultiFileInfo::InitializeLocalState(ExecutionContext &context,
+                                                                            GlobalTableFunctionState &function_state) {
+	return make_uniq<AvroFileLocalState>(context);
+}
+
+shared_ptr<BaseFileReader> AvroMultiFileInfo::CreateReader(ClientContext &context, GlobalTableFunctionState &gstate_p,
+                                                           BaseUnionData &union_data,
+                                                           const MultiFileBindData &bind_data) {
+	throw NotImplementedException("'union_by_name' is not implemented for the Avro reader yet");
+}
+
+shared_ptr<BaseFileReader> AvroMultiFileInfo::CreateReader(ClientContext &context, GlobalTableFunctionState &gstate_p,
+                                                           const OpenFileInfo &file, idx_t file_idx,
+                                                           const MultiFileBindData &bind_data) {
+	return make_shared_ptr<AvroReader>(context, file.path);
+}
+
+shared_ptr<BaseFileReader> AvroMultiFileInfo::CreateReader(ClientContext &context, const OpenFileInfo &file,
+                                                           AvroFileReaderOptions &options,
+                                                           const MultiFileOptions &file_options) {
+	return make_shared_ptr<AvroReader>(context, file.path);
+}
+
+shared_ptr<BaseUnionData> AvroMultiFileInfo::GetUnionData(shared_ptr<BaseFileReader> scan_p, idx_t file_idx) {
+	throw NotImplementedException("'union_by_name' is not implemented");
+}
+
+void AvroMultiFileInfo::FinalizeReader(ClientContext &context, BaseFileReader &reader, GlobalTableFunctionState &) {
+}
+
+bool AvroMultiFileInfo::TryInitializeScan(ClientContext &context, const shared_ptr<BaseFileReader> &reader_p,
+                                          GlobalTableFunctionState &gstate_p, LocalTableFunctionState &lstate_p) {
+	auto &gstate = gstate_p.Cast<AvroFileGlobalState>();
+	auto &lstate = lstate_p.Cast<AvroFileLocalState>();
+	auto &reader = reader_p->Cast<AvroReader>();
+	if (gstate.files.count(reader.file_list_idx.GetIndex())) {
+		// Return false because we don't currently support more than one thread
+		// scanning a file.
+		return false;
+	}
+	gstate.files.insert(reader.file_list_idx.GetIndex());
+	lstate.file_scan = shared_ptr_cast<BaseFileReader, AvroReader>(reader_p);
+	return true;
+}
+
+void AvroMultiFileInfo::Scan(ClientContext &context, BaseFileReader &reader_p, GlobalTableFunctionState &global_state,
+                             LocalTableFunctionState &local_state_p, DataChunk &chunk) {
+	auto &reader = reader_p.Cast<AvroReader>();
+	reader.Read(chunk);
+}
+
+void AvroMultiFileInfo::FinishFile(ClientContext &context, GlobalTableFunctionState &global_state,
+                                   BaseFileReader &reader) {
+	//! FIXME: this is where the state of the current file being read would be reset
+	//! once we support parallelizing over a single file.
+}
+
+void AvroMultiFileInfo::FinishReading(ClientContext &context, GlobalTableFunctionState &global_state,
+                                      LocalTableFunctionState &local_state) {
+}
+
+unique_ptr<NodeStatistics> AvroMultiFileInfo::GetCardinality(const MultiFileBindData &bind_data, idx_t file_count) {
+	//! FIXME: Here is where we might set statistics, for optimizations if we have them
+	return make_uniq<NodeStatistics>();
+}
+
+unique_ptr<BaseStatistics> AvroMultiFileInfo::GetStatistics(ClientContext &context, BaseFileReader &reader,
+                                                            const string &name) {
+	return nullptr;
+}
+
+double AvroMultiFileInfo::GetProgressInFile(ClientContext &context, const BaseFileReader &reader) {
+	//! TODO: interrogate the avro reader to figure out the progress of the memory reader
+	return 0;
+}
+
+void AvroMultiFileInfo::GetVirtualColumns(ClientContext &, MultiFileBindData &, virtual_column_map_t &result) {
+}
+
+} // namespace duckdb
diff --git a/src/avro_reader.cpp b/src/avro_reader.cpp
new file mode 100644
index 0000000..3975633
--- /dev/null
+++ b/src/avro_reader.cpp
@@ -0,0 +1,398 @@
+#include "avro_reader.hpp"
+#include "utf8proc_wrapper.hpp"
+#include "duckdb/common/file_system.hpp"
+#include "duckdb/common/multi_file/multi_file_data.hpp"
+
+namespace duckdb {
+
+static AvroType TransformSchema(avro_schema_t &avro_schema, unordered_set<string> parent_schema_names) {
+	switch (avro_typeof(avro_schema)) {
+	case AVRO_NULL:
+		return AvroType(AVRO_NULL, LogicalType::SQLNULL);
+	case AVRO_BOOLEAN:
+		return AvroType(AVRO_BOOLEAN, LogicalType::BOOLEAN);
+	case AVRO_INT32:
+		return AvroType(AVRO_INT32, LogicalType::INTEGER);
+	case AVRO_INT64:
+		return AvroType(AVRO_INT64, LogicalType::BIGINT);
+	case AVRO_FLOAT:
+		return AvroType(AVRO_FLOAT, LogicalType::FLOAT);
+	case AVRO_DOUBLE:
+		return AvroType(AVRO_DOUBLE, LogicalType::DOUBLE);
+	case AVRO_BYTES:
+		return AvroType(AVRO_BYTES, LogicalType::BLOB);
+	case AVRO_STRING:
+		return AvroType(AVRO_STRING, LogicalType::VARCHAR);
+	case AVRO_UNION: {
+		auto num_children = avro_schema_union_size(avro_schema);
+		child_list_t<AvroType> union_children;
+		idx_t non_null_child_idx = 0;
+		unordered_map<idx_t, optional_idx> union_child_map;
+		for (idx_t child_idx = 0; child_idx < num_children; child_idx++) {
+			auto child_schema = avro_schema_union_branch(avro_schema, child_idx);
+			auto child_type = TransformSchema(child_schema, parent_schema_names);
+			union_children.push_back(
+			    std::pair<std::string, AvroType>(StringUtil::Format("u%llu", child_idx), std::move(child_type)));
+			if (child_type.duckdb_type.id() != LogicalTypeId::SQLNULL) {
+				union_child_map[child_idx] = non_null_child_idx++;
+			}
+		}
+		return AvroType(AVRO_UNION, LogicalTypeId::UNION, std::move(union_children), union_child_map);
+	}
+	case AVRO_RECORD: {
+		auto schema_name = string(avro_schema_name(avro_schema));
+		if (parent_schema_names.find(schema_name) != parent_schema_names.end()) {
+			throw InvalidInputException("Recursive Avro types not supported: %s", schema_name);
+		}
+		parent_schema_names.insert(schema_name);
+
+		auto num_children = avro_schema_record_size(avro_schema);
+		if (num_children == 0) {
+			// this we just ignore but we need a marker so we don't get our offsets
+			// wrong
+			return AvroType(AVRO_RECORD, LogicalTypeId::SQLNULL);
+		}
+		child_list_t<AvroType> struct_children;
+		for (idx_t child_idx = 0; child_idx < num_children; child_idx++) {
+			auto child_schema = avro_schema_record_field_get_by_index(avro_schema, child_idx);
+			auto child_type = TransformSchema(child_schema, parent_schema_names);
+			auto child_name = avro_schema_record_field_name(avro_schema, child_idx);
+			if (!child_name || strlen(child_name) == 0) {
+				throw InvalidInputException("Empty avro field name");
+			}
+
+			struct_children.push_back(std::pair<std::string, AvroType>(child_name, std::move(child_type)));
+		}
+
+		return AvroType(AVRO_RECORD, LogicalTypeId::STRUCT, std::move(struct_children));
+	}
+	case AVRO_ENUM: {
+		auto size = avro_schema_enum_number_of_symbols(avro_schema);
+		Vector levels(LogicalType::VARCHAR, size);
+		auto levels_data = FlatVector::GetData<string_t>(levels);
+		for (idx_t enum_idx = 0; enum_idx < size; enum_idx++) {
+			levels_data[enum_idx] = StringVector::AddString(levels, avro_schema_enum_get(avro_schema, enum_idx));
+		}
+		levels.Verify(size);
+		return AvroType(AVRO_ENUM, LogicalType::ENUM(levels, size));
+	}
+	case AVRO_FIXED: {
+		return AvroType(AVRO_FIXED, LogicalType::BLOB);
+	}
+	case AVRO_ARRAY: {
+		auto child_schema = avro_schema_array_items(avro_schema);
+		auto child_type = TransformSchema(child_schema, parent_schema_names);
+		child_list_t<AvroType> list_children;
+		list_children.push_back(std::pair<std::string, AvroType>("list_entry", std::move(child_type)));
+		return AvroType(AVRO_ARRAY, LogicalTypeId::LIST, std::move(list_children));
+	}
+	case AVRO_MAP: {
+		auto child_schema = avro_schema_map_values(avro_schema);
+		auto child_type = TransformSchema(child_schema, parent_schema_names);
+		child_list_t<AvroType> map_children;
+		map_children.push_back(std::pair<std::string, AvroType>("list_entry", std::move(child_type)));
+		return AvroType(AVRO_MAP, LogicalTypeId::MAP, std::move(map_children));
+	}
+	case AVRO_LINK: {
+		auto target = avro_schema_link_target(avro_schema);
+		return TransformSchema(target, parent_schema_names);
+	}
+	default:
+		throw NotImplementedException("Unknown Avro Type %s", avro_schema_type_name(avro_schema));
+	}
+}
+
+AvroReader::AvroReader(ClientContext &context, string filename_p) : BaseFileReader(std::move(filename_p)) {
+	auto &fs = FileSystem::GetFileSystem(context);
+	if (!fs.FileExists(this->file.path)) {
+		throw InvalidInputException("Avro file %s not found", this->file.path);
+	}
+
+	auto file = fs.OpenFile(this->file.path, FileOpenFlags::FILE_FLAGS_READ);
+	allocated_data = Allocator::Get(context).Allocate(file->GetFileSize());
+	auto n_read = file->Read(allocated_data.get(), allocated_data.GetSize());
+	D_ASSERT(n_read == file->GetFileSize());
+	auto avro_reader = avro_reader_memory(const_char_ptr_cast(allocated_data.get()), allocated_data.GetSize());
+
+	if (avro_reader_reader(avro_reader, &reader)) {
+		throw InvalidInputException(avro_strerror());
+	}
+
+	auto avro_schema = avro_file_reader_get_writer_schema(reader);
+	avro_type = TransformSchema(avro_schema, {});
+	duckdb_type = AvroType::TransformAvroType(avro_type);
+	read_vec = make_uniq<Vector>(duckdb_type);
+
+	auto interface = avro_generic_class_from_schema(avro_schema);
+	avro_generic_value_new(interface, &value);
+	avro_value_iface_decref(interface);
+
+	vector<LogicalType> types;
+	vector<string> names;
+	// special handling for root structs, we pull up the entries
+	if (duckdb_type.id() == LogicalTypeId::STRUCT) {
+		for (idx_t child_idx = 0; child_idx < StructType::GetChildCount(duckdb_type); child_idx++) {
+			names.push_back(StructType::GetChildName(duckdb_type, child_idx));
+			types.push_back(StructType::GetChildType(duckdb_type, child_idx));
+		}
+	} else {
+		auto schema_name = avro_schema_name(avro_schema);
+		names.push_back(schema_name ? schema_name : "avro_schema");
+		types.push_back(duckdb_type);
+	}
+
+	columns = MultiFileColumnDefinition::ColumnsFromNamesAndTypes(names, types);
+	avro_schema_decref(avro_schema);
+}
+
+static void TransformValue(avro_value *avro_val, const AvroType &avro_type, Vector &target, idx_t out_idx) {
+
+	switch (avro_type.duckdb_type.id()) {
+	case LogicalTypeId::SQLNULL: {
+		FlatVector::SetNull(target, out_idx, true);
+		break;
+	}
+	case LogicalTypeId::BOOLEAN: {
+		int bool_val;
+		if (avro_value_get_boolean(avro_val, &bool_val)) {
+			throw InvalidInputException(avro_strerror());
+		}
+		FlatVector::GetData<uint8_t>(target)[out_idx] = bool_val != 0;
+		break;
+	}
+	case LogicalTypeId::INTEGER: {
+		if (avro_value_get_int(avro_val, &FlatVector::GetData<int32_t>(target)[out_idx])) {
+			throw InvalidInputException(avro_strerror());
+		}
+		break;
+	}
+	case LogicalTypeId::BIGINT: {
+		if (avro_value_get_long(avro_val, &FlatVector::GetData<int64_t>(target)[out_idx])) {
+			throw InvalidInputException(avro_strerror());
+		}
+		break;
+	}
+	case LogicalTypeId::FLOAT: {
+		if (avro_value_get_float(avro_val, &FlatVector::GetData<float>(target)[out_idx])) {
+			throw InvalidInputException(avro_strerror());
+		}
+		break;
+	}
+	case LogicalTypeId::DOUBLE: {
+		if (avro_value_get_double(avro_val, &FlatVector::GetData<double>(target)[out_idx])) {
+			throw InvalidInputException(avro_strerror());
+		}
+		break;
+	}
+	case LogicalTypeId::BLOB:
+		switch (avro_type.avro_type) {
+		case AVRO_FIXED: {
+			size_t fixed_size;
+			const void *fixed_data;
+			if (avro_value_get_fixed(avro_val, &fixed_data, &fixed_size)) {
+				throw InvalidInputException(avro_strerror());
+			}
+			FlatVector::GetData<string_t>(target)[out_idx] =
+			    StringVector::AddStringOrBlob(target, const_char_ptr_cast(fixed_data), fixed_size);
+			break;
+		}
+		case AVRO_BYTES: {
+			avro_wrapped_buffer blob_buf = AVRO_WRAPPED_BUFFER_EMPTY;
+			if (avro_value_grab_bytes(avro_val, &blob_buf)) {
+				throw InvalidInputException(avro_strerror());
+			}
+			FlatVector::GetData<string_t>(target)[out_idx] =
+			    StringVector::AddStringOrBlob(target, const_char_ptr_cast(blob_buf.buf), blob_buf.size);
+			blob_buf.free(&blob_buf);
+			break;
+		}
+		default:
+			throw NotImplementedException("Unknown Avro blob type %s");
+		}
+		break;
+
+	case LogicalTypeId::VARCHAR: {
+		avro_wrapped_buffer str_buf = AVRO_WRAPPED_BUFFER_EMPTY;
+		if (avro_value_grab_string(avro_val, &str_buf)) {
+			throw InvalidInputException(avro_strerror());
+		}
+		// avro strings are null-terminated
+		D_ASSERT(const_char_ptr_cast(str_buf.buf)[str_buf.size - 1] == '\0');
+		if (Utf8Proc::Analyze(const_char_ptr_cast(str_buf.buf), str_buf.size - 1) == UnicodeType::INVALID) {
+			throw InvalidInputException("Avro file contains invalid unicode string");
+		}
+		FlatVector::GetData<string_t>(target)[out_idx] =
+		    StringVector::AddString(target, const_char_ptr_cast(str_buf.buf), str_buf.size - 1);
+		str_buf.free(&str_buf);
+		break;
+	}
+	case LogicalTypeId::STRUCT: {
+		size_t child_count;
+		if (avro_value_get_size(avro_val, &child_count)) {
+			throw InvalidInputException(avro_strerror());
+		}
+		D_ASSERT(child_count == StructType::GetChildCount(target.GetType()));
+		D_ASSERT(child_count == avro_type.children.size());
+
+		for (idx_t child_idx = 0; child_idx < child_count; child_idx++) {
+			avro_value child_value;
+			if (avro_value_get_by_index(avro_val, child_idx, &child_value, nullptr)) {
+				throw InvalidInputException(avro_strerror());
+			}
+			TransformValue(&child_value, avro_type.children[child_idx].second,
+			               *StructVector::GetEntries(target)[child_idx], out_idx);
+		}
+		break;
+	}
+
+	case LogicalTypeId::MAP: {
+		size_t entry_count;
+		if (avro_value_get_size(avro_val, &entry_count)) {
+			throw InvalidInputException(avro_strerror());
+		}
+
+		D_ASSERT(avro_type.children.size() == 1);
+		auto child_offset = ListVector::GetListSize(target);
+		ListVector::Reserve(target, child_offset + entry_count);
+
+		auto &key_vector = MapVector::GetKeys(target);
+		auto &value_vector = MapVector::GetValues(target);
+
+		D_ASSERT(key_vector.GetType().id() == LogicalTypeId::VARCHAR);
+		auto string_ptr = FlatVector::GetData<string_t>(key_vector);
+		for (idx_t entry_idx = 0; entry_idx < entry_count; entry_idx++) {
+			avro_value child_value;
+			const char *map_key;
+			if (avro_value_get_by_index(avro_val, entry_idx, &child_value, &map_key)) {
+				throw InvalidInputException(avro_strerror());
+			}
+			D_ASSERT(map_key);
+			string_ptr[child_offset + entry_idx] = StringVector::AddString(key_vector, map_key);
+			TransformValue(&child_value, avro_type.children[0].second, value_vector, child_offset + entry_idx);
+		}
+		auto list_vector = ListVector::GetData(target);
+
+		list_vector[out_idx].offset = child_offset;
+		list_vector[out_idx].length = entry_count;
+		ListVector::SetListSize(target, child_offset + entry_count);
+		break;
+	}
+
+	case LogicalTypeId::UNION: {
+		int discriminant;
+		avro_value union_value;
+		if (avro_value_get_discriminant(avro_val, &discriminant) ||
+		    avro_value_get_current_branch(avro_val, &union_value)) {
+			throw InvalidInputException(avro_strerror());
+		}
+		if (discriminant >= avro_type.children.size()) {
+			throw InvalidInputException("Invalid union tag");
+		}
+
+		if (avro_type.children[discriminant].second.duckdb_type == LogicalTypeId::SQLNULL) {
+			FlatVector::SetNull(target, out_idx, true);
+			break;
+		}
+
+		if (target.GetType().id() == LogicalTypeId::UNION) {
+			auto duckdb_child_index = avro_type.union_child_map.at(discriminant).GetIndex();
+			auto &tags = UnionVector::GetTags(target);
+			FlatVector::GetData<union_tag_t>(tags)[out_idx] = duckdb_child_index;
+			auto &union_vector = UnionVector::GetMember(target, duckdb_child_index);
+
+			// orrrrrrrrrrrrr
+			for (idx_t child_idx = 1; child_idx < StructVector::GetEntries(target).size(); child_idx++) {
+				if (child_idx != duckdb_child_index + 1) { // duckdb child index is bigger because of the tag
+					FlatVector::SetNull(*StructVector::GetEntries(target)[child_idx], out_idx, true);
+				}
+			}
+
+			TransformValue(&union_value, avro_type.children[discriminant].second, union_vector, out_idx);
+		} else { // directly recurse, we have dissolved the union
+			TransformValue(&union_value, avro_type.children[discriminant].second, target, out_idx);
+		}
+
+		break;
+	}
+	case LogicalTypeId::ENUM: {
+		auto enum_type = EnumType::GetPhysicalType(target.GetType());
+		int enum_val;
+
+		if (avro_value_get_enum(avro_val, &enum_val)) {
+			throw InvalidInputException(avro_strerror());
+		}
+		if (enum_val < 0 || enum_val >= EnumType::GetSize(target.GetType())) {
+			throw InvalidInputException("Enum value out of range");
+		}
+
+		switch (enum_type) {
+		case PhysicalType::UINT8:
+			FlatVector::GetData<uint8_t>(target)[out_idx] = enum_val;
+			break;
+		case PhysicalType::UINT16:
+			FlatVector::GetData<uint16_t>(target)[out_idx] = enum_val;
+			break;
+		case PhysicalType::UINT32:
+			FlatVector::GetData<uint32_t>(target)[out_idx] = enum_val;
+			break;
+		default:
+			throw InternalException("Unsupported Enum Internal Type");
+		}
+		break;
+	}
+
+	case LogicalTypeId::LIST: {
+		size_t list_len;
+
+		if (avro_value_get_size(avro_val, &list_len)) {
+			throw InvalidInputException(avro_strerror());
+		}
+		auto &child_vector = ListVector::GetEntry(target);
+		auto child_offset = ListVector::GetListSize(target);
+		ListVector::Reserve(target, child_offset + list_len);
+
+		for (idx_t child_idx = 0; child_idx < list_len; child_idx++) {
+			avro_value_t child_value;
+			if (avro_value_get_by_index(avro_val, child_idx, &child_value, nullptr)) {
+				throw InvalidInputException(avro_strerror());
+			}
+			TransformValue(&child_value, avro_type.children[0].second, child_vector, child_offset + child_idx);
+		}
+		auto list_vector_data = ListVector::GetData(target);
+		list_vector_data[out_idx].length = list_len;
+		list_vector_data[out_idx].offset = child_offset;
+		ListVector::SetListSize(target, child_offset + list_len);
+
+		break;
+	}
+
+	default:
+		throw NotImplementedException(avro_type.duckdb_type.ToString());
+	}
+}
+
+void AvroReader::Read(DataChunk &output) {
+	idx_t out_idx = 0;
+
+	while (avro_file_reader_read_value(reader, &value) == 0) {
+		TransformValue(&value, avro_type, *read_vec, out_idx++);
+		if (out_idx == STANDARD_VECTOR_SIZE) {
+			break;
+		}
+	}
+	// pull up root struct into output chunk
+	if (duckdb_type.id() == LogicalTypeId::STRUCT) {
+		for (idx_t col_idx = 0; col_idx < column_indexes.size(); col_idx++) {
+			if (column_indexes[col_idx].GetPrimaryIndex() >= columns.size()) {
+				continue; // to be filled in later
+			}
+			output.data[col_idx].Reference(
+			    *StructVector::GetEntries(*read_vec)[column_indexes[col_idx].GetPrimaryIndex()]);
+		}
+	} else {
+		output.data[column_indexes[0].GetPrimaryIndex()].Reference(*read_vec);
+	}
+	output.SetCardinality(out_idx);
+}
+
+} // namespace duckdb
diff --git a/src/include/avro_extension.hpp b/src/include/avro_extension.hpp
index 807a8ad..941d511 100644
--- a/src/include/avro_extension.hpp
+++ b/src/include/avro_extension.hpp
@@ -6,9 +6,9 @@ namespace duckdb {
 
 class AvroExtension : public Extension {
 public:
-  void Load(DuckDB &db) override;
-  std::string Name() override;
-  std::string Version() const override;
+	void Load(DuckDB &db) override;
+	std::string Name() override;
+	std::string Version() const override;
 };
 
 } // namespace duckdb
diff --git a/src/include/avro_multi_file_info.hpp b/src/include/avro_multi_file_info.hpp
new file mode 100644
index 0000000..4ae1d21
--- /dev/null
+++ b/src/include/avro_multi_file_info.hpp
@@ -0,0 +1,88 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// avro_multi_file_info.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "duckdb/common/multi_file/multi_file_function.hpp"
+
+namespace duckdb {
+
+//! We might have avro specific options one day
+class AvroFileReaderOptions : public BaseFileReaderOptions {};
+
+struct AvroMultiFileInfo {
+	static unique_ptr<BaseFileReaderOptions> InitializeOptions(ClientContext &context,
+	                                                           optional_ptr<TableFunctionInfo> info);
+
+	static bool ParseCopyOption(ClientContext &context, const string &key, const vector<Value> &values,
+	                            BaseFileReaderOptions &options, vector<string> &expected_names,
+	                            vector<LogicalType> &expected_types);
+
+	static bool ParseOption(ClientContext &context, const string &key, const Value &val, MultiFileOptions &file_options,
+	                        BaseFileReaderOptions &options);
+
+	static void FinalizeCopyBind(ClientContext &context, BaseFileReaderOptions &options,
+	                             const vector<string> &expected_names, const vector<LogicalType> &expected_types);
+
+	static unique_ptr<TableFunctionData> InitializeBindData(MultiFileBindData &multi_file_data,
+	                                                        unique_ptr<BaseFileReaderOptions> options);
+
+	//! This is where the actual binding must happen, so in this function we either:
+	//! 1. union_by_name = False. We set the schema/name depending on the first file
+	//! 2. union_by_name = True.
+	static void BindReader(ClientContext &context, vector<LogicalType> &return_types, vector<string> &names,
+	                       MultiFileBindData &bind_data);
+
+	static void FinalizeBindData(MultiFileBindData &multi_file_data);
+
+	static void GetBindInfo(const TableFunctionData &bind_data, BindInfo &info);
+
+	static optional_idx MaxThreads(const MultiFileBindData &bind_data_p, const MultiFileGlobalState &global_state,
+	                               FileExpandResult expand_result);
+
+	static unique_ptr<GlobalTableFunctionState>
+	InitializeGlobalState(ClientContext &context, MultiFileBindData &bind_data, MultiFileGlobalState &global_state);
+
+	static unique_ptr<LocalTableFunctionState> InitializeLocalState(ExecutionContext &context,
+	                                                                GlobalTableFunctionState &function_state);
+
+	static shared_ptr<BaseFileReader> CreateReader(ClientContext &context, GlobalTableFunctionState &gstate,
+	                                               BaseUnionData &union_data, const MultiFileBindData &bind_data_p);
+
+	static shared_ptr<BaseFileReader> CreateReader(ClientContext &context, GlobalTableFunctionState &gstate,
+	                                               const OpenFileInfo &file, idx_t file_idx,
+	                                               const MultiFileBindData &bind_data);
+
+	static shared_ptr<BaseFileReader> CreateReader(ClientContext &context, const OpenFileInfo &file,
+	                                               AvroFileReaderOptions &options, const MultiFileOptions &file_options);
+
+	static shared_ptr<BaseUnionData> GetUnionData(shared_ptr<BaseFileReader> scan_p, idx_t file_idx);
+
+	static void FinalizeReader(ClientContext &context, BaseFileReader &reader, GlobalTableFunctionState &);
+
+	static bool TryInitializeScan(ClientContext &context, const shared_ptr<BaseFileReader> &reader,
+	                              GlobalTableFunctionState &gstate, LocalTableFunctionState &lstate);
+
+	static void Scan(ClientContext &context, BaseFileReader &reader, GlobalTableFunctionState &global_state,
+	                 LocalTableFunctionState &local_state, DataChunk &chunk);
+
+	static void FinishFile(ClientContext &context, GlobalTableFunctionState &global_state, BaseFileReader &reader);
+
+	static void FinishReading(ClientContext &context, GlobalTableFunctionState &global_state,
+	                          LocalTableFunctionState &local_state);
+
+	static unique_ptr<NodeStatistics> GetCardinality(const MultiFileBindData &bind_data, idx_t file_count);
+
+	static unique_ptr<BaseStatistics> GetStatistics(ClientContext &context, BaseFileReader &reader, const string &name);
+
+	static double GetProgressInFile(ClientContext &context, const BaseFileReader &reader);
+
+	static void GetVirtualColumns(ClientContext &context, MultiFileBindData &bind_data, virtual_column_map_t &result);
+};
+
+} // namespace duckdb
diff --git a/src/include/avro_reader.hpp b/src/include/avro_reader.hpp
new file mode 100644
index 0000000..5d731c4
--- /dev/null
+++ b/src/include/avro_reader.hpp
@@ -0,0 +1,56 @@
+#pragma once
+
+#include "duckdb/common/helper.hpp"
+#include "avro_type.hpp"
+#include "duckdb/common/multi_file/base_file_reader.hpp"
+
+namespace duckdb {
+
+struct AvroReader;
+
+// this is just a dummy to make the multi file reader compile
+struct AvroUnionData {
+public:
+	AvroUnionData() {
+		throw InternalException("union_by_name not supported");
+	}
+
+public:
+	const string &GetFileName() {
+		return file_name;
+	}
+
+public:
+	string file_name;
+	vector<string> names;
+	vector<LogicalType> types;
+	// AvroOptions options;
+	unique_ptr<AvroReader> reader;
+};
+
+struct AvroReader : public BaseFileReader {
+public:
+	AvroReader(ClientContext &context, const string filename_p);
+
+	~AvroReader() {
+		avro_value_decref(&value);
+		avro_file_reader_close(reader);
+	}
+public:
+	void Read(DataChunk &output);
+
+	string GetReaderType() const override {
+		return "Avro";
+	}
+
+public:
+	avro_file_reader_t reader;
+	avro_value_t value;
+	unique_ptr<Vector> read_vec;
+
+	AllocatedData allocated_data;
+	AvroType avro_type;
+	LogicalType duckdb_type;
+};
+
+} // namespace duckdb
diff --git a/src/include/avro_type.hpp b/src/include/avro_type.hpp
new file mode 100644
index 0000000..3145946
--- /dev/null
+++ b/src/include/avro_type.hpp
@@ -0,0 +1,76 @@
+#pragma once
+
+#include "duckdb/common/types.hpp"
+#include <avro.h>
+#include "duckdb/common/optional_idx.hpp"
+
+namespace duckdb {
+
+struct AvroType {
+public:
+	AvroType() : duckdb_type(LogicalType::INVALID) {
+	}
+	AvroType(avro_type_t avro_type_p, LogicalType duckdb_type_p, child_list_t<AvroType> children_p = {},
+	         unordered_map<idx_t, optional_idx> union_child_map_p = {})
+	    : duckdb_type(duckdb_type_p), avro_type(avro_type_p), children(children_p), union_child_map(union_child_map_p) {
+	}
+
+public:
+	bool operator==(const AvroType &other) const {
+		return duckdb_type == other.duckdb_type && avro_type == other.avro_type && children == other.children &&
+		       union_child_map == other.union_child_map;
+	}
+
+public:
+	// we use special transformation rules for unions with null:
+	// 1) the null does not become a union entry and
+	// 2) if there is only one entry the union disappears and is repaced by its
+	// child
+	static LogicalType TransformAvroType(const AvroType &avro_type) {
+		child_list_t<LogicalType> children;
+
+		switch (avro_type.duckdb_type.id()) {
+		case LogicalTypeId::STRUCT: {
+			for (auto &child : avro_type.children) {
+				children.push_back(std::pair<std::string, LogicalType>(child.first, TransformAvroType(child.second)));
+			}
+			D_ASSERT(!children.empty());
+			return LogicalType::STRUCT(std::move(children));
+		}
+		case LogicalTypeId::LIST:
+			return LogicalType::LIST(TransformAvroType(avro_type.children[0].second));
+		case LogicalTypeId::MAP: {
+			child_list_t<LogicalType> children;
+			children.push_back(std::pair<std::string, LogicalType>("key", LogicalType::VARCHAR));
+			children.push_back(
+			    std::pair<std::string, LogicalType>("value", TransformAvroType(avro_type.children[0].second)));
+			return LogicalType::MAP(LogicalType::STRUCT(std::move(children)));
+		}
+		case LogicalTypeId::UNION: {
+			for (auto &child : avro_type.children) {
+				if (child.second.duckdb_type == LogicalTypeId::SQLNULL) {
+					continue;
+				}
+				children.push_back(std::pair<std::string, LogicalType>(child.first, TransformAvroType(child.second)));
+			}
+			if (children.size() == 1) {
+				return children[0].second;
+			}
+			if (children.empty()) {
+				throw InvalidInputException("Empty union type");
+			}
+			return LogicalType::UNION(std::move(children));
+		}
+		default:
+			return LogicalType(avro_type.duckdb_type);
+		}
+	}
+
+public:
+	LogicalType duckdb_type;
+	avro_type_t avro_type;
+	child_list_t<AvroType> children;
+	unordered_map<idx_t, optional_idx> union_child_map;
+};
+
+} // namespace duckdb
diff --git a/test/sql/avro.test b/test/sql/avro.test
index b3fd052..afc001d 100644
--- a/test/sql/avro.test
+++ b/test/sql/avro.test
@@ -102,7 +102,7 @@ favorite_color	VARCHAR
 statement error
 from read_avro(['test/userdata1.avro', 'test/users.avro'])
 ----
-Schema of file
+schema mismatch in glob
 
 # example from readme
 query III
@@ -334,7 +334,7 @@ avro_schema	UNION(u0 STRUCT("data" BLOB), u1 STRUCT(fatal BOOLEAN, "name" VARCHA
 query I
 FROM read_avro('test/query_small.avro')
 ----
-{'data': 100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A100,200,300,400\x0A300,400,500,600\x0A}
+{'data': '100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A100,200,300,400\\x0A300,400,500,600\\x0A'}
 {'bytesScanned': 1024, 'totalBytes': 1024}
 {'totalBytes': 1024}
 
@@ -415,14 +415,21 @@ comments	VARCHAR
 statement error
 FROM read_avro('test/union-name-*.avro', filename=true, union_by_name=true) order by one;
 ----
-Not implemented Error: union_by_name for Avro reads
+Not implemented Error: 'union_by_name' not implemented for Avro reader yet
 
 
-# need to fail on differing types
-statement error
-FROM read_avro('test/union-name-*.avro', filename=true) order by one;
-----
-Schema of file
+# TODO: add test where schemas can't be combined
+
+# files with different schemas that can be safely combined are okay
+query III
+select * exclude filename FROM read_avro('test/union-name-*.avro', filename=true) order by all;
+----
+10	2.0	s30
+11	2.1	s31
+12	2.2	s32
+13	2.3	s33
+14	2.4	s34
+15	2.5	s35
 
 
 
