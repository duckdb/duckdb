diff --git a/src/create_secret_functions.cpp b/src/create_secret_functions.cpp
index be306433fb6..aa5c9b28f22 100644
--- a/src/create_secret_functions.cpp
+++ b/src/create_secret_functions.cpp
@@ -80,6 +80,12 @@ unique_ptr<BaseSecret> CreateS3SecretFunctions::CreateSecretFunctionInternal(Cli
 				                            lower_name, named_param.second.type().ToString());
 			}
 			secret->secret_map["use_ssl"] = Value::BOOLEAN(named_param.second.GetValue<bool>());
+		} else if (lower_name == "verify_ssl") {
+			if (named_param.second.type() != LogicalType::BOOLEAN) {
+				throw InvalidInputException("Invalid type past to secret option: '%s', found '%s', expected: 'BOOLEAN'",
+				                            lower_name, named_param.second.type().ToString());
+			}
+			secret->secret_map["verify_ssl"] = Value::BOOLEAN(named_param.second.GetValue<bool>());
 		} else if (lower_name == "kms_key_id") {
 			secret->secret_map["kms_key_id"] = named_param.second.ToString();
 		} else if (lower_name == "url_compatibility_mode") {
@@ -201,6 +207,7 @@ void CreateS3SecretFunctions::SetBaseNamedParams(CreateSecretFunction &function,
 	function.named_parameters["endpoint"] = LogicalType::VARCHAR;
 	function.named_parameters["url_style"] = LogicalType::VARCHAR;
 	function.named_parameters["use_ssl"] = LogicalType::BOOLEAN;
+	function.named_parameters["verify_ssl"] = LogicalType::BOOLEAN;
 	function.named_parameters["kms_key_id"] = LogicalType::VARCHAR;
 	function.named_parameters["url_compatibility_mode"] = LogicalType::BOOLEAN;
 	function.named_parameters["requester_pays"] = LogicalType::BOOLEAN;
diff --git a/src/httpfs.cpp b/src/httpfs.cpp
index b7252fde1a3..0e4e6399b70 100644
--- a/src/httpfs.cpp
+++ b/src/httpfs.cpp
@@ -97,6 +97,7 @@ unique_ptr<HTTPParams> HTTPFSUtil::InitializeParameters(optional_ptr<FileOpener>
 		result->http_proxy = host;
 		result->http_proxy_port = port;
 	}
+	result->override_verify_ssl = settings_reader->TryGetSecretKey<bool>("verify_ssl", result->verify_ssl);
 	settings_reader->TryGetSecretKey<string>("http_proxy_username", result->http_proxy_username);
 	settings_reader->TryGetSecretKey<string>("http_proxy_password", result->http_proxy_password);
 	settings_reader->TryGetSecretKey<string>("bearer_token", result->bearer_token);
diff --git a/src/httpfs_curl_client.cpp b/src/httpfs_curl_client.cpp
index 3b56ccf5ab9..d1a750e4d3e 100644
--- a/src/httpfs_curl_client.cpp
+++ b/src/httpfs_curl_client.cpp
@@ -118,9 +118,6 @@ public:
 		curl_url_set(base_url, CURLUPART_URL, proto_host_port.c_str(), 0);
 		stored_bearer_token = "";
 		stored_cert_file_path = "";
-		if (StringUtil::StartsWith(proto_host_port, "https://")) {
-			https_connection = true;
-		}
 		Initialize(http_params);
 	}
 	void Initialize(HTTPParams &http_p) override {
@@ -162,7 +159,9 @@ public:
 			curl_easy_setopt(*curl, CURLOPT_FORBID_REUSE, 0L);
 		}
 
-		if (https_connection && http_params.enable_curl_server_cert_verification) {
+		const bool verify_ssl = http_params.override_verify_ssl ? http_params.verify_ssl : http_params.enable_curl_server_cert_verification;
+
+		if (verify_ssl) {
 			curl_easy_setopt(*curl, CURLOPT_SSL_VERIFYPEER, 1L); // Verify the cert
 			curl_easy_setopt(*curl, CURLOPT_SSL_VERIFYHOST, 2L); // Verify that the cert matches the hostname
 		} else {
@@ -474,7 +473,6 @@ private:
 	CURLU *base_url = nullptr;
 	string stored_bearer_token;
 	string stored_cert_file_path;
-	bool https_connection = false;
 
 	static std::mutex &GetRefLock() {
 		static std::mutex mtx;
diff --git a/src/httpfs_httplib_client.cpp b/src/httpfs_httplib_client.cpp
index d8d41ad1d10..272b6ba4cac 100644
--- a/src/httpfs_httplib_client.cpp
+++ b/src/httpfs_httplib_client.cpp
@@ -9,9 +9,6 @@ class HTTPFSClient : public HTTPClient {
 public:
 	HTTPFSClient(HTTPFSParams &http_params, const string &proto_host_port) {
 		client = make_uniq<duckdb_httplib_openssl::Client>(proto_host_port);
-		if (StringUtil::StartsWith(proto_host_port, "https://")) {
-			https_connection = true;
-		}
 		Initialize(http_params);
 	}
 	void Initialize(HTTPParams &http_p) override {
@@ -21,7 +18,8 @@ public:
 		if (!http_params.ca_cert_file.empty()) {
 			client->set_ca_cert_path(http_params.ca_cert_file.c_str());
 		}
-		client->enable_server_certificate_verification(https_connection && http_params.enable_server_cert_verification);
+		const bool verify_ssl = http_params.override_verify_ssl ? http_params.verify_ssl : http_params.enable_server_cert_verification;
+		client->enable_server_certificate_verification(verify_ssl);
 		client->set_write_timeout(http_params.timeout, http_params.timeout_usec);
 		client->set_read_timeout(http_params.timeout, http_params.timeout_usec);
 		client->set_connection_timeout(http_params.timeout, http_params.timeout_usec);
@@ -162,7 +160,6 @@ private:
 private:
 	unique_ptr<duckdb_httplib_openssl::Client> client;
 	optional_ptr<HTTPState> state;
-	bool https_connection = false;
 };
 
 unique_ptr<HTTPClient> HTTPFSUtil::InitializeClient(HTTPParams &http_params, const string &proto_host_port) {
