diff --git a/src/hnsw/hnsw_index.cpp b/src/hnsw/hnsw_index.cpp
index ca73a9c..2848f39 100644
--- a/src/hnsw/hnsw_index.cpp
+++ b/src/hnsw/hnsw_index.cpp
@@ -566,8 +566,12 @@ bool HNSWIndex::MergeIndexes(IndexLock &state, BoundIndex &other_index) {
 void HNSWIndex::Vacuum(IndexLock &state) {
 }
 
-string HNSWIndex::VerifyAndToString(IndexLock &state, const bool only_verify) {
-	throw NotImplementedException("HNSWIndex::VerifyAndToString() not implemented");
+void HNSWIndex::Verify(IndexLock &l) {
+	throw NotImplementedException("HNSWIndex::Verify() not implemented");
+}
+
+string HNSWIndex::ToString(IndexLock &l, bool display_ascii) {
+	throw NotImplementedException("HNSWIndex::ToString() not implemented");
 }
 
 void HNSWIndex::VerifyAllocations(IndexLock &state) {
diff --git a/src/hnsw/hnsw_index_pragmas.cpp b/src/hnsw/hnsw_index_pragmas.cpp
index 441314b..d680695 100644
--- a/src/hnsw/hnsw_index_pragmas.cpp
+++ b/src/hnsw/hnsw_index_pragmas.cpp
@@ -101,17 +101,16 @@ static void HNSWIndexInfoExecute(ClientContext &context, TableFunctionInput &dat
 		auto &table_info = *storage.GetDataTableInfo();
 
 		table_info.BindIndexes(context, HNSWIndex::TYPE_NAME);
-		table_info.GetIndexes().Scan([&](Index &index) {
+		for(auto &index : table_info.GetIndexes().Indexes()) {
 			if (!index.IsBound() || HNSWIndex::TYPE_NAME != index.GetIndexType()) {
-				return false;
+				continue;
 			}
 			auto &cast_index = index.Cast<HNSWIndex>();
 			if (cast_index.name == index_entry.name) {
 				hnsw_index = &cast_index;
-				return true;
+				break;
 			}
-			return false;
-		});
+		}
 
 		if (!hnsw_index) {
 			throw BinderException("Index %s not found", index_entry.name);
@@ -182,18 +181,17 @@ static void CompactIndexPragma(ClientContext &context, const FunctionParameters
 
 	auto &table_info = *storage.GetDataTableInfo();
 	table_info.BindIndexes(context, HNSWIndex::TYPE_NAME);
-	table_info.GetIndexes().Scan([&](Index &index) {
+	for(auto &index : table_info.GetIndexes().Indexes()) {
 		if (!index.IsBound() || HNSWIndex::TYPE_NAME != index.GetIndexType()) {
-			return false;
+			continue;
 		}
 		auto &cast_index = index.Cast<HNSWIndex>();
 		if (cast_index.name == index_entry.name) {
 			cast_index.Compact();
 			found_index = true;
-			return true;
+			break;
 		}
-		return false;
-	});
+	}
 
 	if (!found_index) {
 		throw BinderException("Index %s not found", index_name);
diff --git a/src/hnsw/hnsw_optimize_expr.cpp b/src/hnsw/hnsw_optimize_expr.cpp
index f3856e9..9c1890a 100644
--- a/src/hnsw/hnsw_optimize_expr.cpp
+++ b/src/hnsw/hnsw_optimize_expr.cpp
@@ -6,8 +6,8 @@
 #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
 #include "duckdb/optimizer/column_binding_replacer.hpp"
 #include "duckdb/optimizer/optimizer.hpp"
+#include "duckdb/optimizer/optimizer_extension.hpp"
 #include "duckdb/main/extension/extension_loader.hpp"
-
 #include "hnsw/hnsw.hpp"
 #include "hnsw/hnsw_index.hpp"
 
@@ -93,7 +93,7 @@ public:
 
 void HNSWModule::RegisterExprOptimizer(DatabaseInstance &db) {
 	// Register the TopKOptimizer
-	db.config.optimizer_extensions.push_back(HNSWExprOptimizer());
+	OptimizerExtension::Register(db.config, HNSWExprOptimizer());
 }
 
 } // namespace duckdb
diff --git a/src/hnsw/hnsw_optimize_join.cpp b/src/hnsw/hnsw_optimize_join.cpp
index fc19ed7..c14b364 100644
--- a/src/hnsw/hnsw_optimize_join.cpp
+++ b/src/hnsw/hnsw_optimize_join.cpp
@@ -20,6 +20,7 @@
 #include "duckdb/storage/table/scan_state.hpp"
 #include "duckdb/transaction/duck_transaction.hpp"
 #include "duckdb/storage/storage_index.hpp"
+#include "duckdb/optimizer/optimizer_extension.hpp"
 
 #include "hnsw/hnsw.hpp"
 #include "hnsw/hnsw_index.hpp"
@@ -515,20 +516,20 @@ bool HNSWIndexJoinOptimizer::TryOptimize(Binder &binder, ClientContext &context,
 	vector<reference<Expression>> bindings;
 
 	table_info.BindIndexes(context, HNSWIndex::TYPE_NAME);
-	table_info.GetIndexes().Scan([&](Index &index) {
+	for(auto &index : table_info.GetIndexes().Indexes()) {
 		if (!index.IsBound() || HNSWIndex::TYPE_NAME != index.GetIndexType()) {
-			return false;
+			continue;
 		}
 		auto &cast_index = index.Cast<HNSWIndex>();
 
 		// Reset the bindings
 		bindings.clear();
 		if (!cast_index.TryMatchDistanceFunction(distance_expr_ptr, bindings)) {
-			return false;
+			continue;
 		}
 		unique_ptr<Expression> bound_index_expr = nullptr;
 		if (!cast_index.TryBindIndexExpression(inner_get, bound_index_expr)) {
-			return false;
+			continue;
 		}
 
 		// We also have to replace the outer table index here with the delim_get table index
@@ -550,14 +551,14 @@ bool HNSWIndexJoinOptimizer::TryOptimize(Binder &binder, ClientContext &context,
 			if (!rhs_dist_expr.get().Equals(*bound_index_expr)) {
 				std::swap(lhs_dist_expr, rhs_dist_expr);
 			} else {
-				return false;
+				continue;
 			}
 		}
 
 		// Save the pointer to the index
 		index_ptr = &cast_index;
-		return true;
-	});
+		break;
+	}
 	if (!index_ptr) {
 		return false;
 	}
@@ -719,7 +720,7 @@ void HNSWIndexJoinOptimizer::Optimize(OptimizerExtensionInput &input, unique_ptr
 
 void HNSWModule::RegisterJoinOptimizer(DatabaseInstance &db) {
 	// Register the JoinOptimizer
-	db.config.optimizer_extensions.push_back(HNSWIndexJoinOptimizer());
+	OptimizerExtension::Register(db.config, HNSWIndexJoinOptimizer());
 }
 
 } // namespace duckdb
diff --git a/src/hnsw/hnsw_optimize_scan.cpp b/src/hnsw/hnsw_optimize_scan.cpp
index 1f84af0..7194ee8 100644
--- a/src/hnsw/hnsw_optimize_scan.cpp
+++ b/src/hnsw/hnsw_optimize_scan.cpp
@@ -102,9 +102,9 @@ public:
 		vector<reference<Expression>> bindings;
 
 		table_info.BindIndexes(context, HNSWIndex::TYPE_NAME);
-		table_info.GetIndexes().Scan([&](Index &index) {
+		for(auto &index : table_info.GetIndexes().Indexes()) {
 			if (!index.IsBound() || HNSWIndex::TYPE_NAME != index.GetIndexType()) {
-				return false;
+				continue;
 			}
 			auto &cast_index = index.Cast<HNSWIndex>();
 
@@ -113,12 +113,12 @@ public:
 
 			// Check that the projection expression is a distance function that matches the index
 			if (!cast_index.TryMatchDistanceFunction(projection_expr, bindings)) {
-				return false;
+				continue;
 			}
 			// Check that the HNSW index actually indexes the expression
 			unique_ptr<Expression> index_expr;
 			if (!cast_index.TryBindIndexExpression(get, index_expr)) {
-				return false;
+				continue;
 			}
 
 			// Now, ensure that one of the bindings is a constant vector, and the other our index expression
@@ -131,7 +131,7 @@ public:
 				if (const_expr_ref.get().type != ExpressionType::VALUE_CONSTANT ||
 				    !index_expr->Equals(index_expr_ref)) {
 					// Nope, not a match, we can't optimize.
-					return false;
+					continue;
 				}
 			}
 
@@ -144,8 +144,8 @@ public:
 			}
 
 			bind_data = make_uniq<HNSWIndexScanBindData>(duck_table, cast_index, top_n.limit, std::move(query_vector));
-			return true;
-		});
+			break;
+		}
 
 		if (!bind_data) {
 			// No index found
@@ -261,7 +261,7 @@ public:
 //-----------------------------------------------------------------------------
 void HNSWModule::RegisterScanOptimizer(DatabaseInstance &db) {
 	// Register the optimizer extension
-	db.config.optimizer_extensions.push_back(HNSWIndexScanOptimizer());
+	OptimizerExtension::Register(db.config, HNSWIndexScanOptimizer());
 }
 
 } // namespace duckdb
diff --git a/src/hnsw/hnsw_optimize_topk.cpp b/src/hnsw/hnsw_optimize_topk.cpp
index d7b1fc4..9afe05e 100644
--- a/src/hnsw/hnsw_optimize_topk.cpp
+++ b/src/hnsw/hnsw_optimize_topk.cpp
@@ -6,6 +6,7 @@
 #include "duckdb/planner/operator/logical_get.hpp"
 #include "duckdb/planner/operator/logical_filter.hpp"
 #include "duckdb/optimizer/optimizer.hpp"
+#include "duckdb/optimizer/optimizer_extension.hpp"
 #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
 #include "duckdb/optimizer/matcher/expression_matcher.hpp"
 #include "duckdb/main/extension/extension_loader.hpp"
@@ -124,9 +125,9 @@ public:
 		vector<reference<Expression>> bindings;
 
 		table_info.BindIndexes(context, HNSWIndex::TYPE_NAME);
-		table_info.GetIndexes().Scan([&](Index &index) {
+		for(auto &index : table_info.GetIndexes().Indexes()) {
 			if (!index.IsBound() || HNSWIndex::TYPE_NAME != index.GetIndexType()) {
-				return false;
+				continue;
 			}
 			auto &cast_index = index.Cast<HNSWIndex>();
 
@@ -135,12 +136,12 @@ public:
 
 			// Check that the projection expression is a distance function that matches the index
 			if (!cast_index.TryMatchDistanceFunction(dist_expr, bindings)) {
-				return false;
+				continue;
 			}
 			// Check that the HNSW index actually indexes the expression
 			unique_ptr<Expression> index_expr;
 			if (!cast_index.TryBindIndexExpression(get, index_expr)) {
-				return false;
+				continue;
 			}
 
 			// Now, ensure that one of the bindings is a constant vector, and the other our index expression
@@ -153,7 +154,7 @@ public:
 				if (const_expr_ref.get().type != ExpressionType::VALUE_CONSTANT ||
 				    !index_expr->Equals(index_expr_ref)) {
 					// Nope, not a match, we can't optimize.
-					return false;
+					continue;
 				}
 			}
 
@@ -167,11 +168,11 @@ public:
 			}
 			const auto k_limit = limit_expr->Cast<BoundConstantExpression>().value.GetValue<int32_t>();
 			if (k_limit <= 0 || k_limit >= STANDARD_VECTOR_SIZE) {
-				return false;
+				continue;
 			}
 			bind_data = make_uniq<HNSWIndexScanBindData>(duck_table, cast_index, k_limit, std::move(query_vector));
-			return true;
-		});
+			break;
+		}
 
 		if (!bind_data) {
 			// No index found
@@ -236,7 +237,7 @@ public:
 
 void HNSWModule::RegisterTopKOptimizer(DatabaseInstance &db) {
 	// Register the TopKOptimizer
-	db.config.optimizer_extensions.push_back(HNSWTopKOptimizer());
+	OptimizerExtension::Register(db.config, HNSWTopKOptimizer());
 }
 
 } // namespace duckdb
diff --git a/src/include/hnsw/hnsw_index.hpp b/src/include/hnsw/hnsw_index.hpp
index d569292..629e2f3 100644
--- a/src/include/hnsw/hnsw_index.hpp
+++ b/src/include/hnsw/hnsw_index.hpp
@@ -93,8 +93,14 @@ public:
 	//! Traverses an HNSWIndex and vacuums the qualifying nodes. The lock obtained from InitializeLock must be held
 	void Vacuum(IndexLock &state) override;
 
-	//! Returns the string representation of the HNSWIndex, or only traverses and verifies the index.
-	string VerifyAndToString(IndexLock &state, const bool only_verify) override;
+	//! Traverses and verifies the index.
+	//! Currently not implemented.
+	void Verify(IndexLock &l) override;
+
+	//! Returns the string representation of an index.
+	//! Currently not implemented.
+	string ToString(IndexLock &l, bool display_ascii = false) override;
+
 	//! Ensures that the node allocation counts match the node counts.
 	void VerifyAllocations(IndexLock &state) override;
 
diff --git a/src/include/hnsw/hnsw_index_physical_create.hpp b/src/include/hnsw/hnsw_index_physical_create.hpp
index 2b1cc6a..0be2536 100644
--- a/src/include/hnsw/hnsw_index_physical_create.hpp
+++ b/src/include/hnsw/hnsw_index_physical_create.hpp
@@ -29,7 +29,7 @@ public:
 
 public:
 	//! Source interface, NOOP for this operator
-	SourceResultType GetData(ExecutionContext &context, DataChunk &chunk, OperatorSourceInput &input) const override {
+	SourceResultType GetDataInternal(ExecutionContext &context, DataChunk &chunk, OperatorSourceInput &input) const override {
 		return SourceResultType::FINISHED;
 	}
 	bool IsSource() const override {
