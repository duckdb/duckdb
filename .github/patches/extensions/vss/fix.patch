diff --git a/src/hnsw/hnsw_index.cpp b/src/hnsw/hnsw_index.cpp
index 218aa0e..f0b0e90 100644
--- a/src/hnsw/hnsw_index.cpp
+++ b/src/hnsw/hnsw_index.cpp
@@ -523,33 +523,33 @@ void HNSWIndex::PersistToDisk() {
 	is_dirty = false;
 }
 
-IndexStorageInfo HNSWIndex::SerializeToDisk(QueryContext context, const case_insensitive_map_t<Value> &options) {
+unique_ptr<IndexStorageInfo> HNSWIndex::SerializeToDisk(QueryContext context, const case_insensitive_map_t<Value> &options) {
 
 	PersistToDisk();
 
-	IndexStorageInfo info;
-	info.name = name;
-	info.root = root_block_ptr.Get();
+	auto info = make_uniq<IndexStorageInfo>();
+	info->name = name;
+	info->root = root_block_ptr.Get();
 
 	// Use the partial block manager to serialize allocator data.
 	auto &block_manager = table_io_manager.GetIndexBlockManager();
 	PartialBlockManager partial_block_manager(context, block_manager, PartialBlockType::FULL_CHECKPOINT);
 	linked_block_allocator->SerializeBuffers(partial_block_manager);
 	partial_block_manager.FlushPartialBlocks();
-	info.allocator_infos.push_back(linked_block_allocator->GetInfo());
+	info->allocator_infos.push_back(linked_block_allocator->GetInfo());
 
 	return info;
 }
 
-IndexStorageInfo HNSWIndex::SerializeToWAL(const case_insensitive_map_t<Value> &options) {
+unique_ptr<IndexStorageInfo> HNSWIndex::SerializeToWAL(const case_insensitive_map_t<Value> &options) {
 
 	PersistToDisk();
 
-	IndexStorageInfo info;
-	info.name = name;
-	info.root = root_block_ptr.Get();
-	info.buffers.push_back(linked_block_allocator->InitSerializationToWAL());
-	info.allocator_infos.push_back(linked_block_allocator->GetInfo());
+	auto info = make_uniq<IndexStorageInfo>();
+	info->name = name;
+	info->root = root_block_ptr.Get();
+	info->buffers.push_back(linked_block_allocator->InitSerializationToWAL());
+	info->allocator_infos.push_back(linked_block_allocator->GetInfo());
 
 	return info;
 }
@@ -566,8 +566,12 @@ bool HNSWIndex::MergeIndexes(IndexLock &state, BoundIndex &other_index) {
 void HNSWIndex::Vacuum(IndexLock &state) {
 }
 
-string HNSWIndex::VerifyAndToString(IndexLock &state, const bool only_verify) {
-	throw NotImplementedException("HNSWIndex::VerifyAndToString() not implemented");
+void HNSWIndex::Verify(IndexLock &l) {
+	throw NotImplementedException("HNSWIndex::Verify() not implemented");
+}
+
+string HNSWIndex::ToString(IndexLock &l, bool display_ascii) {
+	throw NotImplementedException("HNSWIndex::ToString() not implemented");
 }
 
 void HNSWIndex::VerifyAllocations(IndexLock &state) {
diff --git a/src/include/hnsw/hnsw_index.hpp b/src/include/hnsw/hnsw_index.hpp
index 83fb9e7..1370627 100644
--- a/src/include/hnsw/hnsw_index.hpp
+++ b/src/include/hnsw/hnsw_index.hpp
@@ -78,9 +78,9 @@ public:
 	ErrorData Insert(IndexLock &lock, DataChunk &data, Vector &row_ids) override;
 
 	//! Serializes HNSW memory to disk and returns the index storage information.
-	IndexStorageInfo SerializeToDisk(QueryContext context, const case_insensitive_map_t<Value> &options) override;
+	unique_ptr<IndexStorageInfo> SerializeToDisk(QueryContext context, const case_insensitive_map_t<Value> &options) override;
 	//! Serializes HNSW memory to the WAL and returns the index storage information.
-	IndexStorageInfo SerializeToWAL(const case_insensitive_map_t<Value> &options) override;
+	unique_ptr<IndexStorageInfo> SerializeToWAL(const case_insensitive_map_t<Value> &options) override;
 
 	idx_t GetInMemorySize(IndexLock &state) override;
 
@@ -91,8 +91,14 @@ public:
 	//! Traverses an HNSWIndex and vacuums the qualifying nodes. The lock obtained from InitializeLock must be held
 	void Vacuum(IndexLock &state) override;
 
-	//! Returns the string representation of the HNSWIndex, or only traverses and verifies the index.
-	string VerifyAndToString(IndexLock &state, const bool only_verify) override;
+	//! Traverses and verifies the index.
+	//! Currently not implemented.
+	void Verify(IndexLock &l) override;
+
+	//! Returns the string representation of an index.
+	//! Currently not implemented.
+	string ToString(IndexLock &l, bool display_ascii = false) override;
+
 	//! Ensures that the node allocation counts match the node counts.
 	void VerifyAllocations(IndexLock &state) override;
 
