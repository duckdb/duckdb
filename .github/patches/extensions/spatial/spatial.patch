diff --git a/src/spatial/modules/gdal/gdal_module.cpp b/src/spatial/modules/gdal/gdal_module.cpp
index 213c13d..5762359 100644
--- a/src/spatial/modules/gdal/gdal_module.cpp
+++ b/src/spatial/modules/gdal/gdal_module.cpp
@@ -27,6 +27,7 @@
 #include "cpl_vsi.h"
 #include "cpl_vsi_error.h"
 #include "cpl_vsi_virtual.h"
+#include "duckdb/common/types/geometry_crs.hpp"
 #include "duckdb/main/settings.hpp"
 
 namespace duckdb {
@@ -611,7 +612,7 @@ auto Bind(ClientContext &ctx, TableFunctionBindInput &input, vector<LogicalType>
 		// Convert Arrow schema to DuckDB types
 		for (int64_t i = 0; i < schema.n_children; i++) {
 			auto &child_schema = *schema.children[i];
-			const auto gdal_type = ArrowType::GetTypeFromSchema(ctx.db->config, child_schema);
+			const auto gdal_type = ArrowType::GetTypeFromSchema(ctx, child_schema);
 			auto duck_type = gdal_type->GetDuckType();
 
 			// Track geometry columns to compute stats later
@@ -849,7 +850,7 @@ auto InitGlobal(ClientContext &context, TableFunctionInitInput &input) -> unique
 	// Store the column types
 	for (int64_t i = 0; i < schema.n_children; i++) {
 		auto &child_schema = *schema.children[i];
-		result->col_types.push_back(ArrowType::GetTypeFromSchema(context.db->config, child_schema));
+		result->col_types.push_back(ArrowType::GetTypeFromSchema(context, child_schema));
 	}
 
 	return std::move(result);
@@ -1199,6 +1200,16 @@ auto Bind(ClientContext &context, CopyFunctionBindInput &input, const vector<str
 		throw BinderException("Unknown GDAL COPY option: '%s'", option.first);
 	}
 
+	// If no override SRS is set, we will use the SRS of the first geometry column
+	if (result->target_srs.empty()) {
+		for (auto &col : sql_types) {
+			if (col.id() == LogicalTypeId::GEOMETRY && GeoType::HasCRS(col)) {
+				result->target_srs = GeoType::GetCRS(col).GetDefinition();
+				break;
+			}
+		}
+	}
+
 	// Check that options are valid
 	if (result->driver_name.empty()) {
 		throw BinderException("GDAL COPY option 'DRIVER' is required");
diff --git a/src/spatial/modules/proj/proj_module.cpp b/src/spatial/modules/proj/proj_module.cpp
index 616a9d0..6f65e83 100644
--- a/src/spatial/modules/proj/proj_module.cpp
+++ b/src/spatial/modules/proj/proj_module.cpp
@@ -8,10 +8,13 @@
 #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
 #include "duckdb/execution/expression_executor.hpp"
 #include "duckdb/planner/expression/bound_function_expression.hpp"
+#include "duckdb/common/types/geometry_crs.hpp"
 
 #include "proj.h"
 #include "geodesic.h"
 #include "sqlite3.h"
+#include "duckdb/main/extension_callback_manager.hpp"
+#include "duckdb/parser/parsed_data/create_coordinate_system_info.hpp"
 
 // We embed the whole proj.db in the proj_db.c file, which we then link into the extension binary
 // We can then use the sqlite3 "memvfs" (which we also statically link to) to point to the proj.db database in memory
@@ -1208,6 +1211,66 @@ struct DuckDB_Proj_Compiled_Version {
 
 } // namespace
 
+//======================================================================================================================
+// CRS Provider
+//======================================================================================================================
+namespace {
+
+struct CoordinateSystemLoader {
+
+	static void Load(ExtensionLoader &loader) {
+
+		// Load all CRS from proj database
+		PJ_CONTEXT *ctx = ProjModule::GetThreadProjContext();
+
+		// List all EPSG CRS's
+		int ncrs = 0;
+		PROJ_CRS_INFO **crs_info = proj_get_crs_info_list_from_database(ctx, "epsg", nullptr, &ncrs);
+
+		if (crs_info) {
+			for (int i = 0; i < ncrs; i++) {
+
+				string auth_name = crs_info[i]->auth_name ? crs_info[i]->auth_name : "";
+				string auth_code = crs_info[i]->code ? crs_info[i]->code : "";
+				string crs_name = auth_name + ":" + auth_code;
+				string wkt_text;
+				string projjson_text;
+
+				// Create PJ object
+				PJ *pj = proj_create_from_database(ctx, crs_info[i]->auth_name, crs_info[i]->code, PJ_CATEGORY_CRS,
+				                                   false, nullptr);
+				if (pj) {
+
+					static const char *const options[] = {"MULTILINE=NO", nullptr};
+
+					// WKT2_2019
+					const auto wkt = proj_as_wkt(ctx, pj, PJ_WKT2_2019, options);
+					if (wkt) {
+						wkt_text = wkt;
+					}
+					// PROJJSON
+					const auto pj_json = proj_as_projjson(ctx, pj, options);
+					if (pj_json) {
+						projjson_text = pj_json;
+					}
+				}
+
+				proj_destroy(pj);
+
+				CreateCoordinateSystemInfo info(std::move(crs_name), std::move(auth_name), std::move(auth_code),
+				                                std::move(projjson_text), std::move(wkt_text));
+				info.on_conflict = OnCreateConflict::IGNORE_ON_CONFLICT;
+
+				loader.RegisterCoordinateSystem(info);
+			}
+		}
+
+		proj_crs_info_list_destroy(crs_info);
+		proj_context_destroy(ctx);
+	}
+};
+
+} // namespace
 //######################################################################################################################
 // Module Registration
 //######################################################################################################################
@@ -1229,6 +1292,8 @@ void RegisterProjModule(ExtensionLoader &loader) {
 	// Meta functions for proj lib
 	DuckDB_Proj_Version::Register(loader);
 	DuckDB_Proj_Compiled_Version::Register(loader);
+
+	CoordinateSystemLoader::Load(loader);
 }
 
 } // namespace duckdb
