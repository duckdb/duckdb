/*
** This file is automatically generated by the script in the canonical
** SQLite source tree at tool/mkshellc.tcl.  That script combines source
** code from various constituent source files of SQLite into this single
** "shell.c" file used to implement the SQLite command-line shell.
**
** Most of the code found below comes from the "src/shell.c.in" file in
** the canonical SQLite source tree.  That main file contains "INCLUDE"
** lines that specify other files in the canonical source tree that are
** inserted to getnerate this complete program source file.
**
** The code from multiple files is combined into this single "shell.c"
** source file to help make the command-line program easier to compile.
**
** To modify this program, get a copy of the canonical SQLite source tree,
** edit the src/shell.c.in" and/or some of the other files that are included
** by "src/shell.c.in", then rerun the tool/mkshellc.tcl script.
*/
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement the "sqlite" command line
** utility for accessing SQLite databases.
*/
#if (defined(_WIN32) || defined(WIN32)) && !defined(_CRT_SECURE_NO_WARNINGS)
/* This needs to come before any includes for MSVC compiler */
#define _CRT_SECURE_NO_WARNINGS
#endif

/*
** Determine if we are dealing with WinRT, which provides only a subset of
** the full Win32 API.
*/
#if !defined(SQLITE_OS_WINRT)
#define SQLITE_OS_WINRT 0
#endif

/*
** Warning pragmas copied from msvc.h in the core.
*/
#if defined(_MSC_VER)
#pragma warning(disable : 4054)
#pragma warning(disable : 4055)
#pragma warning(disable : 4100)
#pragma warning(disable : 4127)
#pragma warning(disable : 4130)
#pragma warning(disable : 4152)
#pragma warning(disable : 4189)
#pragma warning(disable : 4206)
#pragma warning(disable : 4210)
#pragma warning(disable : 4232)
#pragma warning(disable : 4244)
#pragma warning(disable : 4305)
#pragma warning(disable : 4306)
#pragma warning(disable : 4702)
#pragma warning(disable : 4706)
#endif /* defined(_MSC_VER) */

/*
** Enable large-file support for fopen() and friends on unix.
*/
#ifndef SQLITE_DISABLE_LFS
#define _LARGE_FILE 1
#ifndef _FILE_OFFSET_BITS
#define _FILE_OFFSET_BITS 64
#endif
#define _LARGEFILE_SOURCE 1
#endif

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#include "duckdb/common/box_renderer.hpp"
#include "duckdb/common/file_system.hpp"
#include "duckdb/parser/qualified_name.hpp"
#include "duckdb/parser/parser.hpp"
#include "duckdb/common/local_file_system.hpp"
#ifdef SHELL_INLINE_AUTOCOMPLETE
#include "autocomplete_extension.hpp"
#endif
#include "shell_extension.hpp"
#include <ctype.h>

#if !defined(_WIN32) && !defined(WIN32)
#include <signal.h>
#if !defined(__RTP__) && !defined(_WRS_KERNEL)
#include <pwd.h>
#endif
#endif
#if (!defined(_WIN32) && !defined(WIN32)) || defined(__MINGW32__)
#include <unistd.h>
#include <dirent.h>
#endif
#if defined(__MINGW32__)
#define DIRENT dirent
#ifndef S_ISLNK
#define S_ISLNK(mode) (0)
#endif
#endif
#include <sys/types.h>
#include <sys/stat.h>

#if HAVE_READLINE
#include <readline/readline.h>
#include <readline/history.h>
#endif

#if HAVE_EDITLINE
#include <editline/readline.h>
#endif

#if HAVE_EDITLINE || HAVE_READLINE

#define shell_add_history(X)    add_history(X)
#define shell_read_history(X)   read_history(X)
#define shell_write_history(X)  write_history(X)
#define shell_stifle_history(X) stifle_history(X)
#define shell_readline(X)       readline(X)

#elif HAVE_LINENOISE

#include "linenoise.h"
#define shell_add_history(X)    linenoiseHistoryAdd(X)
#define shell_read_history(X)   linenoiseHistoryLoad(X)
#define shell_write_history(X)  linenoiseHistorySave(X)
#define shell_stifle_history(X) linenoiseHistorySetMaxLen(X)
#define shell_readline(X)       linenoise(X)

#else

#define shell_read_history(X)
#define shell_write_history(X)
#define shell_stifle_history(X)

#define SHELL_USE_LOCAL_GETLINE 1
#endif

#include "duckdb.hpp"
#include "shell_renderer.hpp"
#include "shell_highlight.hpp"
#include "shell_state.hpp"
#include "duckdb/main/error_manager.hpp"

using duckdb::KeywordHelper;
using duckdb::SQLIdentifier;
using duckdb::SQLString;
using duckdb::StringUtil;
using namespace duckdb_shell;

#if defined(_WIN32) || defined(WIN32)
#if SQLITE_OS_WINRT
#define SQLITE_OMIT_POPEN 1
#else
#include <io.h>
#include <fcntl.h>
#define isatty(h) _isatty(h)
#ifndef access
#define access(f, m) _access((f), (m))
#endif
#ifndef unlink
#define unlink _unlink
#endif
#ifndef strdup
#define strdup _strdup
#endif
#undef popen
#define popen _popen
#undef pclose
#define pclose _pclose
#endif
#else
/* Make sure isatty() has a prototype. */
extern int isatty(int);

#if !defined(__RTP__) && !defined(_WRS_KERNEL)
/* popen and pclose are not C89 functions and so are
** sometimes omitted from the <stdio.h> header */
extern FILE *popen(const char *, const char *);
extern int pclose(FILE *);
#else
#define SQLITE_OMIT_POPEN 1
#endif
#endif

#if defined(_WIN32_WCE)
/* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()
 * thus we always assume that we have a console. That can be
 * overridden with the -batch command line option.
 */
#define isatty(x) 1
#endif

#if defined(_WIN32) || defined(WIN32)
#if SQLITE_OS_WINRT
#include <intrin.h>
#endif
#include <windows.h>

#endif

/* On Windows, we normally run with output mode of TEXT so that \n characters
** are automatically translated into \r\n.  However, this behavior needs
** to be disabled in some cases (ex: when generating CSV output and when
** rendering quoted strings that contain \n characters).  The following
** routines take care of that.
*/
#if (defined(_WIN32) || defined(WIN32)) && !SQLITE_OS_WINRT
static void setBinaryMode(FILE *file, int isOutput) {
	if (isOutput)
		fflush(file);
	_setmode(_fileno(file), _O_BINARY);
}
static void setTextMode(FILE *file, int isOutput) {
	if (isOutput)
		fflush(file);
	_setmode(_fileno(file), _O_TEXT);
}
#else
#define setBinaryMode(X, Y)
#define setTextMode(X, Y)
#endif

/* True if the timer is enabled */
static bool enableTimer = false;

/* Return the current wall-clock time */
static int64_t timeOfDay(void) {
	using namespace std::chrono;
	return (int64_t)duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
}

#if !defined(_WIN32) && !defined(WIN32) && !defined(__minux)
#include <sys/time.h>
#include <sys/resource.h>

/* VxWorks does not support getrusage() as far as we can determine */
#if defined(_WRS_KERNEL) || defined(__RTP__)
struct rusage {
	struct timeval ru_utime; /* user CPU time used */
	struct timeval ru_stime; /* system CPU time used */
};
#define getrusage(A, B) memset(B, 0, sizeof(*B))
#endif

/* Saved resource information for the beginning of an operation */
static struct rusage sBegin; /* CPU time at start */
static int64_t iBegin;       /* Wall-clock time at start */

/*
** Begin timing an operation
*/
static void beginTimer(void) {
	if (enableTimer) {
		getrusage(RUSAGE_SELF, &sBegin);
		iBegin = timeOfDay();
	}
}

/* Return the difference of two time_structs in seconds */
static double timeDiff(struct timeval *pStart, struct timeval *pEnd) {
	return (pEnd->tv_usec - pStart->tv_usec) * 0.000001 + (double)(pEnd->tv_sec - pStart->tv_sec);
}

/*
** Print the timing results.
*/
static void endTimer(void) {
	if (enableTimer) {
		int64_t iEnd = timeOfDay();
		struct rusage sEnd;
		getrusage(RUSAGE_SELF, &sEnd);
		printf("Run Time (s): real %.3f user %f sys %f\n", (iEnd - iBegin) * 0.001,
		       timeDiff(&sBegin.ru_utime, &sEnd.ru_utime), timeDiff(&sBegin.ru_stime, &sEnd.ru_stime));
	}
}

#define BEGIN_TIMER beginTimer()
#define END_TIMER   endTimer()
#define HAS_TIMER   1

#elif (defined(_WIN32) || defined(WIN32))

/* Saved resource information for the beginning of an operation */
static HANDLE hProcess;
static FILETIME ftKernelBegin;
static FILETIME ftUserBegin;
static int64_t ftWallBegin;
typedef BOOL(WINAPI *GETPROCTIMES)(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME, LPFILETIME);
static GETPROCTIMES getProcessTimesAddr = NULL;

/*
** Check to see if we have timer support.  Return 1 if necessary
** support found (or found previously).
*/
static int hasTimer(void) {
	if (getProcessTimesAddr) {
		return 1;
	} else {
#if !SQLITE_OS_WINRT
		/* GetProcessTimes() isn't supported in WIN95 and some other Windows
		** versions. See if the version we are running on has it, and if it
		** does, save off a pointer to it and the current process handle.
		*/
		hProcess = GetCurrentProcess();
		if (hProcess) {
			HINSTANCE hinstLib = LoadLibrary(TEXT("Kernel32.dll"));
			if (NULL != hinstLib) {
				getProcessTimesAddr = (GETPROCTIMES)GetProcAddress(hinstLib, "GetProcessTimes");
				if (NULL != getProcessTimesAddr) {
					return 1;
				}
				FreeLibrary(hinstLib);
			}
		}
#endif
	}
	return 0;
}

/*
** Begin timing an operation
*/
static void beginTimer(void) {
	if (enableTimer && getProcessTimesAddr) {
		FILETIME ftCreation, ftExit;
		getProcessTimesAddr(hProcess, &ftCreation, &ftExit, &ftKernelBegin, &ftUserBegin);
		ftWallBegin = timeOfDay();
	}
}

/* Return the difference of two FILETIME structs in seconds */
static double timeDiff(FILETIME *pStart, FILETIME *pEnd) {
	sqlite_int64 i64Start = *((sqlite_int64 *)pStart);
	sqlite_int64 i64End = *((sqlite_int64 *)pEnd);
	return (double)((i64End - i64Start) / 10000000.0);
}

/*
** Print the timing results.
*/
static void endTimer(void) {
	if (enableTimer && getProcessTimesAddr) {
		FILETIME ftCreation, ftExit, ftKernelEnd, ftUserEnd;
		int64_t ftWallEnd = timeOfDay();
		getProcessTimesAddr(hProcess, &ftCreation, &ftExit, &ftKernelEnd, &ftUserEnd);
		printf("Run Time (s): real %.3f user %f sys %f\n", (ftWallEnd - ftWallBegin) * 0.001,
		       timeDiff(&ftUserBegin, &ftUserEnd), timeDiff(&ftKernelBegin, &ftKernelEnd));
	}
}

#define BEGIN_TIMER beginTimer()
#define END_TIMER   endTimer()
#define HAS_TIMER   hasTimer()

#else
#define BEGIN_TIMER
#define END_TIMER
#define HAS_TIMER 0
#endif

/*
** Used to prevent warnings about unused parameters
*/
#define UNUSED_PARAMETER(x) (void)(x)

/*
** Number of elements in an array
*/
#define ArraySize(X) (int)(sizeof(X) / sizeof(X[0]))

/*
** If the following flag is set, then command execution stops at an error
** if we are not interactive, including any error in processed files.
*/
static bool bail_on_error = false;

/*
** Treat stdin as an interactive input if the following variable
** is true.  Otherwise, assume stdin is connected to a file or pipe.
*/
static bool stdin_is_interactive = true;

/*
** On Windows systems we have to know if standard output is a console
** in order to translate UTF-8 into MBCS.  The following variable is
** true if translation is required.
*/
static bool stdout_is_console = true;
static bool stderr_is_console = true;

/*
** The following is the open database.  We make a pointer
** to this database a static variable so that it can be accessed
** by the SIGINT handler to interrupt database processing.
*/
static duckdb_shell::ShellState *globalState = nullptr;

/*
** True if an interrupt (Control-C) has been received.
*/
static volatile int seenInterrupt = 0;

/*
** This is the name of our program. It is set in main(), used
** in a number of other places, mostly for error messages.
*/
static const char *program_name;

enum class OptionType { DEFAULT, ON, OFF };

/*
** Whether or not we are running in safe mode
*/
static bool safe_mode = false;

/*
** Whether or not we are highlighting errors
*/
static OptionType highlight_errors = OptionType::DEFAULT;

static bool HighlightErrors() {
	if (highlight_errors == OptionType::DEFAULT) {
		return stderr_is_console;
	}
	return highlight_errors == OptionType::ON;
}

/*
** Whether or not we are highlighting results
*/
static OptionType highlight_results = OptionType::DEFAULT;

static bool HighlightResults() {
	if (highlight_results == OptionType::DEFAULT) {
		return stdout_is_console;
	}
	return highlight_results == OptionType::ON;
}

/*
** Prompt strings. Initialized in main. Settable with
**   .prompt main continue
*/
static char mainPrompt[20];             /* First line prompt. default: "D "*/
static char continuePrompt[20];         /* Continuation prompt. default: "   ...> " */
static char continuePromptSelected[20]; /* Selected continuation prompt. default: "   ...> " */

/*
** Render output like fprintf().  Except, if the output is going to the
** console and if this is running on a Windows machine, translate the
** output from UTF-8 into MBCS.
*/
#if defined(_WIN32) || defined(WIN32)
static int win_utf8_mode = 0;

void utf8_printf(FILE *out, const char *zFormat, ...) {
	va_list ap;
	va_start(ap, zFormat);
	if (stdout_is_console && (out == stdout || out == stderr)) {
		char buffer[2048];
		int required_characters = vsnprintf(buffer, 2048, zFormat, ap);
		const char *z1;
		unique_ptr<char[]> zbuf;
		if (required_characters > 2048) {
			zbuf = unique_ptr<char[]>(new char[required_characters + 1]);
			vsnprintf(zbuf.get(), required_characters + 1, zFormat, ap);
			z1 = zbuf.get();
		} else {
			z1 = buffer;
		}
		if (win_utf8_mode && SetConsoleOutputCP(CP_UTF8)) {
			// we can write UTF8 directly
			fputs(z1, out);
		} else {
			// fallback to writing old style windows unicode
			auto z2 = ShellState::Win32Utf8ToMbcs(z1, false);
			fputs((const char *)z2.get(), out);
		}
	} else {
		vfprintf(out, zFormat, ap);
	}
	va_end(ap);
}
#elif !defined(utf8_printf)
#define utf8_printf fprintf
#endif

/*
** Render output like fprintf().  This should not be used on anything that
** includes string formatting (e.g. "%s").
*/
#if !defined(raw_printf)
#define raw_printf fprintf
#endif

/* Indicate out-of-memory and exit. */
static void shell_out_of_memory(void) {
	raw_printf(stderr, "Error: out of memory\n");
	exit(1);
}

ShellState::ShellState() {
	config.error_manager->AddCustomError(
	    duckdb::ErrorType::UNSIGNED_EXTENSION,
	    "Extension \"%s\" could not be loaded because its signature is either missing or invalid and unsigned "
	    "extensions are disabled by configuration.\nStart the shell with the -unsigned parameter to allow this "
	    "(e.g. duckdb -unsigned).");
	nullValue = "NULL";
}

void ShellState::Print(PrintOutput output, const char *str) {
	utf8_printf(output == PrintOutput::STDOUT ? out : stderr, "%s", str);
}

void ShellState::Print(PrintOutput output, const string &str) {
	Print(output, str.c_str());
}

void ShellState::Print(const char *str) {
	Print(PrintOutput::STDOUT, str);
}

void ShellState::Print(const string &str) {
	Print(PrintOutput::STDOUT, str.c_str());
}

void ShellState::PrintPadded(const char *str, idx_t len) {
	utf8_printf(out, "%*s", int(len), str);
}

/*
** Output string zUtf to stream pOut as w characters.  If w is negative,
** then right-justify the text.  W is the width in UTF-8 characters, not
** in bytes.  This is different from the %*.*s specification in printf
** since with %*.*s the width is measured in bytes, not characters.
*/
void ShellState::UTF8WidthPrint(FILE *pOut, idx_t w, const string &str, bool right_align) {
	auto zUtf = str.c_str();
	int i;
	int n;
	int aw = w < 0 ? -w : w;
#ifdef HAVE_LINENOISE
	i = linenoiseGetRenderPosition(zUtf, strlen(zUtf), aw, &n);
	if (i < 0)
#endif
		for (i = n = 0; zUtf[i]; i++) {
			if ((zUtf[i] & 0xc0) != 0x80) {
				n++;
				if (n == aw) {
					do {
						i++;
					} while ((zUtf[i] & 0xc0) == 0x80);
					break;
				}
			}
		}
	if (n >= aw) {
		utf8_printf(pOut, "%.*s", i, zUtf);
	} else if (right_align) {
		utf8_printf(pOut, "%*s%s", aw - n, "", zUtf);
	} else {
		utf8_printf(pOut, "%s%*s", zUtf, aw - n, "");
	}
}

bool ShellState::IsSpace(char c) {
	return duckdb::StringUtil::CharacterIsSpace(c);
}

bool ShellState::IsDigit(char c) {
	return isdigit(c);
}

/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
*/
idx_t ShellState::StringLength(const char *z) {
	return strlen(z);
}

/*
** Return the length of a string in characters.
*/
idx_t ShellState::RenderLength(const char *z) {
#ifdef HAVE_LINENOISE
	return linenoiseComputeRenderWidth(z, strlen(z));
#else
	int n = 0;
	while (*z) {
		if ((0xc0 & *(z++)) != 0x80)
			n++;
	}
	return n;
#endif
}

idx_t ShellState::RenderLength(const string &str) {
	return RenderLength(str.c_str());
}

int ShellState::RunInitialCommand(char *sql, bool bail) {
	int rc = 0;
	if (sql[0] == '.') {
		rc = DoMetaCommand(sql);
		if (rc && bail) {
			return rc == 2 ? false : rc;
		}
	} else {
		string zErrMsg;
		OpenDB();
		BEGIN_TIMER;
		auto res = ExecuteSQL(sql);
		END_TIMER;
		if (res == SuccessState::FAILURE && bail) {
			return 1;
		}
	}
	return 0;
}

/*
** Return true if zFile does not exist or if it is not an ordinary file.
*/
#ifdef _WIN32
#define notNormalFile(X) 0
#else
static int notNormalFile(const char *zFile) {
	struct stat x;
	int rc;
	memset(&x, 0, sizeof(x));
	rc = stat(zFile, &x);
	return rc || !S_ISREG(x.st_mode);
}
#endif

/*
** This routine reads a line of text from FILE in, stores
** the text in memory obtained from malloc() and returns a pointer
** to the text.  NULL is returned at end of file, or if malloc()
** fails.
**
** If zLine is not NULL then it is a malloced buffer returned from
** a previous call to this routine that may be reused.
*/
static char *local_getline(char *zLine, FILE *in) {
	idx_t nLine = zLine == 0 ? 0 : 100;
	idx_t n = 0;

#if defined(_WIN32) || defined(WIN32)
	int is_stdin = stdin_is_interactive && in == stdin;
	int is_utf8 = 0;
	if (is_stdin && win_utf8_mode) {
		if (SetConsoleCP(CP_UTF8)) {
			is_utf8 = 1;
		}
	}
#endif
	while (1) {
		if (n + 100 > nLine) {
			nLine = nLine * 2 + 100;
			zLine = (char *)realloc(zLine, nLine);
			if (zLine == 0)
				shell_out_of_memory();
		}
		if (fgets(&zLine[n], nLine - n, in) == 0) {
			if (n == 0) {
				free(zLine);
				return 0;
			}
			zLine[n] = 0;
			break;
		}
		while (zLine[n])
			n++;
		if (n > 0 && zLine[n - 1] == '\n') {
			n--;
			if (n > 0 && zLine[n - 1] == '\r')
				n--;
			zLine[n] = 0;
			break;
		}
	}
#if defined(_WIN32) || defined(WIN32)
	/* For interactive input on Windows systems, translate the
	** multi-byte characterset characters into UTF-8. */
	if (is_stdin && !is_utf8) {
		auto zTrans = ShellState::Win32MbcsToUtf8(zLine, 0);
		idx_t nTrans = zTrans.size() + 1;
		if (nTrans > nLine) {
			zLine = (char *)realloc(zLine, nTrans);
			if (zLine == 0) {
				shell_out_of_memory();
			}
		}
		memcpy(zLine, zTrans.data(), nTrans);
	}
#endif /* defined(_WIN32) || defined(WIN32) */
	return zLine;
}

/*
** Retrieve a single line of input text.
**
** If in==0 then read from standard input and prompt before each line.
** If isContinuation is true, then a continuation prompt is appropriate.
** If isContinuation is zero, then the main prompt should be used.
**
** If zPrior is not NULL then it is a buffer from a prior call to this
** routine that can be reused.
**
** The result is stored in space obtained from malloc() and must either
** be freed by the caller or else passed back into this routine via the
** zPrior argument for reuse.
*/
static char *one_input_line(FILE *in, char *zPrior, int isContinuation) {
	char *zPrompt;
	char *zResult;
	if (in != 0) {
		zResult = local_getline(zPrior, in);
	} else {
		zPrompt = isContinuation ? continuePrompt : mainPrompt;
#if SHELL_USE_LOCAL_GETLINE
		printf("%s", zPrompt);
		fflush(stdout);
		zResult = local_getline(zPrior, stdin);
#else
		free(zPrior);
		zResult = shell_readline(zPrompt);
#endif
	}
	return zResult;
}

/*
** Return the value of a hexadecimal digit.  Return -1 if the input
** is not a hex digit.
*/
static int hexDigitValue(char c) {
	if (c >= '0' && c <= '9')
		return c - '0';
	if (c >= 'a' && c <= 'f')
		return c - 'a' + 10;
	if (c >= 'A' && c <= 'F')
		return c - 'A' + 10;
	return -1;
}

/*
** Interpret zArg as an integer value, possibly with suffixes.
*/
int64_t ShellState::StringToInt(const string &arg) {
	int64_t v = 0;
	static const struct {
		const char *zSuffix;
		int iMult;
	} aMult[] = {
	    {"KiB", 1024}, {"MiB", 1024 * 1024}, {"GiB", 1024 * 1024 * 1024},
	    {"KB", 1000},  {"MB", 1000000},      {"GB", 1000000000},
	    {"K", 1000},   {"M", 1000000},       {"G", 1000000000},
	};
	int i;
	int isNeg = 0;
	auto zArg = arg.c_str();
	if (zArg[0] == '-') {
		isNeg = 1;
		zArg++;
	} else if (zArg[0] == '+') {
		zArg++;
	}
	if (zArg[0] == '0' && zArg[1] == 'x') {
		int x;
		zArg += 2;
		while ((x = hexDigitValue(zArg[0])) >= 0) {
			v = (v << 4) + x;
			zArg++;
		}
	} else {
		while (IsDigit(zArg[0])) {
			v = v * 10 + zArg[0] - '0';
			zArg++;
		}
	}
	for (i = 0; i < ArraySize(aMult); i++) {
		if (StringUtil::CIEquals(aMult[i].zSuffix, zArg)) {
			v *= aMult[i].iMult;
			break;
		}
	}
	return isNeg ? -v : v;
}

static const char *modeDescr[] = {"line",     "column", "list",    "semi",  "html",        "insert",    "quote",
                                  "tcl",      "csv",    "explain", "ascii", "prettyprint", "eqp",       "json",
                                  "markdown", "table",  "box",     "latex", "trash",       "jsonlines", "duckbox"};

/*
** These are the column/row/line separators used by the various
** import/export modes.
*/
#define SEP_Column "|"
#define SEP_Row    "\n"
#define SEP_Tab    "\t"
#define SEP_Space  " "
#define SEP_Comma  ","
#define SEP_CrLf   "\r\n"
#define SEP_Unit   "\x1F"
#define SEP_Record "\x1E"

/*
** Save or restore the current output mode
*/
void ShellState::PushOutputMode() {
	modePrior = mode;
	priorShFlgs = shellFlgs;
	colSepPrior = colSeparator;
	rowSepPrior = rowSeparator;
}

void ShellState::PopOutputMode() {
	mode = modePrior;
	shellFlgs = priorShFlgs;
	colSeparator = colSepPrior;
	rowSeparator = rowSepPrior;
}

/*
** Output the given string as a hex-encoded blob (eg. X'1234' )
*/
void ShellState::OutputHexBlob(const void *pBlob, int nBlob) {
	int i;
	char *zBlob = (char *)pBlob;
	raw_printf(out, "X'");
	for (i = 0; i < nBlob; i++) {
		raw_printf(out, "%02x", zBlob[i] & 0xff);
	}
	raw_printf(out, "'");
}

/*
** Output the given string as a quoted string using SQL quoting conventions.
**
** See also: output_quoted_escaped_string()
*/
void ShellState::OutputQuotedString(const char *z) {
	int i;
	char c;
	SetBinaryMode();
	for (i = 0; (c = z[i]) != 0 && c != '\''; i++) {
	}
	if (c == 0) {
		utf8_printf(out, "'%s'", z);
	} else {
		raw_printf(out, "'");
		while (*z) {
			for (i = 0; (c = z[i]) != 0 && c != '\''; i++) {
			}
			if (c == '\'')
				i++;
			if (i) {
				utf8_printf(out, "%.*s", i, z);
				z += i;
			}
			if (c == '\'') {
				raw_printf(out, "'");
				continue;
			}
			if (c == 0) {
				break;
			}
			z++;
		}
		raw_printf(out, "'");
	}
	SetTextMode();
}

/*
** Output the given string as a quoted string using SQL quoting conventions.
** Additionallly , escape the "\n" and "\r" characters so that they do not
** get corrupted by end-of-line translation facilities in some operating
** systems.
**
** This is like output_quoted_string() but with the addition of the \r\n
** escape mechanism.
*/
void ShellState::OutputQuotedEscapedString(const char *z) {
	bool needs_quoting = false;
	bool needs_concat = false;
	for (idx_t i = 0; z[i]; i++) {
		if (z[i] == '\n' || z[i] == '\r') {
			needs_quoting = true;
			needs_concat = true;
			break;
		}
		if (z[i] == '\'') {
			needs_quoting = true;
		}
	}
	if (!needs_quoting) {
		utf8_printf(out, "'%s'", z);
		return;
	}
	string res;
	if (needs_concat) {
		res = "concat('";
	} else {
		res = "'";
	}
	for (idx_t i = 0; z[i]; i++) {
		switch (z[i]) {
		case '\n':
		case '\r':
			// newline - finish the current string literal and write the newline with a chr function
			res += "', chr(";
			if (z[i] == '\n') {
				res += "10";
			} else {
				res += "13";
			}
			res += "), '";
			break;
		case '\'':
			// escape the quote
			res += "''";
			break;
		default:
			res += z[i];
			break;
		}
	}
	res += "'";
	if (needs_concat) {
		res += ")";
	}
	utf8_printf(out, "%s", res.c_str());
}

/*
** Output the given string as a quoted according to C or TCL quoting rules.
*/
void ShellState::OutputCString(const char *z) {
	unsigned int c;
	fputc('"', out);
	while ((c = *(z++)) != 0) {
		if (c == '\\') {
			fputc(c, out);
			fputc(c, out);
		} else if (c == '"') {
			fputc('\\', out);
			fputc('"', out);
		} else if (c == '\t') {
			fputc('\\', out);
			fputc('t', out);
		} else if (c == '\n') {
			fputc('\\', out);
			fputc('n', out);
		} else if (c == '\r') {
			fputc('\\', out);
			fputc('r', out);
		} else if (!isprint(c & 0xff)) {
			raw_printf(out, "\\%03o", c & 0xff);
		} else {
			fputc(c, out);
		}
	}
	fputc('"', out);
}

/*
** Output the given string as a quoted according to JSON quoting rules.
*/
void ShellState::OutputJSONString(const char *z, int n) {
	unsigned int c;
	if (n < 0)
		n = (int)strlen(z);
	fputc('"', out);
	while (n--) {
		c = *(z++);
		if (c == '\\' || c == '"') {
			fputc('\\', out);
			fputc(c, out);
		} else if (c <= 0x1f) {
			fputc('\\', out);
			if (c == '\b') {
				fputc('b', out);
			} else if (c == '\f') {
				fputc('f', out);
			} else if (c == '\n') {
				fputc('n', out);
			} else if (c == '\r') {
				fputc('r', out);
			} else if (c == '\t') {
				fputc('t', out);
			} else {
				raw_printf(out, "u%04x", c);
			}
		} else {
			fputc(c, out);
		}
	}
	fputc('"', out);
}

/*
** If a field contains any character identified by a 1 in the following
** array, then the string must be quoted for CSV.
*/
static const char needCsvQuote[] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0,
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
};

void ShellState::PrintOptionallyQuotedIdentifier(const char *input) {
	Print(StringUtil::Format("%s", SQLIdentifier(input)));
}

/*
** Output a single term of CSV.  Actually, p->colSeparator is used for
** the separator, which may or may not be a comma.  p->nullValue is
** the null value.  Strings are quoted if necessary.  The separator
** is only issued if bSep is true.
*/
void ShellState::OutputCSV(const char *z, int bSep) {
	if (!z) {
		Print(nullValue);
	} else {
		int i;
		int nSep = colSeparator.size();
		for (i = 0; z[i]; i++) {
			if (needCsvQuote[((unsigned char *)z)[i]] ||
			    (z[i] == colSeparator[0] && (nSep == 1 || memcmp(z, colSeparator.c_str(), nSep) == 0))) {
				i = 0;
				break;
			}
		}
		if (i == 0) {
			auto zQuoted = StringUtil::Format("%s", SQLIdentifier(z));
			Print(zQuoted);
		} else {
			Print(z);
		}
	}
	if (bSep) {
		Print(colSeparator);
	}
}

/*
** This routine runs when the user presses Ctrl-C
*/
static void interrupt_handler(int NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	seenInterrupt++;
	if (seenInterrupt > 2) {
		exit(1);
	}
	if (globalState && globalState->conn) {
		globalState->conn->Interrupt();
	}
}

#if (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)
/*
** This routine runs for console events (e.g. Ctrl-C) on Win32
*/
static BOOL WINAPI ConsoleCtrlHandler(DWORD dwCtrlType /* One of the CTRL_*_EVENT constants */
) {
	if (dwCtrlType == CTRL_C_EVENT) {
		interrupt_handler(0);
		return TRUE;
	}
	return FALSE;
}
#endif

/*
** Print a schema statement.  Part of RenderMode::Semi and RenderMode::Pretty output.
**
** This routine converts some CREATE TABLE statements for shadow tables
** in FTS3/4/5 into CREATE TABLE IF NOT EXISTS statements.
*/
void ShellState::PrintSchemaLine(const char *z, const char *zTail) {
	if (!z || !zTail) {
		return;
	}
	if (StringGlob("CREATE TABLE ['\"]*", z) == 0) {
		utf8_printf(out, "CREATE TABLE IF NOT EXISTS %s%s", z + 13, zTail);
	} else {
		utf8_printf(out, "%s%s", z, zTail);
	}
}
void ShellState::PrintSchemaLineN(char *z, int n, const char *zTail) {
	char c = z[n];
	z[n] = 0;
	PrintSchemaLine(z, zTail);
	z[n] = c;
}

/*
** Print N dashes
*/
void ShellState::PrintDashes(idx_t N) {
	const char zDash[] = "--------------------------------------------------";
	const idx_t nDash = sizeof(zDash) - 1;
	while (N > nDash) {
		fputs(zDash, out);
		N -= nDash;
	}
	raw_printf(out, "%.*s", static_cast<int>(N), zDash);
}

/*
** Print a markdown or table-style row separator using ascii-art
*/
void ShellState::PrintRowSeparator(idx_t nArg, const char *zSep, const vector<idx_t> &actualWidth) {
	if (nArg > 0) {
		fputs(zSep, out);
		PrintDashes(actualWidth[0] + 2);
		for (idx_t i = 1; i < nArg; i++) {
			fputs(zSep, out);
			PrintDashes(actualWidth[i] + 2);
		}
		fputs(zSep, out);
	}
	fputs("\n", out);
}

void ShellState::PrintMarkdownSeparator(idx_t nArg, const char *zSep, const vector<duckdb::LogicalType> &colTypes,
                                        const vector<idx_t> &actualWidth) {
	if (nArg > 0) {
		for (idx_t i = 0; i < nArg; i++) {
			Print(zSep);
			if (colTypes[i].IsNumeric()) {
				// right-align numerics in tables
				PrintDashes(actualWidth[i] + 1);
				Print(":");
			} else {
				PrintDashes(actualWidth[i] + 2);
			}
		}
		Print(zSep);
	}
	Print("\n");
}

void ShellState::SetBinaryMode() {
	setBinaryMode(out, 1);
}

void ShellState::SetTextMode() {
	setTextMode(out, 1);
}
/*
** This is the callback routine that the shell
** invokes for each row of a query result.
*/
int ShellState::RenderRow(RowRenderer &renderer, RowResult &result) {
	auto &data = result.data;
	if (data.empty()) {
		return 0;
	}
	renderer.Render(result);
	return 0;
}

SuccessState ShellState::RenderQuery(RowRenderer &renderer, const string &query) {
	auto &con = *conn;
	auto result = con.SendQuery(query);
	if (result->HasError()) {
		PrintDatabaseError(result->GetError());
		return SuccessState::FAILURE;
	}
	return RenderQueryResult(renderer, *result);
}

/*
** Set the destination table field of the ShellState structure to
** the name of the table given.  Escape any quote characters in the
** table name.
*/
void ShellState::SetTableName(const char *zName) {
	zDestTable = zName ? StringUtil::Format("%s", SQLIdentifier(zName)) : string();
}

/*
** Execute a query statement that will generate SQL output.  Print
** the result columns, comma-separated, on a line and then add a
** semicolon terminator to the end of that line.
**
** If the number of columns is 1 and that column contains text "--"
** then write the semicolon on a separate line.  That way, if a
** "--" comment occurs at the end of the statement, the comment
** won't consume the semicolon terminator.
*/
void ShellState::RunTableDumpQuery(const string &zSelect) {
	auto &con = *conn;
	auto result = con.Query(zSelect);
	if (result->HasError()) {
		utf8_printf(out, "/**** ERROR: %s *****/\n", result->GetError().c_str());
		AddError();
		return;
	}
	for (auto &row : *result) {
		auto zStr = row.GetValue<string>(0);
		Print(zStr);
		auto z = zStr.c_str();
		if (!z) {
			z = "";
		}
		while (z[0] && (z[0] != '-' || z[1] != '-')) {
			z++;
		}
		if (z[0]) {
			raw_printf(out, "\n;\n");
		} else {
			raw_printf(out, ";\n");
		}
	}
}

string ShellState::strdup_handle_newline(const char *z) {
	static constexpr idx_t MAX_SIZE = 80;
	if (!z) {
		return nullValue;
	}
	if (cMode != RenderMode::BOX) {
		return z;
	}
	string result;
	idx_t count = 0;
	bool interrupted = false;
	for (const char *s = z; *s; s++) {
		if (*s == '\n') {
			result += "\\";
			result += "n";
		} else {
			result += *s;
		}
		count++;
		if (count >= MAX_SIZE && ((*s & 0xc0) != 0x80)) {
			interrupted = true;
			break;
		}
	}
	if (interrupted) {
		result += "...";
	}
	return result;
}

bool ShellState::ColumnTypeIsInteger(const char *type) {
	if (!type) {
		return false;
	}
	if (strcmp(type, "TINYINT") == 0) {
		return true;
	}
	if (strcmp(type, "SMALLINT") == 0) {
		return true;
	}
	if (strcmp(type, "INTEGER") == 0) {
		return true;
	}
	if (strcmp(type, "BIGINT") == 0) {
		return true;
	}
	if (strcmp(type, "FLOAT") == 0) {
		return true;
	}
	if (strcmp(type, "DOUBLE") == 0) {
		return true;
	}
	if (strcmp(type, "DECIMAL") == 0) {
		return true;
	}
	return false;
}

string GetTypeName(duckdb::LogicalType &type) {
	switch (type.id()) {
	case duckdb::LogicalTypeId::BOOLEAN:
		return "BOOLEAN";
	case duckdb::LogicalTypeId::TINYINT:
		return "TINYINT";
	case duckdb::LogicalTypeId::SMALLINT:
		return "SMALLINT";
	case duckdb::LogicalTypeId::INTEGER:
		return "INTEGER";
	case duckdb::LogicalTypeId::BIGINT:
		return "BIGINT";
	case duckdb::LogicalTypeId::FLOAT:
		return "FLOAT";
	case duckdb::LogicalTypeId::DOUBLE:
		return "DOUBLE";
	case duckdb::LogicalTypeId::DECIMAL:
		return "DECIMAL";
	case duckdb::LogicalTypeId::DATE:
		return "DATE";
	case duckdb::LogicalTypeId::TIME:
		return "TIME";
	case duckdb::LogicalTypeId::TIMESTAMP:
	case duckdb::LogicalTypeId::TIMESTAMP_NS:
	case duckdb::LogicalTypeId::TIMESTAMP_MS:
	case duckdb::LogicalTypeId::TIMESTAMP_SEC:
		return "TIMESTAMP";
	case duckdb::LogicalTypeId::VARCHAR:
		return "VARCHAR";
	case duckdb::LogicalTypeId::LIST:
		return "LIST";
	case duckdb::LogicalTypeId::MAP:
		return "MAP";
	case duckdb::LogicalTypeId::STRUCT:
		return "STRUCT";
	case duckdb::LogicalTypeId::BLOB:
		return "BLOB";
	default:
		return "NULL";
	}
}

SuccessState ShellState::RenderQueryResult(RowRenderer &renderer, duckdb::QueryResult &query_result) {
	RowResult result;
	// initialize the result and the column names
	idx_t nCol = query_result.ColumnCount();
	result.column_names.reserve(nCol);
	result.data.reserve(nCol);
	result.types.reserve(nCol);
	result.is_null.resize(nCol, false);
	for (idx_t c = 0; c < nCol; c++) {
		result.column_names.push_back(query_result.names[c]);
		result.types.push_back(query_result.types[c]);
	}
	for (auto &row : query_result) {
		if (seenInterrupt) {
			utf8_printf(out, "Interrupt\n");
			return SuccessState::FAILURE;
		}
		result.is_null.clear();
		result.is_null.resize(nCol, false);
		result.data.clear();
		for (idx_t c = 0; c < nCol; c++) {
			if (row.IsNull(c)) {
				result.is_null[c] = true;
				result.data.push_back(renderer.NullValue());
			} else {
				result.data.push_back(row.GetValue<string>(c));
			}
		}
		RenderRow(renderer, result);
	}
	renderer.RenderFooter(result);
	return SuccessState::SUCCESS;
}

void ShellState::ConvertColumnarResult(duckdb::QueryResult &res, ColumnarResult &result) {
	// fetch the column count, column names and types
	result.column_count = res.ColumnCount();
	result.data.reserve(result.column_count * 4);
	for (idx_t c = 0; c < result.column_count; c++) {
		result.data.push_back(strdup_handle_newline(res.names[c].c_str()));
		result.types.push_back(res.types[c]);
		result.type_names.push_back(GetTypeName(res.types[c]));
	}

	for (auto &row : res) {
		for (idx_t c = 0; c < result.column_count; c++) {
			auto str_val = row.GetValue<string>(c);
			result.data.push_back(strdup_handle_newline(str_val.c_str()));
		}
	}

	// compute the column widths
	for (idx_t i = 0; i < result.column_count; i++) {
		int w = i < colWidth.size() ? colWidth[i] : 0;
		if (w < 0) {
			result.right_align.push_back(true);
			w = -w;
		} else {
			result.right_align.push_back(false);
		}
		result.column_width.push_back(static_cast<idx_t>(w));
	}
	for (idx_t i = 0; i < result.data.size(); i++) {
		idx_t width = RenderLength(result.data[i]);
		idx_t column_idx = i % result.column_count;
		if (width > result.column_width[column_idx]) {
			result.column_width[column_idx] = width;
		}
	}
}

/*
** Run a prepared statement and output the result in one of the
** table-oriented formats: RenderMode::Column, RenderMode::Markdown, RenderMode::Table,
** RenderMode::Box or RenderMode::DuckBox
**
** This is different from ordinary exec_prepared_stmt() in that
** it has to run the entire query and gather the results into memory
** first, in order to determine column widths, before providing
** any output.
*/
void ShellState::RenderColumnarResult(duckdb::QueryResult &res) {
	ColumnarResult result;
	ConvertColumnarResult(res, result);

	auto column_renderer = GetColumnRenderer();
	column_renderer->RenderHeader(result);
	auto colSep = column_renderer->GetColumnSeparator();
	auto rowSep = column_renderer->GetRowSeparator();
	auto row_start = column_renderer->GetRowStart();

	for (idx_t i = result.column_count, j = 0; i < result.data.size(); i++, j++) {
		if (j == 0 && row_start) {
			Print(row_start);
		}
		idx_t w = result.column_width[j];
		bool right_align = result.right_align[j];
		UTF8WidthPrint(out, w, result.data[i], right_align);
		if (j == result.column_count - 1) {
			Print(rowSep);
			j = -1;
			if (seenInterrupt) {
				return;
			}
		} else {
			Print(colSep);
		}
	}
	column_renderer->RenderFooter(result);
}

class DuckBoxRenderer : public duckdb::BaseResultRenderer {
public:
	DuckBoxRenderer(ShellState &state, bool highlight)
	    : shell_highlight(state), output(PrintOutput::STDOUT), highlight(highlight) {
	}

	void RenderLayout(const string &text) override {
		PrintText(text, HighlightElementType::LAYOUT);
	}

	void RenderColumnName(const string &text) override {
		PrintText(text, HighlightElementType::COLUMN_NAME);
	}

	void RenderType(const string &text) override {
		PrintText(text, HighlightElementType::COLUMN_TYPE);
	}

	void RenderValue(const string &text, const duckdb::LogicalType &type) override {
		if (type.IsNumeric()) {
			PrintText(text, HighlightElementType::NUMERIC_VALUE);
		} else if (type.IsTemporal()) {
			PrintText(text, HighlightElementType::TEMPORAL_VALUE);
		} else {
			PrintText(text, HighlightElementType::STRING_VALUE);
		}
	}

	void RenderNull(const string &text, const duckdb::LogicalType &type) override {
		PrintText(text, HighlightElementType::NULL_VALUE);
	}

	void RenderFooter(const string &text) override {
		PrintText(text, HighlightElementType::FOOTER);
	}

	void PrintText(const string &text, HighlightElementType element_type) {
		if (highlight) {
			shell_highlight.PrintText(text, output, element_type);
		} else {
			utf8_printf(shell_highlight.state.out, "%s", text.c_str());
		}
	}

private:
	ShellHighlight shell_highlight;
	PrintOutput output;
	bool highlight = true;
};

SuccessState ShellState::ExecuteStatement(unique_ptr<duckdb::SQLStatement> statement) {
	if (!statement->named_param_map.empty()) {
		PrintDatabaseError("Prepared statement parameters cannot be used directly\nTo use prepared "
		                   "statement parameters, use PREPARE to prepare a statement, followed by EXECUTE");
		return SuccessState::FAILURE;
	}
	auto &con = *conn;
	unique_ptr<duckdb::QueryResult> res;
	if (ShellRenderer::IsColumnar(cMode) && cMode != RenderMode::TRASH && cMode != RenderMode::DUCKBOX) {
		// for row-wise rendering we can use streaming results
		res = con.SendQuery(std::move(statement));
	} else {
		res = con.Query(std::move(statement));
	}
	if (res->HasError()) {
		PrintDatabaseError(res->GetError());
		return SuccessState::FAILURE;
	}
	auto &properties = res->properties;
	if (properties.return_type == duckdb::StatementReturnType::CHANGED_ROWS) {
		auto result_chunk = res->Fetch();
		if (result_chunk && result_chunk->size() == 1) {
			// update total changes
			auto row_changes = result_chunk->GetValue(0, 0);
			if (!row_changes.IsNull() && row_changes.DefaultTryCastAs(duckdb::LogicalType::BIGINT)) {
				last_changes = row_changes.GetValue<int64_t>();
				total_changes += last_changes;
			}
		}
	}
	if (properties.return_type != duckdb::StatementReturnType::QUERY_RESULT) {
		// only SELECT statements return results that need to be rendered
		return SuccessState::SUCCESS;
	}
	if (ShellRenderer::IsColumnar(cMode)) {
		RenderColumnarResult(*res);
		return SuccessState::SUCCESS;
	}
	if (cMode == RenderMode::TRASH) {
		// execute the query but don't render anything
		return SuccessState::SUCCESS;
	}
	if (cMode == RenderMode::DUCKBOX) {
		return RenderDuckBoxResult(*res);
	}
	// row rendering
	auto renderer = GetRowRenderer();
	return RenderQueryResult(*renderer, *res);
}

SuccessState ShellState::RenderDuckBoxResult(duckdb::QueryResult &res) {
	DuckBoxRenderer result_renderer(*this, HighlightResults());
	try {
		duckdb::BoxRendererConfig config;
		config.max_rows = max_rows;
		config.max_width = max_width;
		if (!outfile.empty() && outfile[0] != '|') {
			config.max_rows = (size_t)-1;
			config.max_width = (size_t)-1;
		}
		LargeNumberRendering large_rendering = large_number_rendering;
		if (!stdout_is_console) {
			config.max_width = (size_t)-1;
		}
		if (large_rendering == LargeNumberRendering::DEFAULT) {
			large_rendering = stdout_is_console ? LargeNumberRendering::FOOTER : LargeNumberRendering::NONE;
		}
		config.null_value = nullValue;
		if (columns) {
			config.render_mode = duckdb::RenderMode::COLUMNS;
		}
		config.decimal_separator = decimal_separator;
		config.thousand_separator = thousand_separator;
		config.max_width = max_width;
		config.large_number_rendering = static_cast<duckdb::LargeNumberRendering>(static_cast<int>(large_rendering));
		duckdb::BoxRenderer renderer(config);
		auto &materialized = res.Cast<duckdb::MaterializedQueryResult>();
		auto &con = *conn;
		renderer.Render(*con.context, res.names, materialized.Collection(), result_renderer);
		return SuccessState::SUCCESS;
	} catch (std::exception &ex) {
		string error_str = duckdb::ErrorData(ex).Message() + "\n";
		result_renderer.RenderLayout(error_str);
		return SuccessState::FAILURE;
	}
}
/*
** Execute a statement or set of statements.  Print
** any result rows/columns depending on the current mode
** set via the supplied callback.
**
** This is very similar to SQLite's built-in sqlite3_exec()
** function except it takes a slightly different callback
** and callback data argument.
*/
SuccessState ShellState::ExecuteSQL(const string &zSql) {
	auto &con = *conn;
	try {
		auto statements = con.ExtractStatements(zSql);
		for (auto &statement : statements) {
			idx_t start_pos = statement->stmt_location;
			idx_t len = statement->stmt_length;
			while (len > 0 && IsSpace(zSql[start_pos])) {
				start_pos++;
				len--;
			}
			auto zStmtSql = zSql.substr(start_pos, len);

			/* echo the sql statement if echo on */
			if (ShellHasFlag(ShellFlags::SHFLG_Echo)) {
				utf8_printf(out, "%s\n", !zStmtSql.empty() ? zStmtSql.c_str() : zSql.c_str());
			}

			cMode = mode;
			if (statement->type == duckdb::StatementType::EXPLAIN_STATEMENT) {
				cMode = RenderMode::EXPLAIN;
			}

			ExecuteStatement(std::move(statement));
		} /* end while */
	} catch (std::exception &ex) {
		duckdb::ErrorData error(ex);
		PrintDatabaseError(error.Message());
		return SuccessState::FAILURE;
	}
	return SuccessState::SUCCESS;
}

/*
** Return a list of pointers to strings which are the names of all
** columns in table zTab.   The memory to hold the names is dynamically
** allocated and must be released by the caller using a subsequent call
** to freeColumnList().
**
** The azCol[0] entry is usually NULL.  However, if zTab contains a rowid
** value that needs to be preserved, then azCol[0] is filled in with the
** name of the rowid column.
**
** The first regular column in the table is azCol[1].  The list is terminated
** by an entry with azCol[i]==0.
*/
vector<string> ShellState::TableColumnList(const char *zTab) {
	vector<string> result;

	auto zSql = StringUtil::Format("PRAGMA table_info=%s", SQLString(zTab));
	auto &con = *conn;
	auto query_result = con.Query(zSql);
	if (query_result->HasError()) {
		return result;
	}
	for (auto &row : *query_result) {
		result.push_back(row.GetValue<string>(1));
	}
	return result;
}

/*
** Lookup the schema for a table using the information schema.
*/
static string getTableSchema(duckdb::Connection &con, const char *zTable) {
	string zSchema;
	auto zSql = StringUtil::Format("SELECT table_schema FROM information_schema.tables "
	                               "WHERE table_name = %s AND table_type='BASE TABLE' "
	                               "ORDER BY (table_schema='main') DESC LIMIT 1",
	                               SQLString(zTable));

	auto query_result = con.Query(zSql);
	if (query_result->HasError()) {
		return zSchema;
	}
	for (auto &row : *query_result) {
		zSchema = row.GetValue<string>(0);
	}
	return zSchema;
}

/*
** Build a qualified name: schema.table
*/
static string buildQualifiedName(const char *zSchema, const char *zTable) {
	return StringUtil::Format("%s.%s", SQLIdentifier(zSchema), SQLIdentifier(zTable));
}

void ShellState::AddError() {
	nErr++;
}
/*
** Run zQuery.  Use dump_callback() as the callback routine so that
** the contents of the query are output as SQL statements.
**
** If we get a SQLITE_CORRUPT error, rerun the query after appending
** "ORDER BY rowid DESC" to the end.
*/
void ShellState::RunSchemaDumpQuery(const string &zQuery) {
	auto &con = *conn;
	auto result = con.Query(zQuery);
	for (auto &row : *result) {
		auto zTable = row.GetValue<string>(0);
		auto zType = row.GetValue<string>(1);
		auto zSql = row.GetValue<string>(2);

		// print sql
		PrintSchemaLine(zSql.c_str(), ";\n");
		if (zType == "table") {
			// dump table contents
			string sSelect;
			string sTable;

			auto zSchema = getTableSchema(con, zTable.c_str());
			auto zQualifiedName = buildQualifiedName(zSchema.c_str(), zTable.c_str());

			auto table_columns = TableColumnList(zQualifiedName.c_str());
			if (table_columns.empty()) {
				AddError();
				break;
			}

			if (!zSchema.empty()) {
				sTable += zQualifiedName;
			} else {
				sTable += StringUtil::Format("%s", SQLIdentifier(zTable));
			}

			/* Build an appropriate SELECT statement */
			sSelect += "SELECT ";
			for (idx_t i = 0; i < table_columns.size(); i++) {
				if (i > 0) {
					sSelect += ", ";
				}
				sSelect += StringUtil::Format("%s", SQLIdentifier(table_columns[i]));
			}
			sSelect += " FROM ";
			sSelect += zQualifiedName;

			auto savedDestTable = zDestTable;
			auto savedMode = mode;
			zDestTable = sTable;
			mode = cMode = RenderMode::INSERT;
			auto res = ExecuteSQL(sSelect);
			zDestTable = savedDestTable;
			mode = savedMode;
			if (res != SuccessState::SUCCESS) {
				AddError();
			}
		}
	}
}

/*
** Text of help messages.
**
** The help text for each individual command begins with a line that starts
** with ".".  Subsequent lines are supplimental information.
**
** There must be two or more spaces between the end of the command and the
** start of the description of what that command does.
*/
static const char *azHelp[] = {
    ".bail on|off             Stop after hitting an error.  Default OFF",
    ".binary on|off           Turn binary output on or off.  Default OFF",
    ".cd DIRECTORY            Change the working directory to DIRECTORY",
    ".changes on|off          Show number of rows changed by SQL",
    ".check GLOB              Fail if output since .testcase does not match",
    ".columns                 Column-wise rendering of query results",
#ifdef HAVE_LINENOISE
    ".constant ?COLOR?        Sets the syntax highlighting color used for constant values",
    "   COLOR is one of:",
    "     red|green|yellow|blue|magenta|cyan|white|brightblack|brightred|brightgreen",
    "     brightyellow|brightblue|brightmagenta|brightcyan|brightwhite",
    ".constantcode ?CODE?     Sets the syntax highlighting terminal code used for constant values",
#endif
    ".databases               List names and files of attached databases",
    ".decimal_sep SEP         Sets the decimal separator used when rendering numbers. Only for duckbox mode.",
    ".dump ?TABLE?            Render database content as SQL",
    "   Options:",
    "     --newlines             Allow unescaped newline characters in output",
    "   TABLE is a LIKE pattern for the tables to dump",
    "   Additional LIKE patterns can be given in subsequent arguments",
    ".echo on|off             Turn command echo on or off",
    ".excel                   Display the output of next command in spreadsheet",
    "   --bom                   Put a UTF8 byte-order mark on intermediate file",
#ifdef HAVE_LINENOISE
    ".edit                    Opens an external text editor to edit a query.",
    "   Notes:",
    "     *  The editor is read from the environment variables",
    "        DUCKDB_EDITOR, EDITOR, VISUAL in-order",
    "     * If none of these are set, the default editor is vi",
    "   * \\e can be used as an alias for .edit",
#endif
    ".exit ?CODE?             Exit this program with return-code CODE",
    ".explain ?on|off|auto?   Change the EXPLAIN formatting mode.  Default: auto",
    ".fullschema ?--indent?   Show schema and the content of sqlite_stat tables",
    ".headers on|off          Turn display of headers on or off",
    ".help ?-all? ?PATTERN?   Show help text for PATTERN",
#ifdef HAVE_LINENOISE
    ".highlight [on|off]      Toggle syntax highlighting in the shell on/off",
#endif
    ".highlight_colors [element] [color]  ([bold])? Configure highlighting colors",
    ".highlight_errors [on|off] Toggle highlighting of errors in the shell on/off",
    ".highlight_results [on|off] Toggle highlighting of results in the shell on/off",
    ".import FILE TABLE       Import data from FILE into TABLE",
    "   Options:",
    "     --ascii               Use \\037 and \\036 as column and row separators",
    "     --csv                 Use , and \\n as column and row separators",
    "     --skip N              Skip the first N rows of input",
    "     -v                    \"Verbose\" - increase auxiliary output",
    "   Notes:",
    "     *  If TABLE does not exist, it is created.  The first row of input",
    "        determines the column names.",
    "     *  If neither --csv or --ascii are used, the input mode is derived",
    "        from the \".mode\" output mode",
    "     *  If FILE begins with \"|\" then it is a command that generates the",
    "        input text.",
    ".indexes ?TABLE?         Show names of indexes",
    "                           If TABLE is specified, only show indexes for",
    "                           tables matching TABLE using the LIKE operator.",
#ifdef HAVE_LINENOISE
    ".keyword ?COLOR?         Sets the syntax highlighting color used for keywords",
    "   COLOR is one of:",
    "     red|green|yellow|blue|magenta|cyan|white|brightblack|brightred|brightgreen",
    "     brightyellow|brightblue|brightmagenta|brightcyan|brightwhite",
    ".keywordcode ?CODE?      Sets the syntax highlighting terminal code used for keywords",
#endif
    ".large_number_rendering all|footer|off Toggle readable rendering of large numbers (duckbox only)",
    ".log FILE|off            Turn logging on or off.  FILE can be stderr/stdout",
    ".maxrows COUNT           Sets the maximum number of rows for display (default: 40). Only for duckbox mode.",
    ".maxwidth COUNT          Sets the maximum width in characters. 0 defaults to terminal width. Only for duckbox "
    "mode.",
    ".mode MODE ?TABLE?       Set output mode",
    "   MODE is one of:",
    "     ascii     Columns/rows delimited by 0x1F and 0x1E",
    "     box       Tables using unicode box-drawing characters",
    "     csv       Comma-separated values",
    "     column    Output in columns.  (See .width)",
    "     duckbox   Tables with extensive features",
    "     html      HTML <table> code",
    "     insert    SQL insert statements for TABLE",
    "     json      Results in a JSON array",
    "     jsonlines Results in a NDJSON",
    "     latex     LaTeX tabular environment code",
    "     line      One value per line",
    "     list      Values delimited by \"|\"",
    "     markdown  Markdown table format",
    "     quote     Escape answers as for SQL",
    "     table     ASCII-art table",
    "     tabs      Tab-separated values",
    "     tcl       TCL list elements",
    "     trash     No output",
    ".nullvalue STRING        Use STRING in place of NULL values",
    ".once ?OPTIONS? ?FILE?   Output for the next SQL command only to FILE",
    "     If FILE begins with '|' then open as a pipe",
    "       --bom  Put a UTF8 byte-order mark at the beginning",
    "       -e     Send output to the system text editor",
    "       -x     Send output as CSV to a spreadsheet (same as \".excel\")",
    ".open ?OPTIONS? ?FILE?   Close existing database and reopen FILE",
    "     Options:",
    "        --new           Initialize FILE to an empty database",
    "        --nofollow      Do not follow symbolic links",
    "        --readonly      Open FILE readonly",
    ".output ?FILE?           Send output to FILE or stdout if FILE is omitted",
    "   If FILE begins with '|' then open it as a pipe.",
    "   Options:",
    "     --bom                 Prefix output with a UTF8 byte-order mark",
    "     -e                    Send output to the system text editor",
    "     -x                    Send output as CSV to a spreadsheet",
    ".print STRING...         Print literal STRING",
    ".prompt MAIN CONTINUE    Replace the standard prompts",
    ".quit                    Exit this program",
    ".read FILE               Read input from FILE",
    ".rows                    Row-wise rendering of query results (default)",
    ".safe_mode               Enable safe-mode",
    ".schema ?PATTERN?        Show the CREATE statements matching PATTERN",
    "     Options:",
    "         --indent            Try to pretty-print the schema",
    ".separator COL ?ROW?     Change the column and row separators",
    ".shell CMD ARGS...       Run CMD ARGS... in a system shell",
    ".show                    Show the current values for various settings",
    ".system CMD ARGS...      Run CMD ARGS... in a system shell",
    ".tables ?TABLE?          List names of tables matching LIKE pattern TABLE",
    ".testcase NAME           Begin redirecting output to 'testcase-out.txt'",
    ".thousand_sep SEP        Sets the thousand separator used when rendering numbers. Only for duckbox mode.",
    ".timer on|off            Turn SQL timer on or off",
    ".width NUM1 NUM2 ...     Set minimum column widths for columnar output",
    "     Negative values right-justify",
#if defined(_WIN32) || defined(WIN32)
    ".utf8                    Enable experimental UTF-8 console output mode"
#endif
};

/*
** Output help text.
**
** zPattern describes the set of commands for which help text is provided.
** If zPattern is NULL, then show all commands, but only give a one-line
** description of each.
**
** Return the number of matches.
*/
static int showHelp(FILE *out, const char *zPattern) {
	int i = 0;
	int j = 0;
	int n = 0;
	string zPat;
	if (zPattern == 0 || zPattern[0] == '0' || strcmp(zPattern, "-a") == 0 || strcmp(zPattern, "-all") == 0 ||
	    strcmp(zPattern, "--all") == 0) {
		/* Show all commands, but only one line per command */
		if (zPattern == 0)
			zPattern = "";
		for (i = 0; i < ArraySize(azHelp); i++) {
			if (azHelp[i][0] == '.' || zPattern[0]) {
				utf8_printf(out, "%s\n", azHelp[i]);
				n++;
			}
		}
	} else {
		/* Look for commands that for which zPattern is an exact prefix */
		zPat = StringUtil::Format(".%s*", zPattern);
		for (i = 0; i < ArraySize(azHelp); i++) {
			if (ShellState::StringGlob(zPat.c_str(), azHelp[i]) == 0) {
				utf8_printf(out, "%s\n", azHelp[i]);
				j = i + 1;
				n++;
			}
		}
		if (n) {
			if (n == 1) {
				/* when zPattern is a prefix of exactly one command, then include the
				** details of that command, which should begin at offset j */
				while (j < ArraySize(azHelp) - 1 && azHelp[j][0] != '.') {
					utf8_printf(out, "%s\n", azHelp[j]);
					j++;
				}
			}
			return n;
		}
		/* Look for commands that contain zPattern anywhere.  Show the complete
		** text of all commands that match. */
		zPat = StringUtil::Format("%%%s%%", zPattern);
		for (i = 0; i < ArraySize(azHelp); i++) {
			if (azHelp[i][0] == '.')
				j = i;
			if (ShellState::StringLike(zPat.c_str(), azHelp[i], 0) == 0) {
				utf8_printf(out, "%s\n", azHelp[j]);
				while (j < ArraySize(azHelp) - 1 && azHelp[j + 1][0] != '.') {
					j++;
					utf8_printf(out, "%s\n", azHelp[j]);
				}
				i = j;
				n++;
			}
		}
	}
	return n;
}

SuccessState ShellState::ExecuteQuery(const string &query) {
	auto &con = *conn;
	auto res = con.Query(query);
	if (res->HasError()) {
		utf8_printf(stderr, "Failed to execute query \"%s\": %s\n", query.c_str(), res->GetError().c_str());
		return SuccessState::FAILURE;
	}
	return SuccessState::SUCCESS;
}

void ShellState::OpenDB(ShellOpenFlags flags) {
	if (!db) {
		try {
			db = make_uniq<duckdb::DuckDB>(zDbFilename.c_str(), &config);
			conn = make_uniq<duckdb::Connection>(*db);
		} catch (std::exception &ex) {
			duckdb::ErrorData error(ex);
			PrintDatabaseError(error.Message());
			if (flags == ShellOpenFlags::KEEP_ALIVE_ON_FAILURE) {
				db = make_uniq<duckdb::DuckDB>(":memory:", &config);
				conn = make_uniq<duckdb::Connection>(*db);
			} else {
				exit(1);
			}
		}
#ifdef SHELL_INLINE_AUTOCOMPLETE
		db->LoadStaticExtension<duckdb::AutocompleteExtension>();
#endif
		db->LoadStaticExtension<duckdb::ShellExtension>();
		if (safe_mode) {
			ExecuteQuery("SET enable_external_access=false");
		}
		if (stdout_is_console) {
			ExecuteQuery("PRAGMA enable_progress_bar");
			ExecuteQuery("PRAGMA enable_print_progress_bar");
		}
	}
}

#ifdef HAVE_LINENOISE
/*
** Linenoise completion callback
*/
static void linenoise_completion(const char *zLine, linenoiseCompletions *lc) {
	idx_t nLine = ShellState::StringLength(zLine);
	char zBuf[1000];

	if (nLine > sizeof(zBuf) - 30) {
		return;
	}
	if (!globalState) {
		return;
	}
	if (zLine[0] == '.') {
		// auto-complete dot command
		// look for all completions in the help file
		size_t line_idx;
		for (line_idx = 0; line_idx < ArraySize(azHelp); line_idx++) {
			const char *line = azHelp[line_idx];
			if (line[0] != '.') {
				continue;
			}
			int found_match = 1;
			size_t line_pos;
			for (line_pos = 0; !ShellState::IsSpace(line[line_pos]) && line[line_pos] && line_pos + 1 < sizeof(zBuf);
			     line_pos++) {
				zBuf[line_pos] = line[line_pos];
				if (line_pos < nLine && line[line_pos] != zLine[line_pos]) {
					// only match prefixes for auto-completion, i.e. ".sh" matches ".shell"
					found_match = 0;
					break;
				}
			}
			zBuf[line_pos] = '\0';
			if (found_match && line_pos >= nLine) {
				linenoiseAddCompletion(lc, zBuf);
			}
		}
		return;
	}
	if (zLine[0] == '#') {
		return;
	}
	//  if( i==nLine-1 ) return;
	auto zSql = StringUtil::Format("CALL sql_auto_complete(%s)", SQLString(zLine));
	unique_ptr<duckdb::DuckDB> localDB;
	unique_ptr<duckdb::Connection> localCon;

	if (!globalState->conn) {
		globalState->OpenDB();
	}
	auto &con = *globalState->conn;
	bool copiedSuggestion = false;
	auto result = con.Query(zSql);
	for (auto &row : *result) {
		auto zCompletion = row.GetValue<string>(0);
		auto nCompletion = zCompletion.size();
		idx_t iStart = row.GetValue<idx_t>(1);
		if (iStart + nCompletion < (sizeof(zBuf) - 1)) {
			if (!copiedSuggestion) {
				memcpy(zBuf, zLine, iStart);
				copiedSuggestion = true;
			}
			memcpy(zBuf + iStart, zCompletion.c_str(), nCompletion + 1);
			linenoiseAddCompletion(lc, zBuf);
		}
	}
}
#endif

/*
** Do C-language style dequoting.
**
**    \a    -> alarm
**    \b    -> backspace
**    \t    -> tab
**    \n    -> newline
**    \v    -> vertical tab
**    \f    -> form feed
**    \r    -> carriage return
**    \s    -> space
**    \"    -> "
**    \'    -> '
**    \\    -> backslash
**    \NNN  -> ascii character NNN in octal
*/
static string resolve_backslashes(const string &z) {
	string result;
	for (idx_t pos = 0; pos < z.size(); pos++) {
		auto c = z[pos];
		if (c == '\\' && pos + 1 < z.size()) {
			c = z[++pos];
			if (c == 'a') {
				c = '\a';
			} else if (c == 'b') {
				c = '\b';
			} else if (c == 't') {
				c = '\t';
			} else if (c == 'n') {
				c = '\n';
			} else if (c == 'v') {
				c = '\v';
			} else if (c == 'f') {
				c = '\f';
			} else if (c == 'r') {
				c = '\r';
			} else if (c == '"') {
				c = '"';
			} else if (c == '\'') {
				c = '\'';
			} else if (c == '\\') {
				c = '\\';
			} else if (c >= '0' && c <= '7') {
				c -= '0';
				if (pos + 1 < z.size() && z[pos + 1] >= '0' && z[pos + 1] <= '7') {
					pos++;
					c = (c << 3) + z[pos] - '0';
					if (pos + 1 < z.size() && z[pos + 1] >= '0' && z[pos + 1] <= '7') {
						pos++;
						c = (c << 3) + z[pos] - '0';
					}
				}
			}
		}
		result += c;
	}
	return result;
}

/*
** Interpret zArg as either an integer or a boolean value.  Return 1 or 0
** for TRUE and FALSE.  Return the integer value if appropriate.
*/
static bool booleanValue(const string &zArg) {
	idx_t i;
	if (zArg[0] == '0' && zArg[1] == 'x') {
		for (i = 2; hexDigitValue(zArg[i]) >= 0; i++) {
		}
	} else {
		for (i = 0; zArg[i] >= '0' && zArg[i] <= '9'; i++) {
		}
	}
	if (i > 0 && zArg[i] == 0) {
		return bool(ShellState::StringToInt(zArg) & 0xffffffff);
	}
	if (StringUtil::CIEquals(zArg, "on") || StringUtil::CIEquals(zArg, "yes")) {
		return true;
	}
	if (StringUtil::CIEquals(zArg, "off") || StringUtil::CIEquals(zArg, "no")) {
		return false;
	}
	utf8_printf(stderr, "ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n", zArg.c_str());
	return false;
}

/*
** Set or clear a shell flag according to a boolean value.
*/
void ShellState::SetOrClearFlag(ShellFlags mFlag, const string &zArg) {
	if (booleanValue(zArg)) {
		ShellSetFlag(mFlag);
	} else {
		ShellClearFlag(mFlag);
	}
}

/*
** Close an output file, assuming it is not stderr or stdout
*/
static void output_file_close(FILE *f) {
	if (f && f != stdout && f != stderr)
		fclose(f);
}

/*
** Try to open an output file.   The names "stdout" and "stderr" are
** recognized and do the right thing.  NULL is returned if the output
** filename is "off".
*/
static FILE *output_file_open(const char *zFile, int bTextMode) {
	FILE *f = nullptr;
	if (strcmp(zFile, "stdout") == 0) {
		f = stdout;
	} else if (strcmp(zFile, "stderr") == 0) {
		f = stderr;
	} else if (strcmp(zFile, "off") == 0) {
		f = 0;
	} else {
		const string expanded_path = duckdb::FileSystem::ExpandPath(zFile, /*opener=*/nullptr);
		f = fopen(expanded_path.c_str(), bTextMode ? "w" : "wb");
		if (f == 0) {
			utf8_printf(stderr, "Error: cannot open \"%s\"\n", zFile);
		}
	}
	return f;
}

/*
** An object used to read a CSV and other files for import.
*/
typedef struct ImportCtx ImportCtx;
struct ImportCtx {
	const char *zFile;      /* Name of the input file */
	FILE *in;               /* Read the CSV text from this input stream */
	int (*xCloser)(FILE *); /* Func to close in */
	string z;
	int nLine;     /* Current line number */
	int nRow;      /* Number of rows imported */
	int nErr;      /* Number of errors encountered */
	int bNotFirst; /* True if one or more bytes already read */
	int cTerm;     /* Character that terminated the most recent field */
	int cColSep;   /* The column separator character.  (Usually ",") */
	int cRowSep;   /* The row separator character.  (Usually "\n") */

	void AddError() {
		nErr++;
	}
};

/* Clean up resourced used by an ImportCtx */
static void import_cleanup(ImportCtx *p) {
	if (p->in != 0 && p->xCloser != 0) {
		p->xCloser(p->in);
		p->in = 0;
	}
	p->z = string();
}

/* Append a single byte to z[] */
static void import_append_char(ImportCtx *p, int c) {
	p->z += char(c);
}

/* Read a single field of CSV text.  Compatible with rfc4180 and extended
** with the option of having a separator other than ",".
**
**   +  Input comes from p->in.
**   +  Store results in p->z of length p->n.  Space to hold p->z comes
**      from sqlite3_malloc64().
**   +  Use p->cSep as the column separator.  The default is ",".
**   +  Use p->rSep as the row separator.  The default is "\n".
**   +  Keep track of the line number in p->nLine.
**   +  Store the character that terminates the field in p->cTerm.  Store
**      EOF on end-of-file.
**   +  Report syntax errors on stderr
*/
static const char *csv_read_one_field(ImportCtx *p) {
	int c;
	int cSep = p->cColSep;
	int rSep = p->cRowSep;
	p->z.clear();
	c = fgetc(p->in);
	if (c == EOF || seenInterrupt) {
		p->cTerm = EOF;
		return 0;
	}
	if (c == '"') {
		int pc, ppc;
		int startLine = p->nLine;
		int cQuote = c;
		pc = ppc = 0;
		while (1) {
			c = fgetc(p->in);
			if (c == rSep)
				p->nLine++;
			if (c == cQuote) {
				if (pc == cQuote) {
					pc = 0;
					continue;
				}
			}
			if ((c == cSep && pc == cQuote) || (c == rSep && pc == cQuote) ||
			    (c == rSep && pc == '\r' && ppc == cQuote) || (c == EOF && pc == cQuote)) {
				do {
					p->z.pop_back();
				} while (!p->z.empty() && p->z.back() != cQuote);
				p->cTerm = c;
				break;
			}
			if (pc == cQuote && c != '\r') {
				utf8_printf(stderr, "%s:%d: unescaped %c character\n", p->zFile, p->nLine, cQuote);
			}
			if (c == EOF) {
				utf8_printf(stderr, "%s:%d: unterminated %c-quoted field\n", p->zFile, startLine, cQuote);
				p->cTerm = c;
				break;
			}
			import_append_char(p, c);
			ppc = pc;
			pc = c;
		}
	} else {
		/* If this is the first field being parsed and it begins with the
		** UTF-8 BOM  (0xEF BB BF) then skip the BOM */
		if ((c & 0xff) == 0xef && p->bNotFirst == 0) {
			import_append_char(p, c);
			c = fgetc(p->in);
			if ((c & 0xff) == 0xbb) {
				import_append_char(p, c);
				c = fgetc(p->in);
				if ((c & 0xff) == 0xbf) {
					p->bNotFirst = 1;
					p->z.clear();
					return csv_read_one_field(p);
				}
			}
		}
		while (c != EOF && c != cSep && c != rSep) {
			import_append_char(p, c);
			c = fgetc(p->in);
		}
		if (c == rSep) {
			p->nLine++;
			if (!p->z.empty() && p->z.back() == '\r')
				p->z.pop_back();
		}
		p->cTerm = c;
	}
	p->bNotFirst = 1;
	return p->z.c_str();
}

/* Read a single field of ASCII delimited text.
**
**   +  Input comes from p->in.
**   +  Store results in p->z of length p->n.  Space to hold p->z comes
**      from sqlite3_malloc64().
**   +  Use p->cSep as the column separator.  The default is "\x1F".
**   +  Use p->rSep as the row separator.  The default is "\x1E".
**   +  Keep track of the row number in p->nLine.
**   +  Store the character that terminates the field in p->cTerm.  Store
**      EOF on end-of-file.
**   +  Report syntax errors on stderr
*/
static const char *ascii_read_one_field(ImportCtx *p) {
	int c;
	int cSep = p->cColSep;
	int rSep = p->cRowSep;
	p->z.clear();
	c = fgetc(p->in);
	if (c == EOF || seenInterrupt) {
		p->cTerm = EOF;
		return nullptr;
	}
	while (c != EOF && c != cSep && c != rSep) {
		import_append_char(p, c);
		c = fgetc(p->in);
	}
	if (c == rSep) {
		p->nLine++;
	}
	p->cTerm = c;
	return p->z.c_str();
}

/*
** Change the output file back to stdout.
**
** If the p->doXdgOpen flag is set, that means the output was being
** redirected to a temporary file named by p->zTempFile.  In that case,
** launch start/open/xdg-open on that temporary file.
*/
void ShellState::ResetOutput() {
	if (outfile.size() > 1 && outfile[0] == '|') {
#ifndef SQLITE_OMIT_POPEN
		pclose(out);
#endif
	} else {
		output_file_close(out);
#ifndef SQLITE_NOHAVE_SYSTEM
		if (doXdgOpen) {
			const char *zXdgOpenCmd =
#if defined(_WIN32)
			    "start";
#elif defined(__APPLE__)
			    "open";
#else
			    "xdg-open";
#endif
			auto zCmd = StringUtil::Format("%s %s", zXdgOpenCmd, zTempFile);
			if (system(zCmd.c_str())) {
				utf8_printf(stderr, "Failed: [%s]\n", zCmd.c_str());
			} else {
				/* Give the start/open/xdg-open command some time to get
				** going before we continue, and potential delete the
				** zTempFile data file out from under it */
				Sleep(2000);
			}
			PopOutputMode();
			doXdgOpen = 0;
		}
#endif /* !defined(SQLITE_NOHAVE_SYSTEM) */
	}
	outfile = string();
	out = stdout;
	stdout_is_console = true;
}

void ShellState::PrintDatabaseError(const string &zErr) {
	if (!HighlightErrors()) {
		utf8_printf(stderr, "%s\n", zErr.c_str());
		return;
	}
	ShellHighlight shell_highlight(*this);
	shell_highlight.PrintError(zErr);
}

/*
** Compare the string as a command-line option with either one or two
** initial "-" characters.
*/
static bool optionMatch(const string &str, const string &zOpt) {
	auto zStr = str.c_str();
	if (zStr[0] != '-') {
		return false;
	}
	zStr++;
	if (zStr[0] == '-') {
		zStr++;
	}
	return StringUtil::Equals(zStr, zOpt);
}

/*
** Delete a file.
*/
int shellDeleteFile(const char *zFilename) {
	int rc;
#ifdef _WIN32
	auto z = ShellState::Win32Utf8ToUnicode(zFilename);
	rc = _wunlink((wchar_t *)z.get());
#else
	rc = unlink(zFilename);
#endif
	return rc;
}

/*
** Try to delete the temporary file (if there is one) and free the
** memory used to hold the name of the temp file.
*/
void ShellState::ClearTempFile() {
	if (!zTempFile.empty()) {
		return;
	}
	if (doXdgOpen) {
		return;
	}
	if (shellDeleteFile(zTempFile.c_str())) {
		return;
	}
	zTempFile = string();
}

/*
** Create a new temp file name with the given suffix.
*/
void ShellState::NewTempFile(const char *zSuffix) {
	ClearTempFile();
	zTempFile = string();
	if (zTempFile.empty()) {
		/* If db is an in-memory database then the TEMPFILENAME file-control
		** will not work and we will need to fallback to guessing */
		const char *zTemp;
		uint64_t r;
		GenerateRandomBytes(sizeof(r), &r);
		zTemp = getenv("TEMP");
		if (zTemp == 0)
			zTemp = getenv("TMP");
		if (zTemp == 0) {
#ifdef _WIN32
			zTemp = "\\tmp";
#else
			zTemp = "/tmp";
#endif
		}
		zTempFile = StringUtil::Format("%s/temp%llx.%s", zTemp, r, zSuffix);
	} else {
		zTempFile = StringUtil::Format("%z.%s", zTempFile, zSuffix);
	}
	if (zTempFile.empty()) {
		raw_printf(stderr, "out of memory\n");
		exit(1);
	}
}

enum class MetadataResult : uint8_t { SUCCESS = 0, FAIL = 1, EXIT = 2, PRINT_USAGE = 3 };

typedef MetadataResult (*metadata_command_t)(ShellState &state, const vector<string> &args);

struct MetadataCommand {
	const char *command;
	idx_t argument_count;
	metadata_command_t callback;
	const char *usage;
	const char *description;
	idx_t match_size;
};

MetadataResult ToggleBail(ShellState &state, const vector<string> &args) {
	bail_on_error = booleanValue(args[1]);
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleBinary(ShellState &state, const vector<string> &args) {
	if (booleanValue(args[1])) {
		state.SetBinaryMode();
	} else {
		state.SetTextMode();
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ChangeDirectory(ShellState &state, const vector<string> &args) {
	if (safe_mode) {
		utf8_printf(stderr, ".cd cannot be used in -safe mode\n");
		return MetadataResult::FAIL;
	}
	int rc;
#if defined(_WIN32) || defined(WIN32)
	auto z = ShellState::Win32Utf8ToUnicode(args[1].c_str());
	rc = !SetCurrentDirectoryW((wchar_t *)z.get());
#else
	rc = chdir(args[1].c_str());
#endif
	if (rc) {
		utf8_printf(stderr, "Cannot change to directory \"%s\"\n", args[1].c_str());
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleChanges(ShellState &state, const vector<string> &args) {
	state.SetOrClearFlag(ShellFlags::SHFLG_CountChanges, args[1]);
	return MetadataResult::SUCCESS;
}

MetadataResult ShowDatabases(ShellState &state, const vector<string> &args) {
	state.OpenDB();

	auto renderer = state.GetRowRenderer(RenderMode::LIST);
	renderer->show_header = false;
	renderer->col_sep = ": ";
	auto res = state.RenderQuery(*renderer, "SELECT name, file FROM pragma_database_list");
	if (res == SuccessState::FAILURE) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetSeparator(ShellState &state, const vector<string> &args, const char *separator_name,
                            char &separator) {
	if (args.size() == 1) {
		raw_printf(state.out, "current %s separator: %c\n", separator_name, separator);
	} else if (args.size() != 2) {
		return MetadataResult::PRINT_USAGE;
	} else if (StringUtil::Equals(args[1], "space")) {
		separator = ' ';
	} else if (StringUtil::Equals(args[1], "none")) {
		separator = '\0';
	} else if (args[1].size() != 1) {
		raw_printf(stderr, ".%s_sep SEP must be one byte, \"space\" or \"none\"\n", separator_name);
		return MetadataResult::FAIL;
	} else {
		separator = args[1][0];
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetDecimalSep(ShellState &state, const vector<string> &args) {
	return SetSeparator(state, args, "decimal", state.decimal_separator);
}

MetadataResult SetThousandSep(ShellState &state, const vector<string> &args) {
	return SetSeparator(state, args, "thousand", state.thousand_separator);
}

MetadataResult SetLargeNumberRendering(ShellState &state, const vector<string> &args) {
	if (StringUtil::Equals(args[1], "all")) {
		state.large_number_rendering = LargeNumberRendering::ALL;
	} else if (StringUtil::Equals(args[1], "footer")) {
		state.large_number_rendering = LargeNumberRendering::FOOTER;
	} else {
		if (booleanValue(args[1])) {
			state.large_number_rendering = LargeNumberRendering::DEFAULT;
		} else {
			state.large_number_rendering = LargeNumberRendering::NONE;
		}
	}
	return MetadataResult::SUCCESS;
}

MetadataResult DumpTable(ShellState &state, const vector<string> &args) {
	string zLike;
	bool savedShowHeader = state.showHeader;
	int savedShellFlags = state.shellFlgs;
	state.ShellClearFlag(ShellFlags::SHFLG_Newlines);
	state.ShellClearFlag(ShellFlags::SHFLG_Echo);
	for (idx_t i = 1; i < args.size(); i++) {
		if (args[i][0] == '-') {
			const char *z = args[i].c_str() + 1;
			if (z[0] == '-')
				z++;
			if (StringUtil::Equals(z, "newlines")) {
				state.ShellSetFlag(ShellFlags::SHFLG_Newlines);
			} else {
				raw_printf(stderr, "Unknown option \"%s\" on \".dump\"\n", args[i].c_str());
				return MetadataResult::FAIL;
			}
		} else if (!zLike.empty()) {
			zLike = StringUtil::Format("%s OR name LIKE %s ESCAPE '\\'", zLike, SQLString(args[i]));
		} else {
			zLike = StringUtil::Format("name LIKE %s ESCAPE '\\'", SQLString(args[i]));
		}
	}

	state.OpenDB();

	/* When playing back a "dump", the content might appear in an order
	** which causes immediate foreign key constraints to be violated.
	** So disable foreign-key constraint enforcement to prevent problems. */
	raw_printf(state.out, "BEGIN TRANSACTION;\n");
	state.showHeader = 0;
	state.nErr = 0;
	if (zLike.empty()) {
		zLike = "true";
	}

	// Emit CREATE SCHEMA for non-main schemas first
	auto zSql = StringUtil::Format("SELECT DISTINCT table_schema FROM information_schema.tables "
	                               "WHERE table_schema != 'main' AND table_schema NOT LIKE 'pg_%%' "
	                               "AND table_schema != 'information_schema' "
	                               "AND table_name IN (SELECT name FROM sqlite_schema WHERE (%s) AND type=='table') "
	                               "ORDER BY table_schema",
	                               zLike);
	auto result = state.conn->Query(zSql);
	for (auto &row : *result) {
		auto schema = row.GetValue<string>(0);
		auto create_schema = StringUtil::Format("CREATE SCHEMA IF NOT EXISTS %s;", SQLIdentifier(schema));
		raw_printf(state.out, "%s;\n", create_schema.c_str());
	}

	zSql = StringUtil::Format("SELECT name, type, sql FROM sqlite_schema "
	                          "WHERE (%s) AND type=='table'"
	                          "  AND sql NOT NULL"
	                          " ORDER BY tbl_name='sqlite_sequence'",
	                          zLike);
	state.RunSchemaDumpQuery(zSql);
	zSql = StringUtil::Format("SELECT sql FROM sqlite_schema "
	                          "WHERE (%s) AND sql NOT NULL"
	                          "  AND type IN ('index','trigger','view')",
	                          zLike);
	state.RunTableDumpQuery(zSql);
	raw_printf(state.out, state.nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");
	state.showHeader = savedShowHeader;
	state.shellFlgs = savedShellFlags;
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleEcho(ShellState &state, const vector<string> &args) {
	state.SetOrClearFlag(ShellFlags::SHFLG_Echo, args[1]);
	return MetadataResult::SUCCESS;
}

MetadataResult ExitProcess(ShellState &state, const vector<string> &args) {
	if (args.size() > 2) {
		return MetadataResult::PRINT_USAGE;
	}
	int rc = 0;
	if (args.size() > 1 && (rc = (int)ShellState::StringToInt(args[1])) != 0) {
		// exit immediately if a custom error code is provided
		exit(rc);
	}
	return MetadataResult::EXIT;
}

MetadataResult ToggleHeaders(ShellState &state, const vector<string> &args) {
	state.showHeader = booleanValue(args[1]);
	state.ShellSetFlag(ShellFlags::SHFLG_HeaderSet);
	return MetadataResult::SUCCESS;
}

MetadataResult SetHighlightColors(ShellState &state, const vector<string> &args) {
	if (args.size() < 3 || args.size() > 4) {
		return MetadataResult::PRINT_USAGE;
	}
	ShellHighlight highlighter(state);
	if (!highlighter.SetColor(args[1].c_str(), args[2].c_str(), args.size() == 3 ? nullptr : args[3].c_str())) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleHighlighErrors(ShellState &state, const vector<string> &args) {
	highlight_errors = booleanValue(args[1]) ? OptionType::ON : OptionType::OFF;
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleHighlightResult(ShellState &state, const vector<string> &args) {
	highlight_results = booleanValue(args[1]) ? OptionType::ON : OptionType::OFF;
	return MetadataResult::SUCCESS;
}

MetadataResult ShowHelp(ShellState &state, const vector<string> &args) {
	if (args.size() >= 2) {
		int n = showHelp(state.out, args[1].c_str());
		if (n == 0) {
			utf8_printf(state.out, "Nothing matches '%s'\n", args[1].c_str());
		}
	} else {
		showHelp(state.out, 0);
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleLog(ShellState &state, const vector<string> &args) {
	if (safe_mode) {
		utf8_printf(stderr, ".log cannot be used in -safe mode\n");
		return MetadataResult::FAIL;
	}
	const char *zFile = args[1].c_str();
	output_file_close(state.pLog);
	state.pLog = output_file_open(zFile, 0);
	return MetadataResult::SUCCESS;
}

MetadataResult SetMaxRows(ShellState &state, const vector<string> &args) {
	if (args.size() > 2) {
		return MetadataResult::PRINT_USAGE;
	}
	if (args.size() == 1) {
		raw_printf(state.out, "current max rows: %zu\n", state.max_rows);
	} else {
		state.max_rows = (size_t)ShellState::StringToInt(args[1]);
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetMaxWidth(ShellState &state, const vector<string> &args) {
	if (args.size() > 2) {
		return MetadataResult::PRINT_USAGE;
	}
	if (args.size() == 1) {
		raw_printf(state.out, "current max rows: %zu\n", state.max_width);
	} else {
		state.max_width = (size_t)ShellState::StringToInt(args[1]);
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetColumnRendering(ShellState &state, const vector<string> &args) {
	state.columns = 1;
	return MetadataResult::SUCCESS;
}

MetadataResult SetRowRendering(ShellState &state, const vector<string> &args) {
	state.columns = 0;
	return MetadataResult::SUCCESS;
}

MetadataResult EnableSafeMode(ShellState &state, const vector<string> &args) {
	safe_mode = true;
	if (state.db) {
		// db has been opened - disable external access
		state.ExecuteQuery("SET enable_external_access=false");
	}
	return MetadataResult::SUCCESS;
}

bool ShellState::SetOutputMode(const string &mode_name, const char *tbl_name) {
	auto mode_str = mode_name.c_str();
	idx_t n2 = mode_name.size();
	char c2 = mode_str[0];
	if (tbl_name && !(c2 == 'i' && strncmp(mode_str, "insert", n2) == 0)) {
		raw_printf(stderr, "TABLE argument can only be used with .mode insert");
		return false;
	}
	if (c2 == 'l' && n2 > 2 && strncmp(mode_str, "lines", n2) == 0) {
		mode = RenderMode::LINE;
		rowSeparator = SEP_Row;
	} else if (c2 == 'c' && strncmp(mode_str, "columns", n2) == 0) {
		mode = RenderMode::COLUMN;
		if (ShellHasFlag(ShellFlags::SHFLG_HeaderSet)) {
			showHeader = true;
		}
		rowSeparator = SEP_Row;
	} else if (c2 == 'l' && n2 > 2 && strncmp(mode_str, "list", n2) == 0) {
		mode = RenderMode::LIST;
		colSeparator = SEP_Column;
		rowSeparator = SEP_Row;
	} else if (c2 == 'h' && strncmp(mode_str, "html", n2) == 0) {
		mode = RenderMode::HTML;
	} else if (c2 == 't' && strncmp(mode_str, "tcl", n2) == 0) {
		mode = RenderMode::TCL;
		colSeparator = SEP_Space;
		rowSeparator = SEP_Row;
	} else if (c2 == 'c' && strncmp(mode_str, "csv", n2) == 0) {
		mode = RenderMode::CSV;
		colSeparator = SEP_Comma;
		rowSeparator = SEP_CrLf;
	} else if (c2 == 't' && strncmp(mode_str, "tabs", n2) == 0) {
		mode = RenderMode::LIST;
		colSeparator = SEP_Tab;
	} else if (c2 == 'i' && strncmp(mode_str, "insert", n2) == 0) {
		mode = RenderMode::INSERT;
		SetTableName(tbl_name ? tbl_name : "table");
	} else if (c2 == 'q' && strncmp(mode_str, "quote", n2) == 0) {
		mode = RenderMode::QUOTE;
		colSeparator = SEP_Comma;
		rowSeparator = SEP_Row;
	} else if (c2 == 'a' && strncmp(mode_str, "ascii", n2) == 0) {
		mode = RenderMode::ASCII;
		colSeparator = SEP_Unit;
		rowSeparator = SEP_Record;
	} else if (c2 == 'm' && strncmp(mode_str, "markdown", n2) == 0) {
		mode = RenderMode::MARKDOWN;
	} else if (c2 == 't' && strncmp(mode_str, "table", n2) == 0) {
		mode = RenderMode::TABLE;
	} else if (c2 == 'b' && strncmp(mode_str, "box", n2) == 0) {
		mode = RenderMode::BOX;
	} else if (c2 == 'd' && strncmp(mode_str, "duckbox", n2) == 0) {
		mode = RenderMode::DUCKBOX;
	} else if (c2 == 'j' && strncmp(mode_str, "json", n2) == 0) {
		mode = RenderMode::JSON;
	} else if (c2 == 'l' && strncmp(mode_str, "latex", n2) == 0) {
		mode = RenderMode::LATEX;
	} else if (c2 == 't' && strncmp(mode_str, "trash", n2) == 0) {
		mode = RenderMode::TRASH;
	} else if (c2 == 'j' && strncmp(mode_str, "jsonlines", n2) == 0) {
		mode = RenderMode::JSONLINES;
	} else {
		raw_printf(stderr, "Error: mode should be one of: "
		                   "ascii box column csv duckbox html insert json jsonlines latex line "
		                   "list markdown quote table tabs tcl trash \n");
		return false;
	}
	cMode = mode;
	return true;
}

MetadataResult SetOutputMode(ShellState &state, const vector<string> &args) {
	if (args.size() > 3) {
		return MetadataResult::PRINT_USAGE;
	}
	if (args.size() == 1) {
		raw_printf(state.out, "current output mode: %s\n", modeDescr[int(state.mode)]);
	} else {
		if (!state.SetOutputMode(args[1], args.size() > 2 ? args[2].c_str() : nullptr)) {
			return MetadataResult::FAIL;
		}
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetNullValue(ShellState &state, const vector<string> &args) {
	state.nullValue = args[1];
	return MetadataResult::SUCCESS;
}

bool ShellState::ImportData(const vector<string> &args) {
	if (safe_mode) {
		utf8_printf(stderr, ".import cannot be used in -safe mode\n");
		return false;
	}
	const char *zTable = nullptr;      /* Insert data into this table */
	const char *zFile = nullptr;       /* Name of file to extra content from */
	ImportCtx sCtx;                    /* Reader context */
	const char *(*xRead)(ImportCtx *); /* Func to read one value */
	int eVerbose = 0;                  /* Larger for more console output */
	int nSkip = 0;                     /* Initial lines to skip */
	int useOutputMode = 1;             /* Use output mode to determine separators */

	memset(&sCtx, 0, sizeof(sCtx));
	if (mode == RenderMode::ASCII) {
		xRead = ascii_read_one_field;
	} else {
		xRead = csv_read_one_field;
	}
	for (idx_t i = 1; i < args.size(); i++) {
		auto z = args[i].c_str();
		if (z[0] == '-' && z[1] == '-') {
			z++;
		}
		if (z[0] != '-') {
			if (zFile == nullptr) {
				zFile = z;
			} else if (zTable == nullptr) {
				zTable = z;
			} else {
				utf8_printf(out, "ERROR: extra argument: \"%s\".  Usage:\n", z);
				showHelp(out, "import");
				return false;
			}
		} else if (strcmp(z, "-v") == 0) {
			eVerbose++;
		} else if (strcmp(z, "-skip") == 0 && i < args.size() - 1) {
			nSkip = (int)StringToInt(args[++i]);
		} else if (strcmp(z, "-ascii") == 0) {
			sCtx.cColSep = SEP_Unit[0];
			sCtx.cRowSep = SEP_Record[0];
			xRead = ascii_read_one_field;
			useOutputMode = 0;
		} else if (strcmp(z, "-csv") == 0) {
			sCtx.cColSep = ',';
			sCtx.cRowSep = '\n';
			xRead = csv_read_one_field;
			useOutputMode = 0;
		} else {
			utf8_printf(out, "ERROR: unknown option: \"%s\".  Usage:\n", z);
			showHelp(out, "import");
			return false;
		}
	}
	if (zTable == 0) {
		utf8_printf(out, "ERROR: missing %s argument. Usage:\n", zFile == 0 ? "FILE" : "TABLE");
		showHelp(out, "import");
		return false;
	}
	seenInterrupt = 0;
	OpenDB();
	if (useOutputMode) {
		/* If neither the --csv or --ascii options are specified, then set
		** the column and row separator characters from the output mode. */
		int nSep = colSeparator.size();
		if (nSep == 0) {
			raw_printf(stderr, "Error: non-null column separator required for import\n");
			return false;
		}
		if (nSep > 1) {
			raw_printf(stderr, "Error: multi-character column separators not allowed"
			                   " for import\n");
			return false;
		}
		nSep = rowSeparator.size();
		if (nSep == 0) {
			raw_printf(stderr, "Error: non-null row separator required for import\n");
			return false;
		}
		if (nSep == 2 && mode == RenderMode::CSV && rowSeparator == SEP_CrLf) {
			/* When importing CSV (only), if the row separator is set to the
			** default output row separator, change it to the default input
			** row separator.  This avoids having to maintain different input
			** and output row separators. */
			rowSeparator = SEP_Row;
			nSep = rowSeparator.size();
		}
		if (nSep > 1) {
			raw_printf(stderr, "Error: multi-character row separators not allowed"
			                   " for import\n");
			return false;
		}
		sCtx.cColSep = colSeparator[0];
		sCtx.cRowSep = rowSeparator[0];
	}
	sCtx.zFile = zFile;
	sCtx.nLine = 1;
	if (sCtx.zFile[0] == '|') {
#ifdef SQLITE_OMIT_POPEN
		raw_printf(stderr, "Error: pipes are not supported in this OS\n");
		rc = 1;
		goto meta_command_exit;
#else
		sCtx.in = popen(sCtx.zFile + 1, "r");
		sCtx.zFile = "<pipe>";
		sCtx.xCloser = pclose;
#endif
	} else {
		sCtx.in = fopen(sCtx.zFile, "rb");
		sCtx.xCloser = fclose;
	}
	if (sCtx.in == 0) {
		utf8_printf(stderr, "Error: cannot open \"%s\"\n", zFile);
		return false;
	}
	if (eVerbose >= 2 || (eVerbose >= 1 && useOutputMode)) {
		char zSep[2];
		zSep[1] = 0;
		zSep[0] = sCtx.cColSep;
		utf8_printf(out, "Column separator ");
		OutputCString(zSep);
		utf8_printf(out, ", row separator ");
		zSep[0] = sCtx.cRowSep;
		OutputCString(zSep);
		utf8_printf(out, "\n");
	}
	while ((nSkip--) > 0) {
		while (xRead(&sCtx) && sCtx.cTerm == sCtx.cColSep) {
		}
	}
	// check if the table exists
	auto &con = *conn;
	auto needCommit = con.context->transaction.IsAutoCommit();
	if (needCommit) {
		ExecuteQuery("BEGIN");
	}
	auto table_info = con.TableInfo(zTable);

	import_append_char(&sCtx, 0); /* To ensure sCtx.z is allocated */
	idx_t nCol;
	if (!table_info) {
		// table does not exist - read the first line and create it based on the row values in the first line
		string zCreate = "CREATE TABLE ";
		zCreate += zTable;
		char cSep = '(';
		nCol = 0;
		while (xRead(&sCtx)) {
			zCreate += cSep;
			zCreate += "\"";
			zCreate += sCtx.z;
			zCreate += "\"";
			zCreate += " TEXT";
			cSep = ',';
			nCol++;
			if (sCtx.cTerm != sCtx.cColSep) {
				break;
			}
		}
		if (nCol == 0) {
			import_cleanup(&sCtx);
			utf8_printf(stderr, "%s: empty file\n", sCtx.zFile);
			return false;
		}
		zCreate += "\n)";
		if (eVerbose >= 1) {
			utf8_printf(out, "%s\n", zCreate.c_str());
		}
		auto res = ExecuteQuery(zCreate);
		if (res == SuccessState::FAILURE) {
			import_cleanup(&sCtx);
			return false;
		}
	} else {
		nCol = table_info->columns.size();
	}
	string zSql = StringUtil::Format("INSERT INTO %s VALUES(?", SQLIdentifier(zTable));
	for (idx_t i = 1; i < nCol; i++) {
		zSql += ",?";
	}
	zSql += ")";
	if (eVerbose >= 2) {
		utf8_printf(out, "Insert using: %s\n", zSql.c_str());
	}
	auto prepared = con.Prepare(zSql);
	if (prepared->HasError()) {
		PrintDatabaseError(prepared->GetError());
		import_cleanup(&sCtx);
		return false;
	}
	do {
		duckdb::vector<duckdb::Value> bind_values;
		int startLine = sCtx.nLine;
		int i;
		for (i = 0; i < nCol; i++) {
			const char *z = xRead(&sCtx);
			/*
			** Did we reach end-of-file before finding any columns?
			** If so, stop instead of NULL filling the remaining columns.
			*/
			if (z == nullptr && i == 0) {
				break;
			}
			/*
			** Did we reach end-of-file OR end-of-line before finding any
			** columns in ASCII mode?  If so, stop instead of NULL filling
			** the remaining columns.
			*/
			if (mode == RenderMode::ASCII && (z == nullptr || z[0] == 0) && i == 0) {
				break;
			}
			if (!duckdb::Value::StringIsValid(z, strlen(z))) {
				bind_values.emplace_back();
			} else {
				bind_values.emplace_back(z);
			}
			if (i < nCol - 1 && sCtx.cTerm != sCtx.cColSep) {
				utf8_printf(stderr,
				            "%s:%d: expected %llu columns but found %d - "
				            "filling the rest with NULL\n",
				            sCtx.zFile, startLine, nCol, i + 1);
				i += 2;
				while (i <= nCol) {
					bind_values.emplace_back();
					i++;
				}
			}
		}
		if (sCtx.cTerm == sCtx.cColSep) {
			do {
				xRead(&sCtx);
				i++;
			} while (sCtx.cTerm == sCtx.cColSep);
			utf8_printf(stderr,
			            "%s:%d: expected %llu columns but found %d - "
			            "extras ignored\n",
			            sCtx.zFile, startLine, nCol, i);
		}
		if (i >= nCol) {
			auto result = prepared->Execute(bind_values);
			if (result->HasError()) {
				utf8_printf(stderr, "%s:%d: INSERT failed: %s\n", sCtx.zFile, startLine, result->GetError().c_str());
				sCtx.AddError();
			} else {
				sCtx.nRow++;
			}
		}
	} while (sCtx.cTerm != EOF);

	prepared.reset();
	import_cleanup(&sCtx);
	if (needCommit) {
		ExecuteQuery("COMMIT");
	}
	if (eVerbose > 0) {
		utf8_printf(out, "Added %d rows with %d errors using %d lines of input\n", sCtx.nRow, sCtx.nErr,
		            sCtx.nLine - 1);
	}
	return true;
}

MetadataResult ImportData(ShellState &state, const vector<string> &args) {
	if (!state.ImportData(args)) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

bool ShellState::OpenDatabase(const vector<string> &args) {
	if (safe_mode) {
		utf8_printf(stderr, ".open cannot be used in -safe mode\n");
		return false;
	}
	string zNewFilename;  /* Name of the database file to open */
	idx_t iName = 1;      /* Index in azArg[] of the filename */
	bool newFlag = false; /* True to delete file before opening */
	/* Close the existing database */
	db.reset();
	conn.reset();
	zDbFilename = string();
	szMax = 0;
	/* Check for command-line arguments */
	config.options.access_mode = duckdb::AccessMode::READ_WRITE;
	for (iName = 1; iName < args.size() && args[iName][0] == '-'; iName++) {
		const char *z = args[iName].c_str();
		if (optionMatch(z, "new")) {
			newFlag = true;
		} else if (optionMatch(z, "readonly")) {
			config.options.access_mode = duckdb::AccessMode::READ_ONLY;
		} else if (optionMatch(z, "nofollow")) {
		} else if (z[0] == '-') {
			utf8_printf(stderr, "unknown option: %s\n", z);
			return false;
		}
	}
	/* If a filename is specified, try to open it first */
	if (args.size() > iName) {
		zNewFilename = args[iName];
	}
	if (!zNewFilename.empty()) {
		if (newFlag) {
			shellDeleteFile(zNewFilename.c_str());
		}
		zDbFilename = zNewFilename;
		OpenDB(ShellOpenFlags::KEEP_ALIVE_ON_FAILURE);
		if (!db) {
			utf8_printf(stderr, "Error: cannot open '%s'\n", zNewFilename.c_str());
		}
	}
	if (!db) {
		/* As a fall-back open a TEMP database */
		zDbFilename = string();
		OpenDB();
	}
	return true;
}

MetadataResult OpenDatabase(ShellState &state, const vector<string> &args) {
	if (!state.OpenDatabase(args)) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult PrintArguments(ShellState &state, const vector<string> &args) {
	for (idx_t i = 1; i < args.size(); i++) {
		if (i > 1) {
			raw_printf(state.out, " ");
		}
		utf8_printf(state.out, "%s", args[i].c_str());
	}
	raw_printf(state.out, "\n");
	return MetadataResult::SUCCESS;
}

MetadataResult SetPrompt(ShellState &, const vector<string> &args) {
	if (args.size() >= 2) {
		strncpy(mainPrompt, args[1].c_str(), (int)ArraySize(mainPrompt) - 1);
	}
	if (args.size() >= 3) {
		strncpy(continuePrompt, args[2].c_str(), (int)ArraySize(continuePrompt) - 1);
	}
	if (args.size() >= 4) {
		strncpy(continuePromptSelected, args[3].c_str(), (int)ArraySize(continuePromptSelected) - 1);
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetSeparator(ShellState &state, const vector<string> &args) {
	if (args.size() < 2 || args.size() > 3) {
		return MetadataResult::PRINT_USAGE;
	}
	state.colSeparator = args[1];
	if (args.size() >= 3) {
		state.rowSeparator = args[2];
	}
	return MetadataResult::SUCCESS;
}

MetadataResult QuitProcess(ShellState &, const vector<string> &args) {
	return MetadataResult::EXIT;
}

bool ShellState::SetOutputFile(const vector<string> &args, char output_mode) {
	if (safe_mode) {
		utf8_printf(stderr, ".output/.once/.excel cannot be used in -safe mode\n");
		return false;
	}
	string zFile;
	int bTxtMode = 0;
	int eMode = 0;
	bool bBOM = false;
	int bOnce = 0; /* 0: .output, 1: .once, 2: .excel */

	if (output_mode == 'e') {
		// .excel
		eMode = 'x';
		bOnce = 2;
	} else if (output_mode == 'o') {
		// .once
		bOnce = 1;
	}
	for (idx_t i = 1; i < args.size(); i++) {
		const char *z = args[i].c_str();
		if (z[0] == '-') {
			if (z[1] == '-') {
				z++;
			}
			if (strcmp(z, "-bom") == 0) {
				bBOM = true;
			} else if (output_mode != 'e' && strcmp(z, "-x") == 0) {
				eMode = 'x'; /* spreadsheet */
			} else if (output_mode != 'e' && strcmp(z, "-e") == 0) {
				eMode = 'e'; /* text editor */
			} else {
				utf8_printf(out, "ERROR: unknown option: \"%s\".  Usage:\n", args[i].c_str());
				showHelp(out, args[0].c_str());
				return false;
			}
		} else if (zFile.empty()) {
			zFile = z;
		} else {
			utf8_printf(out, "ERROR: extra parameter: \"%s\".  Usage:\n", args[i].c_str());
			showHelp(out, args[0].c_str());
			return false;
		}
	}
	if (zFile.empty()) {
		zFile = "stdout";
	}
	if (bOnce) {
		outCount = 2;
	} else {
		outCount = 0;
	}
	ResetOutput();
#ifndef SQLITE_NOHAVE_SYSTEM
	if (eMode == 'e' || eMode == 'x') {
		doXdgOpen = 1;
		PushOutputMode();
		if (eMode == 'x') {
			/* spreadsheet mode.  Output as CSV. */
			NewTempFile("csv");
			ShellClearFlag(ShellFlags::SHFLG_Echo);
			mode = RenderMode::CSV;
			colSeparator = SEP_Comma;
			rowSeparator = SEP_CrLf;
		} else {
			/* text editor mode */
			NewTempFile("txt");
			bTxtMode = 1;
		}
		zFile = zTempFile;
	}
#endif /* SQLITE_NOHAVE_SYSTEM */
	if (zFile[0] == '|') {
#ifdef SQLITE_OMIT_POPEN
		raw_printf(stderr, "Error: pipes are not supported in this OS\n");
		out = stdout;
		return false;
#else
		out = popen(zFile.c_str() + 1, "w");
		if (out == 0) {
			utf8_printf(stderr, "Error: cannot open pipe \"%s\"\n", zFile.c_str() + 1);
			out = stdout;
			return false;
		} else {
			if (bBOM) {
				fprintf(out, "\357\273\277");
			}
			outfile = zFile;
		}
#endif
	} else {
		out = output_file_open(zFile.c_str(), bTxtMode);
		if (!out) {
			if (zFile == "off") {
				utf8_printf(stderr, "Error: cannot write to \"%s\"\n", zFile.c_str());
			}
			out = stdout;
			return false;
		} else {
			if (bBOM) {
				fprintf(out, "\357\273\277");
			}
			outfile = zFile;
		}
	}
	stdout_is_console = false;
	return true;
}

MetadataResult SetOutput(ShellState &state, const vector<string> &args) {
	if (!state.SetOutputFile(args, '\0')) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetOutputOnce(ShellState &state, const vector<string> &args) {
	if (!state.SetOutputFile(args, 'o')) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetOutputExcel(ShellState &state, const vector<string> &args) {
	if (!state.SetOutputFile(args, 'e')) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

bool ShellState::ReadFromFile(const string &file) {
	if (safe_mode) {
		utf8_printf(stderr, ".read cannot be used in -safe mode\n");
		return false;
	}
	FILE *inSaved = in;
	int savedLineno = lineno;
	int rc;
	if (notNormalFile(file.c_str()) || (in = fopen(file.c_str(), "rb")) == 0) {
		utf8_printf(stderr, "Error: cannot open \"%s\"\n", file.c_str());
		rc = 1;
	} else {
		rc = ProcessInput(InputMode::FILE);
		fclose(in);
	}
	in = inSaved;
	lineno = savedLineno;
	return rc == 0;
}

MetadataResult ReadFromFile(ShellState &state, const vector<string> &args) {
	if (!state.ReadFromFile(args[1])) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

bool ShellState::DisplaySchemas(const vector<string> &args) {
	const char *zName = nullptr;
	bool bDebug = 0;
	SuccessState rc = SuccessState::SUCCESS;

	OpenDB();

	RenderMode mode = RenderMode::SEMI;
	for (idx_t ii = 1; ii < args.size(); ii++) {
		if (optionMatch(args[ii], "indent")) {
			mode = RenderMode::PRETTY;
		} else if (optionMatch(args[ii], "debug")) {
			bDebug = true;
		} else if (zName == 0) {
			zName = args[ii].c_str();
		} else {
			raw_printf(stderr, "Usage: .schema ?--indent? ?LIKE-PATTERN?\n");
			return false;
		}
	}
	auto renderer = GetRowRenderer(mode);
	renderer->show_header = false;

	string sSelect;
	sSelect += "SELECT sql FROM sqlite_master WHERE ";
	if (zName) {
		auto zQarg = StringUtil::Format("%s", SQLString(zName));
		int bGlob = strchr(zName, '*') != 0 || strchr(zName, '?') != 0 || strchr(zName, '[') != 0;
		if (strchr(zName, '.')) {
			sSelect += "lower(printf('%s.%s',sname,tbl_name))";
		} else {
			sSelect += "lower(tbl_name)";
		}
		sSelect += bGlob ? " GLOB " : " LIKE ";
		sSelect += zQarg.c_str();
		if (!bGlob) {
			sSelect += " ESCAPE '\\' ";
		}
		sSelect += " AND ";
	}
	sSelect += "type!='meta' AND sql IS NOT NULL"
	           " ORDER BY name";
	if (bDebug) {
		utf8_printf(out, "SQL: %s;\n", sSelect.c_str());
	} else {
		rc = RenderQuery(*renderer, sSelect);
	}
	if (rc == SuccessState::FAILURE) {
		raw_printf(stderr, "Error: querying schema information\n");
		return false;
	} else {
		return true;
	}
}

MetadataResult DisplaySchemas(ShellState &state, const vector<string> &args) {
	if (!state.DisplaySchemas(args)) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult RunShellCommand(ShellState &state, const vector<string> &args) {
	if (safe_mode) {
		utf8_printf(stderr, ".sh/.system cannot be used in -safe mode\n");
		return MetadataResult::FAIL;
	}
	int x;
	if (args.size() < 2) {
		return MetadataResult::PRINT_USAGE;
	}
	auto zCmd = StringUtil::Format(StringUtil::Contains(args[1], ' ') ? "%s" : "\"%s\"", args[1]);
	for (idx_t i = 2; i < args.size(); i++) {
		zCmd += StringUtil::Format(StringUtil::Contains(args[i], ' ') ? " %s" : " \"%s\"", args[i]);
	}
	x = system(zCmd.c_str());
	if (x) {
		raw_printf(stderr, "System command returns %d\n", x);
	}
	return MetadataResult::SUCCESS;
}

void ShellState::ShowConfiguration() {
	utf8_printf(out, "%12.12s: %s\n", "echo", ShellHasFlag(ShellFlags::SHFLG_Echo) ? "on" : "off");
	utf8_printf(out, "%12.12s: %s\n", "headers", showHeader ? "on" : "off");
	utf8_printf(out, "%12.12s: %s\n", "mode", modeDescr[int(mode)]);
	utf8_printf(out, "%12.12s: ", "nullvalue");
	OutputCString(nullValue.c_str());
	raw_printf(out, "\n");
	utf8_printf(out, "%12.12s: %s\n", "output", !outfile.empty() ? outfile.c_str() : "stdout");
	utf8_printf(out, "%12.12s: ", "colseparator");
	OutputCString(colSeparator.c_str());
	raw_printf(out, "\n");
	utf8_printf(out, "%12.12s: ", "rowseparator");
	OutputCString(rowSeparator.c_str());
	raw_printf(out, "\n");
	utf8_printf(out, "%12.12s: ", "width");
	for (auto w : colWidth) {
		raw_printf(out, "%d ", w);
	}
	raw_printf(out, "\n");
	utf8_printf(out, "%12.12s: %s\n", "filename", zDbFilename.c_str());
}

MetadataResult ShowConfiguration(ShellState &state, const vector<string> &args) {
	state.ShowConfiguration();
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleTimer(ShellState &state, const vector<string> &args) {
	enableTimer = booleanValue(args[1]);
	if (enableTimer && !HAS_TIMER) {
		raw_printf(stderr, "Error: timer not available on this system.\n");
		enableTimer = false;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ShowVersion(ShellState &state, const vector<string> &args) {
	utf8_printf(state.out, "DuckDB %s (%s) %s\n" /*extra-version-info*/, duckdb::DuckDB::LibraryVersion(),
	            duckdb::DuckDB::ReleaseCodename(), duckdb::DuckDB::SourceID());
#define CTIMEOPT_VAL_(opt) #opt
#define CTIMEOPT_VAL(opt)  CTIMEOPT_VAL_(opt)
#if defined(__clang__) && defined(__clang_major__)
	utf8_printf(state.out, "clang-" CTIMEOPT_VAL(__clang_major__) "." CTIMEOPT_VAL(__clang_minor__) "." CTIMEOPT_VAL(
	                           __clang_patchlevel__) "\n");
#elif defined(_MSC_VER)
	utf8_printf(state.out, "msvc-" CTIMEOPT_VAL(_MSC_VER) "\n");
#elif defined(__GNUC__) && defined(__VERSION__)
	utf8_printf(state.out, "gcc-" __VERSION__ "\n");
#endif
	return MetadataResult::SUCCESS;
}

MetadataResult SetWidths(ShellState &state, const vector<string> &args) {
	state.colWidth.clear();
	for (idx_t j = 1; j < args.size(); j++) {
		state.colWidth.push_back((int)ShellState::StringToInt(args[j]));
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ShellState::DisplayEntries(const vector<string> &args, char type) {
	string s;
	OpenDB();

	if (args.size() > 2) {
		return MetadataResult::PRINT_USAGE;
	}

	// Parse the filter pattern to check for schema qualification
	string filter_pattern = args.size() > 1 ? args[1] : "%";
	string schema_filter = "";
	string table_filter = filter_pattern;

	// Parse the filter pattern to check for schema qualification
	try {
		auto components = duckdb::QualifiedName::ParseComponents(filter_pattern);
		if (components.size() >= 2) {
			// e.g : "schema.table" or "schema.%"
			schema_filter = components[0];
			table_filter = components[1];
			// e.g : "schema."
			if (table_filter.empty()) {
				table_filter = "%";
			}
		}
	} catch (const duckdb::ParserException &) {
		// If parsing fails, treat as a simple table pattern
		schema_filter = "";
		table_filter = filter_pattern;
	}

	// Use DuckDB's system tables instead of SQLite's sqlite_schema
	if (type == 't') {
		string schema_filter_str;
		string name_filter = "WHERE ao.name LIKE ?1";
		if (!schema_filter.empty()) {
			schema_filter_str = "\n  WHERE schema_name LIKE ?1";
			name_filter = "WHERE ao.name LIKE ?2";
		}
		s = StringUtil::Format(R"(
WITH all_objects AS (
  SELECT schema_name, table_name as name FROM duckdb_tables%s
  UNION ALL
  SELECT schema_name, view_name as name FROM duckdb_views%s
),
name_counts AS (
  SELECT name, COUNT(*) as count FROM all_objects
  GROUP BY name
),
disambiguated AS (
  SELECT
    CASE
      WHEN nc.count > 1 THEN ao.schema_name || '.' || ao.name
      ELSE ao.name
    END as display_name
  FROM all_objects ao
  JOIN name_counts nc ON ao.name = nc.name
  %s
)
SELECT DISTINCT display_name FROM disambiguated ORDER BY display_name
)",
		                       schema_filter_str, schema_filter_str, name_filter);
	} else {
		// For indexes, use the original SQLite approach
		s = R"(
SELECT name FROM
sqlite_schema
WHERE type='index' AND tbl_name LIKE ?1)";
	}

	auto &con = *conn;
	auto prepared = con.Prepare(s);
	if (prepared->HasError()) {
		PrintDatabaseError(prepared->GetError());
		return MetadataResult::FAIL;
	}

	duckdb::vector<duckdb::Value> bind_values;

	if (type == 't') {
		// Bind parameters for the new DuckDB query
		if (!schema_filter.empty()) {
			bind_values.emplace_back(schema_filter);
			bind_values.emplace_back(table_filter);
		} else {
			bind_values.emplace_back(filter_pattern);
		}
	} else {
		// Original binding for indexes
		if (args.size() > 1) {
			bind_values.emplace_back(args[1]);
		} else {
			bind_values.emplace_back("%");
		}
	}

	auto query_result = prepared->Execute(bind_values);
	if (query_result->HasError()) {
		PrintDatabaseError(query_result->GetError());
	}
	vector<string> result;
	for (auto &row : *query_result) {
		result.push_back(row.GetValue<string>(0));
	}

	/* Pretty-print the contents of array azResult[] to the output */
	if (!result.empty()) {
		idx_t maxlen = 0;
		for (auto &r : result) {
			idx_t len = r.size();
			if (len > maxlen) {
				maxlen = len;
			}
		}
		idx_t nPrintCol = 80 / (maxlen + 2);
		if (nPrintCol < 1) {
			nPrintCol = 1;
		}
		idx_t nPrintRow = (result.size() + nPrintCol - 1) / nPrintCol;
		for (idx_t i = 0; i < nPrintRow; i++) {
			for (idx_t j = i; j < result.size(); j += nPrintRow) {
				const char *zSp = j < nPrintRow ? "" : "  ";
				utf8_printf(out, "%s%-*s", zSp, static_cast<int>(maxlen), result[j].c_str());
			}
			raw_printf(out, "\n");
		}
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ShowIndexes(ShellState &state, const vector<string> &args) {
	return state.DisplayEntries(args, 'i');
}

MetadataResult ShowTables(ShellState &state, const vector<string> &args) {
	return state.DisplayEntries(args, 't');
}

MetadataResult SetUICommand(ShellState &state, const vector<string> &args) {
	if (args.size() < 1) {
		return MetadataResult::PRINT_USAGE;
	}
	string command;
	for (idx_t i = 1; i < args.size(); i++) {
		if (i > 1) {
			command += " ";
		}
		command += args[i];
	}
	state.ui_command = "CALL " + command;
	return MetadataResult::SUCCESS;
}

#if defined(_WIN32) || defined(WIN32)
MetadataResult SetUTF8Mode(ShellState &state, const vector<string> &args) {
	win_utf8_mode = 1;
	return MetadataResult::SUCCESS;
}
#endif

#ifdef HAVE_LINENOISE
MetadataResult ToggleHighlighting(ShellState &state, const vector<string> &args) {
	linenoiseSetHighlighting(booleanValue(args[1]));
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleErrorRendering(ShellState &state, const vector<string> &args) {
	linenoiseSetErrorRendering(booleanValue(args[1]));
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleCompletionRendering(ShellState &state, const vector<string> &args) {
	linenoiseSetCompletionRendering(booleanValue(args[1]));
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleMultiLine(ShellState &state, const vector<string> &args) {
	if (!args.empty()) {
		return MetadataResult::PRINT_USAGE;
	}
	linenoiseSetMultiLine(true);
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleSingleLine(ShellState &state, const vector<string> &args) {
	if (!args.empty()) {
		return MetadataResult::PRINT_USAGE;
	}
	linenoiseSetMultiLine(false);
	return MetadataResult::SUCCESS;
}

MetadataResult TrySetHighlightColor(const string &component, const string &code) {
	char error[1024];
	if (!linenoiseTrySetHighlightColor(component.c_str(), code.c_str(), error, 1024)) {
		utf8_printf(stderr, "%s\n", error);
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetRenderHighlightColor(ShellState &state, const vector<string> &args) {
	return TrySetHighlightColor(args[1], args[2]);
}

enum class DeprecatedHighlightColors {
	COMMENT,
	COMMENT_CODE,
	CONSTANT,
	CONSTANT_CODE,
	KEYWORD,
	KEYWORD_CODE,
	ERROR,
	ERROR_CODE,
	CONT,
	CONT_CODE,
	CONT_SEL,
	CONT_SEL_CODE
};

template <DeprecatedHighlightColors T>
MetadataResult SetHighlightingColor(ShellState &state, const vector<string> &args) {
	string literal;
	switch (T) {
	case DeprecatedHighlightColors::COMMENT:
		literal = "comment";
		break;
	case DeprecatedHighlightColors::COMMENT_CODE:
		literal = "commentcode";
		break;
	case DeprecatedHighlightColors::CONSTANT:
		literal = "constant";
		break;
	case DeprecatedHighlightColors::CONSTANT_CODE:
		literal = "constantcode";
		break;
	case DeprecatedHighlightColors::KEYWORD:
		literal = "keyword";
		break;
	case DeprecatedHighlightColors::KEYWORD_CODE:
		literal = "keywordcode";
		break;
	case DeprecatedHighlightColors::ERROR:
		literal = "error";
		break;
	case DeprecatedHighlightColors::ERROR_CODE:
		literal = "errorcode";
		break;
	case DeprecatedHighlightColors::CONT:
		literal = "cont";
		break;
	case DeprecatedHighlightColors::CONT_CODE:
		literal = "contcode";
		break;
	case DeprecatedHighlightColors::CONT_SEL:
		literal = "cont_sel";
		break;
	case DeprecatedHighlightColors::CONT_SEL_CODE:
		literal = "cont_selcode";
		break;
	default:
		throw std::runtime_error("eek");
	}
	utf8_printf(stderr, "WARNING: .%s [COLOR] will be removed in a future release, use .render_color %s %s instead\n",
	            literal.c_str(), literal.c_str(), args[1].c_str());
	return TrySetHighlightColor(literal, args[1]);
}

#endif

static const MetadataCommand metadata_commands[] = {
    {"backup", 0, nullptr, "?DB? FILE", "Backup DB (default \"main\") to FILE", 3},
    {"bail", 2, ToggleBail, "on|off", "Stop after hitting an error.  Default OFF", 3},
    {"binary", 2, ToggleBinary, "on|off", "Turn binary output on or off.  Default OFF", 3},
    {"cd", 2, ChangeDirectory, "DIRECTORY", "Change the working directory to DIRECTORY", 0},
    {"changes", 2, ToggleChanges, "on|off", "Show number of rows changed by SQL", 3},
    {"columns", 1, SetColumnRendering, "", "Column-wise rendering of query results", 0},
#ifdef HAVE_LINENOISE
    {"comment", 2, SetHighlightingColor<DeprecatedHighlightColors::COMMENT>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for comment values", 0},
    {"commentcode", 2, SetHighlightingColor<DeprecatedHighlightColors::COMMENT_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for comment values", 0},
    {"constant", 2, SetHighlightingColor<DeprecatedHighlightColors::CONSTANT>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for constant values", 0},
    {"constantcode", 2, SetHighlightingColor<DeprecatedHighlightColors::CONSTANT_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for constant values", 0},
    {"cont", 2, SetHighlightingColor<DeprecatedHighlightColors::CONT>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for continuation markers", 0},
    {"contcode", 2, SetHighlightingColor<DeprecatedHighlightColors::CONT_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for continuation markers", 0},
    {"cont_sel", 2, SetHighlightingColor<DeprecatedHighlightColors::CONT_SEL>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for continuation markers", 0},
    {"cont_selcode", 2, SetHighlightingColor<DeprecatedHighlightColors::CONT_SEL_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for continuation markers", 0},
#endif
    {"decimal_sep", 0, SetDecimalSep, "SEP",
     "Sets the decimal separator used when rendering numbers. Only for duckbox mode.", 3},
    {"databases", 1, ShowDatabases, "", "List names and files of attached databases", 2},
    {"dump", 0, DumpTable, "?TABLE?",
     "Render database content as SQL\n   Options:\n     --newlines             Allow unescaped newline characters in "
     "output\n   TABLE is a LIKE pattern for the tables to dump\n   Additional LIKE patterns can be given in "
     "subsequent arguments",
     0},
    {"echo", 2, ToggleEcho, "on|off", "Turn command echo on or off", 3},
#ifdef HAVE_LINENOISE
    {"error", 2, SetHighlightingColor<DeprecatedHighlightColors::ERROR>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for errors", 0},
    {"errorcode", 2, SetHighlightingColor<DeprecatedHighlightColors::ERROR_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for errors", 0},
#endif
    {"excel", 0, SetOutputExcel, "", "Display the output of next command in spreadsheet", 0},
    {"exit", 0, ExitProcess, "?CODE?", "Exit this program with return-code CODE", 0},
    {"fullschema", 0, nullptr, "", "", 0},
    {"headers", 2, ToggleHeaders, "on|off", "Turn display of headers on or off", 0},
    {"help", 0, ShowHelp, "?-all? ?PATTERN?", "Show help text for PATTERN", 0},
#ifdef HAVE_LINENOISE
    {"highlight", 2, ToggleHighlighting, "on|off", "Toggle syntax highlighting in the shell on/off", 0},
#endif
    {"highlight_colors", 0, SetHighlightColors, "[element] [color] ([bold])?", "Configure highlighting colors", 0},
    {"highlight_errors", 2, ToggleHighlighErrors, "on|off", "Turn highlighting of errors on or off", 0},
    {"highlight_results", 2, ToggleHighlightResult, "on|off", "Turn highlighting of results on or off", 0},
    {"import", 0, ImportData, "FILE TABLE", "Import data from FILE into TABLE", 0},

    {"indexes", 0, ShowIndexes, "?TABLE?", "Show names of indexes", 0},
    {"indices", 0, ShowIndexes, "?TABLE?", "Show names of indexes", 0},
#ifdef HAVE_LINENOISE
    {"keyword", 2, SetHighlightingColor<DeprecatedHighlightColors::KEYWORD>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for keywords", 0},
    {"keywordcode", 2, SetHighlightingColor<DeprecatedHighlightColors::KEYWORD_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for keywords", 0},
#endif
    {"large_number_rendering", 2, SetLargeNumberRendering, "all|footer|off",
     "Toggle readable rendering of large numbers (duckbox only)", 0},
    {"log", 2, ToggleLog, "FILE|off", "Turn logging on or off.  FILE can be stderr/stdout", 0},
    {"maxrows", 0, SetMaxRows, "COUNT",
     "Sets the maximum number of rows for display (default: 40). Only for duckbox mode.", 0},
    {"maxwidth", 0, SetMaxWidth, "COUNT",
     "Sets the maximum width in characters. 0 defaults to terminal width. Only for duckbox mode.", 0},
    {"mode", 0, SetOutputMode, "MODE ?TABLE?", "Set output mode", 0},
#ifdef HAVE_LINENOISE
    {"multiline", 1, ToggleMultiLine, "", "Sets the render mode to multi-line", 0},
#endif
    {"nullvalue", 2, SetNullValue, "STRING", "Use STRING in place of NULL values", 0},

    {"open", 0, OpenDatabase, "?OPTIONS? ?FILE?", "Close existing database and reopen FILE", 2},
    {"once", 0, SetOutputOnce, "?FILE?", "Output for the next SQL command only to FILE", 0},
    {"output", 0, SetOutput, "?FILE?", "Send output to FILE or stdout if FILE is omitted", 0},
    {"print", 0, PrintArguments, "STRING...", "Print literal STRING", 3},
    {"prompt", 0, SetPrompt, "MAIN CONTINUE", "Replace the standard prompts", 0},

    {"quit", 0, QuitProcess, "", "Exit this program", 0},
    {"read", 2, ReadFromFile, "FILE", "Read input from FILE", 3},
#ifdef HAVE_LINENOISE
    {"render_color", 3, SetRenderHighlightColor, "?COMP? ?COLOR?",
     "Configure highlighting colors for the interactive prompt", 0},
    {"render_completion", 2, ToggleCompletionRendering, "on|off",
     "Toggle displaying of completion prompts in the shell on/off", 0},
    {"render_errors", 2, ToggleErrorRendering, "on|off", "Toggle rendering of errors in the shell on/off", 0},
#endif
    {"rows", 1, SetRowRendering, "", "Row-wise rendering of query results (default)", 0},
    {"restore", 0, nullptr, "", "", 3},
    {"save", 0, nullptr, "?DB? FILE", "Backup DB (default \"main\") to FILE", 3},
    {"safe_mode", 0, EnableSafeMode, "", "enable safe-mode", 0},
    {"separator", 0, SetSeparator, "COL ?ROW?", "Change the column and row separators", 0},
    {"schema", 0, DisplaySchemas, "?PATTERN?", "Show the CREATE statements matching PATTERN", 0},
    {"shell", 0, RunShellCommand, "CMD ARGS...", "Run CMD ARGS... in a system shell", 0},
    {"show", 1, ShowConfiguration, "", "Show the current values for various settings", 0},
#ifdef HAVE_LINENOISE
    {"singleline", 1, ToggleSingleLine, "", "Sets the render mode to single-line", 0},
#endif
    {"system", 0, RunShellCommand, "CMD ARGS...", "Run CMD ARGS... in a system shell", 0},
    {"tables", 0, ShowTables, "?TABLE?", "List names of tables matching LIKE pattern TABLE", 2},
    {"thousand_sep", 0, SetThousandSep, "SEP",
     "Sets the thousand separator used when rendering numbers. Only for duckbox mode.", 4},
    {"timeout", 0, nullptr, "", "", 5},
    {"timer", 2, ToggleTimer, "on|off", "Turn SQL timer on or off", 0},
    {"ui_command", 0, SetUICommand, "[command]", "Set the UI command", 0},
    {"version", 1, ShowVersion, "", "Show the version", 0},
    {"width", 0, SetWidths, "NUM1 NUM2 ...", "Set minimum column widths for columnar output", 0},
#if defined(_WIN32) || defined(WIN32)
    {"utf8", 1, SetUTF8Mode, "", "Enable experimental UTF-8 console output mode", 0},
#endif

    {nullptr, 0, nullptr}};

/*
** If an input line begins with "." then invoke this routine to
** process that line.
**
** Return 1 on error, 2 to exit, and 0 otherwise.
*/
int ShellState::DoMetaCommand(const string &zLine) {
	int n, c;
	int rc = 0;
	vector<string> args;
	// skip initial dot
	idx_t pos = 1;
	while (pos < zLine.size()) {
		// skip initial spaces
		while (pos < zLine.size() && IsSpace(zLine[pos])) {
			pos++;
		}
		if (pos >= zLine.size()) {
			break;
		}
		string arg;
		if (zLine[pos] == '\'' || zLine[pos] == '"') {
			// quoted argument - scan until next quote
			auto quote = zLine[pos];
			// skip over the initial quote
			pos++;

			while (pos < zLine.size() && zLine[pos] != quote) {
				if (zLine[pos] == '\\' && quote == '"' && pos + 1 < zLine.size()) {
					// skip over any escaped characters
					arg += zLine[pos++];
				}
				arg += zLine[pos++];
			}
			if (pos < zLine.size()) {
				// skip over the final quote
				pos++;
			}
			if (quote == '"') {
				arg = resolve_backslashes(arg);
			}
		} else {
			// unquoted argument - scan until the next space
			while (pos < zLine.size() && !IsSpace(zLine[pos])) {
				arg += zLine[pos];
				pos++;
			}
			arg = resolve_backslashes(arg);
		}
		args.push_back(std::move(arg));
	}

	/* Process the input line.
	 */
	if (args.empty()) {
		return 0; /* no tokens, no error */
	}
	n = args[0].size();
	c = args[0][0];
	ClearTempFile();

	bool found_argument = false;
	for (idx_t command_idx = 0; metadata_commands[command_idx].command; command_idx++) {
		auto &command = metadata_commands[command_idx];
		idx_t match_size = command.match_size ? command.match_size : n;
		if (n < int(match_size) || c != *command.command || strncmp(args[0].c_str(), command.command, n) != 0) {
			continue;
		}
		found_argument = true;
		MetadataResult result = MetadataResult::PRINT_USAGE;
		if (!command.callback) {
			raw_printf(stderr, "Command \"%s\" is unsupported in the current version of the CLI\n", command.command);
			result = MetadataResult::FAIL;
		} else if (command.argument_count == 0 || int(command.argument_count) == args.size()) {
			result = command.callback(*this, args);
		}
		if (result == MetadataResult::PRINT_USAGE) {
			raw_printf(stderr, "Usage: .%s %s\n", command.command, command.usage);
			result = MetadataResult::FAIL;
		}
		rc = int(result);
		break;
	}
	if (!found_argument) {
		utf8_printf(stderr,
		            "Error: unknown command or invalid arguments: "
		            " \"%s\". Enter \".help\" for help\n",
		            args[0].c_str());
		rc = 1;
	}

	if (outCount) {
		outCount--;
		if (outCount == 0) {
			ResetOutput();
		}
	}
	return rc;
}

/*
** Return TRUE if a semicolon occurs anywhere in the first N characters
** of string z[].
*/
static bool line_contains_semicolon(const char *z, idx_t N) {
	for (idx_t i = 0; i < N; i++) {
		if (z[i] == ';') {
			return true;
		}
	}
	return false;
}

/*
** Test to see if a line consists entirely of whitespace.
*/
static bool _all_whitespace(const char *z) {
	for (; *z; z++) {
		if (ShellState::IsSpace(z[0])) {
			continue;
		}
		if (*z == '/' && z[1] == '*') {
			z += 2;
			while (*z && (*z != '*' || z[1] != '/')) {
				z++;
			}
			if (*z == 0) {
				return false;
			}
			z++;
			continue;
		}
		if (*z == '-' && z[1] == '-') {
			z += 2;
			while (*z && *z != '\n') {
				z++;
			}
			if (*z == 0)
				return true;
			continue;
		}
		return false;
	}
	return true;
}

enum class SQLParseState { SEMICOLON, WHITESPACE, NORMAL };

static const char *skipDollarQuotedString(const char *zSql, const char *delimiterStart, idx_t delimiterLength) {
	for (; *zSql; zSql++) {
		if (*zSql == '$') {
			// found a dollar
			// move forward and find the next dollar
			zSql++;
			auto start = zSql;
			while (*zSql && *zSql != '$') {
				zSql++;
			}
			if (!zSql[0]) {
				// reached end of string while looking for the dollar
				return nullptr;
			}
			// check if the dollar quoted string name matches
			if (delimiterLength == idx_t(zSql - start)) {
				if (memcmp(start, delimiterStart, delimiterLength) == 0) {
					return zSql;
				}
			}
			// dollar does not match - reset position to start and keep looking
			zSql = start - 1;
		}
	}
	// unterminated
	return nullptr;
}

bool ShellState::SQLIsComplete(const char *zSql) {
	auto state = SQLParseState::NORMAL;

	for (; *zSql; zSql++) {
		SQLParseState next_state;
		switch (*zSql) {
		case ';':
			next_state = SQLParseState::SEMICOLON;
			break;
		case ' ':
		case '\r':
		case '\t':
		case '\n':
		case '\f': { /* White space is ignored */
			next_state = SQLParseState::WHITESPACE;
			break;
		}
		case '/': { /* C-style comments */
			if (zSql[1] != '*') {
				next_state = SQLParseState::NORMAL;
				break;
			}
			zSql += 2;
			while (zSql[0] && (zSql[0] != '*' || zSql[1] != '/')) {
				zSql++;
			}
			if (zSql[0] == 0) {
				// unterminated c-style string
				return false;
			}
			zSql++;
			next_state = SQLParseState::WHITESPACE;
			break;
		}
		case '-': { /* SQL-style comments from "--" to end of line */
			if (zSql[1] != '-') {
				next_state = SQLParseState::NORMAL;
				break;
			}
			while (*zSql && *zSql != '\n') {
				zSql++;
			}
			if (*zSql == 0) {
				// unterminated SQL-style comment - return whether or not we had a semicolon right before it
				return state == SQLParseState::SEMICOLON;
			}
			next_state = SQLParseState::WHITESPACE;
			break;
		}
		case '$': { /* Dollar-quoted strings */
			// check if this is a dollar-quoted string
			idx_t next_dollar = 0;
			for (idx_t idx = 1; zSql[idx]; idx++) {
				if (zSql[idx] == '$') {
					// found the next dollar
					next_dollar = idx;
					break;
				}
				// all characters can be between A-Z, a-z or \200 - \377
				if (zSql[idx] >= 'A' && zSql[idx] <= 'Z') {
					continue;
				}
				if (zSql[idx] >= 'a' && zSql[idx] <= 'z') {
					continue;
				}
				if (zSql[idx] >= '\200' && zSql[idx] <= '\377') {
					continue;
				}
				// the first character CANNOT be a numeric, only subsequent characters
				if (idx > 1 && zSql[idx] >= '0' && zSql[idx] <= '9') {
					continue;
				}
				// not a dollar quoted string
				break;
			}
			if (next_dollar == 0) {
				// not a dollar quoted string
				next_state = SQLParseState::NORMAL;
				break;
			}
			auto start = zSql + 1;
			zSql += next_dollar;
			const char *delimiterStart = start;
			idx_t delimiterLength = zSql - start;
			zSql++;
			// skip the dollar quoted string
			zSql = skipDollarQuotedString(zSql, delimiterStart, delimiterLength);
			if (!zSql) {
				// unterminated dollar string
				return false;
			}
			next_state = SQLParseState::WHITESPACE;
			break;
		}
			//		case '`': /* Grave-accent quoted symbols used by MySQL */
		case '"': /* single- and double-quoted strings */
		case '\'': {
			int c = *zSql;
			zSql++;
			while (*zSql && *zSql != c) {
				zSql++;
			}
			if (*zSql == 0) {
				// unterminated single or double quoted string
				return 0;
			}
			next_state = SQLParseState::WHITESPACE;
			break;
		}
		default:
			next_state = SQLParseState::NORMAL;
		}
		// white space is ignored (no change in state)
		if (next_state != SQLParseState::WHITESPACE) {
			state = next_state;
		}
	}
	// the statement is complete only if we end in a semicolon
	return state == SQLParseState::SEMICOLON;
}

/*
** Run a single line of SQL.  Return the number of errors.
*/
int ShellState::RunOneSqlLine(InputMode mode, char *zSql) {
	string zErrMsg;

	OpenDB();
#ifndef SHELL_USE_LOCAL_GETLINE
	if (mode == InputMode::STANDARD && zSql && *zSql && *zSql != '\3') {
		shell_add_history(zSql);
	}
#endif
	BEGIN_TIMER;
	auto success = ExecuteSQL(zSql);
	END_TIMER;
	if (success != SuccessState::SUCCESS) {
		return 1;
	} else if (ShellHasFlag(ShellFlags::SHFLG_CountChanges)) {
		raw_printf(out, "changes: %3llu   total_changes: %llu\n", last_changes, total_changes);
	}
	return 0;
}

/*
** Read input from *in and process it.  If *in==0 then input
** is interactive - the user is typing it it.  Otherwise, input
** is coming from a file or device.  A prompt is issued and history
** is saved only if input is interactive.  An interrupt signal will
** cause this routine to exit immediately, unless input is interactive.
**
** Return the number of errors.
*/
int ShellState::ProcessInput(InputMode mode) {
	char *zLine = nullptr; /* A single input line */
	char *zSql = nullptr;  /* Accumulated SQL text */
	idx_t nLine;           /* Length of current line */
	idx_t nSql = 0;        /* Bytes of zSql[] used */
	idx_t nAlloc = 0;      /* Allocated zSql[] space */
	idx_t nSqlPrior = 0;   /* Bytes of zSql[] used by prior line */
	int rc;                /* Error code */
	idx_t errCnt = 0;      /* Number of errors seen */
	idx_t numCtrlC = 0;
	lineno = 0;
	while (errCnt == 0 || !bail_on_error || (!in && stdin_is_interactive)) {
		fflush(out);
		zLine = one_input_line(in, zLine, nSql > 0);
		if (!zLine) {
			/* End of input */
			if (!in && stdin_is_interactive) {
				printf("\n");
			}
			break;
		}
		if (*zLine == '\3') {
			// ctrl c: reset sql statement
			if (nSql == 0 && zLine[1] == '\0' && stdin_is_interactive) {
				// if in interactive mode and we press ctrl c twice
				// on an empty line, we exit
				numCtrlC++;
				if (numCtrlC >= 2) {
					break;
				}
			}
			nSql = 0;
			continue;
		} else {
			numCtrlC = 0;
		}
		if (seenInterrupt) {
			if (in) {
				break;
			}
			seenInterrupt = 0;
		}
		lineno++;
		if (nSql == 0 && _all_whitespace(zLine)) {
			if (ShellHasFlag(ShellFlags::SHFLG_Echo)) {
				printf("%s\n", zLine);
			}
			continue;
		}
		if (zLine && (zLine[0] == '.' || zLine[0] == '#') && nSql == 0) {
			if (ShellHasFlag(ShellFlags::SHFLG_Echo)) {
				printf("%s\n", zLine);
			}
			if (zLine[0] == '.') {
#ifndef SHELL_USE_LOCAL_GETLINE
				if (mode == InputMode::STANDARD && zLine && *zLine && *zLine != '\3')
					shell_add_history(zLine);
#endif
				rc = DoMetaCommand(zLine);
				if (rc == 2) { /* exit requested */
					break;
				} else if (rc) {
					errCnt++;
				}
			}
			continue;
		}
		nLine = StringLength(zLine);
		if (nSql + nLine + 2 >= nAlloc) {
			nAlloc = nSql + nLine + 100;
			zSql = (char *)realloc(zSql, nAlloc);
			if (!zSql) {
				shell_out_of_memory();
			}
		}
		nSqlPrior = nSql;
		if (nSql == 0) {
			int i;
			for (i = 0; zLine[i] && IsSpace(zLine[i]); i++) {
			}
			assert(nAlloc > 0 && zSql);
			memcpy(zSql, zLine + i, nLine + 1 - i);
			nSql = nLine - i;
		} else {
			zSql[nSql++] = '\n';
			memcpy(zSql + nSql, zLine, nLine + 1);
			nSql += nLine;
		}
		if (nSql && line_contains_semicolon(&zSql[nSqlPrior], nSql - nSqlPrior) && SQLIsComplete(zSql)) {
			errCnt += RunOneSqlLine(mode, zSql);
			nSql = 0;
			if (outCount) {
				ResetOutput();
				outCount = 0;
			} else {
				ClearTempFile();
			}
		} else if (nSql && _all_whitespace(zSql)) {
			if (ShellHasFlag(ShellFlags::SHFLG_Echo)) {
				printf("%s\n", zSql);
			}
			nSql = 0;
		}
	}
	if (nSql && !_all_whitespace(zSql)) {
		errCnt += RunOneSqlLine(mode, zSql);
	}
	free(zSql);
	free(zLine);
	return errCnt > 0;
}

static string GetHomeDirectory() {
	duckdb::LocalFileSystem lfs;
	return lfs.GetHomeDirectory();
}

string ShellState::GetDefaultDuckDBRC() {
	return GetHomeDirectory() + "/.duckdbrc";
}

/*
** Read input from the file given by sqliterc_override.  Or if that
** parameter is NULL, take input from ~/.duckdbrc
**
** Returns true if successful, false otherwise.
*/

bool ShellState::ProcessFile(const string &file, bool is_duckdb_rc) {
	FILE *inSaved = in;
	int savedLineno = lineno;
	int rc = 0;

	in = fopen(file.c_str(), "rb");
	if (in) {
		if (stdin_is_interactive && is_duckdb_rc) {
			utf8_printf(stderr, "-- Loading resources from %s\n", file.c_str());
		}
		rc = ProcessInput(InputMode::FILE);
		fclose(in);
	} else if (!is_duckdb_rc) {
		utf8_printf(stderr, "Failed to read file \"%s\"\n", file.c_str());
		rc = 1;
	}
	in = inSaved;
	lineno = savedLineno;
	return rc == 0;
}

bool ShellState::ProcessDuckDBRC(const char *file) {
	string path;
	if (!file) {
		// use default .duckdbrc path
		path = ShellState::GetDefaultDuckDBRC();
		if (path.empty()) {
			// could not find home directory - return
			raw_printf(stderr, "-- warning: cannot find home directory;"
			                   " cannot read ~/.duckdbrc\n");
			return true;
		}
		file = path.c_str();
	}
	return ProcessFile(file, true);
}

/*
** Show available command line options
*/
static const char zOptions[] =
    "   -ascii               set output mode to 'ascii'\n"
    "   -bail                stop after hitting an error\n"
    "   -batch               force batch I/O\n"
    "   -box                 set output mode to 'box'\n"
    "   -column              set output mode to 'column'\n"
    "   -cmd COMMAND         run \"COMMAND\" before reading stdin\n"
    "   -c COMMAND           run \"COMMAND\" and exit\n"
    "   -csv                 set output mode to 'csv'\n"
    "   -echo                print commands before execution\n"
    "   -f FILENAME          read/process named file and exit\n"
    "   -init FILENAME       read/process named file\n"
    "   -[no]header          turn headers on or off\n"
    "   -help                show this message\n"
    "   -html                set output mode to HTML\n"
    "   -interactive         force interactive I/O\n"
    "   -json                set output mode to 'json'\n"
    "   -line                set output mode to 'line'\n"
    "   -list                set output mode to 'list'\n"
    "   -markdown            set output mode to 'markdown'\n"
    "   -newline SEP         set output row separator. Default: '\\n'\n"
    "   -no-stdin            exit after processing options instead of reading stdin\n"
    "   -nullvalue TEXT      set text string for NULL values. Default 'NULL'\n"
    "   -quote               set output mode to 'quote'\n"
    "   -readonly            open the database read-only\n"
    "   -s COMMAND           run \"COMMAND\" and exit\n"
    "   -safe                enable safe-mode\n"
    "   -separator SEP       set output column separator. Default: '|'\n"
    "   -storage-version V   database storage compatibility version to use. Default: 'v0.10.0'\n"
    "   -table               set output mode to 'table'\n"
    "   -ui                  launches a web interface using the ui extension (configurable with .ui_command)\n"
    "   -unredacted          allow printing unredacted secrets\n"
    "   -unsigned            allow loading of unsigned extensions\n"
    "   -version             show DuckDB version\n";
static void usage(int showDetail) {
	utf8_printf(stdout,
	            "Usage: %s [OPTIONS] FILENAME [SQL]\n"
	            "FILENAME is the name of a DuckDB database. A new database is created\n"
	            "if the file does not previously exist.\n",
	            program_name);
	if (showDetail) {
		utf8_printf(stdout, "OPTIONS include:\n%s", zOptions);
	} else {
		raw_printf(stdout, "Use the -help option for additional information\n");
	}
	exit(0);
}

/*
** Initialize the state information in data
*/
static void main_init(ShellState *data) {
	data->normalMode = data->cMode = data->mode = RenderMode::DUCKBOX;
	data->max_rows = 40;
	data->colSeparator = SEP_Column;
	data->rowSeparator = SEP_Row;
	data->showHeader = true;
	strcpy(mainPrompt, "D ");
	strcpy(continuePrompt, " ");
	strcpy(continuePromptSelected, " ");
#ifdef HAVE_LINENOISE
	linenoiseSetPrompt(continuePrompt, continuePromptSelected);
#endif
}

/*
** Get the argument to an --option.  Throw an error and die if no argument
** is available.
*/
static char *cmdline_option_value(int argc, char **argv, int i) {
	if (i == argc) {
		utf8_printf(stderr, "%s: Error: missing argument to %s\n", argv[0], argv[argc - 1]);
		exit(1);
	}
	return argv[i];
}

#ifndef SQLITE_SHELL_IS_UTF8
#if (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)
#define SQLITE_SHELL_IS_UTF8 (0)
#else
#define SQLITE_SHELL_IS_UTF8 (1)
#endif
#endif

#if SQLITE_SHELL_IS_UTF8
int main(int argc, char **argv) {
#else
int wmain(int argc, wchar_t **wargv) {
	char **argv;
#endif
	ShellState data;
	const char *zInitFile = nullptr;
	int i;
	int rc = 0;
	bool warnInmemoryDb = false;
	bool readStdin = true;
	vector<string> extra_commands;
#if !SQLITE_SHELL_IS_UTF8
	char **argvToFree = 0;
	int argcToFree = 0;
#endif

	globalState = &data;

	setBinaryMode(stdin, 0);
	setvbuf(stderr, 0, _IONBF, 0); /* Make sure stderr is unbuffered */
	stdin_is_interactive = isatty(0);
	stdout_is_console = isatty(1);
	stderr_is_console = isatty(2);

	main_init(&data);

	/* On Windows, we must translate command-line arguments into UTF-8.
	** The SQLite memory allocator subsystem has to be enabled in order to
	** do this.  But we want to run an sqlite3_shutdown() afterwards so that
	** subsequent sqlite3_config() calls will work.  So copy all results into
	** memory that does not come from the SQLite memory allocator.
	*/
#if !SQLITE_SHELL_IS_UTF8
	argvToFree = (char **)malloc(sizeof(argv[0]) * argc * 2);
	argcToFree = argc;
	argv = argvToFree + argc;
	if (argv == 0)
		shell_out_of_memory();
	for (i = 0; i < argc; i++) {
		auto z = ShellState::Win32UnicodeToUtf8(wargv[i]);
		argv[i] = (char *)malloc(z.size() + 1);
		if (argv[i] == 0) {
			shell_out_of_memory();
		}
		memcpy(argv[i], z.c_str(), z.size() + 1);
		argvToFree[i] = argv[i];
	}
#endif

	assert(argc >= 1 && argv && argv[0]);
	program_name = argv[0];

	/* Make sure we have a valid signal handler early, before anything
	** else is done.
	*/
#ifdef SIGINT
	signal(SIGINT, interrupt_handler);
#elif (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)
	SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);
#endif

	/* Do an initial pass through the command-line argument to locate
	** the name of the database file, the name of the initialization file,
	** the size of the alternative malloc heap,
	** and the first command to execute.
	*/
	for (i = 1; i < argc; i++) {
		char *z;
		z = argv[i];
		if (z[0] != '-') {
			if (data.zDbFilename.empty()) {
				data.zDbFilename = z;
			} else {
				/* Excesss arguments are interpreted as SQL (or dot-commands) and
				** mean that nothing is read from stdin */
				readStdin = false;
				extra_commands.push_back(z);
			}
		}
		if (z[1] == '-') {
			z++;
		}
		if (strcmp(z, "-separator") == 0 || strcmp(z, "-nullvalue") == 0 || strcmp(z, "-newline") == 0 ||
		    strcmp(z, "-cmd") == 0) {
			(void)cmdline_option_value(argc, argv, ++i);
		} else if (strcmp(z, "-c") == 0 || strcmp(z, "-s") == 0 || strcmp(z, "-f") == 0) {
			(void)cmdline_option_value(argc, argv, ++i);
			stdin_is_interactive = false;
		} else if (strcmp(z, "-init") == 0) {
			zInitFile = cmdline_option_value(argc, argv, ++i);
		} else if (strcmp(z, "-batch") == 0) {
			/* Need to check for batch mode here to so we can avoid printing
			** informational messages (like from process_sqliterc) before
			** we do the actual processing of arguments later in a second pass.
			*/
			stdin_is_interactive = false;
		} else if (strcmp(z, "-readonly") == 0) {
			data.config.options.access_mode = duckdb::AccessMode::READ_ONLY;
		} else if (strcmp(z, "-unredacted") == 0) {
			data.config.options.allow_unsigned_extensions = true;
		} else if (strcmp(z, "-unsigned") == 0) {
			data.config.options.allow_unsigned_extensions = true;
		} else if (strcmp(z, "-safe") == 0) {
			safe_mode = true;
		} else if (strcmp(z, "-storage_version") == 0 || strcmp(z, "-storage-version") == 0) {
			auto storage_version = string(cmdline_option_value(argc, argv, ++i));
			if (storage_version != "latest") {
				utf8_printf(
				    stderr,
				    "%s: Error: unknown argument (%s) for '-storage-version', only 'latest' is supported currently\n",
				    program_name, storage_version.c_str());
			} else {
				data.config.options.serialization_compatibility =
				    duckdb::SerializationCompatibility::FromString("latest");
			}
		} else if (strcmp(z, "-bail") == 0) {
			bail_on_error = true;
		}
	}

	if (data.zDbFilename.empty()) {
		data.zDbFilename = ":memory:";
		warnInmemoryDb = argc == 1;
	}
	data.out = stdout;

	/* Go ahead and open the database file if it already exists.  If the
	** file does not exist, delay opening it.  This prevents empty database
	** files from being created if a user mistypes the database name argument
	** to the sqlite command-line tool.
	*/
	if (access(data.zDbFilename.c_str(), 0) == 0) {
		data.OpenDB();
	}

	/* Process the initialization file if there is one.  If no -init option
	** is given on the command line, look for a file named ~/.sqliterc and
	** try to process it.
	*/
	if (!data.ProcessDuckDBRC(zInitFile) && bail_on_error) {
		return 1;
	}

	/* Make a second pass through the command-line argument and set
	** options.  This second pass is delayed until after the initialization
	** file is processed so that the command-line arguments will override
	** settings in the initialization file.
	*/
	for (i = 1; i < argc; i++) {
		char *z = argv[i];
		if (z[0] != '-') {
			continue;
		}
		if (z[1] == '-') {
			z++;
		}
		if (strcmp(z, "-init") == 0) {
			i++;
		} else if (strcmp(z, "-html") == 0) {
			data.mode = RenderMode::HTML;
		} else if (strcmp(z, "-list") == 0) {
			data.mode = RenderMode::LIST;
		} else if (strcmp(z, "-quote") == 0) {
			data.mode = RenderMode::QUOTE;
		} else if (strcmp(z, "-line") == 0) {
			data.mode = RenderMode::LINE;
		} else if (strcmp(z, "-column") == 0) {
			data.mode = RenderMode::COLUMN;
		} else if (strcmp(z, "-json") == 0) {
			data.mode = RenderMode::JSON;
		} else if (strcmp(z, "-jsonlines") == 0) {
			data.mode = RenderMode::JSONLINES;
		} else if (strcmp(z, "-markdown") == 0) {
			data.mode = RenderMode::MARKDOWN;
		} else if (strcmp(z, "-table") == 0) {
			data.mode = RenderMode::TABLE;
		} else if (strcmp(z, "-box") == 0) {
			data.mode = RenderMode::BOX;
		} else if (strcmp(z, "-latex") == 0) {
			data.mode = RenderMode::LATEX;
		} else if (strcmp(z, "-csv") == 0) {
			data.mode = RenderMode::CSV;
			data.colSeparator = ",";
		} else if (strcmp(z, "-readonly") == 0) {
			data.config.options.access_mode = duckdb::AccessMode::READ_ONLY;
		} else if (strcmp(z, "-ascii") == 0) {
			data.mode = RenderMode::ASCII;
			data.colSeparator = SEP_Unit;
			data.rowSeparator = SEP_Record;
		} else if (strcmp(z, "-separator") == 0) {
			data.colSeparator = cmdline_option_value(argc, argv, ++i);
		} else if (strcmp(z, "-newline") == 0) {
			data.rowSeparator = cmdline_option_value(argc, argv, ++i);
		} else if (strcmp(z, "-nullvalue") == 0) {
			data.nullValue = cmdline_option_value(argc, argv, ++i);
		} else if (strcmp(z, "-header") == 0) {
			data.showHeader = 1;
		} else if (strcmp(z, "-noheader") == 0) {
			data.showHeader = 0;
		} else if (strcmp(z, "-echo") == 0) {
			data.ShellSetFlag(ShellFlags::SHFLG_Echo);
		} else if (strcmp(z, "-unsigned") == 0) {
			data.config.options.allow_unsigned_extensions = true;
		} else if (strcmp(z, "-unredacted") == 0) {
			data.config.options.allow_unredacted_secrets = true;
		} else if (strcmp(z, "-bail") == 0) {
			bail_on_error = true;
		} else if (strcmp(z, "-version") == 0) {
			printf("%s (%s) %s\n", duckdb::DuckDB::LibraryVersion(), duckdb::DuckDB::ReleaseCodename(),
			       duckdb::DuckDB::SourceID());
			return 0;
		} else if (strcmp(z, "-interactive") == 0) {
			stdin_is_interactive = true;
		} else if (strcmp(z, "-batch") == 0) {
			stdin_is_interactive = false;
		} else if (strcmp(z, "-help") == 0) {
			usage(1);
		} else if (strcmp(z, "-no-stdin") == 0) {
			readStdin = false;
		} else if (strcmp(z, "-f") == 0) {
			readStdin = false;
			if (i == argc - 1) {
				break;
			}
			auto old_bail = bail_on_error;
			bail_on_error = true;
			z = cmdline_option_value(argc, argv, ++i);
			if (!data.ProcessFile(string(z))) {
				return 1;
			}
			bail_on_error = old_bail;
		} else if (strcmp(z, "-cmd") == 0 || strcmp(z, "-c") == 0 || strcmp(z, "-s") == 0) {
			if (strcmp(z, "-c") == 0 || strcmp(z, "-s") == 0) {
				readStdin = false;
			}
			/* Run commands that follow -cmd first and separately from commands
			** that simply appear on the command-line.  This seems goofy.  It would
			** be better if all commands ran in the order that they appear.  But
			** we retain the goofy behavior for historical compatibility. */
			if (i == argc - 1) {
				break;
			}
			// Always bail if -c or -s fail
			bool bail = bail_on_error || !strcmp(z, "-c") || !strcmp(z, "-s");
			z = cmdline_option_value(argc, argv, ++i);
			rc = data.RunInitialCommand(z, bail);
			if (rc != 0) {
				return rc;
			}
		} else if (strcmp(z, "-safe") == 0) {
			// safe mode has been set before
		} else if (strcmp(z, "-ui") == 0) {
			// run the UI command
			rc = data.RunInitialCommand((char *)data.ui_command.c_str(), true);
			if (rc != 0) {
				return rc;
			}
		} else if (strcmp(z, "-storage_version") == 0) {
			// already processed on start-up
		} else {
			utf8_printf(stderr, "%s: Error: unknown option: %s\n", program_name, z);
			raw_printf(stderr, "Use -help for a list of options.\n");
			return 1;
		}
		data.cMode = data.mode;
	}

	if (!readStdin) {
		/* Run all arguments that do not begin with '-' as if they were separate
		** command-line inputs, except for the argToSkip argument which contains
		** the database filename.
		*/
		for (auto &cmd : extra_commands) {
			if (cmd[0] == '.') {
				rc = data.DoMetaCommand(cmd);
				if (rc) {
					return rc == 2 ? 0 : rc;
				}
			} else {
				data.OpenDB();
				auto success = data.ExecuteSQL(cmd.c_str());
				if (success != SuccessState::SUCCESS) {
					return rc != 0 ? rc : 1;
				}
			}
		}
	} else {
		/* Run commands received from standard input
		 */
		if (stdin_is_interactive) {
			string zHome;
			const char *zHistory;
			printf("DuckDB %s (%s) %.19s\n" /*extra-version-info*/
			       "Enter \".help\" for usage hints.\n",
			       duckdb::DuckDB::LibraryVersion(), duckdb::DuckDB::ReleaseCodename(), duckdb::DuckDB::SourceID());
			if (warnInmemoryDb) {
				printf("Connected to a ");
				ShellHighlight highlighter(data);
				highlighter.PrintText("transient in-memory database", PrintOutput::STDOUT, PrintColor::STANDARD,
				                      PrintIntensity::BOLD);
				printf(".\nUse \".open FILENAME\" to reopen on a "
				       "persistent database.\n");
			}
			zHistory = getenv("DUCKDB_HISTORY");
			if (!zHistory) {
				zHome = GetHomeDirectory() + "/.duckdb_history";
				zHistory = zHome.c_str();
			}
			if (zHistory) {
				shell_read_history(zHistory);
			}
#if HAVE_READLINE || HAVE_EDITLINE
			rl_attempted_completion_function = readline_completion;
#elif HAVE_LINENOISE
			linenoiseSetCompletionCallback(linenoise_completion);
#endif
			data.in = 0;
			rc = data.ProcessInput(InputMode::STANDARD);
			if (zHistory) {
				shell_stifle_history(2000);
				shell_write_history(zHistory);
			}
		} else {
			data.in = stdin;
			rc = data.ProcessInput(InputMode::STANDARD);
		}
	}
	data.SetTableName(0);
	data.db.reset();
	data.conn.reset();
	data.ResetOutput();
	data.doXdgOpen = 0;
	data.ClearTempFile();
#if !SQLITE_SHELL_IS_UTF8
	for (i = 0; i < argcToFree; i++) {
		free(argvToFree[i]);
	}
	free(argvToFree);
#endif
	return rc;
}
