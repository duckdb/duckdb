/*
** This file is automatically generated by the script in the canonical
** SQLite source tree at tool/mkshellc.tcl.  That script combines source
** code from various constituent source files of SQLite into this single
** "shell.c" file used to implement the SQLite command-line shell.
**
** Most of the code found below comes from the "src/shell.c.in" file in
** the canonical SQLite source tree.  That main file contains "INCLUDE"
** lines that specify other files in the canonical source tree that are
** inserted to getnerate this complete program source file.
**
** The code from multiple files is combined into this single "shell.c"
** source file to help make the command-line program easier to compile.
**
** To modify this program, get a copy of the canonical SQLite source tree,
** edit the src/shell.c.in" and/or some of the other files that are included
** by "src/shell.c.in", then rerun the tool/mkshellc.tcl script.
*/
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement the "sqlite" command line
** utility for accessing SQLite databases.
*/
#if (defined(_WIN32) || defined(WIN32)) && !defined(_CRT_SECURE_NO_WARNINGS)
/* This needs to come before any includes for MSVC compiler */
#define _CRT_SECURE_NO_WARNINGS
#endif

/*
** Determine if we are dealing with WinRT, which provides only a subset of
** the full Win32 API.
*/
#if !defined(SQLITE_OS_WINRT)
#define SQLITE_OS_WINRT 0
#endif

/*
** Warning pragmas copied from msvc.h in the core.
*/
#if defined(_MSC_VER)
#pragma warning(disable : 4054)
#pragma warning(disable : 4055)
#pragma warning(disable : 4100)
#pragma warning(disable : 4127)
#pragma warning(disable : 4130)
#pragma warning(disable : 4152)
#pragma warning(disable : 4189)
#pragma warning(disable : 4206)
#pragma warning(disable : 4210)
#pragma warning(disable : 4232)
#pragma warning(disable : 4244)
#pragma warning(disable : 4305)
#pragma warning(disable : 4306)
#pragma warning(disable : 4702)
#pragma warning(disable : 4706)
#endif /* defined(_MSC_VER) */

/*
** Enable large-file support for fopen() and friends on unix.
*/
#ifndef SQLITE_DISABLE_LFS
#define _LARGE_FILE 1
#ifndef _FILE_OFFSET_BITS
#define _FILE_OFFSET_BITS 64
#endif
#define _LARGEFILE_SOURCE 1
#endif

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#include "duckdb/common/box_renderer.hpp"
#include "duckdb/common/file_system.hpp"
#include "duckdb/parser/qualified_name.hpp"
#include "duckdb/parser/parser.hpp"
#include "duckdb/common/local_file_system.hpp"
#ifdef SHELL_INLINE_AUTOCOMPLETE
#include "autocomplete_extension.hpp"
#endif
#include "shell_extension.hpp"
#include <ctype.h>

#if !defined(_WIN32) && !defined(WIN32)
#include <signal.h>
#if !defined(__RTP__) && !defined(_WRS_KERNEL)
#include <pwd.h>
#endif
#endif
#if (!defined(_WIN32) && !defined(WIN32)) || defined(__MINGW32__)
#include <unistd.h>
#include <dirent.h>
#endif
#if defined(__MINGW32__)
#define DIRENT dirent
#ifndef S_ISLNK
#define S_ISLNK(mode) (0)
#endif
#endif
#include <sys/types.h>
#include <sys/stat.h>

#if HAVE_READLINE
#include <readline/readline.h>
#include <readline/history.h>
#endif

#if HAVE_EDITLINE
#include <editline/readline.h>
#endif

#if HAVE_EDITLINE || HAVE_READLINE

#define shell_add_history(X)    add_history(X)
#define shell_read_history(X)   read_history(X)
#define shell_write_history(X)  write_history(X)
#define shell_stifle_history(X) stifle_history(X)
#define shell_readline(X)       readline(X)

#elif HAVE_LINENOISE

#include "linenoise.h"
#define shell_add_history(X)    linenoiseHistoryAdd(X)
#define shell_read_history(X)   linenoiseHistoryLoad(X)
#define shell_write_history(X)  linenoiseHistorySave(X)
#define shell_stifle_history(X) linenoiseHistorySetMaxLen(X)
#define shell_readline(X)       linenoise(X)

#else

#define shell_read_history(X)
#define shell_write_history(X)
#define shell_stifle_history(X)

#define SHELL_USE_LOCAL_GETLINE 1
#endif

#include "duckdb.hpp"
#include "shell_renderer.hpp"
#include "shell_highlight.hpp"
#include "shell_state.hpp"
#include "duckdb/main/error_manager.hpp"

using duckdb::KeywordHelper;
using duckdb::SQLIdentifier;
using duckdb::SQLString;
using duckdb::StringUtil;
using duckdb::unordered_map;
using namespace duckdb_shell;

#if defined(_WIN32) || defined(WIN32)
#if SQLITE_OS_WINRT
#define SQLITE_OMIT_POPEN 1
#else
#include <io.h>
#include <fcntl.h>
#define isatty(h) _isatty(h)
#ifndef access
#define access(f, m) _access((f), (m))
#endif
#ifndef unlink
#define unlink _unlink
#endif
#ifndef strdup
#define strdup _strdup
#endif
#undef popen
#define popen _popen
#undef pclose
#define pclose _pclose
#endif
#else
/* Make sure isatty() has a prototype. */
extern int isatty(int);

#if !defined(__RTP__) && !defined(_WRS_KERNEL)
/* popen and pclose are not C89 functions and so are
** sometimes omitted from the <stdio.h> header */
extern FILE *popen(const char *, const char *);
extern int pclose(FILE *);
#else
#define SQLITE_OMIT_POPEN 1
#endif
#endif

#if defined(_WIN32_WCE)
/* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()
 * thus we always assume that we have a console. That can be
 * overridden with the -batch command line option.
 */
#define isatty(x) 1
#endif

#if defined(_WIN32) || defined(WIN32)
#if SQLITE_OS_WINRT
#include <intrin.h>
#endif
#include <windows.h>

#endif

/* On Windows, we normally run with output mode of TEXT so that \n characters
** are automatically translated into \r\n.  However, this behavior needs
** to be disabled in some cases (ex: when generating CSV output and when
** rendering quoted strings that contain \n characters).  The following
** routines take care of that.
*/
#if (defined(_WIN32) || defined(WIN32)) && !SQLITE_OS_WINRT
static void setBinaryMode(FILE *file, int isOutput) {
	if (isOutput)
		fflush(file);
	_setmode(_fileno(file), _O_BINARY);
}
static void setTextMode(FILE *file, int isOutput) {
	if (isOutput)
		fflush(file);
	_setmode(_fileno(file), _O_TEXT);
}
#else
#define setBinaryMode(X, Y)
#define setTextMode(X, Y)
#endif

/* True if the timer is enabled */
static bool enableTimer = false;

/* Return the current wall-clock time */
static int64_t timeOfDay(void) {
	using namespace std::chrono;
	return (int64_t)duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
}

#if !defined(_WIN32) && !defined(WIN32) && !defined(__minux)
#include <sys/time.h>
#include <sys/resource.h>

/* VxWorks does not support getrusage() as far as we can determine */
#if defined(_WRS_KERNEL) || defined(__RTP__)
struct rusage {
	struct timeval ru_utime; /* user CPU time used */
	struct timeval ru_stime; /* system CPU time used */
};
#define getrusage(A, B) memset(B, 0, sizeof(*B))
#endif

/* Saved resource information for the beginning of an operation */
static struct rusage sBegin; /* CPU time at start */
static int64_t iBegin;       /* Wall-clock time at start */

/*
** Begin timing an operation
*/
static void beginTimer(void) {
	if (enableTimer) {
		getrusage(RUSAGE_SELF, &sBegin);
		iBegin = timeOfDay();
	}
}

/* Return the difference of two time_structs in seconds */
static double timeDiff(struct timeval *pStart, struct timeval *pEnd) {
	return (pEnd->tv_usec - pStart->tv_usec) * 0.000001 + (double)(pEnd->tv_sec - pStart->tv_sec);
}

/*
** Print the timing results.
*/
static void endTimer(void) {
	if (enableTimer) {
		int64_t iEnd = timeOfDay();
		struct rusage sEnd;
		getrusage(RUSAGE_SELF, &sEnd);
		printf("Run Time (s): real %.3f user %f sys %f\n", (iEnd - iBegin) * 0.001,
		       timeDiff(&sBegin.ru_utime, &sEnd.ru_utime), timeDiff(&sBegin.ru_stime, &sEnd.ru_stime));
	}
}

#define BEGIN_TIMER beginTimer()
#define END_TIMER   endTimer()
#define HAS_TIMER   1

#elif (defined(_WIN32) || defined(WIN32))

/* Saved resource information for the beginning of an operation */
static HANDLE hProcess;
static FILETIME ftKernelBegin;
static FILETIME ftUserBegin;
static int64_t ftWallBegin;
typedef BOOL(WINAPI *GETPROCTIMES)(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME, LPFILETIME);
static GETPROCTIMES getProcessTimesAddr = NULL;

/*
** Check to see if we have timer support.  Return 1 if necessary
** support found (or found previously).
*/
static int hasTimer(void) {
	if (getProcessTimesAddr) {
		return 1;
	} else {
#if !SQLITE_OS_WINRT
		/* GetProcessTimes() isn't supported in WIN95 and some other Windows
		** versions. See if the version we are running on has it, and if it
		** does, save off a pointer to it and the current process handle.
		*/
		hProcess = GetCurrentProcess();
		if (hProcess) {
			HINSTANCE hinstLib = LoadLibrary(TEXT("Kernel32.dll"));
			if (NULL != hinstLib) {
				getProcessTimesAddr = (GETPROCTIMES)GetProcAddress(hinstLib, "GetProcessTimes");
				if (NULL != getProcessTimesAddr) {
					return 1;
				}
				FreeLibrary(hinstLib);
			}
		}
#endif
	}
	return 0;
}

/*
** Begin timing an operation
*/
static void beginTimer(void) {
	if (enableTimer && getProcessTimesAddr) {
		FILETIME ftCreation, ftExit;
		getProcessTimesAddr(hProcess, &ftCreation, &ftExit, &ftKernelBegin, &ftUserBegin);
		ftWallBegin = timeOfDay();
	}
}

/* Return the difference of two FILETIME structs in seconds */
static double timeDiff(FILETIME *pStart, FILETIME *pEnd) {
	int64_t i64Start = *((int64_t *)pStart);
	int64_t i64End = *((int64_t *)pEnd);
	return (double)((i64End - i64Start) / 10000000.0);
}

/*
** Print the timing results.
*/
static void endTimer(void) {
	if (enableTimer && getProcessTimesAddr) {
		FILETIME ftCreation, ftExit, ftKernelEnd, ftUserEnd;
		int64_t ftWallEnd = timeOfDay();
		getProcessTimesAddr(hProcess, &ftCreation, &ftExit, &ftKernelEnd, &ftUserEnd);
		printf("Run Time (s): real %.3f user %f sys %f\n", (ftWallEnd - ftWallBegin) * 0.001,
		       timeDiff(&ftUserBegin, &ftUserEnd), timeDiff(&ftKernelBegin, &ftKernelEnd));
	}
}

#define BEGIN_TIMER beginTimer()
#define END_TIMER   endTimer()
#define HAS_TIMER   hasTimer()

#else
#define BEGIN_TIMER
#define END_TIMER
#define HAS_TIMER 0
#endif

/*
** Used to prevent warnings about unused parameters
*/
#define UNUSED_PARAMETER(x) (void)(x)

/*
** Number of elements in an array
*/
#define ArraySize(X) (int)(sizeof(X) / sizeof(X[0]))

bool ShellState::HighlightErrors() const {
	if (highlight_errors == OptionType::DEFAULT) {
		return stderr_is_console;
	}
	return highlight_errors == OptionType::ON;
}

bool ShellState::HighlightResults() const {
	if (highlight_results == OptionType::DEFAULT) {
		return stdout_is_console;
	}
	return highlight_results == OptionType::ON;
}

/*
** Prompt strings. Initialized in main. Settable with
**   .prompt main continue
*/
static char mainPrompt[20];             /* First line prompt. default: "D "*/
static char continuePrompt[20];         /* Continuation prompt. default: "   ...> " */
static char continuePromptSelected[20]; /* Selected continuation prompt. default: "   ...> " */

/*
** Render output like fprintf().  Except, if the output is going to the
** console and if this is running on a Windows machine, translate the
** output from UTF-8 into MBCS.
*/
#if defined(_WIN32) || defined(WIN32)
static int win_utf8_mode = 0;

void utf8_printf(FILE *out, const char *zFormat, ...) {
	va_list ap;
	va_start(ap, zFormat);
	if (stdout_is_console && (out == stdout || out == stderr)) {
		char buffer[2048];
		int required_characters = vsnprintf(buffer, 2048, zFormat, ap);
		const char *z1;
		unique_ptr<char[]> zbuf;
		if (required_characters > 2048) {
			zbuf = unique_ptr<char[]>(new char[required_characters + 1]);
			vsnprintf(zbuf.get(), required_characters + 1, zFormat, ap);
			z1 = zbuf.get();
		} else {
			z1 = buffer;
		}
		if (win_utf8_mode && SetConsoleOutputCP(CP_UTF8)) {
			// we can write UTF8 directly
			fputs(z1, out);
		} else {
			// fallback to writing old style windows unicode
			auto z2 = ShellState::Win32Utf8ToMbcs(z1, false);
			fputs((const char *)z2.get(), out);
		}
	} else {
		vfprintf(out, zFormat, ap);
	}
	va_end(ap);
}
#elif !defined(utf8_printf)
#define utf8_printf fprintf
#endif

void ShellState::Print(PrintOutput output, const char *str) {
	utf8_printf(output == PrintOutput::STDOUT ? out : stderr, "%s", str);
}

void ShellState::Print(PrintOutput output, const string &str) {
	Print(output, str.c_str());
}

void ShellState::Print(const char *str) {
	Print(PrintOutput::STDOUT, str);
}

void ShellState::Print(const string &str) {
	Print(PrintOutput::STDOUT, str.c_str());
}

void ShellState::PrintPadded(const char *str, idx_t len) {
	utf8_printf(out, "%*s", int(len), str);
}

/*
** Render output like fprintf().  This should not be used on anything that
** includes string formatting (e.g. "%s").
*/
#if !defined(raw_printf)
#define raw_printf fprintf
#endif

/* Indicate out-of-memory and exit. */
static void shell_out_of_memory(void) {
	raw_printf(stderr, "Error: out of memory\n");
	exit(1);
}

ShellState::ShellState() : seenInterrupt(0) {
	config.error_manager->AddCustomError(
	    duckdb::ErrorType::UNSIGNED_EXTENSION,
	    "Extension \"%s\" could not be loaded because its signature is either missing or invalid and unsigned "
	    "extensions are disabled by configuration.\nStart the shell with the -unsigned parameter to allow this "
	    "(e.g. duckdb -unsigned).");
	nullValue = "NULL";
}

void ShellState::Destroy() {
	db.reset();
	conn.reset();
	last_result.reset();
}

/*
** Output string zUtf to stream pOut as w characters.  If w is negative,
** then right-justify the text.  W is the width in UTF-8 characters, not
** in bytes.  This is different from the %*.*s specification in printf
** since with %*.*s the width is measured in bytes, not characters.
*/
void ShellState::UTF8WidthPrint(idx_t w, const string &str, bool right_align) {
	auto zUtf = str.c_str();
	int i;
	int n;
	int aw = w < 0 ? -w : w;
#ifdef HAVE_LINENOISE
	i = linenoiseGetRenderPosition(zUtf, strlen(zUtf), aw, &n);
	if (i < 0)
#endif
		for (i = n = 0; zUtf[i]; i++) {
			if ((zUtf[i] & 0xc0) != 0x80) {
				n++;
				if (n == aw) {
					do {
						i++;
					} while ((zUtf[i] & 0xc0) == 0x80);
					break;
				}
			}
		}
	if (n >= aw) {
		PrintF("%.*s", i, zUtf);
	} else if (right_align) {
		PrintF("%*s%s", aw - n, "", zUtf);
	} else {
		PrintF("%s%*s", zUtf, aw - n, "");
	}
}

bool ShellState::IsSpace(char c) {
	return duckdb::StringUtil::CharacterIsSpace(c);
}

bool ShellState::IsDigit(char c) {
	return isdigit(c);
}

/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
*/
idx_t ShellState::StringLength(const char *z) {
	return strlen(z);
}

/*
** Return the length of a string in characters.
*/
idx_t ShellState::RenderLength(const char *z) {
#ifdef HAVE_LINENOISE
	return linenoiseComputeRenderWidth(z, strlen(z));
#else
	int n = 0;
	while (*z) {
		if ((0xc0 & *(z++)) != 0x80)
			n++;
	}
	return n;
#endif
}

idx_t ShellState::RenderLength(const string &str) {
	return RenderLength(str.c_str());
}

int ShellState::RunInitialCommand(const char *sql, bool bail) {
	int rc = 0;
	if (sql[0] == '.') {
		rc = DoMetaCommand(sql);
		if (rc && bail) {
			return rc == 2 ? false : rc;
		}
	} else {
		string zErrMsg;
		OpenDB();
		BEGIN_TIMER;
		auto res = ExecuteSQL(sql);
		END_TIMER;
		if (res == SuccessState::FAILURE && bail) {
			return 1;
		}
	}
	return 0;
}

/*
** Return true if zFile does not exist or if it is not an ordinary file.
*/
#ifdef _WIN32
#define notNormalFile(X) 0
#else
static int notNormalFile(const char *zFile) {
	struct stat x;
	int rc;
	memset(&x, 0, sizeof(x));
	rc = stat(zFile, &x);
	return rc || !S_ISREG(x.st_mode);
}
#endif

/*
** This routine reads a line of text from FILE in, stores
** the text in memory obtained from malloc() and returns a pointer
** to the text.  NULL is returned at end of file, or if malloc()
** fails.
**
** If zLine is not NULL then it is a malloced buffer returned from
** a previous call to this routine that may be reused.
*/
static char *local_getline(char *zLine, FILE *in) {
	idx_t nLine = zLine == 0 ? 0 : 100;
	idx_t n = 0;

#if defined(_WIN32) || defined(WIN32)
	int is_stdin = stdin_is_interactive && in == stdin;
	int is_utf8 = 0;
	if (is_stdin && win_utf8_mode) {
		if (SetConsoleCP(CP_UTF8)) {
			is_utf8 = 1;
		}
	}
#endif
	while (1) {
		if (n + 100 > nLine) {
			nLine = nLine * 2 + 100;
			zLine = (char *)realloc(zLine, nLine);
			if (zLine == 0)
				shell_out_of_memory();
		}
		if (fgets(&zLine[n], nLine - n, in) == 0) {
			if (n == 0) {
				free(zLine);
				return 0;
			}
			zLine[n] = 0;
			break;
		}
		while (zLine[n])
			n++;
		if (n > 0 && zLine[n - 1] == '\n') {
			n--;
			if (n > 0 && zLine[n - 1] == '\r')
				n--;
			zLine[n] = 0;
			break;
		}
	}
#if defined(_WIN32) || defined(WIN32)
	/* For interactive input on Windows systems, translate the
	** multi-byte characterset characters into UTF-8. */
	if (is_stdin && !is_utf8) {
		auto zTrans = ShellState::Win32MbcsToUtf8(zLine, 0);
		idx_t nTrans = zTrans.size() + 1;
		if (nTrans > nLine) {
			zLine = (char *)realloc(zLine, nTrans);
			if (zLine == 0) {
				shell_out_of_memory();
			}
		}
		memcpy(zLine, zTrans.data(), nTrans);
	}
#endif /* defined(_WIN32) || defined(WIN32) */
	return zLine;
}

/*
** Retrieve a single line of input text.
**
** If in==0 then read from standard input and prompt before each line.
** If isContinuation is true, then a continuation prompt is appropriate.
** If isContinuation is zero, then the main prompt should be used.
**
** If zPrior is not NULL then it is a buffer from a prior call to this
** routine that can be reused.
**
** The result is stored in space obtained from malloc() and must either
** be freed by the caller or else passed back into this routine via the
** zPrior argument for reuse.
*/
static char *one_input_line(FILE *in, char *zPrior, int isContinuation) {
	char *zPrompt;
	char *zResult;
	if (in != 0) {
		zResult = local_getline(zPrior, in);
	} else {
		zPrompt = isContinuation ? continuePrompt : mainPrompt;
#if SHELL_USE_LOCAL_GETLINE
		printf("%s", zPrompt);
		fflush(stdout);
		zResult = local_getline(zPrior, stdin);
#else
		free(zPrior);
		zResult = shell_readline(zPrompt);
#endif
	}
	return zResult;
}

/*
** Return the value of a hexadecimal digit.  Return -1 if the input
** is not a hex digit.
*/
static int hexDigitValue(char c) {
	if (c >= '0' && c <= '9')
		return c - '0';
	if (c >= 'a' && c <= 'f')
		return c - 'a' + 10;
	if (c >= 'A' && c <= 'F')
		return c - 'A' + 10;
	return -1;
}

/*
** Interpret zArg as an integer value, possibly with suffixes.
*/
int64_t ShellState::StringToInt(const string &arg) {
	int64_t v = 0;
	static const struct {
		const char *zSuffix;
		int iMult;
	} aMult[] = {
	    {"KiB", 1024}, {"MiB", 1024 * 1024}, {"GiB", 1024 * 1024 * 1024},
	    {"KB", 1000},  {"MB", 1000000},      {"GB", 1000000000},
	    {"K", 1000},   {"M", 1000000},       {"G", 1000000000},
	};
	int i;
	int isNeg = 0;
	auto zArg = arg.c_str();
	if (zArg[0] == '-') {
		isNeg = 1;
		zArg++;
	} else if (zArg[0] == '+') {
		zArg++;
	}
	if (zArg[0] == '0' && zArg[1] == 'x') {
		int x;
		zArg += 2;
		while ((x = hexDigitValue(zArg[0])) >= 0) {
			v = (v << 4) + x;
			zArg++;
		}
	} else {
		while (IsDigit(zArg[0])) {
			v = v * 10 + zArg[0] - '0';
			zArg++;
		}
	}
	for (i = 0; i < ArraySize(aMult); i++) {
		if (StringUtil::CIEquals(aMult[i].zSuffix, zArg)) {
			v *= aMult[i].iMult;
			break;
		}
	}
	return isNeg ? -v : v;
}

static const char *modeDescr[] = {"line",     "column", "list",    "semi",  "html",        "insert",    "quote",
                                  "tcl",      "csv",    "explain", "ascii", "prettyprint", "eqp",       "json",
                                  "markdown", "table",  "box",     "latex", "trash",       "jsonlines", "duckbox"};

/*
** These are the column/row/line separators used by the various
** import/export modes.
*/
#define SEP_Column "|"
#define SEP_Row    "\n"
#define SEP_Tab    "\t"
#define SEP_Space  " "
#define SEP_Comma  ","
#define SEP_CrLf   "\r\n"
#define SEP_Unit   "\x1F"
#define SEP_Record "\x1E"

/*
** Save or restore the current output mode
*/
void ShellState::PushOutputMode() {
	modePrior = mode;
	priorShFlgs = shellFlgs;
	colSepPrior = colSeparator;
	rowSepPrior = rowSeparator;
}

void ShellState::PopOutputMode() {
	mode = modePrior;
	shellFlgs = priorShFlgs;
	colSeparator = colSepPrior;
	rowSeparator = rowSepPrior;
}

/*
** Output the given string as a hex-encoded blob (eg. X'1234' )
*/
void ShellState::OutputHexBlob(const void *pBlob, int nBlob) {
	int i;
	char *zBlob = (char *)pBlob;
	PrintF("X'");
	for (i = 0; i < nBlob; i++) {
		PrintF("%02x", zBlob[i] & 0xff);
	}
	PrintF("'");
}

/*
** Output the given string as a quoted string using SQL quoting conventions.
**
** See also: output_quoted_escaped_string()
*/
void ShellState::OutputQuotedString(const char *z) {
	int i;
	char c;
	SetBinaryMode();
	for (i = 0; (c = z[i]) != 0 && c != '\''; i++) {
	}
	if (c == 0) {
		PrintF("'%s'", z);
	} else {
		PrintF("'");
		while (*z) {
			for (i = 0; (c = z[i]) != 0 && c != '\''; i++) {
			}
			if (c == '\'')
				i++;
			if (i) {
				PrintF("%.*s", i, z);
				z += i;
			}
			if (c == '\'') {
				PrintF("'");
				continue;
			}
			if (c == 0) {
				break;
			}
			z++;
		}
		PrintF("'");
	}
	SetTextMode();
}

/*
** Output the given string as a quoted string using SQL quoting conventions.
** Additionallly , escape the "\n" and "\r" characters so that they do not
** get corrupted by end-of-line translation facilities in some operating
** systems.
**
** This is like output_quoted_string() but with the addition of the \r\n
** escape mechanism.
*/
void ShellState::OutputQuotedEscapedString(const char *z) {
	bool needs_quoting = false;
	bool needs_concat = false;
	for (idx_t i = 0; z[i]; i++) {
		if (z[i] == '\n' || z[i] == '\r') {
			needs_quoting = true;
			needs_concat = true;
			break;
		}
		if (z[i] == '\'') {
			needs_quoting = true;
		}
	}
	if (!needs_quoting) {
		PrintF("'%s'", z);
		return;
	}
	string res;
	if (needs_concat) {
		res = "concat('";
	} else {
		res = "'";
	}
	for (idx_t i = 0; z[i]; i++) {
		switch (z[i]) {
		case '\n':
		case '\r':
			// newline - finish the current string literal and write the newline with a chr function
			res += "', chr(";
			if (z[i] == '\n') {
				res += "10";
			} else {
				res += "13";
			}
			res += "), '";
			break;
		case '\'':
			// escape the quote
			res += "''";
			break;
		default:
			res += z[i];
			break;
		}
	}
	res += "'";
	if (needs_concat) {
		res += ")";
	}
	PrintF("%s", res.c_str());
}

/*
** Output the given string as a quoted according to C or TCL quoting rules.
*/
void ShellState::OutputCString(const char *z) {
	unsigned int c;
	fputc('"', out);
	while ((c = *(z++)) != 0) {
		if (c == '\\') {
			fputc(c, out);
			fputc(c, out);
		} else if (c == '"') {
			fputc('\\', out);
			fputc('"', out);
		} else if (c == '\t') {
			fputc('\\', out);
			fputc('t', out);
		} else if (c == '\n') {
			fputc('\\', out);
			fputc('n', out);
		} else if (c == '\r') {
			fputc('\\', out);
			fputc('r', out);
		} else if (!isprint(c & 0xff)) {
			PrintF("\\%03o", c & 0xff);
		} else {
			fputc(c, out);
		}
	}
	fputc('"', out);
}

/*
** Output the given string as a quoted according to JSON quoting rules.
*/
void ShellState::OutputJSONString(const char *z, int n) {
	unsigned int c;
	if (n < 0)
		n = (int)strlen(z);
	fputc('"', out);
	while (n--) {
		c = *(z++);
		if (c == '\\' || c == '"') {
			fputc('\\', out);
			fputc(c, out);
		} else if (c <= 0x1f) {
			fputc('\\', out);
			if (c == '\b') {
				fputc('b', out);
			} else if (c == '\f') {
				fputc('f', out);
			} else if (c == '\n') {
				fputc('n', out);
			} else if (c == '\r') {
				fputc('r', out);
			} else if (c == '\t') {
				fputc('t', out);
			} else {
				PrintF("u%04x", c);
			}
		} else {
			fputc(c, out);
		}
	}
	fputc('"', out);
}

/*
** If a field contains any character identified by a 1 in the following
** array, then the string must be quoted for CSV.
*/
static const char needCsvQuote[] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0,
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
};

void ShellState::PrintOptionallyQuotedIdentifier(const char *input) {
	Print(StringUtil::Format("%s", SQLIdentifier(input)));
}

/*
** Output a single term of CSV.  Actually, p->colSeparator is used for
** the separator, which may or may not be a comma.  p->nullValue is
** the null value.  Strings are quoted if necessary.  The separator
** is only issued if bSep is true.
*/
void ShellState::OutputCSV(const char *z, int bSep) {
	if (!z) {
		Print(nullValue);
	} else {
		int i;
		int nSep = colSeparator.size();
		for (i = 0; z[i]; i++) {
			if (needCsvQuote[((unsigned char *)z)[i]] ||
			    (z[i] == colSeparator[0] && (nSep == 1 || memcmp(z, colSeparator.c_str(), nSep) == 0))) {
				i = 0;
				break;
			}
		}
		if (i == 0) {
			auto zQuoted = StringUtil::Format("%s", SQLIdentifier(z));
			Print(zQuoted);
		} else {
			Print(z);
		}
	}
	if (bSep) {
		Print(colSeparator);
	}
}

/*
** This routine runs when the user presses Ctrl-C
*/
static void interrupt_handler(int NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	auto &state = ShellState::Get();
	state.seenInterrupt++;
	if (state.seenInterrupt > 2) {
		exit(1);
	}
	if (state.conn) {
		state.conn->Interrupt();
	}
}

#if (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)
/*
** This routine runs for console events (e.g. Ctrl-C) on Win32
*/
static BOOL WINAPI ConsoleCtrlHandler(DWORD dwCtrlType /* One of the CTRL_*_EVENT constants */
) {
	if (dwCtrlType == CTRL_C_EVENT) {
		interrupt_handler(0);
		return TRUE;
	}
	return FALSE;
}
#endif

/*
** Print a schema statement.  Part of RenderMode::Semi and RenderMode::Pretty output.
**
** This routine converts some CREATE TABLE statements for shadow tables
** in FTS3/4/5 into CREATE TABLE IF NOT EXISTS statements.
*/
void ShellState::PrintSchemaLine(const char *z, const char *zTail) {
	if (!z || !zTail) {
		return;
	}
	if (StringGlob("CREATE TABLE ['\"]*", z)) {
		PrintF("CREATE TABLE IF NOT EXISTS %s%s", z + 13, zTail);
	} else {
		PrintF("%s%s", z, zTail);
	}
}
void ShellState::PrintSchemaLineN(char *z, int n, const char *zTail) {
	char c = z[n];
	z[n] = 0;
	PrintSchemaLine(z, zTail);
	z[n] = c;
}

/*
** Print N dashes
*/
void ShellState::PrintDashes(idx_t N) {
	const char zDash[] = "--------------------------------------------------";
	const idx_t nDash = sizeof(zDash) - 1;
	while (N > nDash) {
		fputs(zDash, out);
		N -= nDash;
	}
	PrintF("%.*s", static_cast<int>(N), zDash);
}

/*
** Print a markdown or table-style row separator using ascii-art
*/
void ShellState::PrintRowSeparator(idx_t nArg, const char *zSep, const vector<idx_t> &actualWidth) {
	if (nArg > 0) {
		fputs(zSep, out);
		PrintDashes(actualWidth[0] + 2);
		for (idx_t i = 1; i < nArg; i++) {
			fputs(zSep, out);
			PrintDashes(actualWidth[i] + 2);
		}
		fputs(zSep, out);
	}
	fputs("\n", out);
}

void ShellState::PrintMarkdownSeparator(idx_t nArg, const char *zSep, const vector<duckdb::LogicalType> &colTypes,
                                        const vector<idx_t> &actualWidth) {
	if (nArg > 0) {
		for (idx_t i = 0; i < nArg; i++) {
			Print(zSep);
			if (colTypes[i].IsNumeric()) {
				// right-align numerics in tables
				PrintDashes(actualWidth[i] + 1);
				Print(":");
			} else {
				PrintDashes(actualWidth[i] + 2);
			}
		}
		Print(zSep);
	}
	Print("\n");
}

void ShellState::SetBinaryMode() {
	setBinaryMode(out, 1);
}

void ShellState::SetTextMode() {
	setTextMode(out, 1);
}
/*
** This is the callback routine that the shell
** invokes for each row of a query result.
*/
int ShellState::RenderRow(RowRenderer &renderer, RowResult &result) {
	auto &data = result.data;
	if (data.empty()) {
		return 0;
	}
	renderer.Render(result);
	return 0;
}

SuccessState ShellState::RenderQuery(RowRenderer &renderer, const string &query) {
	auto &con = *conn;
	auto result = con.SendQuery(query);
	if (result->HasError()) {
		PrintDatabaseError(result->GetError());
		return SuccessState::FAILURE;
	}
	return RenderQueryResult(renderer, *result);
}

/*
** Set the destination table field of the ShellState structure to
** the name of the table given.  Escape any quote characters in the
** table name.
*/
void ShellState::SetTableName(const char *zName) {
	zDestTable = zName ? StringUtil::Format("%s", SQLIdentifier(zName)) : string();
}

/*
** Execute a query statement that will generate SQL output.  Print
** the result columns, comma-separated, on a line and then add a
** semicolon terminator to the end of that line.
**
** If the number of columns is 1 and that column contains text "--"
** then write the semicolon on a separate line.  That way, if a
** "--" comment occurs at the end of the statement, the comment
** won't consume the semicolon terminator.
*/
void ShellState::RunTableDumpQuery(const string &zSelect) {
	auto &con = *conn;
	auto result = con.Query(zSelect);
	if (result->HasError()) {
		PrintF("/**** ERROR: %s *****/\n", result->GetError().c_str());
		AddError();
		return;
	}
	for (auto &row : *result) {
		auto zStr = row.GetValue<string>(0);
		Print(zStr);
		auto z = zStr.c_str();
		if (!z) {
			z = "";
		}
		while (z[0] && (z[0] != '-' || z[1] != '-')) {
			z++;
		}
		if (z[0]) {
			PrintF("\n;\n");
		} else {
			PrintF(";\n");
		}
	}
}

string ShellState::strdup_handle_newline(const char *z) {
	static constexpr idx_t MAX_SIZE = 80;
	if (!z) {
		return nullValue;
	}
	if (cMode != RenderMode::BOX) {
		return z;
	}
	string result;
	idx_t count = 0;
	bool interrupted = false;
	for (const char *s = z; *s; s++) {
		if (*s == '\n') {
			result += "\\";
			result += "n";
		} else {
			result += *s;
		}
		count++;
		if (count >= MAX_SIZE && ((*s & 0xc0) != 0x80)) {
			interrupted = true;
			break;
		}
	}
	if (interrupted) {
		result += "...";
	}
	return result;
}

bool ShellState::ColumnTypeIsInteger(const char *type) {
	if (!type) {
		return false;
	}
	if (strcmp(type, "TINYINT") == 0) {
		return true;
	}
	if (strcmp(type, "SMALLINT") == 0) {
		return true;
	}
	if (strcmp(type, "INTEGER") == 0) {
		return true;
	}
	if (strcmp(type, "BIGINT") == 0) {
		return true;
	}
	if (strcmp(type, "FLOAT") == 0) {
		return true;
	}
	if (strcmp(type, "DOUBLE") == 0) {
		return true;
	}
	if (strcmp(type, "DECIMAL") == 0) {
		return true;
	}
	return false;
}

string GetTypeName(duckdb::LogicalType &type) {
	switch (type.id()) {
	case duckdb::LogicalTypeId::BOOLEAN:
		return "BOOLEAN";
	case duckdb::LogicalTypeId::TINYINT:
		return "TINYINT";
	case duckdb::LogicalTypeId::SMALLINT:
		return "SMALLINT";
	case duckdb::LogicalTypeId::INTEGER:
		return "INTEGER";
	case duckdb::LogicalTypeId::BIGINT:
		return "BIGINT";
	case duckdb::LogicalTypeId::FLOAT:
		return "FLOAT";
	case duckdb::LogicalTypeId::DOUBLE:
		return "DOUBLE";
	case duckdb::LogicalTypeId::DECIMAL:
		return "DECIMAL";
	case duckdb::LogicalTypeId::DATE:
		return "DATE";
	case duckdb::LogicalTypeId::TIME:
		return "TIME";
	case duckdb::LogicalTypeId::TIMESTAMP:
	case duckdb::LogicalTypeId::TIMESTAMP_NS:
	case duckdb::LogicalTypeId::TIMESTAMP_MS:
	case duckdb::LogicalTypeId::TIMESTAMP_SEC:
		return "TIMESTAMP";
	case duckdb::LogicalTypeId::VARCHAR:
		return "VARCHAR";
	case duckdb::LogicalTypeId::LIST:
		return "LIST";
	case duckdb::LogicalTypeId::MAP:
		return "MAP";
	case duckdb::LogicalTypeId::STRUCT:
		return "STRUCT";
	case duckdb::LogicalTypeId::BLOB:
		return "BLOB";
	default:
		return "NULL";
	}
}

SuccessState ShellState::RenderQueryResult(RowRenderer &renderer, duckdb::QueryResult &query_result) {
	RowResult result;
	// initialize the result and the column names
	idx_t nCol = query_result.ColumnCount();
	result.column_names.reserve(nCol);
	result.data.reserve(nCol);
	result.types.reserve(nCol);
	result.is_null.resize(nCol, false);
	for (idx_t c = 0; c < nCol; c++) {
		result.column_names.push_back(query_result.names[c]);
		result.types.push_back(query_result.types[c]);
	}
	for (auto &row : query_result) {
		if (seenInterrupt) {
			PrintF("Interrupt\n");
			return SuccessState::FAILURE;
		}
		result.is_null.clear();
		result.is_null.resize(nCol, false);
		result.data.clear();
		for (idx_t c = 0; c < nCol; c++) {
			if (row.IsNull(c)) {
				result.is_null[c] = true;
				result.data.push_back(renderer.NullValue());
			} else {
				result.data.push_back(row.GetValue<string>(c));
			}
		}
		RenderRow(renderer, result);
	}
	renderer.RenderFooter(result);
	return SuccessState::SUCCESS;
}

void ShellState::ConvertColumnarResult(duckdb::QueryResult &res, ColumnarResult &result) {
	// fetch the column count, column names and types
	result.column_count = res.ColumnCount();
	result.data.reserve(result.column_count * 4);
	for (idx_t c = 0; c < result.column_count; c++) {
		result.data.push_back(strdup_handle_newline(res.names[c].c_str()));
		result.types.push_back(res.types[c]);
		result.type_names.push_back(GetTypeName(res.types[c]));
	}

	for (auto &row : res) {
		for (idx_t c = 0; c < result.column_count; c++) {
			auto str_val = row.GetValue<string>(c);
			result.data.push_back(strdup_handle_newline(str_val.c_str()));
		}
	}

	// compute the column widths
	for (idx_t i = 0; i < result.column_count; i++) {
		int w = i < colWidth.size() ? colWidth[i] : 0;
		if (w < 0) {
			result.right_align.push_back(true);
			w = -w;
		} else {
			result.right_align.push_back(false);
		}
		result.column_width.push_back(static_cast<idx_t>(w));
	}
	for (idx_t i = 0; i < result.data.size(); i++) {
		idx_t width = RenderLength(result.data[i]);
		idx_t column_idx = i % result.column_count;
		if (width > result.column_width[column_idx]) {
			result.column_width[column_idx] = width;
		}
	}
}

/*
** Run a prepared statement and output the result in one of the
** table-oriented formats: RenderMode::Column, RenderMode::Markdown, RenderMode::Table,
** RenderMode::Box or RenderMode::DuckBox
**
** This is different from ordinary exec_prepared_stmt() in that
** it has to run the entire query and gather the results into memory
** first, in order to determine column widths, before providing
** any output.
*/
void ShellState::RenderColumnarResult(duckdb::QueryResult &res) {
	ColumnarResult result;
	ConvertColumnarResult(res, result);

	auto column_renderer = GetColumnRenderer();
	column_renderer->RenderHeader(result);
	auto colSep = column_renderer->GetColumnSeparator();
	auto rowSep = column_renderer->GetRowSeparator();
	auto row_start = column_renderer->GetRowStart();

	for (idx_t i = result.column_count, j = 0; i < result.data.size(); i++, j++) {
		if (j == 0 && row_start) {
			Print(row_start);
		}
		idx_t w = result.column_width[j];
		bool right_align = result.right_align[j];
		UTF8WidthPrint(w, result.data[i], right_align);
		if (j == result.column_count - 1) {
			Print(rowSep);
			j = -1;
			if (seenInterrupt) {
				return;
			}
		} else {
			Print(colSep);
		}
	}
	column_renderer->RenderFooter(result);
}

class DuckBoxRenderer : public duckdb::BaseResultRenderer {
public:
	DuckBoxRenderer(ShellState &state, bool highlight)
	    : shell_highlight(state), output(PrintOutput::STDOUT), highlight(highlight) {
	}

	void RenderLayout(const string &text) override {
		PrintText(text, HighlightElementType::LAYOUT);
	}

	void RenderColumnName(const string &text) override {
		PrintText(text, HighlightElementType::COLUMN_NAME);
	}

	void RenderType(const string &text) override {
		PrintText(text, HighlightElementType::COLUMN_TYPE);
	}

	void RenderValue(const string &text, const duckdb::LogicalType &type) override {
		if (type.IsNumeric()) {
			PrintText(text, HighlightElementType::NUMERIC_VALUE);
		} else if (type.IsTemporal()) {
			PrintText(text, HighlightElementType::TEMPORAL_VALUE);
		} else {
			PrintText(text, HighlightElementType::STRING_VALUE);
		}
	}

	void RenderNull(const string &text, const duckdb::LogicalType &type) override {
		PrintText(text, HighlightElementType::NULL_VALUE);
	}

	void RenderFooter(const string &text) override {
		PrintText(text, HighlightElementType::FOOTER);
	}

	void PrintText(const string &text, HighlightElementType element_type) {
		if (highlight) {
			shell_highlight.PrintText(text, output, element_type);
		} else {
			shell_highlight.state.Print(text);
		}
	}

private:
	ShellHighlight shell_highlight;
	PrintOutput output;
	bool highlight = true;
};

ShellState &ShellState::Get() {
	static ShellState state;
	return state;
}

SuccessState ShellState::ExecuteStatement(unique_ptr<duckdb::SQLStatement> statement) {
	if (!statement->named_param_map.empty()) {
		PrintDatabaseError("Prepared statement parameters cannot be used directly\nTo use prepared "
		                   "statement parameters, use PREPARE to prepare a statement, followed by EXECUTE");
		return SuccessState::FAILURE;
	}
	auto &con = *conn;
	unique_ptr<duckdb::QueryResult> result;
	if (ShellRenderer::IsColumnar(cMode) && cMode != RenderMode::TRASH && cMode != RenderMode::DUCKBOX) {
		// for row-wise rendering we can use streaming results
		result = con.SendQuery(std::move(statement));
	} else {
		result = con.Query(std::move(statement));
	}
	auto &res = *result;
	if (res.HasError()) {
		PrintDatabaseError(res.GetError());
		return SuccessState::FAILURE;
	}
	auto &properties = res.properties;
	if (properties.return_type == duckdb::StatementReturnType::CHANGED_ROWS) {
		auto result_chunk = res.Fetch();
		if (result_chunk && result_chunk->size() == 1) {
			// update total changes
			auto row_changes = result_chunk->GetValue(0, 0);
			if (!row_changes.IsNull() && row_changes.DefaultTryCastAs(duckdb::LogicalType::BIGINT)) {
				last_changes = row_changes.GetValue<int64_t>();
				total_changes += last_changes;
			}
		}
	}
	if (properties.return_type != duckdb::StatementReturnType::QUERY_RESULT) {
		// only SELECT statements return results that need to be rendered
		return SuccessState::SUCCESS;
	}
	if (res.type == duckdb::QueryResultType::MATERIALIZED_RESULT) {
		last_result = duckdb::unique_ptr_cast<duckdb::QueryResult, MaterializedQueryResult>(std::move(result));
	}
	if (ShellRenderer::IsColumnar(cMode)) {
		RenderColumnarResult(res);
		return SuccessState::SUCCESS;
	}
	if (cMode == RenderMode::TRASH) {
		// execute the query but don't render anything
		return SuccessState::SUCCESS;
	}
	if (cMode == RenderMode::DUCKBOX) {
		return RenderDuckBoxResult(res);
	}
	// row rendering
	auto renderer = GetRowRenderer();
	return RenderQueryResult(*renderer, res);
}

SuccessState ShellState::RenderDuckBoxResult(duckdb::QueryResult &res) {
	DuckBoxRenderer result_renderer(*this, HighlightResults());
	try {
		duckdb::BoxRendererConfig config;
		config.max_rows = max_rows;
		config.max_width = max_width;
		if (!outfile.empty() && outfile[0] != '|') {
			config.max_rows = (size_t)-1;
			config.max_width = (size_t)-1;
		}
		LargeNumberRendering large_rendering = large_number_rendering;
		if (!stdout_is_console) {
			config.max_width = (size_t)-1;
		}
		if (large_rendering == LargeNumberRendering::DEFAULT) {
			large_rendering = stdout_is_console ? LargeNumberRendering::FOOTER : LargeNumberRendering::NONE;
		}
		config.null_value = nullValue;
		if (columns) {
			config.render_mode = duckdb::RenderMode::COLUMNS;
		}
		config.decimal_separator = decimal_separator;
		config.thousand_separator = thousand_separator;
		config.max_width = max_width;
		config.large_number_rendering = static_cast<duckdb::LargeNumberRendering>(static_cast<int>(large_rendering));
		duckdb::BoxRenderer renderer(config);
		auto &materialized = res.Cast<duckdb::MaterializedQueryResult>();
		auto &con = *conn;
		renderer.Render(*con.context, res.names, materialized.Collection(), result_renderer);
		return SuccessState::SUCCESS;
	} catch (std::exception &ex) {
		string error_str = duckdb::ErrorData(ex).Message() + "\n";
		result_renderer.RenderLayout(error_str);
		return SuccessState::FAILURE;
	}
}
/*
** Execute a statement or set of statements.  Print
** any result rows/columns depending on the current mode
** set via the supplied callback.
*/
SuccessState ShellState::ExecuteSQL(const string &zSql) {
	auto &con = *conn;
	try {
		auto statements = con.ExtractStatements(zSql);
		for (auto &statement : statements) {
			idx_t start_pos = statement->stmt_location;
			idx_t len = statement->stmt_length;
			while (len > 0 && IsSpace(zSql[start_pos])) {
				start_pos++;
				len--;
			}
			auto zStmtSql = zSql.substr(start_pos, len);

			/* echo the sql statement if echo on */
			if (ShellHasFlag(ShellFlags::SHFLG_Echo)) {
				PrintF("%s\n", !zStmtSql.empty() ? zStmtSql.c_str() : zSql.c_str());
			}

			cMode = mode;
			if (statement->type == duckdb::StatementType::EXPLAIN_STATEMENT) {
				cMode = RenderMode::EXPLAIN;
			}

			auto rc = ExecuteStatement(std::move(statement));
			if (rc != SuccessState::SUCCESS) {
				return rc;
			}
		} /* end while */
	} catch (std::exception &ex) {
		duckdb::ErrorData error(ex);
		PrintDatabaseError(error.Message());
		return SuccessState::FAILURE;
	}
	return SuccessState::SUCCESS;
}

/*
** Return a list of pointers to strings which are the names of all
** columns in table zTab.   The memory to hold the names is dynamically
** allocated and must be released by the caller using a subsequent call
** to freeColumnList().
**
** The azCol[0] entry is usually NULL.  However, if zTab contains a rowid
** value that needs to be preserved, then azCol[0] is filled in with the
** name of the rowid column.
**
** The first regular column in the table is azCol[1].  The list is terminated
** by an entry with azCol[i]==0.
*/
vector<string> ShellState::TableColumnList(const char *zTab) {
	vector<string> result;

	auto zSql = StringUtil::Format("PRAGMA table_info=%s", SQLString(zTab));
	auto &con = *conn;
	auto query_result = con.Query(zSql);
	if (query_result->HasError()) {
		return result;
	}
	for (auto &row : *query_result) {
		result.push_back(row.GetValue<string>(1));
	}
	return result;
}

/*
** Lookup the schema for a table using the information schema.
*/
static string getTableSchema(duckdb::Connection &con, const char *zTable) {
	string zSchema;
	auto zSql = StringUtil::Format("SELECT table_schema FROM information_schema.tables "
	                               "WHERE table_name = %s AND table_type='BASE TABLE' "
	                               "ORDER BY (table_schema='main') DESC LIMIT 1",
	                               SQLString(zTable));

	auto query_result = con.Query(zSql);
	if (query_result->HasError()) {
		return zSchema;
	}
	for (auto &row : *query_result) {
		zSchema = row.GetValue<string>(0);
	}
	return zSchema;
}

/*
** Build a qualified name: schema.table
*/
static string buildQualifiedName(const char *zSchema, const char *zTable) {
	return StringUtil::Format("%s.%s", SQLIdentifier(zSchema), SQLIdentifier(zTable));
}

void ShellState::AddError() {
	nErr++;
}
/*
** Run zQuery.  Use dump_callback() as the callback routine so that
** the contents of the query are output as SQL statements.
**
** If we get a SQLITE_CORRUPT error, rerun the query after appending
** "ORDER BY rowid DESC" to the end.
*/
void ShellState::RunSchemaDumpQuery(const string &zQuery) {
	auto &con = *conn;
	auto result = con.Query(zQuery);
	for (auto &row : *result) {
		auto zTable = row.GetValue<string>(0);
		auto zType = row.GetValue<string>(1);
		auto zSql = row.GetValue<string>(2);

		// print sql
		PrintSchemaLine(zSql.c_str(), ";\n");
		if (zType == "table") {
			// dump table contents
			string sSelect;
			string sTable;

			auto zSchema = getTableSchema(con, zTable.c_str());
			auto zQualifiedName = buildQualifiedName(zSchema.c_str(), zTable.c_str());

			auto table_columns = TableColumnList(zQualifiedName.c_str());
			if (table_columns.empty()) {
				AddError();
				break;
			}

			if (!zSchema.empty()) {
				sTable += zQualifiedName;
			} else {
				sTable += StringUtil::Format("%s", SQLIdentifier(zTable));
			}

			/* Build an appropriate SELECT statement */
			sSelect += "SELECT ";
			for (idx_t i = 0; i < table_columns.size(); i++) {
				if (i > 0) {
					sSelect += ", ";
				}
				sSelect += StringUtil::Format("%s", SQLIdentifier(table_columns[i]));
			}
			sSelect += " FROM ";
			sSelect += zQualifiedName;

			auto savedDestTable = zDestTable;
			auto savedMode = mode;
			zDestTable = sTable;
			mode = cMode = RenderMode::INSERT;
			auto res = ExecuteSQL(sSelect);
			zDestTable = savedDestTable;
			mode = savedMode;
			if (res != SuccessState::SUCCESS) {
				AddError();
			}
		}
	}
}

SuccessState ShellState::ExecuteQuery(const string &query) {
	auto &con = *conn;
	auto res = con.Query(query);
	if (res->HasError()) {
		PrintF(PrintOutput::STDERR, "Failed to execute query \"%s\": %s\n", query.c_str(), res->GetError().c_str());
		return SuccessState::FAILURE;
	}
	return SuccessState::SUCCESS;
}

void ShellState::OpenDB(ShellOpenFlags flags) {
	if (!db) {
		try {
			db = make_uniq<duckdb::DuckDB>(zDbFilename.c_str(), &config);
			conn = make_uniq<duckdb::Connection>(*db);
		} catch (std::exception &ex) {
			duckdb::ErrorData error(ex);
			PrintDatabaseError(error.Message());
			if (flags == ShellOpenFlags::KEEP_ALIVE_ON_FAILURE) {
				db = make_uniq<duckdb::DuckDB>(":memory:", &config);
				conn = make_uniq<duckdb::Connection>(*db);
			} else {
				exit(1);
			}
		}
#ifdef SHELL_INLINE_AUTOCOMPLETE
		db->LoadStaticExtension<duckdb::AutocompleteExtension>();
#endif
		db->LoadStaticExtension<duckdb::ShellExtension>();
		if (safe_mode) {
			ExecuteQuery("SET enable_external_access=false");
		}
		if (stdout_is_console) {
			ExecuteQuery("PRAGMA enable_progress_bar");
			ExecuteQuery("PRAGMA enable_print_progress_bar");
		}
	}
}

/*
** Do C-language style dequoting.
**
**    \a    -> alarm
**    \b    -> backspace
**    \t    -> tab
**    \n    -> newline
**    \v    -> vertical tab
**    \f    -> form feed
**    \r    -> carriage return
**    \s    -> space
**    \"    -> "
**    \'    -> '
**    \\    -> backslash
**    \NNN  -> ascii character NNN in octal
*/
static string resolve_backslashes(const string &z) {
	string result;
	for (idx_t pos = 0; pos < z.size(); pos++) {
		auto c = z[pos];
		if (c == '\\' && pos + 1 < z.size()) {
			c = z[++pos];
			if (c == 'a') {
				c = '\a';
			} else if (c == 'b') {
				c = '\b';
			} else if (c == 't') {
				c = '\t';
			} else if (c == 'n') {
				c = '\n';
			} else if (c == 'v') {
				c = '\v';
			} else if (c == 'f') {
				c = '\f';
			} else if (c == 'r') {
				c = '\r';
			} else if (c == '"') {
				c = '"';
			} else if (c == '\'') {
				c = '\'';
			} else if (c == '\\') {
				c = '\\';
			} else if (c >= '0' && c <= '7') {
				c -= '0';
				if (pos + 1 < z.size() && z[pos + 1] >= '0' && z[pos + 1] <= '7') {
					pos++;
					c = (c << 3) + z[pos] - '0';
					if (pos + 1 < z.size() && z[pos + 1] >= '0' && z[pos + 1] <= '7') {
						pos++;
						c = (c << 3) + z[pos] - '0';
					}
				}
			}
		}
		result += c;
	}
	return result;
}

/*
** Interpret zArg as either an integer or a boolean value.  Return 1 or 0
** for TRUE and FALSE.  Return the integer value if appropriate.
*/
bool ShellState::StringToBool(const string &zArg) {
	idx_t i;
	if (zArg[0] == '0' && zArg[1] == 'x') {
		for (i = 2; hexDigitValue(zArg[i]) >= 0; i++) {
		}
	} else {
		for (i = 0; zArg[i] >= '0' && zArg[i] <= '9'; i++) {
		}
	}
	if (i > 0 && zArg[i] == 0) {
		return bool(ShellState::StringToInt(zArg) & 0xffffffff);
	}
	if (StringUtil::CIEquals(zArg, "on") || StringUtil::CIEquals(zArg, "yes")) {
		return true;
	}
	if (StringUtil::CIEquals(zArg, "off") || StringUtil::CIEquals(zArg, "no")) {
		return false;
	}
	PrintF(PrintOutput::STDERR, "ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n", zArg.c_str());
	return false;
}

/*
** Set or clear a shell flag according to a boolean value.
*/
void ShellState::SetOrClearFlag(ShellFlags mFlag, const string &zArg) {
	if (StringToBool(zArg)) {
		ShellSetFlag(mFlag);
	} else {
		ShellClearFlag(mFlag);
	}
}

/*
** Close an output file, assuming it is not stderr or stdout
*/
static void output_file_close(FILE *f) {
	if (f && f != stdout && f != stderr)
		fclose(f);
}

/*
** Try to open an output file.   The names "stdout" and "stderr" are
** recognized and do the right thing.  NULL is returned if the output
** filename is "off".
*/
static FILE *output_file_open(ShellState &state, const char *zFile, int bTextMode) {
	FILE *f = nullptr;
	if (strcmp(zFile, "stdout") == 0) {
		f = stdout;
	} else if (strcmp(zFile, "stderr") == 0) {
		f = stderr;
	} else if (strcmp(zFile, "off") == 0) {
		f = 0;
	} else {
		const string expanded_path = duckdb::FileSystem::ExpandPath(zFile, /*opener=*/nullptr);
		f = fopen(expanded_path.c_str(), bTextMode ? "w" : "wb");
		if (f == 0) {
			state.PrintF(PrintOutput::STDERR, "Error: cannot open \"%s\"\n", zFile);
		}
	}
	return f;
}

/*
** Change the output file back to stdout.
**
** If the p->doXdgOpen flag is set, that means the output was being
** redirected to a temporary file named by p->zTempFile.  In that case,
** launch start/open/xdg-open on that temporary file.
*/
void ShellState::ResetOutput() {
	if (outfile.size() > 1 && outfile[0] == '|') {
#ifndef SQLITE_OMIT_POPEN
		pclose(out);
#endif
	} else {
		output_file_close(out);
#ifndef SQLITE_NOHAVE_SYSTEM
		if (doXdgOpen) {
			const char *zXdgOpenCmd =
#if defined(_WIN32)
			    "start";
#elif defined(__APPLE__)
			    "open";
#else
			    "xdg-open";
#endif
			auto zCmd = StringUtil::Format("%s %s", zXdgOpenCmd, zTempFile);
			if (system(zCmd.c_str())) {
				PrintF(PrintOutput::STDERR, "Failed: [%s]\n", zCmd.c_str());
			} else {
				/* Give the start/open/xdg-open command some time to get
				** going before we continue, and potential delete the
				** zTempFile data file out from under it */
				Sleep(2000);
			}
			PopOutputMode();
			doXdgOpen = 0;
		}
#endif /* !defined(SQLITE_NOHAVE_SYSTEM) */
	}
	outfile = string();
	out = stdout;
	stdout_is_console = true;
}

void ShellState::PrintDatabaseError(const string &zErr) {
	if (!HighlightErrors()) {
		PrintF(PrintOutput::STDERR, "%s\n", zErr.c_str());
		return;
	}
	ShellHighlight shell_highlight(*this);
	shell_highlight.PrintError(zErr);
}

/*
** Compare the string as a command-line option with either one or two
** initial "-" characters.
*/
static bool optionMatch(const string &str, const string &zOpt) {
	auto zStr = str.c_str();
	if (zStr[0] != '-') {
		return false;
	}
	zStr++;
	if (zStr[0] == '-') {
		zStr++;
	}
	return StringUtil::Equals(zStr, zOpt);
}

/*
** Delete a file.
*/
int shellDeleteFile(const char *zFilename) {
	int rc;
#ifdef _WIN32
	auto z = ShellState::Win32Utf8ToUnicode(zFilename);
	rc = _wunlink((wchar_t *)z.get());
#else
	rc = unlink(zFilename);
#endif
	return rc;
}

/*
** Try to delete the temporary file (if there is one) and free the
** memory used to hold the name of the temp file.
*/
void ShellState::ClearTempFile() {
	if (!zTempFile.empty()) {
		return;
	}
	if (doXdgOpen) {
		return;
	}
	if (shellDeleteFile(zTempFile.c_str())) {
		return;
	}
	zTempFile = string();
}

/*
** Create a new temp file name with the given suffix.
*/
void ShellState::NewTempFile(const char *zSuffix) {
	ClearTempFile();
	zTempFile = string();
	if (zTempFile.empty()) {
		/* If db is an in-memory database then the TEMPFILENAME file-control
		** will not work and we will need to fallback to guessing */
		const char *zTemp;
		uint64_t r;
		GenerateRandomBytes(sizeof(r), &r);
		zTemp = getenv("TEMP");
		if (zTemp == 0)
			zTemp = getenv("TMP");
		if (zTemp == 0) {
#ifdef _WIN32
			zTemp = "\\tmp";
#else
			zTemp = "/tmp";
#endif
		}
		zTempFile = StringUtil::Format("%s/temp%llx.%s", zTemp, r, zSuffix);
	} else {
		zTempFile = StringUtil::Format("%z.%s", zTempFile, zSuffix);
	}
	if (zTempFile.empty()) {
		raw_printf(stderr, "out of memory\n");
		exit(1);
	}
}

enum class MetadataResult : uint8_t { SUCCESS = 0, FAIL = 1, EXIT = 2, PRINT_USAGE = 3 };

struct MetadataCommand {
	const char *command;
	idx_t argument_count;
	metadata_command_t callback;
	const char *usage;
	const char *description;
	idx_t match_size;
	const char *extra_description;
};

MetadataResult ToggleBail(ShellState &state, const vector<string> &args) {
	state.bail_on_error = state.StringToBool(args[1]);
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleBinary(ShellState &state, const vector<string> &args) {
	if (state.StringToBool(args[1])) {
		state.SetBinaryMode();
	} else {
		state.SetTextMode();
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ChangeDirectory(ShellState &state, const vector<string> &args) {
	if (state.safe_mode) {
		state.PrintF(PrintOutput::STDERR, ".cd cannot be used in -safe mode\n");
		return MetadataResult::FAIL;
	}
	int rc;
#if defined(_WIN32) || defined(WIN32)
	auto z = ShellState::Win32Utf8ToUnicode(args[1].c_str());
	rc = !SetCurrentDirectoryW((wchar_t *)z.get());
#else
	rc = chdir(args[1].c_str());
#endif
	if (rc) {
		state.PrintF(PrintOutput::STDERR, "Cannot change to directory \"%s\"\n", args[1].c_str());
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleChanges(ShellState &state, const vector<string> &args) {
	state.SetOrClearFlag(ShellFlags::SHFLG_CountChanges, args[1]);
	return MetadataResult::SUCCESS;
}

MetadataResult ShowDatabases(ShellState &state, const vector<string> &args) {
	state.OpenDB();

	auto renderer = state.GetRowRenderer(RenderMode::LIST);
	renderer->show_header = false;
	renderer->col_sep = ": ";
	auto res = state.RenderQuery(*renderer, "SELECT name, file FROM pragma_database_list");
	if (res == SuccessState::FAILURE) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetSeparator(ShellState &state, const vector<string> &args, const char *separator_name,
                            char &separator) {
	if (args.size() == 1) {
		state.PrintF("current %s separator: %c\n", separator_name, separator);
	} else if (args.size() != 2) {
		return MetadataResult::PRINT_USAGE;
	} else if (StringUtil::Equals(args[1], "space")) {
		separator = ' ';
	} else if (StringUtil::Equals(args[1], "none")) {
		separator = '\0';
	} else if (args[1].size() != 1) {
		raw_printf(stderr, ".%s_sep SEP must be one byte, \"space\" or \"none\"\n", separator_name);
		return MetadataResult::FAIL;
	} else {
		separator = args[1][0];
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetDecimalSep(ShellState &state, const vector<string> &args) {
	return SetSeparator(state, args, "decimal", state.decimal_separator);
}

MetadataResult SetThousandSep(ShellState &state, const vector<string> &args) {
	return SetSeparator(state, args, "thousand", state.thousand_separator);
}

MetadataResult SetLargeNumberRendering(ShellState &state, const vector<string> &args) {
	if (StringUtil::Equals(args[1], "all")) {
		state.large_number_rendering = LargeNumberRendering::ALL;
	} else if (StringUtil::Equals(args[1], "footer")) {
		state.large_number_rendering = LargeNumberRendering::FOOTER;
	} else {
		if (state.StringToBool(args[1])) {
			state.large_number_rendering = LargeNumberRendering::DEFAULT;
		} else {
			state.large_number_rendering = LargeNumberRendering::NONE;
		}
	}
	return MetadataResult::SUCCESS;
}

MetadataResult DumpTable(ShellState &state, const vector<string> &args) {
	string zLike;
	bool savedShowHeader = state.showHeader;
	int savedShellFlags = state.shellFlgs;
	state.ShellClearFlag(ShellFlags::SHFLG_Newlines);
	state.ShellClearFlag(ShellFlags::SHFLG_Echo);
	for (idx_t i = 1; i < args.size(); i++) {
		if (args[i][0] == '-') {
			const char *z = args[i].c_str() + 1;
			if (z[0] == '-')
				z++;
			if (StringUtil::Equals(z, "newlines")) {
				state.ShellSetFlag(ShellFlags::SHFLG_Newlines);
			} else {
				raw_printf(stderr, "Unknown option \"%s\" on \".dump\"\n", args[i].c_str());
				return MetadataResult::FAIL;
			}
		} else if (!zLike.empty()) {
			zLike = StringUtil::Format("%s OR name LIKE %s ESCAPE '\\'", zLike, SQLString(args[i]));
		} else {
			zLike = StringUtil::Format("name LIKE %s ESCAPE '\\'", SQLString(args[i]));
		}
	}

	state.OpenDB();

	/* When playing back a "dump", the content might appear in an order
	** which causes immediate foreign key constraints to be violated.
	** So disable foreign-key constraint enforcement to prevent problems. */
	state.PrintF("BEGIN TRANSACTION;\n");
	state.showHeader = 0;
	state.nErr = 0;
	if (zLike.empty()) {
		zLike = "true";
	}

	// Emit CREATE SCHEMA for non-main schemas first
	auto zSql = StringUtil::Format("SELECT DISTINCT table_schema FROM information_schema.tables "
	                               "WHERE table_schema != 'main' AND table_schema NOT LIKE 'pg_%%' "
	                               "AND table_schema != 'information_schema' "
	                               "AND table_name IN (SELECT name FROM sqlite_schema WHERE (%s) AND type=='table') "
	                               "ORDER BY table_schema",
	                               zLike);
	auto result = state.conn->Query(zSql);
	for (auto &row : *result) {
		auto schema = row.GetValue<string>(0);
		auto create_schema = StringUtil::Format("CREATE SCHEMA IF NOT EXISTS %s;", SQLIdentifier(schema));
		state.PrintF("%s;\n", create_schema.c_str());
	}

	zSql = StringUtil::Format("SELECT name, type, sql FROM sqlite_schema "
	                          "WHERE (%s) AND type=='table'"
	                          "  AND sql NOT NULL"
	                          " ORDER BY tbl_name='sqlite_sequence'",
	                          zLike);
	state.RunSchemaDumpQuery(zSql);
	zSql = StringUtil::Format("SELECT sql FROM sqlite_schema "
	                          "WHERE (%s) AND sql NOT NULL"
	                          "  AND type IN ('index','trigger','view')",
	                          zLike);
	state.RunTableDumpQuery(zSql);
	state.PrintF(state.nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");
	state.showHeader = savedShowHeader;
	state.shellFlgs = savedShellFlags;
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleEcho(ShellState &state, const vector<string> &args) {
	state.SetOrClearFlag(ShellFlags::SHFLG_Echo, args[1]);
	return MetadataResult::SUCCESS;
}

MetadataResult ExitProcess(ShellState &state, const vector<string> &args) {
	if (args.size() > 2) {
		return MetadataResult::PRINT_USAGE;
	}
	int rc = 0;
	if (args.size() > 1 && (rc = (int)ShellState::StringToInt(args[1])) != 0) {
		// exit immediately if a custom error code is provided
		exit(rc);
	}
	return MetadataResult::EXIT;
}

MetadataResult ToggleHeaders(ShellState &state, const vector<string> &args) {
	state.showHeader = state.StringToBool(args[1]);
	state.ShellSetFlag(ShellFlags::SHFLG_HeaderSet);
	return MetadataResult::SUCCESS;
}

MetadataResult SetHighlightColors(ShellState &state, const vector<string> &args) {
	if (args.size() < 3 || args.size() > 4) {
		return MetadataResult::PRINT_USAGE;
	}
	ShellHighlight highlighter(state);
	if (!highlighter.SetColor(args[1].c_str(), args[2].c_str(), args.size() == 3 ? nullptr : args[3].c_str())) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleHighlighErrors(ShellState &state, const vector<string> &args) {
	state.highlight_errors = state.StringToBool(args[1]) ? OptionType::ON : OptionType::OFF;
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleHighlightResult(ShellState &state, const vector<string> &args) {
	state.highlight_results = state.StringToBool(args[1]) ? OptionType::ON : OptionType::OFF;
	return MetadataResult::SUCCESS;
}

MetadataResult ShowHelp(ShellState &state, const vector<string> &args) {
	if (args.size() >= 2) {
		idx_t n = state.PrintHelp(args[1].c_str());
		if (n == 0) {
			state.PrintF("Nothing matches '%s'\n", args[1].c_str());
		}
	} else {
		state.PrintHelp(0);
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleLog(ShellState &state, const vector<string> &args) {
	if (state.safe_mode) {
		state.PrintF(PrintOutput::STDERR, ".log cannot be used in -safe mode\n");
		return MetadataResult::FAIL;
	}
	const char *zFile = args[1].c_str();
	output_file_close(state.pLog);
	state.pLog = output_file_open(state, zFile, 0);
	return MetadataResult::SUCCESS;
}

MetadataResult SetMaxRows(ShellState &state, const vector<string> &args) {
	if (args.size() > 2) {
		return MetadataResult::PRINT_USAGE;
	}
	if (args.size() == 1) {
		state.PrintF("current max rows: %zu\n", state.max_rows);
	} else {
		state.max_rows = (size_t)ShellState::StringToInt(args[1]);
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetMaxWidth(ShellState &state, const vector<string> &args) {
	if (args.size() > 2) {
		return MetadataResult::PRINT_USAGE;
	}
	if (args.size() == 1) {
		state.PrintF("current max rows: %zu\n", state.max_width);
	} else {
		state.max_width = (size_t)ShellState::StringToInt(args[1]);
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetColumnRendering(ShellState &state, const vector<string> &args) {
	state.columns = 1;
	return MetadataResult::SUCCESS;
}

MetadataResult SetRowRendering(ShellState &state, const vector<string> &args) {
	state.columns = 0;
	return MetadataResult::SUCCESS;
}

MetadataResult EnableSafeMode(ShellState &state, const vector<string> &args) {
	state.safe_mode = true;
	if (state.db) {
		// db has been opened - disable external access
		state.ExecuteQuery("SET enable_external_access=false");
	}
	return MetadataResult::SUCCESS;
}

bool ShellState::SetOutputMode(const string &mode_name, const char *tbl_name) {
	auto mode_str = mode_name.c_str();
	idx_t n2 = mode_name.size();
	char c2 = mode_str[0];
	if (tbl_name && !(c2 == 'i' && strncmp(mode_str, "insert", n2) == 0)) {
		PrintF(PrintOutput::STDERR, "TABLE argument can only be used with .mode insert");
		return false;
	}
	if (c2 == 'l' && n2 > 2 && strncmp(mode_str, "lines", n2) == 0) {
		mode = RenderMode::LINE;
		rowSeparator = SEP_Row;
	} else if (c2 == 'c' && strncmp(mode_str, "columns", n2) == 0) {
		mode = RenderMode::COLUMN;
		if (ShellHasFlag(ShellFlags::SHFLG_HeaderSet)) {
			showHeader = true;
		}
		rowSeparator = SEP_Row;
	} else if (c2 == 'l' && n2 > 2 && strncmp(mode_str, "list", n2) == 0) {
		mode = RenderMode::LIST;
		colSeparator = SEP_Column;
		rowSeparator = SEP_Row;
	} else if (c2 == 'h' && strncmp(mode_str, "html", n2) == 0) {
		mode = RenderMode::HTML;
	} else if (c2 == 't' && strncmp(mode_str, "tcl", n2) == 0) {
		mode = RenderMode::TCL;
		colSeparator = SEP_Space;
		rowSeparator = SEP_Row;
	} else if (c2 == 'c' && strncmp(mode_str, "csv", n2) == 0) {
		mode = RenderMode::CSV;
		colSeparator = SEP_Comma;
		rowSeparator = SEP_CrLf;
	} else if (c2 == 't' && strncmp(mode_str, "tabs", n2) == 0) {
		mode = RenderMode::LIST;
		colSeparator = SEP_Tab;
	} else if (c2 == 'i' && strncmp(mode_str, "insert", n2) == 0) {
		mode = RenderMode::INSERT;
		SetTableName(tbl_name ? tbl_name : "table");
	} else if (c2 == 'q' && strncmp(mode_str, "quote", n2) == 0) {
		mode = RenderMode::QUOTE;
		colSeparator = SEP_Comma;
		rowSeparator = SEP_Row;
	} else if (c2 == 'a' && strncmp(mode_str, "ascii", n2) == 0) {
		mode = RenderMode::ASCII;
		colSeparator = SEP_Unit;
		rowSeparator = SEP_Record;
	} else if (c2 == 'm' && strncmp(mode_str, "markdown", n2) == 0) {
		mode = RenderMode::MARKDOWN;
	} else if (c2 == 't' && strncmp(mode_str, "table", n2) == 0) {
		mode = RenderMode::TABLE;
	} else if (c2 == 'b' && strncmp(mode_str, "box", n2) == 0) {
		mode = RenderMode::BOX;
	} else if (c2 == 'd' && strncmp(mode_str, "duckbox", n2) == 0) {
		mode = RenderMode::DUCKBOX;
	} else if (c2 == 'j' && strncmp(mode_str, "json", n2) == 0) {
		mode = RenderMode::JSON;
	} else if (c2 == 'l' && strncmp(mode_str, "latex", n2) == 0) {
		mode = RenderMode::LATEX;
	} else if (c2 == 't' && strncmp(mode_str, "trash", n2) == 0) {
		mode = RenderMode::TRASH;
	} else if (c2 == 'j' && strncmp(mode_str, "jsonlines", n2) == 0) {
		mode = RenderMode::JSONLINES;
	} else {
		PrintF(PrintOutput::STDERR, "Error: mode should be one of: "
		                            "ascii box column csv duckbox html insert json jsonlines latex line "
		                            "list markdown quote table tabs tcl trash \n");
		return false;
	}
	cMode = mode;
	return true;
}

MetadataResult SetOutputMode(ShellState &state, const vector<string> &args) {
	if (args.size() > 3) {
		return MetadataResult::PRINT_USAGE;
	}
	if (args.size() == 1) {
		state.PrintF("current output mode: %s\n", modeDescr[int(state.mode)]);
	} else {
		if (!state.SetOutputMode(args[1], args.size() > 2 ? args[2].c_str() : nullptr)) {
			return MetadataResult::FAIL;
		}
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetNullValue(ShellState &state, const vector<string> &args) {
	state.nullValue = args[1];
	return MetadataResult::SUCCESS;
}

bool ShellState::ImportData(const vector<string> &args) {
	if (safe_mode) {
		PrintF(PrintOutput::STDERR, ".import cannot be used in -safe mode\n");
		return false;
	}
	string table_name;
	string file_name;
	unordered_map<string, string> generic_parameters;
	string function;

	for (idx_t i = 1; i < args.size(); i++) {
		auto z = args[i].c_str();
		if (z[0] == '-' && z[1] == '-') {
			z++;
		}
		if (z[0] != '-') {
			if (file_name.empty()) {
				file_name = z;
			} else if (table_name.empty()) {
				table_name = z;
			} else {
				PrintF("ERROR: extra argument: \"%s\".  Usage:\n", z);
				PrintHelp("import");
				return false;
			}
		} else if (strcmp(z, "-v") == 0) {
			// verbose - ignore
		} else if (strcmp(z, "-ascii") == 0) {
			PrintF(PrintOutput::STDERR, "-ascii mode is no longer supported for .import");
			exit(1);
		} else if (strcmp(z, "-csv") == 0) {
			function = "read_csv";
		} else if (strcmp(z, "-parquet") == 0) {
			function = "read_parquet";
		} else if (strcmp(z, "-json") == 0) {
			function = "read_json";
		} else {
			z++;
			if (i + 1 >= args.size()) {
				PrintF("ERROR: expected an argument for generic parameter: \"%s\".  Usage:\n", z);
				PrintHelp("import");
				return false;
			}
			generic_parameters[z] = args[++i];
		}
	}
	if (table_name.empty()) {
		PrintF("ERROR: missing %s argument. Usage:\n", file_name.empty() ? "FILE" : "TABLE");
		PrintHelp("import");
		return false;
	}
	if (function.empty()) {
		// derive function to use from file extension
		// FIXME: get this list from the system somehow
		unordered_map<string, string> function_map;
		function_map[".parquet"] = "read_parquet";
		function_map[".csv"] = "read_csv";
		function_map[".tsv"] = "read_csv";
		function_map[".tbl"] = "read_csv";
		function_map[".json"] = "read_json";
		function_map[".jsonl"] = "read_json";
		function_map[".ndjson"] = "read_json";
		function_map[".avro"] = "read_avro";
		function_map[".xlsx"] = "read_xlsx";

		vector<string> compression_suffixes {"", ".gz", ".zst"};

		for (auto &entry : function_map) {
			for (auto &compression_suffix : compression_suffixes) {
				auto suffix = entry.first + compression_suffix;
				if (StringUtil::EndsWith(file_name, suffix)) {
					function = entry.second;
					break;
				}
			}
			if (!function.empty()) {
				break;
			}
		}
		if (function.empty()) {
			// fallback to read_csv
			function = "read_csv";
		}
	}
	if (function == "read_csv" && generic_parameters.find("ignore_errors") == generic_parameters.end()) {
		generic_parameters["ignore_errors"] = "true";
	}
	seenInterrupt = 0;
	// check if the table exists
	OpenDB();
	auto &con = *conn;
	auto needCommit = con.context->transaction.IsAutoCommit();
	if (needCommit) {
		con.BeginTransaction();
	}
	auto table_info = con.TableInfo(table_name);

	string import_query;

	if (!table_info) {
		// table does not exist - create it
		import_query = StringUtil::Format("CREATE TABLE %s AS ", SQLIdentifier(table_name));
	} else {
		// table exists - insert into it
		import_query = StringUtil::Format("INSERT INTO %s ", SQLIdentifier(table_name));
	}
	import_query += StringUtil::Format("SELECT * FROM %s(%s", function, SQLString(file_name));
	// add the generic parameters
	for (auto &entry : generic_parameters) {
		import_query += StringUtil::Format(", %s=%s", SQLIdentifier(entry.first), SQLString(entry.second));
	}
	import_query += ")";
	auto result = con.Query(import_query);
	if (result->HasError()) {
		if (needCommit) {
			con.Rollback();
		}
		string error = StringUtil::Format("Failed To Import Error: Failed to import from file '%s'\n", file_name);
		PrintDatabaseError(error);
		PrintDatabaseError(result->GetError());
		return false;
	}
	if (needCommit) {
		con.Commit();
	}
	return true;
}

MetadataResult ImportData(ShellState &state, const vector<string> &args) {
	if (!state.ImportData(args)) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

bool ShellState::OpenDatabase(const vector<string> &args) {
	if (safe_mode) {
		PrintF(PrintOutput::STDERR, ".open cannot be used in -safe mode\n");
		return false;
	}
	string zNewFilename;  /* Name of the database file to open */
	idx_t iName = 1;      /* Index in azArg[] of the filename */
	bool newFlag = false; /* True to delete file before opening */
	/* Close the existing database */
	db.reset();
	conn.reset();
	zDbFilename = string();
	szMax = 0;
	/* Check for command-line arguments */
	config.options.access_mode = duckdb::AccessMode::READ_WRITE;
	for (iName = 1; iName < args.size() && args[iName][0] == '-'; iName++) {
		const char *z = args[iName].c_str();
		if (optionMatch(z, "new")) {
			newFlag = true;
		} else if (optionMatch(z, "readonly")) {
			config.options.access_mode = duckdb::AccessMode::READ_ONLY;
		} else if (optionMatch(z, "nofollow")) {
		} else if (z[0] == '-') {
			PrintF(PrintOutput::STDERR, "unknown option: %s\n", z);
			return false;
		}
	}
	/* If a filename is specified, try to open it first */
	if (args.size() > iName) {
		zNewFilename = args[iName];
	}
	if (!zNewFilename.empty()) {
		if (newFlag) {
			shellDeleteFile(zNewFilename.c_str());
		}
		zDbFilename = zNewFilename;
		OpenDB(ShellOpenFlags::KEEP_ALIVE_ON_FAILURE);
		if (!db) {
			PrintF(PrintOutput::STDERR, "Error: cannot open '%s'\n", zNewFilename.c_str());
		}
	}
	if (!db) {
		/* As a fall-back open a TEMP database */
		zDbFilename = string();
		OpenDB();
	}
	return true;
}

MetadataResult OpenDatabase(ShellState &state, const vector<string> &args) {
	if (!state.OpenDatabase(args)) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult PrintArguments(ShellState &state, const vector<string> &args) {
	for (idx_t i = 1; i < args.size(); i++) {
		if (i > 1) {
			state.PrintF(" ");
		}
		state.PrintF("%s", args[i].c_str());
	}
	state.PrintF("\n");
	return MetadataResult::SUCCESS;
}

MetadataResult SetPrompt(ShellState &, const vector<string> &args) {
	if (args.size() >= 2) {
		strncpy(mainPrompt, args[1].c_str(), (int)ArraySize(mainPrompt) - 1);
	}
	if (args.size() >= 3) {
		strncpy(continuePrompt, args[2].c_str(), (int)ArraySize(continuePrompt) - 1);
	}
	if (args.size() >= 4) {
		strncpy(continuePromptSelected, args[3].c_str(), (int)ArraySize(continuePromptSelected) - 1);
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetSeparator(ShellState &state, const vector<string> &args) {
	if (args.size() < 2 || args.size() > 3) {
		return MetadataResult::PRINT_USAGE;
	}
	state.colSeparator = args[1];
	if (args.size() >= 3) {
		state.rowSeparator = args[2];
	}
	return MetadataResult::SUCCESS;
}

MetadataResult QuitProcess(ShellState &, const vector<string> &args) {
	return MetadataResult::EXIT;
}

bool ShellState::SetOutputFile(const vector<string> &args, char output_mode) {
	if (safe_mode) {
		PrintF(PrintOutput::STDERR, ".output/.once/.excel cannot be used in -safe mode\n");
		return false;
	}
	string zFile;
	int bTxtMode = 0;
	int eMode = 0;
	bool bBOM = false;
	int bOnce = 0; /* 0: .output, 1: .once, 2: .excel */

	if (output_mode == 'e') {
		// .excel
		eMode = 'x';
		bOnce = 2;
	} else if (output_mode == 'o') {
		// .once
		bOnce = 1;
	}
	for (idx_t i = 1; i < args.size(); i++) {
		const char *z = args[i].c_str();
		if (z[0] == '-') {
			if (z[1] == '-') {
				z++;
			}
			if (strcmp(z, "-bom") == 0) {
				bBOM = true;
			} else if (output_mode != 'e' && strcmp(z, "-x") == 0) {
				eMode = 'x'; /* spreadsheet */
			} else if (output_mode != 'e' && strcmp(z, "-e") == 0) {
				eMode = 'e'; /* text editor */
			} else {
				PrintF("ERROR: unknown option: \"%s\".  Usage:\n", args[i].c_str());
				PrintHelp(args[0].c_str());
				return false;
			}
		} else if (zFile.empty()) {
			zFile = z;
		} else {
			PrintF("ERROR: extra parameter: \"%s\".  Usage:\n", args[i].c_str());
			PrintHelp(args[0].c_str());
			return false;
		}
	}
	if (zFile.empty()) {
		zFile = "stdout";
	}
	if (bOnce) {
		outCount = 2;
	} else {
		outCount = 0;
	}
	ResetOutput();
#ifndef SQLITE_NOHAVE_SYSTEM
	if (eMode == 'e' || eMode == 'x') {
		doXdgOpen = 1;
		PushOutputMode();
		if (eMode == 'x') {
			/* spreadsheet mode.  Output as CSV. */
			NewTempFile("csv");
			ShellClearFlag(ShellFlags::SHFLG_Echo);
			mode = RenderMode::CSV;
			colSeparator = SEP_Comma;
			rowSeparator = SEP_CrLf;
		} else {
			/* text editor mode */
			NewTempFile("txt");
			bTxtMode = 1;
		}
		zFile = zTempFile;
	}
#endif /* SQLITE_NOHAVE_SYSTEM */
	if (zFile[0] == '|') {
#ifdef SQLITE_OMIT_POPEN
		raw_printf(stderr, "Error: pipes are not supported in this OS\n");
		out = stdout;
		return false;
#else
		out = popen(zFile.c_str() + 1, "w");
		if (out == 0) {
			PrintF(PrintOutput::STDERR, "Error: cannot open pipe \"%s\"\n", zFile.c_str() + 1);
			out = stdout;
			return false;
		} else {
			if (bBOM) {
				fprintf(out, "\357\273\277");
			}
			outfile = zFile;
		}
#endif
	} else {
		out = output_file_open(*this, zFile.c_str(), bTxtMode);
		if (!out) {
			if (zFile == "off") {
				PrintF(PrintOutput::STDERR, "Error: cannot write to \"%s\"\n", zFile.c_str());
			}
			out = stdout;
			return false;
		} else {
			if (bBOM) {
				fprintf(out, "\357\273\277");
			}
			outfile = zFile;
		}
	}
	stdout_is_console = false;
	return true;
}

MetadataResult SetOutput(ShellState &state, const vector<string> &args) {
	if (!state.SetOutputFile(args, '\0')) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetOutputOnce(ShellState &state, const vector<string> &args) {
	if (!state.SetOutputFile(args, 'o')) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetOutputExcel(ShellState &state, const vector<string> &args) {
	if (!state.SetOutputFile(args, 'e')) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

bool ShellState::ReadFromFile(const string &file) {
	if (safe_mode) {
		PrintF(PrintOutput::STDERR, ".read cannot be used in -safe mode\n");
		return false;
	}
	FILE *inSaved = in;
	int savedLineno = lineno;
	int rc;
	if (notNormalFile(file.c_str()) || (in = fopen(file.c_str(), "rb")) == 0) {
		PrintF(PrintOutput::STDERR, "Error: cannot open \"%s\"\n", file.c_str());
		rc = 1;
	} else {
		rc = ProcessInput(InputMode::FILE);
		fclose(in);
	}
	in = inSaved;
	lineno = savedLineno;
	return rc == 0;
}

MetadataResult ReadFromFile(ShellState &state, const vector<string> &args) {
	if (!state.ReadFromFile(args[1])) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

bool ShellState::DisplaySchemas(const vector<string> &args) {
	const char *zName = nullptr;
	bool bDebug = 0;
	SuccessState rc = SuccessState::SUCCESS;

	OpenDB();

	RenderMode mode = RenderMode::SEMI;
	for (idx_t ii = 1; ii < args.size(); ii++) {
		if (optionMatch(args[ii], "indent")) {
			mode = RenderMode::PRETTY;
		} else if (optionMatch(args[ii], "debug")) {
			bDebug = true;
		} else if (zName == 0) {
			zName = args[ii].c_str();
		} else {
			raw_printf(stderr, "Usage: .schema ?--indent? ?LIKE-PATTERN?\n");
			return false;
		}
	}
	auto renderer = GetRowRenderer(mode);
	renderer->show_header = false;

	string sSelect;
	sSelect += "SELECT sql FROM sqlite_master WHERE ";
	if (zName) {
		auto zQarg = StringUtil::Format("%s", SQLString(zName));
		int bGlob = strchr(zName, '*') != 0 || strchr(zName, '?') != 0 || strchr(zName, '[') != 0;
		if (strchr(zName, '.')) {
			sSelect += "lower(printf('%s.%s',sname,tbl_name))";
		} else {
			sSelect += "lower(tbl_name)";
		}
		sSelect += bGlob ? " GLOB " : " LIKE ";
		sSelect += zQarg.c_str();
		if (!bGlob) {
			sSelect += " ESCAPE '\\' ";
		}
		sSelect += " AND ";
	}
	sSelect += "type!='meta' AND sql IS NOT NULL"
	           " ORDER BY name";
	if (bDebug) {
		PrintF("SQL: %s;\n", sSelect.c_str());
	} else {
		rc = RenderQuery(*renderer, sSelect);
	}
	if (rc == SuccessState::FAILURE) {
		raw_printf(stderr, "Error: querying schema information\n");
		return false;
	} else {
		return true;
	}
}

MetadataResult DisplaySchemas(ShellState &state, const vector<string> &args) {
	if (!state.DisplaySchemas(args)) {
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult RunShellCommand(ShellState &state, const vector<string> &args) {
	if (state.safe_mode) {
		state.Print(PrintOutput::STDERR, ".sh/.system cannot be used in -safe mode\n");
		return MetadataResult::FAIL;
	}
	int x;
	if (args.size() < 2) {
		return MetadataResult::PRINT_USAGE;
	}
	auto zCmd = StringUtil::Format(StringUtil::Contains(args[1], ' ') ? "%s" : "\"%s\"", args[1]);
	for (idx_t i = 2; i < args.size(); i++) {
		zCmd += StringUtil::Format(StringUtil::Contains(args[i], ' ') ? " %s" : " \"%s\"", args[i]);
	}
	x = system(zCmd.c_str());
	if (x) {
		state.PrintF(PrintOutput::STDERR, "System command returns %d\n", x);
	}
	return MetadataResult::SUCCESS;
}

void ShellState::ShowConfiguration() {
	PrintF("%12.12s: %s\n", "echo", ShellHasFlag(ShellFlags::SHFLG_Echo) ? "on" : "off");
	PrintF("%12.12s: %s\n", "headers", showHeader ? "on" : "off");
	PrintF("%12.12s: %s\n", "mode", modeDescr[int(mode)]);
	PrintF("%12.12s: ", "nullvalue");
	OutputCString(nullValue.c_str());
	PrintF("\n");
	PrintF("%12.12s: %s\n", "output", !outfile.empty() ? outfile.c_str() : "stdout");
	PrintF("%12.12s: ", "colseparator");
	OutputCString(colSeparator.c_str());
	PrintF("\n");
	PrintF("%12.12s: ", "rowseparator");
	OutputCString(rowSeparator.c_str());
	PrintF("\n");
	PrintF("%12.12s: ", "width");
	for (auto w : colWidth) {
		PrintF("%d ", w);
	}
	PrintF("\n");
	PrintF("%12.12s: %s\n", "filename", zDbFilename.c_str());
}

MetadataResult ShowConfiguration(ShellState &state, const vector<string> &args) {
	state.ShowConfiguration();
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleTimer(ShellState &state, const vector<string> &args) {
	enableTimer = state.StringToBool(args[1]);
	if (enableTimer && !HAS_TIMER) {
		raw_printf(stderr, "Error: timer not available on this system.\n");
		enableTimer = false;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ShowVersion(ShellState &state, const vector<string> &args) {
	state.PrintF("DuckDB %s (%s) %s\n" /*extra-version-info*/, duckdb::DuckDB::LibraryVersion(),
	             duckdb::DuckDB::ReleaseCodename(), duckdb::DuckDB::SourceID());
#define CTIMEOPT_VAL_(opt) #opt
#define CTIMEOPT_VAL(opt)  CTIMEOPT_VAL_(opt)
#if defined(__clang__) && defined(__clang_major__)
	state.PrintF("clang-" CTIMEOPT_VAL(__clang_major__) "." CTIMEOPT_VAL(__clang_minor__) "." CTIMEOPT_VAL(
	    __clang_patchlevel__) "\n");
#elif defined(_MSC_VER)
	state.PrintF("msvc-" CTIMEOPT_VAL(_MSC_VER) "\n");
#elif defined(__GNUC__) && defined(__VERSION__)
	state.PrintF("gcc-" __VERSION__ "\n");
#endif
	return MetadataResult::SUCCESS;
}

MetadataResult SetWidths(ShellState &state, const vector<string> &args) {
	state.colWidth.clear();
	for (idx_t j = 1; j < args.size(); j++) {
		state.colWidth.push_back((int)ShellState::StringToInt(args[j]));
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ShellState::DisplayEntries(const vector<string> &args, char type) {
	string s;
	OpenDB();

	if (args.size() > 2) {
		return MetadataResult::PRINT_USAGE;
	}

	// Parse the filter pattern to check for schema qualification
	string filter_pattern = args.size() > 1 ? args[1] : "%";
	string schema_filter = "";
	string table_filter = filter_pattern;

	// Parse the filter pattern to check for schema qualification
	try {
		auto components = duckdb::QualifiedName::ParseComponents(filter_pattern);
		if (components.size() >= 2) {
			// e.g : "schema.table" or "schema.%"
			schema_filter = components[0];
			table_filter = components[1];
			// e.g : "schema."
			if (table_filter.empty()) {
				table_filter = "%";
			}
		}
	} catch (const duckdb::ParserException &) {
		// If parsing fails, treat as a simple table pattern
		schema_filter = "";
		table_filter = filter_pattern;
	}

	// Use DuckDB's system tables instead of SQLite's sqlite_schema
	if (type == 't') {
		string schema_filter_str;
		string name_filter = "WHERE ao.name LIKE ?1";
		if (!schema_filter.empty()) {
			schema_filter_str = "\n  WHERE schema_name LIKE ?1";
			name_filter = "WHERE ao.name LIKE ?2";
		}
		s = StringUtil::Format(R"(
WITH all_objects AS (
  SELECT schema_name, table_name as name FROM duckdb_tables%s
  UNION ALL
  SELECT schema_name, view_name as name FROM duckdb_views%s
),
name_counts AS (
  SELECT name, COUNT(*) as count FROM all_objects
  GROUP BY name
),
disambiguated AS (
  SELECT
    CASE
      WHEN nc.count > 1 THEN ao.schema_name || '.' || ao.name
      ELSE ao.name
    END as display_name
  FROM all_objects ao
  JOIN name_counts nc ON ao.name = nc.name
  %s
)
SELECT DISTINCT display_name FROM disambiguated ORDER BY display_name
)",
		                       schema_filter_str, schema_filter_str, name_filter);
	} else {
		// For indexes, use the original SQLite approach
		s = R"(
SELECT name FROM
sqlite_schema
WHERE type='index' AND tbl_name LIKE ?1)";
	}

	auto &con = *conn;
	auto prepared = con.Prepare(s);
	if (prepared->HasError()) {
		PrintDatabaseError(prepared->GetError());
		return MetadataResult::FAIL;
	}

	duckdb::vector<duckdb::Value> bind_values;

	if (type == 't') {
		// Bind parameters for the new DuckDB query
		if (!schema_filter.empty()) {
			bind_values.emplace_back(schema_filter);
			bind_values.emplace_back(table_filter);
		} else {
			bind_values.emplace_back(filter_pattern);
		}
	} else {
		// Original binding for indexes
		if (args.size() > 1) {
			bind_values.emplace_back(args[1]);
		} else {
			bind_values.emplace_back("%");
		}
	}

	auto query_result = prepared->Execute(bind_values);
	if (query_result->HasError()) {
		PrintDatabaseError(query_result->GetError());
	}
	vector<string> result;
	for (auto &row : *query_result) {
		result.push_back(row.GetValue<string>(0));
	}

	/* Pretty-print the contents of array azResult[] to the output */
	if (!result.empty()) {
		idx_t maxlen = 0;
		for (auto &r : result) {
			idx_t len = r.size();
			if (len > maxlen) {
				maxlen = len;
			}
		}
		idx_t nPrintCol = 80 / (maxlen + 2);
		if (nPrintCol < 1) {
			nPrintCol = 1;
		}
		idx_t nPrintRow = (result.size() + nPrintCol - 1) / nPrintCol;
		for (idx_t i = 0; i < nPrintRow; i++) {
			for (idx_t j = i; j < result.size(); j += nPrintRow) {
				const char *zSp = j < nPrintRow ? "" : "  ";
				PrintF("%s%-*s", zSp, static_cast<int>(maxlen), result[j].c_str());
			}
			PrintF("\n");
		}
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ShowIndexes(ShellState &state, const vector<string> &args) {
	return state.DisplayEntries(args, 'i');
}

MetadataResult ShowTables(ShellState &state, const vector<string> &args) {
	return state.DisplayEntries(args, 't');
}

MetadataResult SetUICommand(ShellState &state, const vector<string> &args) {
	if (args.size() < 1) {
		return MetadataResult::PRINT_USAGE;
	}
	string command;
	for (idx_t i = 1; i < args.size(); i++) {
		if (i > 1) {
			command += " ";
		}
		command += args[i];
	}
	state.ui_command = "CALL " + command;
	return MetadataResult::SUCCESS;
}

#if defined(_WIN32) || defined(WIN32)
MetadataResult SetUTF8Mode(ShellState &state, const vector<string> &args) {
	win_utf8_mode = 1;
	return MetadataResult::SUCCESS;
}
#endif

#ifdef HAVE_LINENOISE
MetadataResult ToggleHighlighting(ShellState &state, const vector<string> &args) {
	linenoiseSetHighlighting(state.StringToBool(args[1]));
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleErrorRendering(ShellState &state, const vector<string> &args) {
	linenoiseSetErrorRendering(state.StringToBool(args[1]));
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleCompletionRendering(ShellState &state, const vector<string> &args) {
	linenoiseSetCompletionRendering(state.StringToBool(args[1]));
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleMultiLine(ShellState &state, const vector<string> &args) {
	if (!args.empty()) {
		return MetadataResult::PRINT_USAGE;
	}
	linenoiseSetMultiLine(true);
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleSingleLine(ShellState &state, const vector<string> &args) {
	if (!args.empty()) {
		return MetadataResult::PRINT_USAGE;
	}
	linenoiseSetMultiLine(false);
	return MetadataResult::SUCCESS;
}

MetadataResult TrySetHighlightColor(ShellState &state, const string &component, const string &code) {
	char error[1024];
	if (!linenoiseTrySetHighlightColor(component.c_str(), code.c_str(), error, 1024)) {
		state.PrintF(PrintOutput::STDERR, "%s\n", error);
		return MetadataResult::FAIL;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetRenderHighlightColor(ShellState &state, const vector<string> &args) {
	return TrySetHighlightColor(state, args[1], args[2]);
}

enum class DeprecatedHighlightColors {
	COMMENT,
	COMMENT_CODE,
	CONSTANT,
	CONSTANT_CODE,
	KEYWORD,
	KEYWORD_CODE,
	ERROR,
	ERROR_CODE,
	CONT,
	CONT_CODE,
	CONT_SEL,
	CONT_SEL_CODE
};

template <DeprecatedHighlightColors T>
MetadataResult SetHighlightingColor(ShellState &state, const vector<string> &args) {
	string literal;
	switch (T) {
	case DeprecatedHighlightColors::COMMENT:
		literal = "comment";
		break;
	case DeprecatedHighlightColors::COMMENT_CODE:
		literal = "commentcode";
		break;
	case DeprecatedHighlightColors::CONSTANT:
		literal = "constant";
		break;
	case DeprecatedHighlightColors::CONSTANT_CODE:
		literal = "constantcode";
		break;
	case DeprecatedHighlightColors::KEYWORD:
		literal = "keyword";
		break;
	case DeprecatedHighlightColors::KEYWORD_CODE:
		literal = "keywordcode";
		break;
	case DeprecatedHighlightColors::ERROR:
		literal = "error";
		break;
	case DeprecatedHighlightColors::ERROR_CODE:
		literal = "errorcode";
		break;
	case DeprecatedHighlightColors::CONT:
		literal = "cont";
		break;
	case DeprecatedHighlightColors::CONT_CODE:
		literal = "contcode";
		break;
	case DeprecatedHighlightColors::CONT_SEL:
		literal = "cont_sel";
		break;
	case DeprecatedHighlightColors::CONT_SEL_CODE:
		literal = "cont_selcode";
		break;
	default:
		throw std::runtime_error("eek");
	}
	state.PrintF(PrintOutput::STDERR,
	             "WARNING: .%s [COLOR] will be removed in a future release, use .render_color %s %s instead\n",
	             literal.c_str(), literal.c_str(), args[1].c_str());
	return TrySetHighlightColor(state, literal, args[1]);
}

#endif

static const MetadataCommand metadata_commands[] = {
    {"bail", 2, ToggleBail, "on|off", "Stop after hitting an error.  Default OFF", 3, ""},
    {"binary", 2, ToggleBinary, "on|off", "Turn binary output on or off.  Default OFF", 3, ""},
    {"cd", 2, ChangeDirectory, "DIRECTORY", "Change the working directory to DIRECTORY", 0, ""},
    {"changes", 2, ToggleChanges, "on|off", "Show number of rows changed by SQL", 3, ""},
    {"columns", 1, SetColumnRendering, "", "Column-wise rendering of query results", 0, ""},
#ifdef HAVE_LINENOISE
    {"comment", 2, SetHighlightingColor<DeprecatedHighlightColors::COMMENT>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for comment values", 0, nullptr},
    {"commentcode", 2, SetHighlightingColor<DeprecatedHighlightColors::COMMENT_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for comment values", 0, nullptr},
    {"constant", 2, SetHighlightingColor<DeprecatedHighlightColors::CONSTANT>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for constant values", 0, nullptr},
    {"constantcode", 2, SetHighlightingColor<DeprecatedHighlightColors::CONSTANT_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for constant values", 0, nullptr},
    {"cont", 2, SetHighlightingColor<DeprecatedHighlightColors::CONT>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for continuation markers", 0, nullptr},
    {"contcode", 2, SetHighlightingColor<DeprecatedHighlightColors::CONT_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for continuation markers", 0, nullptr},
    {"cont_sel", 2, SetHighlightingColor<DeprecatedHighlightColors::CONT_SEL>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for continuation markers", 0, nullptr},
    {"cont_selcode", 2, SetHighlightingColor<DeprecatedHighlightColors::CONT_SEL_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for continuation markers", 0, nullptr},
#endif
    {"decimal_sep", 0, SetDecimalSep, "SEP",
     "Sets the decimal separator used when rendering numbers. Only for duckbox mode.", 3, ""},
    {"databases", 1, ShowDatabases, "", "List names and files of attached databases", 2, ""},
    {
        "dump",
        0,
        DumpTable,
        "?TABLE?",
        "Render database content as SQL",
        0,
        "Options:\n\t--newlines\tAllow unescaped newline characters in output\nTABLE is a LIKE pattern for the tables "
        "to dump\nAdditional LIKE patterns can be given in subsequent arguments",
    },
    {"echo", 2, ToggleEcho, "on|off", "Turn command echo on or off", 3, ""},
    {"edit", 0, nullptr, "", "Opens an external text editor to edit a query.", 0,
     "Notes:\n\t* The editor is read from the environment variables\n\t  DUCKDB_EDITOR, EDITOR, VISUAL in-order\n\t* "
     "If "
     "none of these are set, the default editor is vi\n\t* \\e can be used as an alias for .edit"},
#ifdef HAVE_LINENOISE
    {"error", 2, SetHighlightingColor<DeprecatedHighlightColors::ERROR>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for errors", 0, nullptr},
    {"errorcode", 2, SetHighlightingColor<DeprecatedHighlightColors::ERROR_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for errors", 0, nullptr},
#endif
    {"excel", 0, SetOutputExcel, "", "Display the output of next command in spreadsheet", 0,
     "--bom\tPut a UTF8 byte-order mark on intermediate file"},
    {"exit", 0, ExitProcess, "?CODE?", "Exit this program with return-code CODE", 0, ""},
    {"headers", 2, ToggleHeaders, "on|off", "Turn display of headers on or off", 0, ""},
    {"help", 0, ShowHelp, "?-all? ?PATTERN?", "Show help text for PATTERN", 0, ""},
#ifdef HAVE_LINENOISE
    {"highlight", 2, ToggleHighlighting, "on|off", "Toggle syntax highlighting in the shell on/off", 0, ""},
#endif
    {"highlight_colors", 0, SetHighlightColors, "OPTIONS", "Configure highlighting colors", 0, ""},
    {"highlight_errors", 2, ToggleHighlighErrors, "on|off", "Turn highlighting of errors on or off", 0, ""},
    {"highlight_results", 2, ToggleHighlightResult, "on|off", "Turn highlighting of results on or off", 0, ""},
    {"import", 0, ImportData, "FILE TABLE", "Import data from FILE into TABLE", 0,
     "Options:\n\t--csv\tImport data from CSV (read_csv)\n\t--json\tImport data from JSON "
     "(read_json)\n\t--parquet\tImport data from Parquet (read_parquet)\n\t--[parameter] [value]\tProvides a parameter "
     "to the reader function\n\tNotes:\n\t* If TABLE does not exist, it is created.\n\t* If file type is not selected, "
     "the input mode is derived from the file extension\n\t* Generic parameters are passed to the reader functions"},
    {"indexes", 0, ShowIndexes, "?TABLE?", "Show names of indexes", 0,
     "Notes:\n\t* If TABLE is specified, only show indexes for\n\t  tables matching TABLE using the LIKE operator."},
    {"indices", 0, ShowIndexes, "?TABLE?", "Show names of indexes", 0},
#ifdef HAVE_LINENOISE
    {"keyword", 2, SetHighlightingColor<DeprecatedHighlightColors::KEYWORD>, "?COLOR?",
     "DEPRECATED: Sets the syntax highlighting color used for keywords", 0, nullptr},
    {"keywordcode", 2, SetHighlightingColor<DeprecatedHighlightColors::KEYWORD_CODE>, "?CODE?",
     "DEPRECATED: Sets the syntax highlighting terminal code used for keywords", 0, nullptr},
#endif
    {"large_number_rendering", 2, SetLargeNumberRendering, "MODE",
     "Toggle readable rendering of large numbers (duckbox only)", 0, "Mode: all|footer|off"},
    {"log", 2, ToggleLog, "FILE|off", "Turn logging on or off.  FILE can be stderr/stdout", 0, ""},
    {"maxrows", 0, SetMaxRows, "COUNT",
     "Sets the maximum number of rows for display (default: 40). Only for duckbox mode.", 0, ""},
    {"maxwidth", 0, SetMaxWidth, "COUNT",
     "Sets the maximum width in characters. 0 defaults to terminal width. Only for duckbox mode.", 0, ""},
    {"mode", 0, SetOutputMode, "MODE ?TABLE?", "Set output mode", 0,
     "MODE is one of:\n\tascii\tColumns/rows delimited by 0x1F and 0x1E\n\tbox\tTables using unicode box-drawing "
     "characters\n\tcsv\tComma-separated values\n\tcolumn\tOutput in columns. (See .width)\n\tduckbox\tTables "
     "with extensive features\n\thtml\tHTML <table> code\n\tinsert\tSQL insert statements for TABLE\n\t"
     "json\tResults in a JSON array\n\tjsonlines\tResults in a NDJSON\n\tlatex\tLaTeX tabular environment code\n\t"
     "line\tOne value per line\n\tlist\tValues delimited by \"|\"\n\tmarkdown\tMarkdown table format\n\t"
     "quote\tEscape answers as for SQL\n\ttable\tASCII-art table\n\ttabs\tTab-separated values\n\ttcl\tTCL list "
     "elements\n\ttrash\tNo output"},
#ifdef HAVE_LINENOISE
    {"multiline", 1, ToggleMultiLine, "", "Sets the render mode to multi-line", 0, ""},
#endif
    {"nullvalue", 2, SetNullValue, "STRING", "Use STRING in place of NULL values", 0, ""},

    {"open", 0, OpenDatabase, "?OPTIONS? ?FILE?", "Close existing database and reopen FILE", 2,
     "Options:\n\t--new\tInitialize FILE to an empty database\n\t--nofollow\tDo not follow symbolic "
     "links\n\t--readonly\tOpen FILE in read-only mode"},
    {"once", 0, SetOutputOnce, "?FILE?", "Output for the next SQL command only to FILE", 0,
     "If FILE begins with '|' then open as a pipe\n\t--bom\tPut a UTF8 byte-order mark at the beginning\n\t-e\tSend "
     "output to the system text editor\n\t-x\tSend output as CSV to a spreadsheet (same as \".excel\")"},
    {"output", 0, SetOutput, "?FILE?", "Send output to FILE or stdout if FILE is omitted", 0,
     "If FILE begins with '|' then open as a pipe\n\t--bom\tPut a UTF8 byte-order mark at the beginning\n\t-e\tSend "
     "output to the system text editor\n\t-x\tSend output as CSV to a spreadsheet (same as \".excel\")"},
    {"print", 0, PrintArguments, "STRING...", "Print literal STRING", 3, ""},
    {"prompt", 0, SetPrompt, "MAIN CONTINUE", "Replace the standard prompts", 0, ""},

    {"quit", 0, QuitProcess, "", "Exit this program", 0, ""},
    {"read", 2, ReadFromFile, "FILE", "Read input from FILE", 3, ""},
#ifdef HAVE_LINENOISE
    {"render_color", 3, SetRenderHighlightColor, "?COMP? ?COLOR?",
     "Configure highlighting colors for the interactive prompt", 0, ""},
    {"render_completion", 2, ToggleCompletionRendering, "on|off",
     "Toggle displaying of completion prompts in the shell on/off", 0, ""},
    {"render_errors", 2, ToggleErrorRendering, "on|off", "Toggle rendering of errors in the shell on/off", 0, ""},
#endif
    {"rows", 1, SetRowRendering, "", "Row-wise rendering of query results (default)", 0, ""},
    {"safe_mode", 0, EnableSafeMode, "", "enable safe-mode", 0, ""},
    {"separator", 0, SetSeparator, "COL ?ROW?", "Change the column and row separators", 0, ""},
    {"schema", 0, DisplaySchemas, "?PATTERN?", "Show the CREATE statements matching PATTERN", 0,
     "Options:\n\t--indent\tTry to pretty-print the schema"},
    {"shell", 0, RunShellCommand, "CMD ARGS...", "Run CMD ARGS... in a system shell", 0, ""},
    {"show", 1, ShowConfiguration, "", "Show the current values for various settings", 0, ""},
#ifdef HAVE_LINENOISE
    {"singleline", 1, ToggleSingleLine, "", "Sets the render mode to single-line", 0, ""},
#endif
    {"system", 0, RunShellCommand, "CMD ARGS...", "Run CMD ARGS... in a system shell", 0, ""},
    {"tables", 0, ShowTables, "?TABLE?", "List names of tables matching LIKE pattern TABLE", 2, ""},
    {"thousand_sep", 0, SetThousandSep, "SEP",
     "Sets the thousand separator used when rendering numbers. Only for duckbox mode.", 4, ""},
    {"timer", 2, ToggleTimer, "on|off", "Turn SQL timer on or off", 0, ""},
    {"ui_command", 0, SetUICommand, "[command]", "Set the UI command", 0, ""},
    {"version", 1, ShowVersion, "", "Show the version", 0, ""},
    {"width", 0, SetWidths, "NUM1 NUM2 ...", "Set minimum column widths for columnar output", 0,
     "Negative values right-justify"},
#if defined(_WIN32) || defined(WIN32)
    {"utf8", 1, SetUTF8Mode, "", "Enable experimental UTF-8 console output mode", 0, ""},
#endif
    {nullptr, 0, nullptr, 0, nullptr}};

bool ShouldPrintCommand(const MetadataCommand &command, const string &glob_pattern) {
	if (!command.extra_description) {
		return false;
	}
	if (StringUtil::Contains(command.description, "DEPRECATED")) {
		return false;
	}
	// check if the command matches the pattern
	if (glob_pattern.empty()) {
		// no pattern - always matches
		return true;
	}
	// explicit pattern provided - glob
	return ShellState::StringGlob(glob_pattern.c_str(), command.command);
}

struct PrintCommandInfo {
	string command_name;
	string first_part;
	string second_part;
	HighlightElementType first_part_highlight = HighlightElementType::NONE;
};

idx_t ShellState::PrintHelp(const char *pattern) {
	bool print_extended = false;
	string glob_pattern;
	if (pattern) {
		// if a pattern is provided we always print extended info
		print_extended = true;
		if (StringUtil::Equals(pattern, "-a") || StringUtil::Equals(pattern, "-all") ||
		    StringUtil::Equals(pattern, "--all")) {
			// --all matches all commands
			glob_pattern = string();
		} else {
			glob_pattern = StringUtil::Format("%s*", pattern);
		}
	}

	constexpr idx_t MIN_SPACING = 4;
	constexpr idx_t SPACING_PER_LAYER = 2;
	vector<PrintCommandInfo> print_info_list;
	// gather a list of all print statements
	for (idx_t i = 0; metadata_commands[i].command; i++) {
		auto &command = metadata_commands[i];
		if (!ShouldPrintCommand(command, glob_pattern)) {
			continue;
		}
		PrintCommandInfo print_info;
		print_info.command_name = StringUtil::Format(".%s", command.command);
		print_info.first_part += StringUtil::Format(" %s", command.usage);
		print_info.second_part = command.description;
		print_info.first_part_highlight = HighlightElementType::STRING_CONSTANT;
		print_info_list.push_back(std::move(print_info));

		if (print_extended) {
			// process extended info
			PrintCommandInfo current_command;
			bool first_part = true;
			bool after_newline = true;
			for (auto c = command.extra_description; *c; c++) {
				if (*c == '\n') {
					// newline - flush the current command and reset
					print_info_list.push_back(std::move(current_command));
					current_command = PrintCommandInfo();
					first_part = true;
					after_newline = true;
				} else if (*c == '\t') {
					// tab
					if (after_newline) {
						// tab right after newline - add spaces
						current_command.first_part += string(SPACING_PER_LAYER, ' ');
					} else {
						// tab not right after newline move to second part
						if (!first_part) {
							throw duckdb::InternalException(
							    "Failed to parse extra description for command \"%s\" - only one tab (switch from "
							    "first -> second part) was expected",
							    command.command);
						}
						first_part = false;
					}
				} else {
					if (after_newline) {
						// add one more "layer" to commands
						current_command.first_part += string(SPACING_PER_LAYER, ' ');
						if (*c == '-') {
							current_command.first_part_highlight = HighlightElementType::STRING_CONSTANT;
						}
					}
					after_newline = false;
					if (first_part) {
						current_command.first_part += *c;
					} else {
						current_command.second_part += *c;
					}
				}
			}
			if (!current_command.first_part.empty()) {
				// push final command
				print_info_list.push_back(std::move(current_command));
			}
		}
	}
	// figure out alignment based on the total first part print size
	idx_t max_lhs_size = 0;
	for (auto &print_info : print_info_list) {
		if (print_info.second_part.empty()) {
			// only print info with two parts needs to influence padding
			continue;
		}
		idx_t lhs_size = print_info.command_name.size() + print_info.first_part.size() + MIN_SPACING;
		if (lhs_size > max_lhs_size) {
			max_lhs_size = lhs_size;
		}
	}

	// print
	for (auto &print_info : print_info_list) {
		idx_t lhs_size = print_info.command_name.size() + print_info.first_part.size();
		string spaces;
		if (!print_info.second_part.empty()) {
			// only add padding for lines that have extra info
			spaces = string(max_lhs_size - lhs_size, ' ');
		}
		ShellHighlight highlighter(*this);
		if (!print_info.command_name.empty()) {
			highlighter.PrintText(print_info.command_name, PrintOutput::STDOUT, HighlightElementType::KEYWORD);
		}
		highlighter.PrintText(print_info.first_part, PrintOutput::STDOUT, print_info.first_part_highlight);
		PrintF("%s%s\n", spaces.c_str(), print_info.second_part.c_str());
	}
	if (!print_extended) {
		PrintF("\nRun .help --all for extended information\n");
	}
	return print_info_list.size();
}

/*
** If an input line begins with "." then invoke this routine to
** process that line.
**
** Return 1 on error, 2 to exit, and 0 otherwise.
*/
int ShellState::DoMetaCommand(const string &zLine) {
	int n, c;
	int rc = 0;
	vector<string> args;
	// skip initial dot
	idx_t pos = 1;
	while (pos < zLine.size()) {
		// skip initial spaces
		while (pos < zLine.size() && IsSpace(zLine[pos])) {
			pos++;
		}
		if (pos >= zLine.size()) {
			break;
		}
		string arg;
		if (zLine[pos] == '\'' || zLine[pos] == '"') {
			// quoted argument - scan until next quote
			auto quote = zLine[pos];
			// skip over the initial quote
			pos++;

			while (pos < zLine.size() && zLine[pos] != quote) {
				if (zLine[pos] == '\\' && quote == '"' && pos + 1 < zLine.size()) {
					// skip over any escaped characters
					arg += zLine[pos++];
				}
				arg += zLine[pos++];
			}
			if (pos < zLine.size()) {
				// skip over the final quote
				pos++;
			}
			if (quote == '"') {
				arg = resolve_backslashes(arg);
			}
		} else {
			// unquoted argument - scan until the next space
			while (pos < zLine.size() && !IsSpace(zLine[pos])) {
				arg += zLine[pos];
				pos++;
			}
			arg = resolve_backslashes(arg);
		}
		args.push_back(std::move(arg));
	}

	/* Process the input line.
	 */
	if (args.empty()) {
		return 0; /* no tokens, no error */
	}
	n = args[0].size();
	c = args[0][0];
	ClearTempFile();

	bool found_argument = false;
	for (idx_t command_idx = 0; metadata_commands[command_idx].command; command_idx++) {
		auto &command = metadata_commands[command_idx];
		idx_t match_size = command.match_size ? command.match_size : n;
		if (n < int(match_size) || c != *command.command || strncmp(args[0].c_str(), command.command, n) != 0) {
			continue;
		}
		found_argument = true;
		MetadataResult result = MetadataResult::PRINT_USAGE;
		if (!command.callback) {
			raw_printf(stderr, "Command \"%s\" is unsupported in the current version of the CLI\n", command.command);
			result = MetadataResult::FAIL;
		} else if (command.argument_count == 0 || int(command.argument_count) == args.size()) {
			result = command.callback(*this, args);
		}
		if (result == MetadataResult::PRINT_USAGE) {
			string error = StringUtil::Format("Invalid Command Error: Invalid usage of command '.%s'\n\n", args[0]);
			error += StringUtil::Format("Usage: '.%s %s'", command.command, command.usage);
			PrintDatabaseError(error);
			rc = 1;
			result = MetadataResult::FAIL;
		}
		rc = int(result);
		break;
	}
	if (!found_argument) {
		string error = StringUtil::Format("Unknown Command Error: Unrecognized command '%s'\n", args[0]);

		vector<string> command_names;
		for (idx_t command_idx = 0; metadata_commands[command_idx].command; command_idx++) {
			auto &command = metadata_commands[command_idx];
			command_names.push_back(string(".") + command.command);
		}
		auto candidates_msg = StringUtil::CandidatesErrorMessage(command_names, args[0], "Did you mean");
		error += candidates_msg + "\n";
		error += "Run '.help' for more information.";
		PrintDatabaseError(error);
		rc = 1;
	}

	if (outCount) {
		outCount--;
		if (outCount == 0) {
			ResetOutput();
		}
	}
	return rc;
}

/*
** Return TRUE if a semicolon occurs anywhere in the first N characters
** of string z[].
*/
static bool line_contains_semicolon(const char *z, idx_t N) {
	for (idx_t i = 0; i < N; i++) {
		if (z[i] == ';') {
			return true;
		}
	}
	return false;
}

/*
** Test to see if a line consists entirely of whitespace.
*/
static bool _all_whitespace(const char *z) {
	for (; *z; z++) {
		if (ShellState::IsSpace(z[0])) {
			continue;
		}
		if (*z == '/' && z[1] == '*') {
			z += 2;
			while (*z && (*z != '*' || z[1] != '/')) {
				z++;
			}
			if (*z == 0) {
				return false;
			}
			z++;
			continue;
		}
		if (*z == '-' && z[1] == '-') {
			z += 2;
			while (*z && *z != '\n') {
				z++;
			}
			if (*z == 0)
				return true;
			continue;
		}
		return false;
	}
	return true;
}

enum class SQLParseState { SEMICOLON, WHITESPACE, NORMAL };

static const char *skipDollarQuotedString(const char *zSql, const char *delimiterStart, idx_t delimiterLength) {
	for (; *zSql; zSql++) {
		if (*zSql == '$') {
			// found a dollar
			// move forward and find the next dollar
			zSql++;
			auto start = zSql;
			while (*zSql && *zSql != '$') {
				zSql++;
			}
			if (!zSql[0]) {
				// reached end of string while looking for the dollar
				return nullptr;
			}
			// check if the dollar quoted string name matches
			if (delimiterLength == idx_t(zSql - start)) {
				if (memcmp(start, delimiterStart, delimiterLength) == 0) {
					return zSql;
				}
			}
			// dollar does not match - reset position to start and keep looking
			zSql = start - 1;
		}
	}
	// unterminated
	return nullptr;
}

bool ShellState::SQLIsComplete(const char *zSql) {
	auto state = SQLParseState::NORMAL;

	for (; *zSql; zSql++) {
		SQLParseState next_state;
		switch (*zSql) {
		case ';':
			next_state = SQLParseState::SEMICOLON;
			break;
		case ' ':
		case '\r':
		case '\t':
		case '\n':
		case '\f': { /* White space is ignored */
			next_state = SQLParseState::WHITESPACE;
			break;
		}
		case '/': { /* C-style comments */
			if (zSql[1] != '*') {
				next_state = SQLParseState::NORMAL;
				break;
			}
			zSql += 2;
			while (zSql[0] && (zSql[0] != '*' || zSql[1] != '/')) {
				zSql++;
			}
			if (zSql[0] == 0) {
				// unterminated c-style string
				return false;
			}
			zSql++;
			next_state = SQLParseState::WHITESPACE;
			break;
		}
		case '-': { /* SQL-style comments from "--" to end of line */
			if (zSql[1] != '-') {
				next_state = SQLParseState::NORMAL;
				break;
			}
			while (*zSql && *zSql != '\n') {
				zSql++;
			}
			if (*zSql == 0) {
				// unterminated SQL-style comment - return whether or not we had a semicolon right before it
				return state == SQLParseState::SEMICOLON;
			}
			next_state = SQLParseState::WHITESPACE;
			break;
		}
		case '$': { /* Dollar-quoted strings */
			// check if this is a dollar-quoted string
			idx_t next_dollar = 0;
			for (idx_t idx = 1; zSql[idx]; idx++) {
				if (zSql[idx] == '$') {
					// found the next dollar
					next_dollar = idx;
					break;
				}
				// all characters can be between A-Z, a-z or \200 - \377
				if (zSql[idx] >= 'A' && zSql[idx] <= 'Z') {
					continue;
				}
				if (zSql[idx] >= 'a' && zSql[idx] <= 'z') {
					continue;
				}
				if (zSql[idx] >= '\200' && zSql[idx] <= '\377') {
					continue;
				}
				// the first character CANNOT be a numeric, only subsequent characters
				if (idx > 1 && zSql[idx] >= '0' && zSql[idx] <= '9') {
					continue;
				}
				// not a dollar quoted string
				break;
			}
			if (next_dollar == 0) {
				// not a dollar quoted string
				next_state = SQLParseState::NORMAL;
				break;
			}
			auto start = zSql + 1;
			zSql += next_dollar;
			const char *delimiterStart = start;
			idx_t delimiterLength = zSql - start;
			zSql++;
			// skip the dollar quoted string
			zSql = skipDollarQuotedString(zSql, delimiterStart, delimiterLength);
			if (!zSql) {
				// unterminated dollar string
				return false;
			}
			next_state = SQLParseState::WHITESPACE;
			break;
		}
			//		case '`': /* Grave-accent quoted symbols used by MySQL */
		case '"': /* single- and double-quoted strings */
		case '\'': {
			int c = *zSql;
			zSql++;
			while (*zSql && *zSql != c) {
				zSql++;
			}
			if (*zSql == 0) {
				// unterminated single or double quoted string
				return 0;
			}
			next_state = SQLParseState::WHITESPACE;
			break;
		}
		default:
			next_state = SQLParseState::NORMAL;
		}
		// white space is ignored (no change in state)
		if (next_state != SQLParseState::WHITESPACE) {
			state = next_state;
		}
	}
	// the statement is complete only if we end in a semicolon
	return state == SQLParseState::SEMICOLON;
}

/*
** Run a single line of SQL.  Return the number of errors.
*/
int ShellState::RunOneSqlLine(InputMode mode, char *zSql) {
	string zErrMsg;

	OpenDB();
#ifndef SHELL_USE_LOCAL_GETLINE
	if (mode == InputMode::STANDARD && zSql && *zSql && *zSql != '\3') {
		shell_add_history(zSql);
	}
#endif
	BEGIN_TIMER;
	auto success = ExecuteSQL(zSql);
	END_TIMER;
	if (success != SuccessState::SUCCESS) {
		return 1;
	} else if (ShellHasFlag(ShellFlags::SHFLG_CountChanges)) {
		PrintF("changes: %3llu   total_changes: %llu\n", (unsigned long long)last_changes,
		       (unsigned long long)total_changes);
	}
	return 0;
}

/*
** Read input from *in and process it.  If *in==0 then input
** is interactive - the user is typing it it.  Otherwise, input
** is coming from a file or device.  A prompt is issued and history
** is saved only if input is interactive.  An interrupt signal will
** cause this routine to exit immediately, unless input is interactive.
**
** Return the number of errors.
*/
int ShellState::ProcessInput(InputMode mode) {
	char *zLine = nullptr; /* A single input line */
	char *zSql = nullptr;  /* Accumulated SQL text */
	idx_t nLine;           /* Length of current line */
	idx_t nSql = 0;        /* Bytes of zSql[] used */
	idx_t nAlloc = 0;      /* Allocated zSql[] space */
	idx_t nSqlPrior = 0;   /* Bytes of zSql[] used by prior line */
	int rc;                /* Error code */
	idx_t errCnt = 0;      /* Number of errors seen */
	idx_t numCtrlC = 0;
	lineno = 0;
	while (errCnt == 0 || !bail_on_error || (!in && stdin_is_interactive)) {
		fflush(out);
		zLine = one_input_line(in, zLine, nSql > 0);
		if (!zLine) {
			/* End of input */
			if (!in && stdin_is_interactive) {
				printf("\n");
			}
			break;
		}
		if (*zLine == '\3') {
			// ctrl c: reset sql statement
			if (nSql == 0 && zLine[1] == '\0' && stdin_is_interactive) {
				// if in interactive mode and we press ctrl c twice
				// on an empty line, we exit
				numCtrlC++;
				if (numCtrlC >= 2) {
					break;
				}
			}
			nSql = 0;
			continue;
		} else {
			numCtrlC = 0;
		}
		if (seenInterrupt) {
			if (in) {
				break;
			}
			seenInterrupt = 0;
		}
		lineno++;
		if (nSql == 0 && _all_whitespace(zLine)) {
			if (ShellHasFlag(ShellFlags::SHFLG_Echo)) {
				printf("%s\n", zLine);
			}
			continue;
		}
		if (zLine && (zLine[0] == '.' || zLine[0] == '#') && nSql == 0) {
			if (ShellHasFlag(ShellFlags::SHFLG_Echo)) {
				printf("%s\n", zLine);
			}
			if (zLine[0] == '.') {
#ifndef SHELL_USE_LOCAL_GETLINE
				if (mode == InputMode::STANDARD && zLine && *zLine && *zLine != '\3')
					shell_add_history(zLine);
#endif
				rc = DoMetaCommand(zLine);
				if (rc == 2) { /* exit requested */
					break;
				} else if (rc) {
					errCnt++;
				}
			}
			continue;
		}
		nLine = StringLength(zLine);
		if (nSql + nLine + 2 >= nAlloc) {
			nAlloc = nSql + nLine + 100;
			zSql = (char *)realloc(zSql, nAlloc);
			if (!zSql) {
				shell_out_of_memory();
			}
		}
		nSqlPrior = nSql;
		if (nSql == 0) {
			int i;
			for (i = 0; zLine[i] && IsSpace(zLine[i]); i++) {
			}
			assert(nAlloc > 0 && zSql);
			memcpy(zSql, zLine + i, nLine + 1 - i);
			nSql = nLine - i;
		} else {
			zSql[nSql++] = '\n';
			memcpy(zSql + nSql, zLine, nLine + 1);
			nSql += nLine;
		}
		if (nSql && line_contains_semicolon(&zSql[nSqlPrior], nSql - nSqlPrior) && SQLIsComplete(zSql)) {
			errCnt += RunOneSqlLine(mode, zSql);
			nSql = 0;
			if (outCount) {
				ResetOutput();
				outCount = 0;
			} else {
				ClearTempFile();
			}
		} else if (nSql && _all_whitespace(zSql)) {
			if (ShellHasFlag(ShellFlags::SHFLG_Echo)) {
				printf("%s\n", zSql);
			}
			nSql = 0;
		}
	}
	if (nSql && !_all_whitespace(zSql)) {
		errCnt += RunOneSqlLine(mode, zSql);
	}
	free(zSql);
	free(zLine);
	return errCnt > 0;
}

static string GetHomeDirectory() {
	duckdb::LocalFileSystem lfs;
	return lfs.GetHomeDirectory();
}

string ShellState::GetDefaultDuckDBRC() {
	return GetHomeDirectory() + "/.duckdbrc";
}

/*
** Read input from the file given by sqliterc_override.  Or if that
** parameter is NULL, take input from ~/.duckdbrc
**
** Returns true if successful, false otherwise.
*/

bool ShellState::ProcessFile(const string &file, bool is_duckdb_rc) {
	FILE *inSaved = in;
	int savedLineno = lineno;
	int rc = 0;

	in = fopen(file.c_str(), "rb");
	if (in) {
		if (stdin_is_interactive && is_duckdb_rc) {
			PrintF(PrintOutput::STDERR, "-- Loading resources from %s\n", file.c_str());
		}
		rc = ProcessInput(InputMode::FILE);
		fclose(in);
	} else if (!is_duckdb_rc) {
		PrintF(PrintOutput::STDERR, "Failed to read file \"%s\"\n", file.c_str());
		rc = 1;
	}
	in = inSaved;
	lineno = savedLineno;
	return rc == 0;
}

bool ShellState::ProcessDuckDBRC(const char *file) {
	string path;
	if (!file) {
		// use default .duckdbrc path
		path = ShellState::GetDefaultDuckDBRC();
		if (path.empty()) {
			// could not find home directory - return
			PrintF(PrintOutput::STDERR, "-- warning: cannot find home directory;"
			                            " cannot read ~/.duckdbrc\n");
			return true;
		}
		file = path.c_str();
	}
	return ProcessFile(file, true);
}

#ifdef HAVE_LINENOISE
/*
** Linenoise completion callback
*/
static void linenoise_completion(const char *zLine, linenoiseCompletions *lc) {
	idx_t nLine = ShellState::StringLength(zLine);
	char zBuf[1000];

	if (nLine > sizeof(zBuf) - 30) {
		return;
	}
	if (zLine[0] == '.') {
		// auto-complete dot command
		for (idx_t c = 0; metadata_commands[c].command; c++) {
			auto &command = metadata_commands[c];
			auto &line = command.command;
			bool found_match = true;
			idx_t line_pos;
			zBuf[0] = '.';
			for (line_pos = 0; !ShellState::IsSpace(line[line_pos]) && line[line_pos] && line_pos + 2 < sizeof(zBuf);
			     line_pos++) {
				zBuf[line_pos + 1] = line[line_pos];
				if (line_pos + 1 < nLine && line[line_pos] != zLine[line_pos + 1]) {
					// only match prefixes for auto-completion, i.e. ".sh" matches ".shell"
					found_match = false;
					break;
				}
			}
			zBuf[line_pos + 1] = '\0';
			if (found_match && line_pos + 1 >= nLine) {
				linenoiseAddCompletion(lc, zBuf);
			}
		}
		return;
	}
	if (zLine[0] == '#') {
		return;
	}
	//  if( i==nLine-1 ) return;
	auto zSql = StringUtil::Format("CALL sql_auto_complete(%s)", SQLString(zLine));
	unique_ptr<duckdb::DuckDB> localDB;
	unique_ptr<duckdb::Connection> localCon;

	auto &state = ShellState::Get();
	if (!state.conn) {
		state.OpenDB();
	}
	auto &con = *state.conn;
	bool copiedSuggestion = false;
	auto result = con.Query(zSql);
	for (auto &row : *result) {
		auto zCompletion = row.GetValue<string>(0);
		auto nCompletion = zCompletion.size();
		idx_t iStart = row.GetValue<idx_t>(1);
		if (iStart + nCompletion < (sizeof(zBuf) - 1)) {
			if (!copiedSuggestion) {
				memcpy(zBuf, zLine, iStart);
				copiedSuggestion = true;
			}
			memcpy(zBuf + iStart, zCompletion.c_str(), nCompletion + 1);
			linenoiseAddCompletion(lc, zBuf);
		}
	}
}
#endif

struct CommandLineCall {
	CommandLineCall(const CommandLineOption &option, vector<string> arguments_p)
	    : option(option), arguments(std::move(arguments_p)) {
	}

	const CommandLineOption &option;
	vector<string> arguments;
};

template <RenderMode output_mode>
MetadataResult ToggleOutputMode(ShellState &state, const vector<string> &args) {
	state.cMode = state.mode = output_mode;
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleASCIIMode(ShellState &state, const vector<string> &args) {
	state.cMode = state.mode = RenderMode::ASCII;
	state.colSeparator = SEP_Unit;
	state.rowSeparator = SEP_Record;
	return MetadataResult::SUCCESS;
}

MetadataResult ToggleCSVMode(ShellState &state, const vector<string> &args) {
	state.cMode = state.mode = RenderMode::CSV;
	state.colSeparator = ",";
	return MetadataResult::SUCCESS;
}

MetadataResult EnableBail(ShellState &state, const vector<string> &args) {
	state.bail_on_error = true;
	return MetadataResult::SUCCESS;
}

MetadataResult EnableBatch(ShellState &state, const vector<string> &args) {
	state.stdin_is_interactive = false;
	return MetadataResult::SUCCESS;
}

MetadataResult DisableBatch(ShellState &state, const vector<string> &args) {
	state.stdin_is_interactive = true;
	return MetadataResult::SUCCESS;
}

MetadataResult SetReadOnlyMode(ShellState &state, const vector<string> &args) {
	state.config.options.access_mode = duckdb::AccessMode::READ_ONLY;
	return MetadataResult::SUCCESS;
}

template <bool HEADER>
MetadataResult ToggleHeader(ShellState &state, const vector<string> &args) {
	state.showHeader = HEADER;
	return MetadataResult::SUCCESS;
}

MetadataResult DisableStdin(ShellState &state, const vector<string> &args) {
	state.readStdin = false;
	return MetadataResult::SUCCESS;
}

MetadataResult EnableEcho(ShellState &state, const vector<string> &args) {
	state.ShellSetFlag(ShellFlags::SHFLG_Echo);
	return MetadataResult::SUCCESS;
}

MetadataResult AllowUnredacted(ShellState &state, const vector<string> &args) {
	state.config.options.allow_unredacted_secrets = true;
	return MetadataResult::SUCCESS;
}

MetadataResult AllowUnsigned(ShellState &state, const vector<string> &args) {
	state.config.options.allow_unsigned_extensions = true;
	return MetadataResult::SUCCESS;
}

MetadataResult ShowVersionAndExit(ShellState &state, const vector<string> &args) {
	printf("%s (%s) %s\n", duckdb::DuckDB::LibraryVersion(), duckdb::DuckDB::ReleaseCodename(),
	       duckdb::DuckDB::SourceID());
	return MetadataResult::EXIT;
}

MetadataResult PrintHelpAndExit(ShellState &state, const vector<string> &args) {
	state.PrintUsage();
	return MetadataResult::EXIT;
}

MetadataResult LaunchUI(ShellState &state, const vector<string> &args) {
	// run the UI command
	auto rc = state.RunInitialCommand((char *)state.ui_command.c_str(), true);
	if (rc != 0) {
		exit(rc);
		return MetadataResult::EXIT;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult SetNewlineSeparator(ShellState &state, const vector<string> &args) {
	// run the UI command
	state.rowSeparator = args[1];
	return MetadataResult::SUCCESS;
}

MetadataResult SetStorageVersion(ShellState &state, const vector<string> &args) {
	auto &storage_version = args[1];
	try {
		state.config.options.serialization_compatibility =
		    duckdb::SerializationCompatibility::FromString(storage_version);
	} catch (std::exception &ex) {
		duckdb::ErrorData error(ex);
		state.PrintF(PrintOutput::STDERR, "%s: Error: unknown argument (%s) for '-storage-version': %s\n",
		             state.program_name, storage_version.c_str(), error.Message().c_str());
		return MetadataResult::EXIT;
	}
	return MetadataResult::SUCCESS;
}

MetadataResult ProcessFile(ShellState &state, const vector<string> &args) {
	state.readStdin = false;
	auto old_bail = state.bail_on_error;
	state.bail_on_error = true;
	auto &file = args[1];
	if (!state.ProcessFile(file)) {
		exit(1);
		return MetadataResult::EXIT;
	}
	state.bail_on_error = old_bail;
	return MetadataResult::SUCCESS;
}

MetadataResult SetInitFile(ShellState &state, const vector<string> &args) {
	state.initFile = args[1];
	return MetadataResult::SUCCESS;
}

template <bool EXIT>
MetadataResult RunCommand(ShellState &state, const vector<string> &args) {
	if (EXIT) {
		state.readStdin = false;
	}
	// Always bail if -c or -s fail
	bool bail = state.bail_on_error || EXIT;
	auto &cmd = args[1];
	auto rc = state.RunInitialCommand(cmd.c_str(), bail);
	if (rc != 0) {
		exit(rc);
		return MetadataResult::EXIT;
	}
	return MetadataResult::SUCCESS;
}

static const CommandLineOption command_line_options[] = {
    {"ascii", 0, "", nullptr, ToggleASCIIMode, "set output mode to 'ascii'"},
    {"bail", 0, "", nullptr, EnableBail, "stop after hitting an error'"},
    {"batch", 0, "", EnableBatch, EnableBatch, "force batch I/O'"},
    {"box", 0, "", nullptr, ToggleOutputMode<RenderMode::BOX>, "set output mode to 'box'"},
    {"column", 0, "", nullptr, ToggleOutputMode<RenderMode::COLUMN>, "set output mode to 'column'"},
    {"cmd", 1, "COMMAND", nullptr, RunCommand<false>, "run \"COMMAND\" before reading stdin"},
    {"csv", 0, "", nullptr, ToggleCSVMode, "set output mode to 'csv'"},
    {"c", 1, "COMMAND", EnableBatch, RunCommand<true>, "run \"COMMAND\" and exit"},
    {"echo", 0, "", nullptr, EnableEcho, "print commands before execution"},
    {"f", 1, "FILENAME", EnableBatch, ProcessFile, "read/process named file and exit"},
    {"init", 1, "FILENAME", SetInitFile, nullptr, "read/process named file"},
    {"header", 0, "", nullptr, ToggleHeader<true>, "turn headers on"},
    {"help", 0, "", PrintHelpAndExit, nullptr, "show this message"},
    {"html", 0, "", nullptr, ToggleOutputMode<RenderMode::HTML>, "set output mode to HTML"},
    {"interactive", 0, "", nullptr, DisableBatch, "force interactive I/O"},
    {"json", 0, "", nullptr, ToggleOutputMode<RenderMode::JSON>, "set output mode to 'json'"},
    {"line", 0, "", nullptr, ToggleOutputMode<RenderMode::LINE>, "set output mode to 'line'"},
    {"list", 0, "", nullptr, ToggleOutputMode<RenderMode::LIST>, "set output mode to 'list'"},
    {"markdown", 0, "", nullptr, ToggleOutputMode<RenderMode::MARKDOWN>, "set output mode to 'markdown'"},
    {"newline", 1, "SEP", nullptr, SetNewlineSeparator, "set output row separator. Default: '\\n'"},
    {"no-stdin", 0, "", nullptr, DisableStdin, "exit after processing options instead of reading stdin"},
    {"noheader", 0, "", nullptr, ToggleHeader<false>, "turn headers off"},
    {"nullvalue", 1, "TEXT", nullptr, SetNullValue, "set text string for NULL values. Default 'NULL'"},
    {"quote", 0, "", nullptr, ToggleOutputMode<RenderMode::QUOTE>, "set output mode to 'quote'"},
    {"readonly", 0, "", SetReadOnlyMode, nullptr, "open the database read-only"},
    {"s", 1, "COMMAND", EnableBatch, RunCommand<true>, "run \"COMMAND\" and exit"},
    {"safe", 0, "", EnableSafeMode, nullptr, "enable safe-mode"},
    {"separator", 1, "SEP", nullptr, SetSeparator, "set output column separator. Default: '|'"},
    {"storage-version", 1, "VER", SetStorageVersion, nullptr,
     "database storage compatibility version to use. Default: 'v0.10.0'"},
    {"table", 0, "", nullptr, ToggleOutputMode<RenderMode::TABLE>, "set output mode to 'table'"},
    {"ui", 0, "", nullptr, LaunchUI, "launches a web interface using the ui extension (configurable with .ui_command)"},
    {"unredacted", 0, "", AllowUnredacted, nullptr, "allow printing unredacted secrets"},
    {"unsigned", 0, "", AllowUnsigned, nullptr, "allow loading of unsigned extensions"},
    {"version", 0, "", nullptr, ShowVersionAndExit, "show DuckDB version"},
    {nullptr, 0, nullptr, nullptr, nullptr, nullptr}};

optional_idx FindOption(const char *name) {
	for (idx_t c = 0; command_line_options[c].option; c++) {
		auto &option = command_line_options[c];
		if (!StringUtil::Equals(name, option.option)) {
			// not this one
			continue;
		}
		// found it!
		return c;
	}
	return optional_idx();
}

optional_ptr<const CommandLineOption> ShellState::FindCommandLineOption(const string &option, string &error_msg) const {
	auto c = FindOption(option.c_str());
	if (!c.IsValid()) {
		// we haven't found it yet - try substituting all underscores with dashes
		// this is legacy behavior - we allow e.g. "-storage_version" to be used instead of "-storage-version"
		auto option_name = StringUtil::Replace(option, "_", "-");
		c = FindOption(option_name.c_str());
	}
	if (!c.IsValid()) {
		// not found
		string error = StringUtil::Format("Unknown Option Error: Unrecognized option '-%s'\n", option);
		vector<string> option_names;
		for (idx_t c = 0; command_line_options[c].option; c++) {
			auto &option = command_line_options[c];
			option_names.push_back(string("-") + option.option);
		}
		auto candidates_msg = StringUtil::CandidatesErrorMessage(option_names, "-" + option, "Did you mean");
		error += candidates_msg + "\n";
		error += StringUtil::Format("Run '%s -help' for a list of options.\n", program_name);
		return nullptr;
	}
	return command_line_options[c.GetIndex()];
}

struct PrintOptionInfo {
	string command_name;
	string arguments;
	string description;
};

void ShellState::PrintUsage() {
	ShellHighlight highlighter(*this);
	highlighter.PrintText("Usage: ", PrintOutput::STDOUT, PrintColor::STANDARD, PrintIntensity::BOLD);
	highlighter.PrintText(program_name, PrintOutput::STDOUT, HighlightElementType::KEYWORD);
	highlighter.PrintText(" [OPTIONS] FILENAME [SQL]\n\n", PrintOutput::STDOUT, HighlightElementType::STRING_CONSTANT);
	highlighter.PrintText("FILENAME", PrintOutput::STDOUT, PrintColor::STANDARD, PrintIntensity::BOLD);
	PrintF(" is the name of a DuckDB database. A new database is created\n"
	       "if the file does not previously exist.\n\n");
	highlighter.PrintText("OPTIONS:\n", PrintOutput::STDOUT, PrintColor::STANDARD, PrintIntensity::BOLD);
	constexpr idx_t INITIAL_SPACING = 2;
	constexpr idx_t MIN_SPACING = 4;
	vector<PrintOptionInfo> print_options;
	for (idx_t c = 0; command_line_options[c].option; c++) {
		auto &option = command_line_options[c];
		PrintOptionInfo print_option;
		print_option.command_name = string(INITIAL_SPACING, ' ') + "-" + option.option;
		print_option.arguments = option.arguments;
		print_option.description = option.description;
		print_options.push_back(std::move(print_option));
	}
	idx_t max_lhs_length = 0;
	for (auto &option : print_options) {
		auto lhs_length = option.command_name.size() + option.arguments.size();
		if (!option.arguments.empty()) {
			lhs_length++;
		}
		if (lhs_length > max_lhs_length) {
			max_lhs_length = lhs_length;
		}
	}
	// print the options
	for (auto &option : print_options) {
		auto lhs_length = option.command_name.size() + option.arguments.size();
		if (!option.arguments.empty()) {
			lhs_length++;
		}
		idx_t padding = max_lhs_length - lhs_length + MIN_SPACING;
		string spaces(padding, ' ');
		highlighter.PrintText(option.command_name, PrintOutput::STDOUT, HighlightElementType::KEYWORD);
		if (!option.arguments.empty()) {
			highlighter.PrintText(" " + option.arguments, PrintOutput::STDOUT, HighlightElementType::STRING_CONSTANT);
		}
		PrintF("%s%s\n", spaces.c_str(), option.description.c_str());
	}
	exit(0);
}

/*
** Initialize the state information in data
*/
static void main_init(ShellState *data) {
	data->normalMode = data->cMode = data->mode = RenderMode::DUCKBOX;
	data->max_rows = 40;
	data->colSeparator = SEP_Column;
	data->rowSeparator = SEP_Row;
	data->showHeader = true;
	strcpy(mainPrompt, "D ");
	strcpy(continuePrompt, " ");
	strcpy(continuePromptSelected, " ");
#ifdef HAVE_LINENOISE
	linenoiseSetPrompt(continuePrompt, continuePromptSelected);
#endif
}

#ifndef SQLITE_SHELL_IS_UTF8
#if (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)
#define SQLITE_SHELL_IS_UTF8 (0)
#else
#define SQLITE_SHELL_IS_UTF8 (1)
#endif
#endif

struct ShellStateDestroyer {
	~ShellStateDestroyer() {
		ShellState::Get().Destroy();
	}
};

#if SQLITE_SHELL_IS_UTF8
int main(int argc, char **argv) {
#else
int wmain(int argc, wchar_t **wargv) {
	char **argv;
#endif
	int i;
	int rc = 0;
	bool warnInmemoryDb = false;
	vector<string> extra_commands;
#if !SQLITE_SHELL_IS_UTF8
	char **argvToFree = 0;
	int argcToFree = 0;
#endif
	ShellStateDestroyer destroyer;

	auto &data = ShellState::Get();
	data.out = stdout;

	setBinaryMode(stdin, 0);
	setvbuf(stderr, 0, _IONBF, 0); /* Make sure stderr is unbuffered */
	data.stdin_is_interactive = isatty(0);
	data.stdout_is_console = isatty(1);
	data.stderr_is_console = isatty(2);

	main_init(&data);

	/* On Windows, we must translate command-line arguments into UTF-8.
	 */
#if !SQLITE_SHELL_IS_UTF8
	argvToFree = (char **)malloc(sizeof(argv[0]) * argc * 2);
	argcToFree = argc;
	argv = argvToFree + argc;
	if (argv == 0)
		shell_out_of_memory();
	for (i = 0; i < argc; i++) {
		auto z = ShellState::Win32UnicodeToUtf8(wargv[i]);
		argv[i] = (char *)malloc(z.size() + 1);
		if (argv[i] == 0) {
			shell_out_of_memory();
		}
		memcpy(argv[i], z.c_str(), z.size() + 1);
		argvToFree[i] = argv[i];
	}
#endif

	assert(argc >= 1 && argv && argv[0]);
	data.program_name = argv[0];

	/* Make sure we have a valid signal handler early, before anything
	** else is done.
	*/
#ifdef SIGINT
	signal(SIGINT, interrupt_handler);
#elif (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)
	SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);
#endif

	/* Do an initial pass through the command-line argument to locate
	** the name of the database file, the name of the initialization file,
	** the size of the alternative malloc heap,
	** and the first command to execute.
	*/
	vector<CommandLineCall> command_line_calls;
	for (i = 1; i < argc; i++) {
		char *z;
		z = argv[i];
		if (z[0] != '-') {
			if (data.zDbFilename.empty()) {
				data.zDbFilename = z;
			} else {
				/* Excesss arguments are interpreted as SQL (or dot-commands) and
				** mean that nothing is read from stdin */
				data.readStdin = false;
				data.stdin_is_interactive = false;
				extra_commands.emplace_back(z);
			}
			continue;
		}
		z++;
		if (z[0] == '-') {
			// allow for double dashes, i.e. --init and -init are both valid
			z++;
		}

		string error_msg;
		auto command_line_option = data.FindCommandLineOption(z, error_msg);
		if (!command_line_option) {
			data.PrintDatabaseError(error_msg);
			return 1;
		}
		auto &option = *command_line_option;
		// parse arguments
		vector<string> arguments;
		arguments.push_back(option.option);
		for (idx_t arg_idx = 0; arg_idx < option.argument_count; arg_idx++) {
			if (i + 1 >= argc) {
				string error =
				    StringUtil::Format("Missing Argument Error: Argument '-%s' needs %llu arguments, but got %llu\n",
				                       option.option, option.argument_count, arg_idx);
				error += StringUtil::Format("OPTION:\n  -%s %s    %s\n\n", option.option, option.arguments,
				                            option.description);
				error += StringUtil::Format("Run '%s -help' for a list of options.\n", data.program_name);
				data.PrintDatabaseError(error);
				return 1;
			}
			arguments.emplace_back(argv[++i]);
		}
		if (option.pre_init_callback) {
			// invoke the pre-init callback (if any)
			auto result = option.pre_init_callback(data, arguments);
			if (result == MetadataResult::EXIT) {
				return 0;
			}
		}
		// add the call to the list of options to handle
		command_line_calls.emplace_back(option, std::move(arguments));
	}

	if (data.zDbFilename.empty()) {
		data.zDbFilename = ":memory:";
		warnInmemoryDb = argc == 1;
	}
	data.out = stdout;

	/* Go ahead and open the database file if it already exists.  If the
	** file does not exist, delay opening it.  This prevents empty database
	** files from being created if a user mistypes the database name argument
	** to the sqlite command-line tool.
	*/
	if (access(data.zDbFilename.c_str(), 0) == 0) {
		data.OpenDB();
	}

	/* Process the initialization file if there is one.  If no -init option
	** is given on the command line, look for a file named ~/.sqliterc and
	** try to process it.
	*/
	if (!data.ProcessDuckDBRC(data.initFile.empty() ? nullptr : data.initFile.c_str()) && data.bail_on_error) {
		return 1;
	}

	/* Make a second pass through the command-line argument and set
	** options.  This second pass is delayed until after the initialization
	** file is processed so that the command-line arguments will override
	** settings in the initialization file.
	*/
	for (auto &call : command_line_calls) {
		auto &option = call.option;
		if (!option.post_init_callback) {
			continue;
		}
		auto result = option.post_init_callback(data, call.arguments);
		if (result == MetadataResult::EXIT) {
			return 0;
		}
	}

	if (!data.readStdin) {
		/* Run all arguments that do not begin with '-' as if they were separate
		** command-line inputs, except for the argToSkip argument which contains
		** the database filename.
		*/
		for (auto &cmd : extra_commands) {
			if (cmd[0] == '.') {
				rc = data.DoMetaCommand(cmd);
				if (rc) {
					return rc == 2 ? 0 : rc;
				}
			} else {
				data.OpenDB();
				auto success = data.ExecuteSQL(cmd.c_str());
				if (success != SuccessState::SUCCESS) {
					return rc != 0 ? rc : 1;
				}
			}
		}
	} else {
		/* Run commands received from standard input
		 */
		if (data.stdin_is_interactive) {
			string zHome;
			const char *zHistory;
			printf("DuckDB %s (%s) %.19s\n" /*extra-version-info*/
			       "Enter \".help\" for usage hints.\n",
			       duckdb::DuckDB::LibraryVersion(), duckdb::DuckDB::ReleaseCodename(), duckdb::DuckDB::SourceID());
			if (warnInmemoryDb) {
				printf("Connected to a ");
				ShellHighlight highlighter(data);
				highlighter.PrintText("transient in-memory database", PrintOutput::STDOUT, PrintColor::STANDARD,
				                      PrintIntensity::BOLD);
				printf(".\nUse \".open FILENAME\" to reopen on a "
				       "persistent database.\n");
			}
			zHistory = getenv("DUCKDB_HISTORY");
			if (!zHistory) {
				zHome = GetHomeDirectory() + "/.duckdb_history";
				zHistory = zHome.c_str();
			}
			if (zHistory) {
				shell_read_history(zHistory);
			}
#if HAVE_READLINE || HAVE_EDITLINE
			rl_attempted_completion_function = readline_completion;
#elif HAVE_LINENOISE
			linenoiseSetCompletionCallback(linenoise_completion);
#endif
			data.in = 0;
			rc = data.ProcessInput(InputMode::STANDARD);
			if (zHistory) {
				shell_stifle_history(2000);
				shell_write_history(zHistory);
			}
		} else {
			data.in = stdin;
			rc = data.ProcessInput(InputMode::STANDARD);
		}
	}
	data.SetTableName(0);
	data.db.reset();
	data.conn.reset();
	data.ResetOutput();
	data.doXdgOpen = 0;
	data.ClearTempFile();
#if !SQLITE_SHELL_IS_UTF8
	for (i = 0; i < argcToFree; i++) {
		free(argvToFree[i]);
	}
	free(argvToFree);
#endif
	return rc;
}
