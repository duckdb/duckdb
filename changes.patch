diff --git a/Makefile b/Makefile
index a414c98d75..d4109d5b04 100644
--- a/Makefile
+++ b/Makefile
@@ -515,8 +515,8 @@ generate-files:
 	$(PYTHON) scripts/generate_settings.py
 	$(PYTHON) scripts/generate_serialization.py
 	$(PYTHON) scripts/generate_storage_info.py
-	$(PYTHON) scripts/generate_enum_util.py
 	$(PYTHON) scripts/generate_metric_enums.py
+	$(PYTHON) scripts/generate_enum_util.py
 	$(PYTHON) scripts/generate_builtin_types.py
 # Run the formatter again after (re)generating the files
 	$(MAKE) format-main
diff --git a/scripts/generate_metric_enums.py b/scripts/generate_metric_enums.py
index 69b9ffd7d1..176dec6209 100644
--- a/scripts/generate_metric_enums.py
+++ b/scripts/generate_metric_enums.py
@@ -1,399 +1,34 @@
-# Script that takes src/include/duckdb/common/enums/optimizer_type.hpp, extracts the optimizer types
-# and adds them to the metrics types.
-# Then it creates a new file src/include/duckdb/common/enums/metric_type.hpp with the new metrics types as enums.
-# and generates both test/sql/pragma/profiling/test_default_profiling_settings.test
-# and test/sql/pragma/profiling/test_custom_profiling_optimizer.test
-
-import re
-import os
-
-os.chdir(os.path.dirname(__file__))
-
-metrics_header_file = os.path.join("..", "src", "include", "duckdb", "common", "enums", "metric_type.hpp")
-metrics_cpp_file = os.path.join("..", "src", "common", "enums", "metric_type.cpp")
-optimizer_file = os.path.join("..", "src", "include", "duckdb", "common", "enums", "optimizer_type.hpp")
-
-metrics = [
-    "ATTACH_LOAD_STORAGE_LATENCY",
-    "ATTACH_REPLAY_WAL_LATENCY",
-    "BLOCKED_THREAD_TIME",
-    "CHECKPOINT_LATENCY",
-    "CPU_TIME",
-    "CUMULATIVE_CARDINALITY",
-    "CUMULATIVE_ROWS_SCANNED",
-    "EXTRA_INFO",
-    "LATENCY",
-    "OPERATOR_CARDINALITY",
-    "OPERATOR_NAME",
-    "OPERATOR_ROWS_SCANNED",
-    "OPERATOR_TIMING",
-    "OPERATOR_TYPE",
-    "QUERY_NAME",
-    "RESULT_SET_SIZE",
-    "ROWS_RETURNED",
-    "SYSTEM_PEAK_BUFFER_MEMORY",
-    "SYSTEM_PEAK_TEMP_DIR_SIZE",
-    "TOTAL_BYTES_READ",
-    "TOTAL_BYTES_WRITTEN",
-    "WAITING_TO_ATTACH_LATENCY",
-]
-
-phase_timing_metrics = [
-    "ALL_OPTIMIZERS",
-    "CUMULATIVE_OPTIMIZER_TIMING",
-    "PHYSICAL_PLANNER",
-    "PHYSICAL_PLANNER_COLUMN_BINDING",
-    "PHYSICAL_PLANNER_CREATE_PLAN",
-    "PHYSICAL_PLANNER_RESOLVE_TYPES",
-    "PLANNER",
-    "PLANNER_BINDING",
-]
-
-query_global_metrics = [
-    "ATTACH_LOAD_STORAGE_LATENCY",
-    "ATTACH_REPLAY_WAL_LATENCY",
-    "BLOCKED_THREAD_TIME",
-    "CHECKPOINT_LATENCY",
-    "SYSTEM_PEAK_BUFFER_MEMORY",
-    "SYSTEM_PEAK_TEMP_DIR_SIZE",
-    "WAITING_TO_ATTACH_LATENCY",
-]
-
-optimizer_types = []
-
-# Regular expression to match the enum values
-enum_pattern = r'\s*([A-Z_]+)\s*=\s*\d+,?|\s*([A-Z_]+),?'
-
-inside_enum = False
-
-# open the optimizer file and extract the optimizer types
-with open(optimizer_file, "r") as f:
-    for line in f:
-        line = line.strip()
-
-        if line.startswith("enum class OptimizerType"):
-            inside_enum = True
-            continue
-
-        if inside_enum and line.startswith("};"):
-            break
-
-        if inside_enum:
-            match = re.match(enum_pattern, line)
-            if match:
-                optimizer_type = match[1] if match[1] else match[2]
-                if optimizer_type == "INVALID":
-                    continue
-                optimizer_types.append(optimizer_type)
-
-header = """//-------------------------------------------------------------------------
-//                         DuckDB
-//
-//
-// duckdb/common/enums/metrics_type.hpp
-// 
-// This file is automatically generated by scripts/generate_metric_enums.py
-// Do not edit this file manually, your changes will be overwritten
-//-------------------------------------------------------------------------\n
-"""
-
-typedefs = """struct MetricsTypeHashFunction {
-	uint64_t operator()(const MetricsType &index) const {
-		return std::hash<uint8_t>()(static_cast<uint8_t>(index));
-	}
-};
-
-typedef unordered_set<MetricsType, MetricsTypeHashFunction> profiler_settings_t;
-typedef unordered_map<MetricsType, Value, MetricsTypeHashFunction> profiler_metrics_t;
-
-"""
-
-get_optimizer_metric_fun = 'GetOptimizerMetrics()'
-get_phase_timing_metric_fun = 'GetPhaseTimingMetrics()'
-get_optimizer_metric_by_type_fun = 'GetOptimizerMetricByType(OptimizerType type)'
-get_optimizer_type_by_metric_fun = 'GetOptimizerTypeByMetric(MetricsType type)'
-is_optimizer_metric_fun = 'IsOptimizerMetric(MetricsType type)'
-is_phase_timing_metric_fun = 'IsPhaseTimingMetric(MetricsType type)'
-is_query_global_metric_fun = 'IsQueryGlobalMetric(MetricsType type)'
-
-metrics_class = 'MetricsUtils'
-
-# Write the metric type header file
-with open(metrics_header_file, "w") as f:
-    f.write(header)
-
-    f.write('#pragma once\n\n')
-    f.write('#include "duckdb/common/types/value.hpp"\n')
-    f.write('#include "duckdb/common/unordered_set.hpp"\n')
-    f.write('#include "duckdb/common/unordered_map.hpp"\n')
-    f.write('#include "duckdb/common/constants.hpp"\n')
-    f.write('#include "duckdb/common/enum_util.hpp"\n')
-    f.write('#include "duckdb/common/enums/optimizer_type.hpp"\n\n')
-
-    f.write("namespace duckdb {\n\n")
-
-    f.write("enum class MetricsType : uint8_t {\n")
-
-    for metric in metrics:
-        f.write(f"    {metric},\n")
-
-    for metric in phase_timing_metrics:
-        f.write(f"    {metric},\n")
-
-    for metric in optimizer_types:
-        f.write(f"    OPTIMIZER_{metric},\n")
-
-    f.write("};\n\n")
-
-    f.write(typedefs)
-
-    f.write('class MetricsUtils {\n')
-    f.write('public:\n')
-    f.write(f'    static profiler_settings_t {get_optimizer_metric_fun};\n')
-    f.write(f'    static profiler_settings_t {get_phase_timing_metric_fun};\n\n')
-    f.write(f'    static MetricsType {get_optimizer_metric_by_type_fun};\n')
-    f.write(f'    static OptimizerType {get_optimizer_type_by_metric_fun};\n\n')
-    f.write(f'    static bool {is_optimizer_metric_fun};\n')
-    f.write(f'    static bool {is_phase_timing_metric_fun};\n')
-    f.write(f'    static bool {is_query_global_metric_fun};\n')
-    f.write('};\n\n')
-
-    f.write("} // namespace duckdb\n")
-
-# Write the metric_type.cpp file
-with open(metrics_cpp_file, "w") as f:
-    f.write(header)
-
-    f.write('#include "duckdb/common/enums/metric_type.hpp"\n')
-    f.write("namespace duckdb {\n\n")
-
-    f.write(f'profiler_settings_t {metrics_class}::{get_optimizer_metric_fun} {{\n')
-    f.write(f"    return {{\n")
-    for metric in optimizer_types:
-        f.write(f"        MetricsType::OPTIMIZER_{metric},\n")
-    f.write("    };\n")
-    f.write("}\n\n")
-
-    f.write(f'profiler_settings_t {metrics_class}::{get_phase_timing_metric_fun} {{\n')
-    f.write(f"    return {{\n")
-    for metric in phase_timing_metrics:
-        f.write(f"        MetricsType::{metric},\n")
-    f.write("    };\n")
-    f.write("}\n\n")
-
-    f.write(f'MetricsType {metrics_class}::{get_optimizer_metric_by_type_fun} {{\n')
-    f.write('    switch(type) {\n')
-    for metric in optimizer_types:
-        f.write(f"        case OptimizerType::{metric}:\n")
-        f.write(f"            return MetricsType::OPTIMIZER_{metric};\n")
-    f.write('       default:\n')
-    f.write(
-        '            throw InternalException("OptimizerType %s cannot be converted to a MetricsType", '
-        'EnumUtil::ToString(type));\n'
-    )
-    f.write('    };\n')
-    f.write('}\n\n')
-
-    f.write(f'OptimizerType {metrics_class}::{get_optimizer_type_by_metric_fun} {{\n')
-    f.write('    switch(type) {\n')
-    for metric in optimizer_types:
-        f.write(f"        case MetricsType::OPTIMIZER_{metric}:\n")
-        f.write(f"            return OptimizerType::{metric};\n")
-    f.write('    default:\n')
-    f.write('            return OptimizerType::INVALID;\n')
-    f.write('    };\n')
-    f.write('}\n\n')
-
-    f.write(f'bool {metrics_class}::{is_optimizer_metric_fun} {{\n')
-    f.write('    switch(type) {\n')
-    for metric in optimizer_types:
-        f.write(f"        case MetricsType::OPTIMIZER_{metric}:\n")
-
-    f.write('            return true;\n')
-    f.write('        default:\n')
-    f.write('            return false;\n')
-    f.write('    };\n')
-    f.write('}\n\n')
-
-    f.write(f'bool {metrics_class}::{is_phase_timing_metric_fun} {{\n')
-    f.write('    switch(type) {\n')
-    for metric in phase_timing_metrics:
-        f.write(f"        case MetricsType::{metric}:\n")
-
-    f.write('            return true;\n')
-    f.write('        default:\n')
-    f.write('            return false;\n')
-    f.write('    };\n')
-    f.write('}\n\n')
-
-    f.write(f'bool {metrics_class}::{is_query_global_metric_fun} {{\n')
-    f.write('    switch(type) {\n')
-    for metric in query_global_metrics:
-        f.write(f"        case MetricsType::{metric}:\n")
-
-    f.write('            return true;\n')
-    f.write('        default:\n')
-    f.write('            return false;\n')
-    f.write('    };\n')
-    f.write('}\n\n')
-
-    f.write("} // namespace duckdb\n")
-
-# Generate the test files
-test_names = ["test_default_profiling_settings", "test_custom_profiling_optimizer"]
-
-test_descriptions = ["default", "custom optimizer"]
-
-test_files = [os.path.join("..", "test", "sql", "pragma", "profiling", f"{name}.test") for name in test_names]
-
-
-def write_statement(f, statement_type, statement):
-    f.write(f"statement {statement_type}\n")
-    f.write(statement + "\n\n")
-
-
-def write_query(f, options, query):
-    f.write(f"query {options}\n")
-    f.write(query + "\n")
-    f.write("----\n")
-
-
-def write_default_query(f):
-    query = "SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();"
-    write_statement(f, "ok", query)
-    write_statement(f, "ok", "PRAGMA disable_profiling;")
-
-
-def write_get_custom_profiling_settings(f):
-    query = """
-SELECT unnest(res) FROM (
-    SELECT current_setting('custom_profiling_settings') AS raw_setting,
-    raw_setting.trim('{}') AS setting,
-    string_split(setting, ', ') AS res
-) ORDER BY ALL;
-            """.strip()
-    write_query(f, "I", query)
-
-
-def write_custom_profiling_optimizer(f):
-    write_statement(f, "ok", "PRAGMA custom_profiling_settings='{\"ALL_OPTIMIZERS\": \"true\"}';")
-
-    write_default_query(f)
-
-    query = """
-SELECT * FROM (
-    SELECT unnest(res) str FROM (
-        SELECT current_setting('custom_profiling_settings') as raw_setting,
-        raw_setting.trim('{}') AS setting,
-        string_split(setting, ', ') AS res
-    )
-) WHERE '"true"' NOT in str
-ORDER BY ALL \
-            """.strip()
-    write_query(f, "I", query)
-    f.write("\n")
-
-    write_statement(f, "ok", "PRAGMA custom_profiling_settings='{}'")
-    write_default_query(f)
-
-    write_get_custom_profiling_settings(f)
-    f.write("(empty)\n\n")
-
-    write_statement(f, "ok", "PRAGMA custom_profiling_settings='{\"OPTIMIZER_JOIN_ORDER\": \"true\"}'")
-    write_default_query(f)
-
-    write_get_custom_profiling_settings(f)
-    f.write("\"OPTIMIZER_JOIN_ORDER\": \"true\"\n\n")
-
-    write_statement(
-        f, "ok", "CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';"
-    )
-
-    query = """
-SELECT
-    CASE WHEN optimizer_join_order > 0 THEN 'true'
-     ELSE 'false' END
-FROM metrics_output;
-            """.strip()
-    write_query(f, "I", query)
-    f.write("true\n\n")
-
-    write_statement(f, "ok", "SET disabled_optimizers = 'JOIN_ORDER';")
-    write_statement(f, "ok", "PRAGMA custom_profiling_settings='{\"OPTIMIZER_JOIN_ORDER\": \"true\"}'")
-    write_default_query(f)
-
-    write_get_custom_profiling_settings(f)
-    f.write("(empty)\n\n")
-
-    write_statement(f, "ok", "PRAGMA custom_profiling_settings='{\"CUMULATIVE_OPTIMIZER_TIMING\": \"true\"}';")
-    write_default_query(f)
-
-    write_statement(
-        f, "ok", "CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';"
-    )
-
-    query = """
-SELECT
-    CASE WHEN cumulative_optimizer_timing > 0 THEN 'true'
-    ELSE 'false' END
-FROM metrics_output;
-        """.strip()
-    write_query(f, "I", query)
-    f.write("true\n\n")
-
-    f.write("# All phase timings must be collected when using detailed profiling mode.\n\n")
-
-    write_statement(f, "ok", "RESET custom_profiling_settings;")
-    write_statement(f, "ok", "SET profiling_mode = 'detailed';")
-    write_default_query(f)
-
-    query = """
-SELECT * FROM (
-    SELECT unnest(res) str FROM (
-        SELECT current_setting('custom_profiling_settings') AS raw_setting,
-        raw_setting.trim('{}') AS setting,
-        string_split(setting, ', ') AS res
-    )
+from metrics.emit_enum_cpp import generate_metric_type_files
+from metrics.emit_profiling_utils_cpp import generate_profiling_utils
+from metrics.emit_tests import generate_test_files
+from metrics.inputs import load_metrics_json, retrieve_optimizers
+from metrics.model import build_all_metrics
+from metrics.paths import (
+    METRICS_JSON,
+    OPTIMIZER_HPP,
+    OUT_METRIC_HPP,
+    OUT_METRIC_CPP,
+    TEST_PROFILING_DIR,
+    OUT_PROFILING_HPP,
+    OUT_PROFILING_CPP,
 )
-WHERE '"true"' NOT IN str
-ORDER BY ALL
-            """.strip()
-    write_query(f, "I", query)
-    f.write("\n")
-
-    write_statement(f, "ok", "RESET custom_profiling_settings;")
-    write_statement(f, "ok", "SET profiling_mode = 'standard';")
-
 
-# Create the test files
-for test_file, name, description in zip(test_files, test_names, test_descriptions):
-    with open(test_file, "w") as f:
-        display_name = test_file.replace("../", "")
-        f.write(f"# name: {display_name}\n")
-        f.write(f"# description: Test {description} profiling settings.\n")
-        f.write("# group: [profiling]\n\n")
-        f.write("# This file is automatically generated by scripts/generate_metric_enums.py\n")
-        f.write("# Do not edit this file manually, your changes will be overwritten\n\n")
 
-        f.write("require json\n\n")
+def main():
+    # load metrics from JSON
+    metrics_json = load_metrics_json(METRICS_JSON)
 
-        write_statement(f, "ok", "PRAGMA enable_verification;")
-        write_statement(f, "ok", "PRAGMA enable_profiling = 'json';")
-        write_statement(f, "ok", "PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';")
+    optimizers = retrieve_optimizers(OPTIMIZER_HPP)
 
-        if name == "test_custom_profiling_optimizer":
-            write_custom_profiling_optimizer(f)
+    metric_index = build_all_metrics(metrics_json, optimizers)
 
-        write_default_query(f)
+    # emit C++ files
+    generate_metric_type_files(OUT_METRIC_HPP, OUT_METRIC_CPP, metric_index, optimizers)
+    generate_profiling_utils(OUT_PROFILING_HPP, OUT_PROFILING_CPP, metric_index)
 
-        write_get_custom_profiling_settings(f)
-        metrics.sort()
+    # emit test files
+    generate_test_files(TEST_PROFILING_DIR, metric_index.metrics_by_group)
 
-        for metric in metrics:
-            f.write(f'"{metric}": "true"\n')
-        f.write("\n")
 
-        write_statement(
-            f, "ok", "CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';"
-        )
-        write_statement(f, "ok", "SELECT cpu_time, extra_info, rows_returned, latency FROM metrics_output;")
+if __name__ == "__main__":
+    main()
diff --git a/scripts/metrics/__init__.py b/scripts/metrics/__init__.py
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/scripts/metrics/__init__.py
@@ -0,0 +1 @@
+
diff --git a/scripts/metrics/emit_enum_cpp.py b/scripts/metrics/emit_enum_cpp.py
new file mode 100644
index 0000000000..b312f47e5c
--- /dev/null
+++ b/scripts/metrics/emit_enum_cpp.py
@@ -0,0 +1,179 @@
+from __future__ import annotations
+from typing import Dict, List, Tuple
+from pathlib import Path
+
+from .inputs import _to_pascal_case
+from .model import MetricIndex
+from .writer import IndentedFileWriter
+
+HPP_HEADER = """//-------------------------------------------------------------------------
+//                         DuckDB
+//
+// duckdb/common/enums/metric_type.hpp
+// 
+// This file is automatically generated by scripts/generate_metric_enums.py
+// Do not edit this file manually, your changes will be overwritten
+//-------------------------------------------------------------------------
+
+#pragma once
+
+#include "duckdb/common/types/value.hpp"
+#include "duckdb/common/unordered_set.hpp"
+#include "duckdb/common/constants.hpp"
+#include "duckdb/common/enums/optimizer_type.hpp"
+
+namespace duckdb {
+
+"""
+
+HPP_TYPEDEFS = """
+struct MetricsTypeHashFunction {
+    uint64_t operator()(const MetricsType &index) const {
+        return std::hash<uint8_t>()(static_cast<uint8_t>(index));
+    }
+};
+
+typedef unordered_set<MetricsType, MetricsTypeHashFunction> profiler_settings_t;
+typedef unordered_map<MetricsType, Value, MetricsTypeHashFunction> profiler_metrics_t;
+
+"""
+
+CPP_HEADER = """// This file is automatically generated by scripts/generate_metric_enums.py
+// Do not edit this file manually, your changes will be overwritten
+
+#include "duckdb/common/enums/metric_type.hpp"
+#include "duckdb/common/enum_util.hpp"
+
+namespace duckdb {
+
+"""
+
+
+def _setup_hpp(f: IndentedFileWriter, metric_index: MetricIndex):
+    f.write(HPP_HEADER)
+
+    f.write("enum class MetricGroup : uint8_t {\n")
+
+    groups = metric_index.group_names + ["INVALID"]
+    for g in groups:
+        f.write_indented(1, f"{g.upper()},")
+    f.write("};\n\n")
+
+    f.write("enum class MetricsType : uint8_t {\n")
+    for metric in metric_index.all_metrics():
+        f.write_indented(1, f"{metric},")
+    f.write("};\n")
+
+    f.write(HPP_TYPEDEFS)
+    f.write('class MetricsUtils {\n')
+    f.write('public:\n')
+
+
+def _generate_standard_functions(
+    group: str, hpp_f: IndentedFileWriter, cpp_f: IndentedFileWriter, metric_index: MetricIndex
+):
+    formatted = _to_pascal_case(group)
+    get_fn = f"Get{formatted}Metrics"
+
+    hpp_f.write('\n')
+    hpp_f.write_indented(1, f"// {formatted} metrics")
+    hpp_f.write_indented(1, f"static profiler_settings_t {get_fn}();")
+
+    metrics = metric_index.metrics_per_group(group) if group != "root_scope" else metric_index.root_scope_metrics()
+
+    cpp_f.write(f"profiler_settings_t MetricsUtils::{get_fn}() {{\n")
+    cpp_f.write_indented(1, "return {")
+    for m in metrics:
+        cpp_f.write_indented(2, f"MetricsType::{m},")
+    cpp_f.write_indented(1, "};")
+    cpp_f.write('}\n\n')
+
+    if group == "all":
+        _generate_get_metric_by_group_function(hpp_f, cpp_f, metric_index)
+        return
+
+    check_fn = f"Is{formatted}Metric"
+    hpp_f.write_indented(1, f"static bool {check_fn}(MetricsType type);")
+
+    cpp_f.write(f"bool MetricsUtils::{check_fn}(MetricsType type) {{\n")
+    cpp_f.write_indented(1, "switch(type) {")
+    for m in metrics:
+        cpp_f.write_indented(2, f"case MetricsType::{m}:")
+    cpp_f.write_indented(3, "return true;")
+    cpp_f.write_indented(2, "default:")
+    cpp_f.write_indented(3, "return false;")
+    cpp_f.write_indented(1, "}")
+    cpp_f.write("}\n\n")
+
+
+def _generate_custom_optimizer_functions(optimizers: List[str], hpp_f: IndentedFileWriter, cpp_f: IndentedFileWriter):
+    by_type = "GetOptimizerMetricByType(OptimizerType type)"
+    by_metric = "GetOptimizerTypeByMetric(MetricsType type)"
+
+    hpp_f.write_indented(1, f"static MetricsType {by_type};")
+    hpp_f.write_indented(1, f"static OptimizerType {by_metric};")
+
+    cpp_f.write(f"MetricsType MetricsUtils::{by_type} {{\n")
+    cpp_f.write_indented(1, "switch(type) {")
+    for o in optimizers:
+        cpp_f.write_indented(2, f"case OptimizerType::{o}:")
+        cpp_f.write_indented(3, f"return MetricsType::OPTIMIZER_{o};")
+    cpp_f.write_indented(2, "default:")
+    cpp_f.write_indented(
+        3, 'throw InternalException("OptimizerType %s cannot be converted to a MetricsType", EnumUtil::ToString(type));'
+    )
+    cpp_f.write_indented(1, "}")
+    cpp_f.write('}\n\n')
+
+    cpp_f.write(f"OptimizerType MetricsUtils::{by_metric} {{\n")
+    cpp_f.write_indented(1, "switch(type) {")
+    for o in optimizers:
+        cpp_f.write_indented(2, f"case MetricsType::OPTIMIZER_{o}:")
+        cpp_f.write_indented(3, f"return OptimizerType::{o};")
+    cpp_f.write_indented(2, "default:")
+    cpp_f.write_indented(3, "return OptimizerType::INVALID;")
+    cpp_f.write_indented(1, "}")
+    cpp_f.write('}\n\n')
+
+
+def _generate_get_metric_by_group_function(
+    hpp_f: IndentedFileWriter, cpp_f: IndentedFileWriter, metric_index: MetricIndex
+):
+    fn = "GetMetricsByGroupType(MetricGroup type)"
+    hpp_f.write_indented(1, f"static profiler_settings_t {fn};")
+
+    cpp_f.write(f"profiler_settings_t MetricsUtils::{fn} {{\n")
+    cpp_f.write_indented(1, "switch(type) {")
+    for group in metric_index.group_names:
+        formatted = group.upper()
+        cpp_f.write_indented(1, f"case MetricGroup::{formatted}:")
+        cpp_f.write_indented(2, "return {")
+        for m in metric_index.metrics_per_group(group):
+            cpp_f.write_indented(3, f"MetricsType::{m},")
+        cpp_f.write_indented(3, "};")
+    cpp_f.write_indented(1, "default:")
+    cpp_f.write_indented(2, 'throw InternalException("The MetricGroup passed is invalid");')
+    cpp_f.write_indented(1, "}")
+    cpp_f.write('}\n')
+
+
+def generate_metric_type_files(
+    out_hpp: Path,
+    out_cpp: Path,
+    metric_index: MetricIndex,
+    optimizers: List[str],
+) -> None:
+    with IndentedFileWriter(out_hpp) as hpp_f, IndentedFileWriter(out_cpp) as cpp_f:
+        _setup_hpp(hpp_f, metric_index)
+        cpp_f.write(CPP_HEADER)
+
+        for group in metric_index.metrics_by_group:
+            _generate_standard_functions(group, hpp_f, cpp_f, metric_index)
+            if group == "optimizer":
+                _generate_custom_optimizer_functions(optimizers, hpp_f, cpp_f)
+
+        _generate_standard_functions("root_scope", hpp_f, cpp_f, metric_index)
+
+        hpp_f.write("};\n")
+        hpp_f.write("} // namespace duckdb\n")
+        cpp_f.write("}\n")
diff --git a/scripts/metrics/emit_profiling_utils_cpp.py b/scripts/metrics/emit_profiling_utils_cpp.py
new file mode 100644
index 0000000000..09992853e6
--- /dev/null
+++ b/scripts/metrics/emit_profiling_utils_cpp.py
@@ -0,0 +1,261 @@
+from collections import namedtuple
+from dataclasses import dataclass
+from pathlib import Path
+from typing import Dict, Optional, Callable
+
+from .model import MetricIndex
+from .writer import IndentedFileWriter
+
+HPP_HEADER = """//-------------------------------------------------------------------------
+//                         DuckDB
+//
+// duckdb/main/profiling_utils.hpp
+// 
+// This file is automatically generated by scripts/generate_metric_enums.py
+// Do not edit this file manually, your changes will be overwritten
+//-------------------------------------------------------------------------
+
+#pragma once
+
+#include "duckdb/common/enums/metric_type.hpp"
+#include "duckdb/main/query_profiler.hpp"
+#include "duckdb/main/profiling_node.hpp"
+
+namespace duckdb_yyjson {
+struct yyjson_mut_doc;
+struct yyjson_mut_val;
+} // namespace duckdb_yyjson
+
+namespace duckdb {
+
+"""
+
+CPP_HEADER = """// This file is automatically generated by scripts/generate_metric_enums.py
+// Do not edit this file manually, your changes will be overwritten
+
+#include "duckdb/main/profiling_utils.hpp"
+#include "duckdb/common/enum_util.hpp"
+#include "duckdb/main/profiling_node.hpp"
+#include "duckdb/main/query_profiler.hpp"
+
+#include "yyjson.hpp"
+
+using namespace duckdb_yyjson; // NOLINT
+
+namespace duckdb {
+"""
+
+
+def _operator_to_string_function(class_name: str, return_type: str, function_name: str) -> str:
+    return f"""
+{return_type} {class_name}::{function_name} {{
+    const auto type = static_cast<PhysicalOperatorType>(val.GetValue<uint8_t>());
+    return EnumUtil::ToString(type);
+}}
+"""
+
+
+def _aggregate_metric_function(class_name: str, return_type: str, function_name: str) -> str:
+    return f"""
+template <class METRIC_TYPE>
+{return_type} {class_name}::{function_name} {{
+	auto &info = node.GetProfilingInfo();
+	info.metrics[aggregated_metric] = info.metrics[child_metric];
+
+	for (idx_t i = 0; i < node.GetChildCount(); i++) {{
+		auto child = node.GetChild(i);
+		AggregateMetric<METRIC_TYPE>(*child, aggregated_metric, child_metric, update_fun);
+
+		auto &child_info = child->GetProfilingInfo();
+		auto value = child_info.GetMetricValue<METRIC_TYPE>(aggregated_metric);
+		info.MetricUpdate<METRIC_TYPE>(aggregated_metric, value, update_fun);
+	}}
+}}
+"""
+
+
+def _get_cumulative_metric_function(class_name: str, return_type: str, function_name: str) -> str:
+    return f"""
+template <class METRIC_TYPE>
+{return_type} {class_name}::{function_name} {{
+	AggregateMetric<METRIC_TYPE>(
+	    node, cumulative_metric, child_metric,
+	    [](const METRIC_TYPE &old_value, const METRIC_TYPE &new_value) {{ return old_value + new_value; }});
+}}
+"""
+
+
+def _get_cumulative_optimizers_function(class_name: str, return_type: str, function_name: str) -> str:
+    return f"""
+{return_type} {class_name}::{function_name} {{
+	auto &metrics = node.GetProfilingInfo().metrics;
+	double count = 0;
+	for (auto &metric : metrics) {{
+		if (MetricsUtils::IsOptimizerMetric(metric.first)) {{
+			count += metric.second.GetValue<double>();
+		}}
+	}}
+	return Value::CreateValue(count);
+}}
+
+"""
+
+
+def _default_case_logic(t: str) -> Optional[str]:
+    val = "Value::"
+    if t == "map":
+        val += "MAP(InsertionOrderPreservingMap<string>())"
+    else:
+        val += "CreateValue"
+        if t == "string":
+            val += "(\"\")"
+        elif t == "double":
+            val += "(0.0)"
+        elif t == "uint64":
+            val += "<uint64_t>(0)"
+        elif t == "uint8":
+            val += "<uint8_t>(0)"
+
+    return f"metrics[type] = {val};"
+
+
+def _metric_to_json_case_logic(t: str) -> Optional[str]:
+    if t == "map":
+        return None
+    elif t == "string":
+        return "yyjson_mut_obj_add_strcpy(doc, dest, key_ptr, metrics[type].GetValue<string>().c_str());"
+    elif t == "double":
+        return "yyjson_mut_obj_add_real(doc, dest, key_ptr, metrics[type].GetValue<double>());"
+    elif t == "uint64":
+        return "yyjson_mut_obj_add_uint(doc, dest, key_ptr, metrics[type].GetValue<uint64_t>());"
+    elif t == "uint8":
+        return "yyjson_mut_obj_add_strcpy(doc, dest, key_ptr, OperatorToString(metrics[type]).c_str());"
+    return None
+
+
+def _write_function(
+    cpp_f: IndentedFileWriter,
+    types: Dict[str, list[str]],
+    class_name: str,
+    function_name: str,
+    case_logic: Callable[[str], Optional[str]],
+) -> None:
+    # set metric to default
+    cpp_f.write_indented(0, f"void {class_name}::{function_name} {{")
+    cpp_f.write_indented(1, "switch(type) {")
+    for t in types:
+        for m in types[t]:
+            cpp_f.write_indented(2, f"case MetricsType::{m}:")
+
+        res = case_logic(t)
+        if res is not None:
+            cpp_f.write_indented(3, res)
+        cpp_f.write_indented(3, "break;")
+
+    cpp_f.write_indented(2, "default:")
+    cpp_f.write_indented(3, "throw InternalException(\"Unknown metric type %s\", EnumUtil::ToString(type));")
+    cpp_f.write_indented(1, "}")
+    cpp_f.write_indented(0, "}\n")
+
+
+def _generate_collection_methods(
+    cpp_f: IndentedFileWriter, class_name: str, function_name: str, metric_index: MetricIndex
+) -> None:
+    cpp_f.write_indented(0, f"void {class_name}::{function_name} {{")
+    cpp_f.write_indented(1, "switch(type) {")
+    for c in metric_index.collection_index():
+        for m in metric_index.metrics_per_collection(c):
+            cpp_f.write_indented(2, f"case MetricsType::{m}:")
+            if c == "timer":
+                cpp_f.write_indented(3, f"metric = query_metrics.{m.lower()}.Elapsed();")
+            elif c == "child":
+                cpp_f.write_indented(3, f"metric = child_info.metrics[MetricsType::{metric_index.metric_child(m)}];")
+            elif c == "cumulative_operators":
+                cpp_f.write_indented(3, f"metric = GetCumulativeOptimizers(node);")
+            elif c == "query_metric" and metric_index.metric_type(m) == "uint64_t":
+                cpp_f.write_indented(3, f"metric = Value::UBIGINT(query_metrics.{m.lower()});")
+            elif c == "cumulative":
+                cpp_f.write_indented(
+                    3,
+                    f"GetCumulativeMetric<{metric_index.metric_type(m)}>(node, MetricsType::{m}, MetricsType::{metric_index.metric_child(m)});",
+                )
+            else:
+                raise Exception(f"Unknown collection type {c} or metric {m}")
+            cpp_f.write_indented(3, f"break;")
+
+    cpp_f.write_indented(2, "default:")
+    cpp_f.write_indented(3, "return;")
+    cpp_f.write_indented(1, "}")
+    cpp_f.write_indented(0, "}\n")
+
+
+def generate_profiling_utils(
+    out_hpp: Path,
+    out_cpp: Path,
+    metric_index: MetricIndex,
+) -> None:
+    with IndentedFileWriter(out_hpp) as hpp_f, IndentedFileWriter(out_cpp) as cpp_f:
+        hpp_f.write(HPP_HEADER)
+        cpp_f.write(CPP_HEADER)
+
+        class_name = "ProfilingUtils"
+
+        default_function = "SetMetricToDefault(profiler_metrics_t &metrics, const MetricsType &type)"
+        metric_to_json = "MetricToJson(duckdb_yyjson::yyjson_mut_doc *doc, duckdb_yyjson::yyjson_mut_val *dest, const char *key_ptr,  profiler_metrics_t &metrics, const MetricsType &type)"
+        collect_metrics = "CollectMetrics(const MetricsType &type, QueryMetrics &query_metrics, Value &metric, ProfilingNode &node, ProfilingInfo &child_info)"
+
+        hpp_f.write_indented(0, f"class {class_name} {{")
+        hpp_f.write_indented(0, "public:")
+        hpp_f.write_indented(1, f"static void {default_function};")
+        hpp_f.write_indented(1, f"static void {metric_to_json};")
+        hpp_f.write_indented(1, f"static void {collect_metrics};")
+        hpp_f.write_indented(0, "\nprivate:")
+
+        @dataclass
+        class PrivateFunction:
+            f: callable
+            ret: str
+            func_name: str
+            template: Optional[str]
+
+        private_functions = [
+            PrivateFunction(
+                f=_operator_to_string_function,
+                ret="string",
+                func_name="OperatorToString(const Value &val)",
+                template=None,
+            ),
+            PrivateFunction(
+                f=_aggregate_metric_function,
+                ret="void",
+                func_name="AggregateMetric(ProfilingNode &node, MetricsType aggregated_metric, MetricsType child_metric, const std::function<METRIC_TYPE(const METRIC_TYPE &, const METRIC_TYPE &)> &update_fun)",
+                template="template <class METRIC_TYPE>",
+            ),
+            PrivateFunction(
+                f=_get_cumulative_metric_function,
+                ret="void",
+                func_name="GetCumulativeMetric(ProfilingNode &node, MetricsType cumulative_metric, MetricsType child_metric)",
+                template="template <class METRIC_TYPE>",
+            ),
+            PrivateFunction(
+                f=_get_cumulative_optimizers_function,
+                ret="Value",
+                func_name="GetCumulativeOptimizers(ProfilingNode &node)",
+                template=None,
+            ),
+        ]
+
+        for pf in private_functions:
+            if pf.template is not None:
+                hpp_f.write_indented(1, f"{pf.template}")
+            hpp_f.write_indented(1, f"static {pf.ret} {pf.func_name};\n")
+            cpp_f.write(pf.f(class_name, pf.ret, pf.func_name))
+
+        _write_function(cpp_f, metric_index.types_index(), class_name, default_function, _default_case_logic)
+        _write_function(cpp_f, metric_index.types_index(), class_name, metric_to_json, _metric_to_json_case_logic)
+
+        _generate_collection_methods(cpp_f, class_name, collect_metrics, metric_index)
+
+        hpp_f.write_indented(0, "};\n")
+        hpp_f.write_indented(0, "}")
+        cpp_f.write_indented(0, "}")
diff --git a/scripts/metrics/emit_tests.py b/scripts/metrics/emit_tests.py
new file mode 100644
index 0000000000..0e8f957f13
--- /dev/null
+++ b/scripts/metrics/emit_tests.py
@@ -0,0 +1,239 @@
+# scripts/metrics/emit_tests.py
+from __future__ import annotations
+
+from pathlib import Path
+from typing import Dict, List
+
+from .paths import REPO_ROOT
+from .writer import IndentedFileWriter
+
+
+def _write_statement(f, statement_type, statement):
+    f.write(f"statement {statement_type}\n")
+    f.write(statement + "\n\n")
+
+
+def _write_query(f, options, query):
+    f.write(f"query {options}\n")
+    f.write(query + "\n")
+    f.write("----\n")
+
+
+def _write_default_query(f):
+    query = "SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();"
+    _write_statement(f, "ok", query)
+    _write_statement(f, "ok", "PRAGMA disable_profiling;")
+
+
+def _write_get_custom_profiling_settings(f):
+    query = """
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+""".strip()
+    _write_query(f, "I", query)
+
+
+def _write_custom_profiling_optimizer(f):
+    _write_statement(f, "ok", "PRAGMA custom_profiling_settings='{\"ALL_OPTIMIZERS\": \"true\"}';")
+
+    _write_default_query(f)
+
+    query = """
+SELECT * FROM (
+    SELECT unnest(res) str FROM (
+        SELECT current_setting('custom_profiling_settings') as raw_setting,
+        raw_setting.trim('{}') AS setting,
+        string_split(setting, ', ') AS res
+    )
+) WHERE '"true"' NOT in str
+ORDER BY ALL
+""".strip()
+    _write_query(f, "I", query)
+    f.write("\n")
+
+    _write_statement(f, "ok", "PRAGMA custom_profiling_settings='{}'")
+    _write_default_query(f)
+
+    _write_get_custom_profiling_settings(f)
+    f.write("(empty)\n\n")
+
+    _write_statement(f, "ok", "PRAGMA custom_profiling_settings='{\"OPTIMIZER_JOIN_ORDER\": \"true\"}'")
+    _write_default_query(f)
+
+    _write_get_custom_profiling_settings(f)
+    f.write("\"OPTIMIZER_JOIN_ORDER\": \"true\"\n\n")
+
+    _write_statement(
+        f, "ok", "CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';"
+    )
+
+    query = """
+SELECT
+    CASE WHEN optimizer_join_order > 0 THEN 'true'
+     ELSE 'false' END
+FROM metrics_output;
+""".strip()
+    _write_query(f, "I", query)
+    f.write("true\n\n")
+
+    _write_statement(f, "ok", "SET disabled_optimizers = 'JOIN_ORDER';")
+    _write_statement(f, "ok", "PRAGMA custom_profiling_settings='{\"OPTIMIZER_JOIN_ORDER\": \"true\"}'")
+    _write_default_query(f)
+
+    _write_get_custom_profiling_settings(f)
+    f.write("(empty)\n\n")
+
+    _write_statement(f, "ok", "PRAGMA custom_profiling_settings='{\"CUMULATIVE_OPTIMIZER_TIMING\": \"true\"}';")
+    _write_default_query(f)
+
+    _write_statement(
+        f, "ok", "CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';"
+    )
+
+    query = """
+SELECT
+    CASE WHEN cumulative_optimizer_timing > 0 THEN 'true'
+    ELSE 'false' END
+FROM metrics_output;
+""".strip()
+    _write_query(f, "I", query)
+    f.write("true\n\n")
+
+    f.write("# All phase timings must be collected when using detailed profiling mode.\n\n")
+
+    _write_statement(f, "ok", "RESET custom_profiling_settings;")
+    _write_statement(f, "ok", "SET profiling_mode = 'detailed';")
+    _write_default_query(f)
+
+    query = """
+SELECT * FROM (
+    SELECT unnest(res) str FROM (
+        SELECT current_setting('custom_profiling_settings') AS raw_setting,
+        raw_setting.trim('{}') AS setting,
+        string_split(setting, ', ') AS res
+    )
+)
+WHERE '"true"' NOT IN str
+ORDER BY ALL
+""".strip()
+    _write_query(f, "I", query)
+    f.write("\n")
+
+    _write_statement(f, "ok", "RESET custom_profiling_settings;")
+    _write_statement(f, "ok", "SET profiling_mode = 'standard';")
+
+
+def _generate_group_test(f, groups: list[str], all_metrics: Dict[str, List[str]]):
+    _write_statement(f, "ok", "PRAGMA enable_profiling = 'json';")
+    _write_statement(f, "ok", "PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';")
+
+    group_str = ", ".join(f'"{g.upper()}": "true"' for g in groups)
+    _write_statement(f, "ok", f"PRAGMA custom_profiling_settings='{{{group_str}}}';")
+
+    _write_default_query(f)
+    _write_get_custom_profiling_settings(f)
+
+    metrics: list[str] = []
+    for g in groups:
+        metrics += all_metrics[g]
+
+    if "all" not in groups and "ALL_OPTIMIZERS" in metrics:
+        metrics.extend(all_metrics.get("optimizer", []))
+
+    metrics.sort()
+    for m in metrics:
+        f.write(f'"{m}": "true"\n')
+    f.write("\n")
+
+    _write_statement(
+        f, "ok", "CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';"
+    )
+
+    cols: list[str] = []
+    operator_metrics = set(all_metrics.get("operator", []))
+    for m in metrics:
+        if m in operator_metrics and "operator" not in groups:
+            continue
+        cols.append(m)
+
+    select = "SELECT " + ",\n\t".join(cols)
+
+    if "operator" in groups:
+        select += "\nFROM (\n"
+        select += "\tSELECT unnest(children, max_depth := 2)\n"
+        select += "\tFROM metrics_output\n"
+        select += ")"
+    else:
+        select += "\nFROM metrics_output;"
+
+    _write_statement(f, "ok", select)
+
+
+def _generate_metric_group_test_file(out_path, all_metrics: Dict[str, List[str]]):
+    top = """# name: test/sql/pragma/profiling/test_custom_profiling_using_groups.test
+# description: Test default profiling settings using groups.
+# group: [profiling]
+
+# This file is automatically generated by scripts/generate_metric_enums.py
+# Do not edit this file manually, your changes will be overwritten
+
+require json
+
+"""
+    with IndentedFileWriter(out_path) as f:
+        f.write(top)
+        for group in all_metrics:
+            _generate_group_test(f, [group], all_metrics)
+        _generate_group_test(f, ["default", "file"], all_metrics)
+        _generate_group_test(f, ["file", "optimizer"], all_metrics)
+        _generate_group_test(f, ["phase_timing", "execution", "file"], all_metrics)
+
+
+def _generate_profiling_setting_tests(out_dir: Path, all_metrics: Dict[str, List[str]]):
+    test_names = [
+        "test_default_profiling_settings",
+        "test_custom_profiling_optimizer_settings",
+        "test_all_profiling_settings",
+    ]
+    test_descriptions = ["default", "custom optimizer", "all settings"]
+    test_paths = [out_dir / f"{name}.test" for name in test_names]
+    metrics_group = ["default", "default", "all"]
+
+    for test_file, name, description, group in zip(test_paths, test_names, test_descriptions, metrics_group):
+        with IndentedFileWriter(test_file) as f:
+            display_name = test_file.relative_to(REPO_ROOT).as_posix()
+            f.write(f"# name: {display_name}\n")
+            f.write(f"# description: Test {description} profiling settings.\n")
+            f.write("# group: [profiling]\n\n")
+            f.write("# This file is automatically generated by scripts/generate_metric_enums.py\n")
+            f.write("# Do not edit this file manually, your changes will be overwritten\n\n")
+            f.write("require json\n\n")
+
+            _write_statement(f, "ok", "PRAGMA enable_profiling = 'json';")
+            _write_statement(f, "ok", "PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';")
+
+            mode = "standard" if group == "default" else group
+            _write_statement(f, "ok", f"SET profiling_mode='{mode}';")
+
+            if name == "test_custom_profiling_optimizer_settings":
+                _write_custom_profiling_optimizer(f)
+
+            _write_default_query(f)
+            _write_get_custom_profiling_settings(f)
+
+            for m in all_metrics[group]:
+                f.write(f'"{m}": "true"\n')
+            f.write("\n")
+
+            _write_statement(
+                f, "ok", "CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';"
+            )
+            _write_statement(f, "ok", "SELECT cpu_time, extra_info, rows_returned, latency FROM metrics_output;")
+
+
+def generate_test_files(out_dir: Path, all_metrics: Dict[str, List[str]]):
+    _generate_profiling_setting_tests(out_dir, all_metrics)
+    _generate_metric_group_test_file(out_dir / "test_custom_profiling_using_groups.test", all_metrics)
diff --git a/scripts/metrics/inputs.py b/scripts/metrics/inputs.py
new file mode 100644
index 0000000000..008858b53d
--- /dev/null
+++ b/scripts/metrics/inputs.py
@@ -0,0 +1,51 @@
+from __future__ import annotations
+import json
+import re
+from pathlib import Path
+
+IDENT_RE = re.compile(r"^[A-Z_][A-Z0-9_]*$")
+
+
+def load_metrics_json(path: Path) -> list[dict]:
+    if not path.exists():
+        raise FileNotFoundError(f"metric_type.json not found at {path}")
+    with path.open("r", encoding="utf-8") as f:
+        return json.load(f)
+
+
+def validate_identifier(name: str, group: str) -> None:
+    if not IDENT_RE.match(name):
+        raise ValueError(f"Invalid metric identifier: {name}, in group {group}")
+
+
+def _to_pascal_case(s: str) -> str:
+    return ''.join(word.capitalize() for word in s.split('_'))
+
+
+def retrieve_optimizers(optimizer_file: Path) -> list[str]:
+    if not optimizer_file.exists():
+        raise FileNotFoundError(f"optimizer_type.hpp not found at {optimizer_file}.")
+    enum_pattern = r"\s*([A-Z_]+)\s*=\s*\d+,?|\s*([A-Z_]+),?"
+    inside_enum = False
+    result: list[str] = []
+    with optimizer_file.open("r", encoding="utf-8") as f:
+        for line in f:
+            line = line.strip()
+            if line.startswith("enum class OptimizerType"):
+                inside_enum = True
+                continue
+
+            if inside_enum and line.startswith("};"):
+                break
+
+            if inside_enum:
+                m = re.match(enum_pattern, line)
+                if not m:
+                    continue
+                name = m[1] if m[1] else m[2]
+                if name == "INVALID":
+                    continue
+                result.append(name)
+
+    result.sort()
+    return result
diff --git a/scripts/metrics/model.py b/scripts/metrics/model.py
new file mode 100644
index 0000000000..e6a52910d2
--- /dev/null
+++ b/scripts/metrics/model.py
@@ -0,0 +1,127 @@
+from __future__ import annotations
+from collections import OrderedDict, defaultdict
+from dataclasses import dataclass
+from typing import Dict, List, Tuple, Optional, Iterable
+
+from .inputs import validate_identifier
+
+
+@dataclass(frozen=True)
+class MetricDef:
+    name: str
+    group: str  # e.g., "file", "default", ...
+    type: str  # e.g., "double", "uint64", "string", "map", "uint8"
+    query_root: bool = False
+    collection_method: Optional[str] = None
+    child: Optional[str] = None
+
+
+class MetricIndex:
+    def __init__(self, defs: Iterable[MetricDef], optimizers: List[str]):
+        self.defs: List[MetricDef] = list(defs)
+
+        # Build group → names (existing contract for emitters)
+        by_group: Dict[str, List[str]] = defaultdict(list)
+        for d in self.defs:
+            by_group[d.group].append(d.name)
+        for g in by_group:
+            by_group[g].sort()
+
+        # Add optimizer group (names only)
+        optimizer_names = [f"OPTIMIZER_{o}" for o in sorted(optimizers)]
+        by_group["optimizer"] = optimizer_names
+
+        # Add "all"
+        all_set = set().union(*by_group.values()) if by_group else set()
+        by_group["all"] = sorted(all_set)
+
+        # Deterministic order of groups
+        self.metrics_by_group: Dict[str, List[str]] = OrderedDict(sorted(by_group.items()))
+
+        # List of group names from metrics_by_group
+        self.group_names: List[str] = sorted(list(self.metrics_by_group.keys()))
+
+        # Root scope list
+        self.root_scope: List[str] = sorted({d.name for d in self.defs if d.query_root})
+
+        # Type → names (for profiling utils)
+        type_map: Dict[str, List[str]] = defaultdict(list)
+        for d in self.defs:
+            t = d.type if d.name != "OPERATOR_TYPE" else "uint8"  # preserve your special-case
+            type_map[t].append(d.name)
+        for t in type_map:
+            type_map[t].sort()
+        self.type_to_names: Dict[str, List[str]] = dict(type_map)
+
+        # Collection method → names (only for those that have it)
+        coll_map: Dict[str, List[str]] = defaultdict(list)
+        for d in self.defs:
+            if d.collection_method:
+                coll_map[d.collection_method].append(d.name)
+        for c in coll_map:
+            coll_map[c].sort()
+        self.collection_to_names: Dict[str, List[str]] = dict(coll_map)
+
+        # Children mapping (name → child-key)
+        self.child_of: Dict[str, str] = {d.name: d.child for d in self.defs if d.child is not None}
+
+    def all_metrics(self) -> List[str]:
+        return self.metrics_by_group["all"]
+
+    def metrics_per_group(self, group: str) -> List[str]:
+        return self.metrics_by_group[group]
+
+    def root_scope_metrics(self) -> List[str]:
+        return self.root_scope
+
+    def types_index(self) -> Dict[str, List[str]]:
+        return self.type_to_names
+
+    def collection_index(self) -> Dict[str, List[str]]:
+        return self.collection_to_names
+
+    def metrics_per_collection(self, collection: str) -> List[str]:
+        return self.collection_to_names[collection]
+
+    def child_index(self) -> Dict[str, str]:
+        return self.child_of
+
+    def metric_type(self, metric: str) -> str:
+        for d in self.defs:
+            if d.name == metric:
+                if d.type == "uint8":
+                    return "uint8_t"
+                elif d.type == "uint64":
+                    return "uint64_t"
+                return d.type
+        raise Exception(f"Unknown metric: {metric}")
+
+    def metric_child(self, metric: str) -> Optional[str]:
+        for d in self.defs:
+            if d.name == metric:
+                return d.child
+        return None
+
+
+def build_all_metrics(metrics_json: list[dict], optimizers: list[str]) -> MetricIndex:
+    defs: list[MetricDef] = []
+    for group in metrics_json:
+        gname = group.get("group")
+        for metric in group.get("metrics", []):
+            name = metric["name"]
+            validate_identifier(name, gname)
+            mtype = metric.get("type", "double")
+            query_root = "query_root" in metric
+            collection_method = metric.get("collection_method")
+            child = metric.get("child")
+            defs.append(
+                MetricDef(
+                    name=name,
+                    group=gname,
+                    type=mtype if name != "OPERATOR_TYPE" else "uint8",
+                    query_root=query_root,
+                    collection_method=collection_method,
+                    child=child,
+                )
+            )
+    return MetricIndex(defs, optimizers)
diff --git a/scripts/metrics/paths.py b/scripts/metrics/paths.py
new file mode 100644
index 0000000000..6fd65d4160
--- /dev/null
+++ b/scripts/metrics/paths.py
@@ -0,0 +1,27 @@
+from pathlib import Path
+
+# Repository root inferred relative to this file
+REPO_ROOT = Path(__file__).resolve().parents[2]
+
+# Top-level source directories
+SRC_DIR = REPO_ROOT / "src"
+INCLUDE_ROOT = SRC_DIR / "include" / "duckdb"
+
+# Subdirectories we target
+COMMON_ENUMS_DIR = SRC_DIR / "common" / "enums"
+INCLUDE_ENUMS_DIR = INCLUDE_ROOT / "common" / "enums"
+INCLUDE_MAIN_DIR = INCLUDE_ROOT / "main"
+SRC_MAIN_DIR = SRC_DIR / "main"
+
+# Tests output directory
+TEST_PROFILING_DIR = REPO_ROOT / "test" / "sql" / "pragma" / "profiling"
+
+# Inputs
+METRICS_JSON = COMMON_ENUMS_DIR / "metric_type.json"
+OPTIMIZER_HPP = INCLUDE_ENUMS_DIR / "optimizer_type.hpp"
+
+# Outputs
+OUT_METRIC_HPP = INCLUDE_ENUMS_DIR / "metric_type.hpp"
+OUT_METRIC_CPP = COMMON_ENUMS_DIR / "metric_type.cpp"
+OUT_PROFILING_HPP = INCLUDE_MAIN_DIR / "profiling_utils.hpp"
+OUT_PROFILING_CPP = SRC_MAIN_DIR / "profiling_utils.cpp"
diff --git a/scripts/metrics/writer.py b/scripts/metrics/writer.py
new file mode 100644
index 0000000000..df08ce1bbe
--- /dev/null
+++ b/scripts/metrics/writer.py
@@ -0,0 +1,25 @@
+class IndentedFileWriter:
+    """Wrapper around a file object that adds write_indented method."""
+
+    def __init__(self, file_path, read_only=False):
+        mode = 'r' if read_only else 'w'
+        self.file = open(file_path, mode, encoding='utf-8', newline='\n')
+
+    def write_indented(self, indent_level, text):
+        """Write text to file with the specified indentation level."""
+        indent = '\t' * indent_level
+        self.file.write(f"{indent}{text}\n")
+
+    def write(self, text):
+        """Delegate write to the underlying file object."""
+        self.file.write(text)
+
+    def close(self):
+        """Delegate close to the underlying file object."""
+        self.file.close()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        self.close()
diff --git a/src/common/enum_util.cpp b/src/common/enum_util.cpp
index 5003cc5815..60e469ea5a 100644
--- a/src/common/enum_util.cpp
+++ b/src/common/enum_util.cpp
@@ -2796,14 +2796,40 @@ MetaPipelineType EnumUtil::FromString<MetaPipelineType>(const char *value) {
 	return static_cast<MetaPipelineType>(StringUtil::StringToEnum(GetMetaPipelineTypeValues(), 2, "MetaPipelineType", value));
 }
 
+const StringUtil::EnumStringLiteral *GetMetricGroupValues() {
+	static constexpr StringUtil::EnumStringLiteral values[] {
+		{ static_cast<uint32_t>(MetricGroup::ALL), "ALL" },
+		{ static_cast<uint32_t>(MetricGroup::DEFAULT), "DEFAULT" },
+		{ static_cast<uint32_t>(MetricGroup::EXECUTION), "EXECUTION" },
+		{ static_cast<uint32_t>(MetricGroup::FILE), "FILE" },
+		{ static_cast<uint32_t>(MetricGroup::OPERATOR), "OPERATOR" },
+		{ static_cast<uint32_t>(MetricGroup::OPTIMIZER), "OPTIMIZER" },
+		{ static_cast<uint32_t>(MetricGroup::PHASE_TIMING), "PHASE_TIMING" },
+		{ static_cast<uint32_t>(MetricGroup::INVALID), "INVALID" }
+	};
+	return values;
+}
+
+template<>
+const char* EnumUtil::ToChars<MetricGroup>(MetricGroup value) {
+	return StringUtil::EnumToString(GetMetricGroupValues(), 8, "MetricGroup", static_cast<uint32_t>(value));
+}
+
+template<>
+MetricGroup EnumUtil::FromString<MetricGroup>(const char *value) {
+	return static_cast<MetricGroup>(StringUtil::StringToEnum(GetMetricGroupValues(), 8, "MetricGroup", value));
+}
+
 const StringUtil::EnumStringLiteral *GetMetricsTypeValues() {
 	static constexpr StringUtil::EnumStringLiteral values[] {
+		{ static_cast<uint32_t>(MetricsType::ALL_OPTIMIZERS), "ALL_OPTIMIZERS" },
 		{ static_cast<uint32_t>(MetricsType::ATTACH_LOAD_STORAGE_LATENCY), "ATTACH_LOAD_STORAGE_LATENCY" },
 		{ static_cast<uint32_t>(MetricsType::ATTACH_REPLAY_WAL_LATENCY), "ATTACH_REPLAY_WAL_LATENCY" },
 		{ static_cast<uint32_t>(MetricsType::BLOCKED_THREAD_TIME), "BLOCKED_THREAD_TIME" },
 		{ static_cast<uint32_t>(MetricsType::CHECKPOINT_LATENCY), "CHECKPOINT_LATENCY" },
 		{ static_cast<uint32_t>(MetricsType::CPU_TIME), "CPU_TIME" },
 		{ static_cast<uint32_t>(MetricsType::CUMULATIVE_CARDINALITY), "CUMULATIVE_CARDINALITY" },
+		{ static_cast<uint32_t>(MetricsType::CUMULATIVE_OPTIMIZER_TIMING), "CUMULATIVE_OPTIMIZER_TIMING" },
 		{ static_cast<uint32_t>(MetricsType::CUMULATIVE_ROWS_SCANNED), "CUMULATIVE_ROWS_SCANNED" },
 		{ static_cast<uint32_t>(MetricsType::EXTRA_INFO), "EXTRA_INFO" },
 		{ static_cast<uint32_t>(MetricsType::LATENCY), "LATENCY" },
@@ -2812,52 +2838,50 @@ const StringUtil::EnumStringLiteral *GetMetricsTypeValues() {
 		{ static_cast<uint32_t>(MetricsType::OPERATOR_ROWS_SCANNED), "OPERATOR_ROWS_SCANNED" },
 		{ static_cast<uint32_t>(MetricsType::OPERATOR_TIMING), "OPERATOR_TIMING" },
 		{ static_cast<uint32_t>(MetricsType::OPERATOR_TYPE), "OPERATOR_TYPE" },
-		{ static_cast<uint32_t>(MetricsType::QUERY_NAME), "QUERY_NAME" },
-		{ static_cast<uint32_t>(MetricsType::RESULT_SET_SIZE), "RESULT_SET_SIZE" },
-		{ static_cast<uint32_t>(MetricsType::ROWS_RETURNED), "ROWS_RETURNED" },
-		{ static_cast<uint32_t>(MetricsType::SYSTEM_PEAK_BUFFER_MEMORY), "SYSTEM_PEAK_BUFFER_MEMORY" },
-		{ static_cast<uint32_t>(MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE), "SYSTEM_PEAK_TEMP_DIR_SIZE" },
-		{ static_cast<uint32_t>(MetricsType::TOTAL_BYTES_READ), "TOTAL_BYTES_READ" },
-		{ static_cast<uint32_t>(MetricsType::TOTAL_BYTES_WRITTEN), "TOTAL_BYTES_WRITTEN" },
-		{ static_cast<uint32_t>(MetricsType::WAITING_TO_ATTACH_LATENCY), "WAITING_TO_ATTACH_LATENCY" },
-		{ static_cast<uint32_t>(MetricsType::ALL_OPTIMIZERS), "ALL_OPTIMIZERS" },
-		{ static_cast<uint32_t>(MetricsType::CUMULATIVE_OPTIMIZER_TIMING), "CUMULATIVE_OPTIMIZER_TIMING" },
-		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER), "PHYSICAL_PLANNER" },
-		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING), "PHYSICAL_PLANNER_COLUMN_BINDING" },
-		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER_CREATE_PLAN), "PHYSICAL_PLANNER_CREATE_PLAN" },
-		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES), "PHYSICAL_PLANNER_RESOLVE_TYPES" },
-		{ static_cast<uint32_t>(MetricsType::PLANNER), "PLANNER" },
-		{ static_cast<uint32_t>(MetricsType::PLANNER_BINDING), "PLANNER_BINDING" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE), "OPTIMIZER_BUILD_SIDE_PROBE_SIDE" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COLUMN_LIFETIME), "OPTIMIZER_COLUMN_LIFETIME" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMMON_AGGREGATE), "OPTIMIZER_COMMON_AGGREGATE" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS), "OPTIMIZER_COMMON_SUBEXPRESSIONS" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMMON_SUBPLAN), "OPTIMIZER_COMMON_SUBPLAN" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION), "OPTIMIZER_COMPRESSED_MATERIALIZATION" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_CTE_FILTER_PUSHER), "OPTIMIZER_CTE_FILTER_PUSHER" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_CTE_INLINING), "OPTIMIZER_CTE_INLINING" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_DELIMINATOR), "OPTIMIZER_DELIMINATOR" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_DUPLICATE_GROUPS), "OPTIMIZER_DUPLICATE_GROUPS" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP), "OPTIMIZER_EMPTY_RESULT_PULLUP" },
 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_EXPRESSION_REWRITER), "OPTIMIZER_EXPRESSION_REWRITER" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_EXTENSION), "OPTIMIZER_EXTENSION" },
 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_FILTER_PULLUP), "OPTIMIZER_FILTER_PULLUP" },
 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_FILTER_PUSHDOWN), "OPTIMIZER_FILTER_PUSHDOWN" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP), "OPTIMIZER_EMPTY_RESULT_PULLUP" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_CTE_FILTER_PUSHER), "OPTIMIZER_CTE_FILTER_PUSHER" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_REGEX_RANGE), "OPTIMIZER_REGEX_RANGE" },
 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_IN_CLAUSE), "OPTIMIZER_IN_CLAUSE" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN), "OPTIMIZER_JOIN_FILTER_PUSHDOWN" },
 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_JOIN_ORDER), "OPTIMIZER_JOIN_ORDER" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_DELIMINATOR), "OPTIMIZER_DELIMINATOR" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_UNNEST_REWRITER), "OPTIMIZER_UNNEST_REWRITER" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_UNUSED_COLUMNS), "OPTIMIZER_UNUSED_COLUMNS" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_STATISTICS_PROPAGATION), "OPTIMIZER_STATISTICS_PROPAGATION" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS), "OPTIMIZER_COMMON_SUBEXPRESSIONS" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMMON_AGGREGATE), "OPTIMIZER_COMMON_AGGREGATE" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COLUMN_LIFETIME), "OPTIMIZER_COLUMN_LIFETIME" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE), "OPTIMIZER_BUILD_SIDE_PROBE_SIDE" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_LATE_MATERIALIZATION), "OPTIMIZER_LATE_MATERIALIZATION" },
 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_LIMIT_PUSHDOWN), "OPTIMIZER_LIMIT_PUSHDOWN" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_TOP_N), "OPTIMIZER_TOP_N" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION), "OPTIMIZER_TOP_N_WINDOW_ELIMINATION" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION), "OPTIMIZER_COMPRESSED_MATERIALIZATION" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_DUPLICATE_GROUPS), "OPTIMIZER_DUPLICATE_GROUPS" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_MATERIALIZED_CTE), "OPTIMIZER_MATERIALIZED_CTE" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_REGEX_RANGE), "OPTIMIZER_REGEX_RANGE" },
 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_REORDER_FILTER), "OPTIMIZER_REORDER_FILTER" },
 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN), "OPTIMIZER_SAMPLING_PUSHDOWN" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN), "OPTIMIZER_JOIN_FILTER_PUSHDOWN" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_EXTENSION), "OPTIMIZER_EXTENSION" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_MATERIALIZED_CTE), "OPTIMIZER_MATERIALIZED_CTE" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_STATISTICS_PROPAGATION), "OPTIMIZER_STATISTICS_PROPAGATION" },
 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_SUM_REWRITER), "OPTIMIZER_SUM_REWRITER" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_LATE_MATERIALIZATION), "OPTIMIZER_LATE_MATERIALIZATION" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_CTE_INLINING), "OPTIMIZER_CTE_INLINING" },
-		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMMON_SUBPLAN), "OPTIMIZER_COMMON_SUBPLAN" }
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_TOP_N), "OPTIMIZER_TOP_N" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION), "OPTIMIZER_TOP_N_WINDOW_ELIMINATION" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_UNNEST_REWRITER), "OPTIMIZER_UNNEST_REWRITER" },
+		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_UNUSED_COLUMNS), "OPTIMIZER_UNUSED_COLUMNS" },
+		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER), "PHYSICAL_PLANNER" },
+		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING), "PHYSICAL_PLANNER_COLUMN_BINDING" },
+		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER_CREATE_PLAN), "PHYSICAL_PLANNER_CREATE_PLAN" },
+		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES), "PHYSICAL_PLANNER_RESOLVE_TYPES" },
+		{ static_cast<uint32_t>(MetricsType::PLANNER), "PLANNER" },
+		{ static_cast<uint32_t>(MetricsType::PLANNER_BINDING), "PLANNER_BINDING" },
+		{ static_cast<uint32_t>(MetricsType::QUERY_NAME), "QUERY_NAME" },
+		{ static_cast<uint32_t>(MetricsType::RESULT_SET_SIZE), "RESULT_SET_SIZE" },
+		{ static_cast<uint32_t>(MetricsType::ROWS_RETURNED), "ROWS_RETURNED" },
+		{ static_cast<uint32_t>(MetricsType::SYSTEM_PEAK_BUFFER_MEMORY), "SYSTEM_PEAK_BUFFER_MEMORY" },
+		{ static_cast<uint32_t>(MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE), "SYSTEM_PEAK_TEMP_DIR_SIZE" },
+		{ static_cast<uint32_t>(MetricsType::TOTAL_BYTES_READ), "TOTAL_BYTES_READ" },
+		{ static_cast<uint32_t>(MetricsType::TOTAL_BYTES_WRITTEN), "TOTAL_BYTES_WRITTEN" },
+		{ static_cast<uint32_t>(MetricsType::WAITING_TO_ATTACH_LATENCY), "WAITING_TO_ATTACH_LATENCY" }
 	};
 	return values;
 }
diff --git a/src/common/enums/metric_type.cpp b/src/common/enums/metric_type.cpp
index 84b552037d..b8ceb3b11d 100644
--- a/src/common/enums/metric_type.cpp
+++ b/src/common/enums/metric_type.cpp
@@ -1,265 +1,586 @@
-//-------------------------------------------------------------------------
-//                         DuckDB
-//
-//
-// duckdb/common/enums/metrics_type.hpp
-// 
 // This file is automatically generated by scripts/generate_metric_enums.py
 // Do not edit this file manually, your changes will be overwritten
-//-------------------------------------------------------------------------
 
 #include "duckdb/common/enums/metric_type.hpp"
+#include "duckdb/common/enum_util.hpp"
+
 namespace duckdb {
 
+profiler_settings_t MetricsUtils::GetAllMetrics() {
+	return {
+		MetricsType::ALL_OPTIMIZERS,
+		MetricsType::ATTACH_LOAD_STORAGE_LATENCY,
+		MetricsType::ATTACH_REPLAY_WAL_LATENCY,
+		MetricsType::BLOCKED_THREAD_TIME,
+		MetricsType::CHECKPOINT_LATENCY,
+		MetricsType::CPU_TIME,
+		MetricsType::CUMULATIVE_CARDINALITY,
+		MetricsType::CUMULATIVE_OPTIMIZER_TIMING,
+		MetricsType::CUMULATIVE_ROWS_SCANNED,
+		MetricsType::EXTRA_INFO,
+		MetricsType::LATENCY,
+		MetricsType::OPERATOR_CARDINALITY,
+		MetricsType::OPERATOR_NAME,
+		MetricsType::OPERATOR_ROWS_SCANNED,
+		MetricsType::OPERATOR_TIMING,
+		MetricsType::OPERATOR_TYPE,
+		MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
+		MetricsType::OPTIMIZER_COLUMN_LIFETIME,
+		MetricsType::OPTIMIZER_COMMON_AGGREGATE,
+		MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS,
+		MetricsType::OPTIMIZER_COMMON_SUBPLAN,
+		MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION,
+		MetricsType::OPTIMIZER_CTE_FILTER_PUSHER,
+		MetricsType::OPTIMIZER_CTE_INLINING,
+		MetricsType::OPTIMIZER_DELIMINATOR,
+		MetricsType::OPTIMIZER_DUPLICATE_GROUPS,
+		MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP,
+		MetricsType::OPTIMIZER_EXPRESSION_REWRITER,
+		MetricsType::OPTIMIZER_EXTENSION,
+		MetricsType::OPTIMIZER_FILTER_PULLUP,
+		MetricsType::OPTIMIZER_FILTER_PUSHDOWN,
+		MetricsType::OPTIMIZER_IN_CLAUSE,
+		MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN,
+		MetricsType::OPTIMIZER_JOIN_ORDER,
+		MetricsType::OPTIMIZER_LATE_MATERIALIZATION,
+		MetricsType::OPTIMIZER_LIMIT_PUSHDOWN,
+		MetricsType::OPTIMIZER_MATERIALIZED_CTE,
+		MetricsType::OPTIMIZER_REGEX_RANGE,
+		MetricsType::OPTIMIZER_REORDER_FILTER,
+		MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN,
+		MetricsType::OPTIMIZER_STATISTICS_PROPAGATION,
+		MetricsType::OPTIMIZER_SUM_REWRITER,
+		MetricsType::OPTIMIZER_TOP_N,
+		MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
+		MetricsType::OPTIMIZER_UNNEST_REWRITER,
+		MetricsType::OPTIMIZER_UNUSED_COLUMNS,
+		MetricsType::PHYSICAL_PLANNER,
+		MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING,
+		MetricsType::PHYSICAL_PLANNER_CREATE_PLAN,
+		MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES,
+		MetricsType::PLANNER,
+		MetricsType::PLANNER_BINDING,
+		MetricsType::QUERY_NAME,
+		MetricsType::RESULT_SET_SIZE,
+		MetricsType::ROWS_RETURNED,
+		MetricsType::SYSTEM_PEAK_BUFFER_MEMORY,
+		MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE,
+		MetricsType::TOTAL_BYTES_READ,
+		MetricsType::TOTAL_BYTES_WRITTEN,
+		MetricsType::WAITING_TO_ATTACH_LATENCY,
+	};
+}
+
+profiler_settings_t MetricsUtils::GetMetricsByGroupType(MetricGroup type) {
+	switch(type) {
+	case MetricGroup::ALL:
+		return {
+			MetricsType::ALL_OPTIMIZERS,
+			MetricsType::ATTACH_LOAD_STORAGE_LATENCY,
+			MetricsType::ATTACH_REPLAY_WAL_LATENCY,
+			MetricsType::BLOCKED_THREAD_TIME,
+			MetricsType::CHECKPOINT_LATENCY,
+			MetricsType::CPU_TIME,
+			MetricsType::CUMULATIVE_CARDINALITY,
+			MetricsType::CUMULATIVE_OPTIMIZER_TIMING,
+			MetricsType::CUMULATIVE_ROWS_SCANNED,
+			MetricsType::EXTRA_INFO,
+			MetricsType::LATENCY,
+			MetricsType::OPERATOR_CARDINALITY,
+			MetricsType::OPERATOR_NAME,
+			MetricsType::OPERATOR_ROWS_SCANNED,
+			MetricsType::OPERATOR_TIMING,
+			MetricsType::OPERATOR_TYPE,
+			MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
+			MetricsType::OPTIMIZER_COLUMN_LIFETIME,
+			MetricsType::OPTIMIZER_COMMON_AGGREGATE,
+			MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS,
+			MetricsType::OPTIMIZER_COMMON_SUBPLAN,
+			MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION,
+			MetricsType::OPTIMIZER_CTE_FILTER_PUSHER,
+			MetricsType::OPTIMIZER_CTE_INLINING,
+			MetricsType::OPTIMIZER_DELIMINATOR,
+			MetricsType::OPTIMIZER_DUPLICATE_GROUPS,
+			MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP,
+			MetricsType::OPTIMIZER_EXPRESSION_REWRITER,
+			MetricsType::OPTIMIZER_EXTENSION,
+			MetricsType::OPTIMIZER_FILTER_PULLUP,
+			MetricsType::OPTIMIZER_FILTER_PUSHDOWN,
+			MetricsType::OPTIMIZER_IN_CLAUSE,
+			MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN,
+			MetricsType::OPTIMIZER_JOIN_ORDER,
+			MetricsType::OPTIMIZER_LATE_MATERIALIZATION,
+			MetricsType::OPTIMIZER_LIMIT_PUSHDOWN,
+			MetricsType::OPTIMIZER_MATERIALIZED_CTE,
+			MetricsType::OPTIMIZER_REGEX_RANGE,
+			MetricsType::OPTIMIZER_REORDER_FILTER,
+			MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN,
+			MetricsType::OPTIMIZER_STATISTICS_PROPAGATION,
+			MetricsType::OPTIMIZER_SUM_REWRITER,
+			MetricsType::OPTIMIZER_TOP_N,
+			MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
+			MetricsType::OPTIMIZER_UNNEST_REWRITER,
+			MetricsType::OPTIMIZER_UNUSED_COLUMNS,
+			MetricsType::PHYSICAL_PLANNER,
+			MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING,
+			MetricsType::PHYSICAL_PLANNER_CREATE_PLAN,
+			MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES,
+			MetricsType::PLANNER,
+			MetricsType::PLANNER_BINDING,
+			MetricsType::QUERY_NAME,
+			MetricsType::RESULT_SET_SIZE,
+			MetricsType::ROWS_RETURNED,
+			MetricsType::SYSTEM_PEAK_BUFFER_MEMORY,
+			MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE,
+			MetricsType::TOTAL_BYTES_READ,
+			MetricsType::TOTAL_BYTES_WRITTEN,
+			MetricsType::WAITING_TO_ATTACH_LATENCY,
+			};
+	case MetricGroup::DEFAULT:
+		return {
+			MetricsType::CPU_TIME,
+			MetricsType::CUMULATIVE_CARDINALITY,
+			MetricsType::CUMULATIVE_ROWS_SCANNED,
+			MetricsType::EXTRA_INFO,
+			MetricsType::LATENCY,
+			MetricsType::QUERY_NAME,
+			MetricsType::RESULT_SET_SIZE,
+			MetricsType::ROWS_RETURNED,
+			};
+	case MetricGroup::EXECUTION:
+		return {
+			MetricsType::BLOCKED_THREAD_TIME,
+			MetricsType::SYSTEM_PEAK_BUFFER_MEMORY,
+			MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE,
+			};
+	case MetricGroup::FILE:
+		return {
+			MetricsType::ATTACH_LOAD_STORAGE_LATENCY,
+			MetricsType::ATTACH_REPLAY_WAL_LATENCY,
+			MetricsType::CHECKPOINT_LATENCY,
+			MetricsType::TOTAL_BYTES_READ,
+			MetricsType::TOTAL_BYTES_WRITTEN,
+			MetricsType::WAITING_TO_ATTACH_LATENCY,
+			};
+	case MetricGroup::OPERATOR:
+		return {
+			MetricsType::OPERATOR_CARDINALITY,
+			MetricsType::OPERATOR_NAME,
+			MetricsType::OPERATOR_ROWS_SCANNED,
+			MetricsType::OPERATOR_TIMING,
+			MetricsType::OPERATOR_TYPE,
+			};
+	case MetricGroup::OPTIMIZER:
+		return {
+			MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
+			MetricsType::OPTIMIZER_COLUMN_LIFETIME,
+			MetricsType::OPTIMIZER_COMMON_AGGREGATE,
+			MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS,
+			MetricsType::OPTIMIZER_COMMON_SUBPLAN,
+			MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION,
+			MetricsType::OPTIMIZER_CTE_FILTER_PUSHER,
+			MetricsType::OPTIMIZER_CTE_INLINING,
+			MetricsType::OPTIMIZER_DELIMINATOR,
+			MetricsType::OPTIMIZER_DUPLICATE_GROUPS,
+			MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP,
+			MetricsType::OPTIMIZER_EXPRESSION_REWRITER,
+			MetricsType::OPTIMIZER_EXTENSION,
+			MetricsType::OPTIMIZER_FILTER_PULLUP,
+			MetricsType::OPTIMIZER_FILTER_PUSHDOWN,
+			MetricsType::OPTIMIZER_IN_CLAUSE,
+			MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN,
+			MetricsType::OPTIMIZER_JOIN_ORDER,
+			MetricsType::OPTIMIZER_LATE_MATERIALIZATION,
+			MetricsType::OPTIMIZER_LIMIT_PUSHDOWN,
+			MetricsType::OPTIMIZER_MATERIALIZED_CTE,
+			MetricsType::OPTIMIZER_REGEX_RANGE,
+			MetricsType::OPTIMIZER_REORDER_FILTER,
+			MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN,
+			MetricsType::OPTIMIZER_STATISTICS_PROPAGATION,
+			MetricsType::OPTIMIZER_SUM_REWRITER,
+			MetricsType::OPTIMIZER_TOP_N,
+			MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
+			MetricsType::OPTIMIZER_UNNEST_REWRITER,
+			MetricsType::OPTIMIZER_UNUSED_COLUMNS,
+			};
+	case MetricGroup::PHASE_TIMING:
+		return {
+			MetricsType::ALL_OPTIMIZERS,
+			MetricsType::CUMULATIVE_OPTIMIZER_TIMING,
+			MetricsType::PHYSICAL_PLANNER,
+			MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING,
+			MetricsType::PHYSICAL_PLANNER_CREATE_PLAN,
+			MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES,
+			MetricsType::PLANNER,
+			MetricsType::PLANNER_BINDING,
+			};
+	default:
+		throw InternalException("The MetricGroup passed is invalid");
+	}
+}
+profiler_settings_t MetricsUtils::GetDefaultMetrics() {
+	return {
+		MetricsType::CPU_TIME,
+		MetricsType::CUMULATIVE_CARDINALITY,
+		MetricsType::CUMULATIVE_ROWS_SCANNED,
+		MetricsType::EXTRA_INFO,
+		MetricsType::LATENCY,
+		MetricsType::QUERY_NAME,
+		MetricsType::RESULT_SET_SIZE,
+		MetricsType::ROWS_RETURNED,
+	};
+}
+
+bool MetricsUtils::IsDefaultMetric(MetricsType type) {
+	switch(type) {
+		case MetricsType::CPU_TIME:
+		case MetricsType::CUMULATIVE_CARDINALITY:
+		case MetricsType::CUMULATIVE_ROWS_SCANNED:
+		case MetricsType::EXTRA_INFO:
+		case MetricsType::LATENCY:
+		case MetricsType::QUERY_NAME:
+		case MetricsType::RESULT_SET_SIZE:
+		case MetricsType::ROWS_RETURNED:
+			return true;
+		default:
+			return false;
+	}
+}
+
+profiler_settings_t MetricsUtils::GetExecutionMetrics() {
+	return {
+		MetricsType::BLOCKED_THREAD_TIME,
+		MetricsType::SYSTEM_PEAK_BUFFER_MEMORY,
+		MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE,
+	};
+}
+
+bool MetricsUtils::IsExecutionMetric(MetricsType type) {
+	switch(type) {
+		case MetricsType::BLOCKED_THREAD_TIME:
+		case MetricsType::SYSTEM_PEAK_BUFFER_MEMORY:
+		case MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE:
+			return true;
+		default:
+			return false;
+	}
+}
+
+profiler_settings_t MetricsUtils::GetFileMetrics() {
+	return {
+		MetricsType::ATTACH_LOAD_STORAGE_LATENCY,
+		MetricsType::ATTACH_REPLAY_WAL_LATENCY,
+		MetricsType::CHECKPOINT_LATENCY,
+		MetricsType::TOTAL_BYTES_READ,
+		MetricsType::TOTAL_BYTES_WRITTEN,
+		MetricsType::WAITING_TO_ATTACH_LATENCY,
+	};
+}
+
+bool MetricsUtils::IsFileMetric(MetricsType type) {
+	switch(type) {
+		case MetricsType::ATTACH_LOAD_STORAGE_LATENCY:
+		case MetricsType::ATTACH_REPLAY_WAL_LATENCY:
+		case MetricsType::CHECKPOINT_LATENCY:
+		case MetricsType::TOTAL_BYTES_READ:
+		case MetricsType::TOTAL_BYTES_WRITTEN:
+		case MetricsType::WAITING_TO_ATTACH_LATENCY:
+			return true;
+		default:
+			return false;
+	}
+}
+
+profiler_settings_t MetricsUtils::GetOperatorMetrics() {
+	return {
+		MetricsType::OPERATOR_CARDINALITY,
+		MetricsType::OPERATOR_NAME,
+		MetricsType::OPERATOR_ROWS_SCANNED,
+		MetricsType::OPERATOR_TIMING,
+		MetricsType::OPERATOR_TYPE,
+	};
+}
+
+bool MetricsUtils::IsOperatorMetric(MetricsType type) {
+	switch(type) {
+		case MetricsType::OPERATOR_CARDINALITY:
+		case MetricsType::OPERATOR_NAME:
+		case MetricsType::OPERATOR_ROWS_SCANNED:
+		case MetricsType::OPERATOR_TIMING:
+		case MetricsType::OPERATOR_TYPE:
+			return true;
+		default:
+			return false;
+	}
+}
+
 profiler_settings_t MetricsUtils::GetOptimizerMetrics() {
-    return {
-        MetricsType::OPTIMIZER_EXPRESSION_REWRITER,
-        MetricsType::OPTIMIZER_FILTER_PULLUP,
-        MetricsType::OPTIMIZER_FILTER_PUSHDOWN,
-        MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP,
-        MetricsType::OPTIMIZER_CTE_FILTER_PUSHER,
-        MetricsType::OPTIMIZER_REGEX_RANGE,
-        MetricsType::OPTIMIZER_IN_CLAUSE,
-        MetricsType::OPTIMIZER_JOIN_ORDER,
-        MetricsType::OPTIMIZER_DELIMINATOR,
-        MetricsType::OPTIMIZER_UNNEST_REWRITER,
-        MetricsType::OPTIMIZER_UNUSED_COLUMNS,
-        MetricsType::OPTIMIZER_STATISTICS_PROPAGATION,
-        MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS,
-        MetricsType::OPTIMIZER_COMMON_AGGREGATE,
-        MetricsType::OPTIMIZER_COLUMN_LIFETIME,
-        MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
-        MetricsType::OPTIMIZER_LIMIT_PUSHDOWN,
-        MetricsType::OPTIMIZER_TOP_N,
-        MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
-        MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION,
-        MetricsType::OPTIMIZER_DUPLICATE_GROUPS,
-        MetricsType::OPTIMIZER_REORDER_FILTER,
-        MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN,
-        MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN,
-        MetricsType::OPTIMIZER_EXTENSION,
-        MetricsType::OPTIMIZER_MATERIALIZED_CTE,
-        MetricsType::OPTIMIZER_SUM_REWRITER,
-        MetricsType::OPTIMIZER_LATE_MATERIALIZATION,
-        MetricsType::OPTIMIZER_CTE_INLINING,
-        MetricsType::OPTIMIZER_COMMON_SUBPLAN,
-    };
+	return {
+		MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
+		MetricsType::OPTIMIZER_COLUMN_LIFETIME,
+		MetricsType::OPTIMIZER_COMMON_AGGREGATE,
+		MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS,
+		MetricsType::OPTIMIZER_COMMON_SUBPLAN,
+		MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION,
+		MetricsType::OPTIMIZER_CTE_FILTER_PUSHER,
+		MetricsType::OPTIMIZER_CTE_INLINING,
+		MetricsType::OPTIMIZER_DELIMINATOR,
+		MetricsType::OPTIMIZER_DUPLICATE_GROUPS,
+		MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP,
+		MetricsType::OPTIMIZER_EXPRESSION_REWRITER,
+		MetricsType::OPTIMIZER_EXTENSION,
+		MetricsType::OPTIMIZER_FILTER_PULLUP,
+		MetricsType::OPTIMIZER_FILTER_PUSHDOWN,
+		MetricsType::OPTIMIZER_IN_CLAUSE,
+		MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN,
+		MetricsType::OPTIMIZER_JOIN_ORDER,
+		MetricsType::OPTIMIZER_LATE_MATERIALIZATION,
+		MetricsType::OPTIMIZER_LIMIT_PUSHDOWN,
+		MetricsType::OPTIMIZER_MATERIALIZED_CTE,
+		MetricsType::OPTIMIZER_REGEX_RANGE,
+		MetricsType::OPTIMIZER_REORDER_FILTER,
+		MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN,
+		MetricsType::OPTIMIZER_STATISTICS_PROPAGATION,
+		MetricsType::OPTIMIZER_SUM_REWRITER,
+		MetricsType::OPTIMIZER_TOP_N,
+		MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
+		MetricsType::OPTIMIZER_UNNEST_REWRITER,
+		MetricsType::OPTIMIZER_UNUSED_COLUMNS,
+	};
 }
 
-profiler_settings_t MetricsUtils::GetPhaseTimingMetrics() {
-    return {
-        MetricsType::ALL_OPTIMIZERS,
-        MetricsType::CUMULATIVE_OPTIMIZER_TIMING,
-        MetricsType::PHYSICAL_PLANNER,
-        MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING,
-        MetricsType::PHYSICAL_PLANNER_CREATE_PLAN,
-        MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES,
-        MetricsType::PLANNER,
-        MetricsType::PLANNER_BINDING,
-    };
+bool MetricsUtils::IsOptimizerMetric(MetricsType type) {
+	switch(type) {
+		case MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE:
+		case MetricsType::OPTIMIZER_COLUMN_LIFETIME:
+		case MetricsType::OPTIMIZER_COMMON_AGGREGATE:
+		case MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS:
+		case MetricsType::OPTIMIZER_COMMON_SUBPLAN:
+		case MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION:
+		case MetricsType::OPTIMIZER_CTE_FILTER_PUSHER:
+		case MetricsType::OPTIMIZER_CTE_INLINING:
+		case MetricsType::OPTIMIZER_DELIMINATOR:
+		case MetricsType::OPTIMIZER_DUPLICATE_GROUPS:
+		case MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP:
+		case MetricsType::OPTIMIZER_EXPRESSION_REWRITER:
+		case MetricsType::OPTIMIZER_EXTENSION:
+		case MetricsType::OPTIMIZER_FILTER_PULLUP:
+		case MetricsType::OPTIMIZER_FILTER_PUSHDOWN:
+		case MetricsType::OPTIMIZER_IN_CLAUSE:
+		case MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN:
+		case MetricsType::OPTIMIZER_JOIN_ORDER:
+		case MetricsType::OPTIMIZER_LATE_MATERIALIZATION:
+		case MetricsType::OPTIMIZER_LIMIT_PUSHDOWN:
+		case MetricsType::OPTIMIZER_MATERIALIZED_CTE:
+		case MetricsType::OPTIMIZER_REGEX_RANGE:
+		case MetricsType::OPTIMIZER_REORDER_FILTER:
+		case MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN:
+		case MetricsType::OPTIMIZER_STATISTICS_PROPAGATION:
+		case MetricsType::OPTIMIZER_SUM_REWRITER:
+		case MetricsType::OPTIMIZER_TOP_N:
+		case MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION:
+		case MetricsType::OPTIMIZER_UNNEST_REWRITER:
+		case MetricsType::OPTIMIZER_UNUSED_COLUMNS:
+			return true;
+		default:
+			return false;
+	}
 }
 
 MetricsType MetricsUtils::GetOptimizerMetricByType(OptimizerType type) {
-    switch(type) {
-        case OptimizerType::EXPRESSION_REWRITER:
-            return MetricsType::OPTIMIZER_EXPRESSION_REWRITER;
-        case OptimizerType::FILTER_PULLUP:
-            return MetricsType::OPTIMIZER_FILTER_PULLUP;
-        case OptimizerType::FILTER_PUSHDOWN:
-            return MetricsType::OPTIMIZER_FILTER_PUSHDOWN;
-        case OptimizerType::EMPTY_RESULT_PULLUP:
-            return MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP;
-        case OptimizerType::CTE_FILTER_PUSHER:
-            return MetricsType::OPTIMIZER_CTE_FILTER_PUSHER;
-        case OptimizerType::REGEX_RANGE:
-            return MetricsType::OPTIMIZER_REGEX_RANGE;
-        case OptimizerType::IN_CLAUSE:
-            return MetricsType::OPTIMIZER_IN_CLAUSE;
-        case OptimizerType::JOIN_ORDER:
-            return MetricsType::OPTIMIZER_JOIN_ORDER;
-        case OptimizerType::DELIMINATOR:
-            return MetricsType::OPTIMIZER_DELIMINATOR;
-        case OptimizerType::UNNEST_REWRITER:
-            return MetricsType::OPTIMIZER_UNNEST_REWRITER;
-        case OptimizerType::UNUSED_COLUMNS:
-            return MetricsType::OPTIMIZER_UNUSED_COLUMNS;
-        case OptimizerType::STATISTICS_PROPAGATION:
-            return MetricsType::OPTIMIZER_STATISTICS_PROPAGATION;
-        case OptimizerType::COMMON_SUBEXPRESSIONS:
-            return MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS;
-        case OptimizerType::COMMON_AGGREGATE:
-            return MetricsType::OPTIMIZER_COMMON_AGGREGATE;
-        case OptimizerType::COLUMN_LIFETIME:
-            return MetricsType::OPTIMIZER_COLUMN_LIFETIME;
-        case OptimizerType::BUILD_SIDE_PROBE_SIDE:
-            return MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE;
-        case OptimizerType::LIMIT_PUSHDOWN:
-            return MetricsType::OPTIMIZER_LIMIT_PUSHDOWN;
-        case OptimizerType::TOP_N:
-            return MetricsType::OPTIMIZER_TOP_N;
-        case OptimizerType::TOP_N_WINDOW_ELIMINATION:
-            return MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION;
-        case OptimizerType::COMPRESSED_MATERIALIZATION:
-            return MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION;
-        case OptimizerType::DUPLICATE_GROUPS:
-            return MetricsType::OPTIMIZER_DUPLICATE_GROUPS;
-        case OptimizerType::REORDER_FILTER:
-            return MetricsType::OPTIMIZER_REORDER_FILTER;
-        case OptimizerType::SAMPLING_PUSHDOWN:
-            return MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN;
-        case OptimizerType::JOIN_FILTER_PUSHDOWN:
-            return MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN;
-        case OptimizerType::EXTENSION:
-            return MetricsType::OPTIMIZER_EXTENSION;
-        case OptimizerType::MATERIALIZED_CTE:
-            return MetricsType::OPTIMIZER_MATERIALIZED_CTE;
-        case OptimizerType::SUM_REWRITER:
-            return MetricsType::OPTIMIZER_SUM_REWRITER;
-        case OptimizerType::LATE_MATERIALIZATION:
-            return MetricsType::OPTIMIZER_LATE_MATERIALIZATION;
-        case OptimizerType::CTE_INLINING:
-            return MetricsType::OPTIMIZER_CTE_INLINING;
-        case OptimizerType::COMMON_SUBPLAN:
-            return MetricsType::OPTIMIZER_COMMON_SUBPLAN;
-       default:
-            throw InternalException("OptimizerType %s cannot be converted to a MetricsType", EnumUtil::ToString(type));
-    };
+	switch(type) {
+		case OptimizerType::BUILD_SIDE_PROBE_SIDE:
+			return MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE;
+		case OptimizerType::COLUMN_LIFETIME:
+			return MetricsType::OPTIMIZER_COLUMN_LIFETIME;
+		case OptimizerType::COMMON_AGGREGATE:
+			return MetricsType::OPTIMIZER_COMMON_AGGREGATE;
+		case OptimizerType::COMMON_SUBEXPRESSIONS:
+			return MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS;
+		case OptimizerType::COMMON_SUBPLAN:
+			return MetricsType::OPTIMIZER_COMMON_SUBPLAN;
+		case OptimizerType::COMPRESSED_MATERIALIZATION:
+			return MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION;
+		case OptimizerType::CTE_FILTER_PUSHER:
+			return MetricsType::OPTIMIZER_CTE_FILTER_PUSHER;
+		case OptimizerType::CTE_INLINING:
+			return MetricsType::OPTIMIZER_CTE_INLINING;
+		case OptimizerType::DELIMINATOR:
+			return MetricsType::OPTIMIZER_DELIMINATOR;
+		case OptimizerType::DUPLICATE_GROUPS:
+			return MetricsType::OPTIMIZER_DUPLICATE_GROUPS;
+		case OptimizerType::EMPTY_RESULT_PULLUP:
+			return MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP;
+		case OptimizerType::EXPRESSION_REWRITER:
+			return MetricsType::OPTIMIZER_EXPRESSION_REWRITER;
+		case OptimizerType::EXTENSION:
+			return MetricsType::OPTIMIZER_EXTENSION;
+		case OptimizerType::FILTER_PULLUP:
+			return MetricsType::OPTIMIZER_FILTER_PULLUP;
+		case OptimizerType::FILTER_PUSHDOWN:
+			return MetricsType::OPTIMIZER_FILTER_PUSHDOWN;
+		case OptimizerType::IN_CLAUSE:
+			return MetricsType::OPTIMIZER_IN_CLAUSE;
+		case OptimizerType::JOIN_FILTER_PUSHDOWN:
+			return MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN;
+		case OptimizerType::JOIN_ORDER:
+			return MetricsType::OPTIMIZER_JOIN_ORDER;
+		case OptimizerType::LATE_MATERIALIZATION:
+			return MetricsType::OPTIMIZER_LATE_MATERIALIZATION;
+		case OptimizerType::LIMIT_PUSHDOWN:
+			return MetricsType::OPTIMIZER_LIMIT_PUSHDOWN;
+		case OptimizerType::MATERIALIZED_CTE:
+			return MetricsType::OPTIMIZER_MATERIALIZED_CTE;
+		case OptimizerType::REGEX_RANGE:
+			return MetricsType::OPTIMIZER_REGEX_RANGE;
+		case OptimizerType::REORDER_FILTER:
+			return MetricsType::OPTIMIZER_REORDER_FILTER;
+		case OptimizerType::SAMPLING_PUSHDOWN:
+			return MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN;
+		case OptimizerType::STATISTICS_PROPAGATION:
+			return MetricsType::OPTIMIZER_STATISTICS_PROPAGATION;
+		case OptimizerType::SUM_REWRITER:
+			return MetricsType::OPTIMIZER_SUM_REWRITER;
+		case OptimizerType::TOP_N:
+			return MetricsType::OPTIMIZER_TOP_N;
+		case OptimizerType::TOP_N_WINDOW_ELIMINATION:
+			return MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION;
+		case OptimizerType::UNNEST_REWRITER:
+			return MetricsType::OPTIMIZER_UNNEST_REWRITER;
+		case OptimizerType::UNUSED_COLUMNS:
+			return MetricsType::OPTIMIZER_UNUSED_COLUMNS;
+		default:
+			throw InternalException("OptimizerType %s cannot be converted to a MetricsType", EnumUtil::ToString(type));
+	}
 }
 
 OptimizerType MetricsUtils::GetOptimizerTypeByMetric(MetricsType type) {
-    switch(type) {
-        case MetricsType::OPTIMIZER_EXPRESSION_REWRITER:
-            return OptimizerType::EXPRESSION_REWRITER;
-        case MetricsType::OPTIMIZER_FILTER_PULLUP:
-            return OptimizerType::FILTER_PULLUP;
-        case MetricsType::OPTIMIZER_FILTER_PUSHDOWN:
-            return OptimizerType::FILTER_PUSHDOWN;
-        case MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP:
-            return OptimizerType::EMPTY_RESULT_PULLUP;
-        case MetricsType::OPTIMIZER_CTE_FILTER_PUSHER:
-            return OptimizerType::CTE_FILTER_PUSHER;
-        case MetricsType::OPTIMIZER_REGEX_RANGE:
-            return OptimizerType::REGEX_RANGE;
-        case MetricsType::OPTIMIZER_IN_CLAUSE:
-            return OptimizerType::IN_CLAUSE;
-        case MetricsType::OPTIMIZER_JOIN_ORDER:
-            return OptimizerType::JOIN_ORDER;
-        case MetricsType::OPTIMIZER_DELIMINATOR:
-            return OptimizerType::DELIMINATOR;
-        case MetricsType::OPTIMIZER_UNNEST_REWRITER:
-            return OptimizerType::UNNEST_REWRITER;
-        case MetricsType::OPTIMIZER_UNUSED_COLUMNS:
-            return OptimizerType::UNUSED_COLUMNS;
-        case MetricsType::OPTIMIZER_STATISTICS_PROPAGATION:
-            return OptimizerType::STATISTICS_PROPAGATION;
-        case MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS:
-            return OptimizerType::COMMON_SUBEXPRESSIONS;
-        case MetricsType::OPTIMIZER_COMMON_AGGREGATE:
-            return OptimizerType::COMMON_AGGREGATE;
-        case MetricsType::OPTIMIZER_COLUMN_LIFETIME:
-            return OptimizerType::COLUMN_LIFETIME;
-        case MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE:
-            return OptimizerType::BUILD_SIDE_PROBE_SIDE;
-        case MetricsType::OPTIMIZER_LIMIT_PUSHDOWN:
-            return OptimizerType::LIMIT_PUSHDOWN;
-        case MetricsType::OPTIMIZER_TOP_N:
-            return OptimizerType::TOP_N;
-        case MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION:
-            return OptimizerType::TOP_N_WINDOW_ELIMINATION;
-        case MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION:
-            return OptimizerType::COMPRESSED_MATERIALIZATION;
-        case MetricsType::OPTIMIZER_DUPLICATE_GROUPS:
-            return OptimizerType::DUPLICATE_GROUPS;
-        case MetricsType::OPTIMIZER_REORDER_FILTER:
-            return OptimizerType::REORDER_FILTER;
-        case MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN:
-            return OptimizerType::SAMPLING_PUSHDOWN;
-        case MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN:
-            return OptimizerType::JOIN_FILTER_PUSHDOWN;
-        case MetricsType::OPTIMIZER_EXTENSION:
-            return OptimizerType::EXTENSION;
-        case MetricsType::OPTIMIZER_MATERIALIZED_CTE:
-            return OptimizerType::MATERIALIZED_CTE;
-        case MetricsType::OPTIMIZER_SUM_REWRITER:
-            return OptimizerType::SUM_REWRITER;
-        case MetricsType::OPTIMIZER_LATE_MATERIALIZATION:
-            return OptimizerType::LATE_MATERIALIZATION;
-        case MetricsType::OPTIMIZER_CTE_INLINING:
-            return OptimizerType::CTE_INLINING;
-        case MetricsType::OPTIMIZER_COMMON_SUBPLAN:
-            return OptimizerType::COMMON_SUBPLAN;
-    default:
-            return OptimizerType::INVALID;
-    };
+	switch(type) {
+		case MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE:
+			return OptimizerType::BUILD_SIDE_PROBE_SIDE;
+		case MetricsType::OPTIMIZER_COLUMN_LIFETIME:
+			return OptimizerType::COLUMN_LIFETIME;
+		case MetricsType::OPTIMIZER_COMMON_AGGREGATE:
+			return OptimizerType::COMMON_AGGREGATE;
+		case MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS:
+			return OptimizerType::COMMON_SUBEXPRESSIONS;
+		case MetricsType::OPTIMIZER_COMMON_SUBPLAN:
+			return OptimizerType::COMMON_SUBPLAN;
+		case MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION:
+			return OptimizerType::COMPRESSED_MATERIALIZATION;
+		case MetricsType::OPTIMIZER_CTE_FILTER_PUSHER:
+			return OptimizerType::CTE_FILTER_PUSHER;
+		case MetricsType::OPTIMIZER_CTE_INLINING:
+			return OptimizerType::CTE_INLINING;
+		case MetricsType::OPTIMIZER_DELIMINATOR:
+			return OptimizerType::DELIMINATOR;
+		case MetricsType::OPTIMIZER_DUPLICATE_GROUPS:
+			return OptimizerType::DUPLICATE_GROUPS;
+		case MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP:
+			return OptimizerType::EMPTY_RESULT_PULLUP;
+		case MetricsType::OPTIMIZER_EXPRESSION_REWRITER:
+			return OptimizerType::EXPRESSION_REWRITER;
+		case MetricsType::OPTIMIZER_EXTENSION:
+			return OptimizerType::EXTENSION;
+		case MetricsType::OPTIMIZER_FILTER_PULLUP:
+			return OptimizerType::FILTER_PULLUP;
+		case MetricsType::OPTIMIZER_FILTER_PUSHDOWN:
+			return OptimizerType::FILTER_PUSHDOWN;
+		case MetricsType::OPTIMIZER_IN_CLAUSE:
+			return OptimizerType::IN_CLAUSE;
+		case MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN:
+			return OptimizerType::JOIN_FILTER_PUSHDOWN;
+		case MetricsType::OPTIMIZER_JOIN_ORDER:
+			return OptimizerType::JOIN_ORDER;
+		case MetricsType::OPTIMIZER_LATE_MATERIALIZATION:
+			return OptimizerType::LATE_MATERIALIZATION;
+		case MetricsType::OPTIMIZER_LIMIT_PUSHDOWN:
+			return OptimizerType::LIMIT_PUSHDOWN;
+		case MetricsType::OPTIMIZER_MATERIALIZED_CTE:
+			return OptimizerType::MATERIALIZED_CTE;
+		case MetricsType::OPTIMIZER_REGEX_RANGE:
+			return OptimizerType::REGEX_RANGE;
+		case MetricsType::OPTIMIZER_REORDER_FILTER:
+			return OptimizerType::REORDER_FILTER;
+		case MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN:
+			return OptimizerType::SAMPLING_PUSHDOWN;
+		case MetricsType::OPTIMIZER_STATISTICS_PROPAGATION:
+			return OptimizerType::STATISTICS_PROPAGATION;
+		case MetricsType::OPTIMIZER_SUM_REWRITER:
+			return OptimizerType::SUM_REWRITER;
+		case MetricsType::OPTIMIZER_TOP_N:
+			return OptimizerType::TOP_N;
+		case MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION:
+			return OptimizerType::TOP_N_WINDOW_ELIMINATION;
+		case MetricsType::OPTIMIZER_UNNEST_REWRITER:
+			return OptimizerType::UNNEST_REWRITER;
+		case MetricsType::OPTIMIZER_UNUSED_COLUMNS:
+			return OptimizerType::UNUSED_COLUMNS;
+		default:
+			return OptimizerType::INVALID;
+	}
 }
 
-bool MetricsUtils::IsOptimizerMetric(MetricsType type) {
-    switch(type) {
-        case MetricsType::OPTIMIZER_EXPRESSION_REWRITER:
-        case MetricsType::OPTIMIZER_FILTER_PULLUP:
-        case MetricsType::OPTIMIZER_FILTER_PUSHDOWN:
-        case MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP:
-        case MetricsType::OPTIMIZER_CTE_FILTER_PUSHER:
-        case MetricsType::OPTIMIZER_REGEX_RANGE:
-        case MetricsType::OPTIMIZER_IN_CLAUSE:
-        case MetricsType::OPTIMIZER_JOIN_ORDER:
-        case MetricsType::OPTIMIZER_DELIMINATOR:
-        case MetricsType::OPTIMIZER_UNNEST_REWRITER:
-        case MetricsType::OPTIMIZER_UNUSED_COLUMNS:
-        case MetricsType::OPTIMIZER_STATISTICS_PROPAGATION:
-        case MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS:
-        case MetricsType::OPTIMIZER_COMMON_AGGREGATE:
-        case MetricsType::OPTIMIZER_COLUMN_LIFETIME:
-        case MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE:
-        case MetricsType::OPTIMIZER_LIMIT_PUSHDOWN:
-        case MetricsType::OPTIMIZER_TOP_N:
-        case MetricsType::OPTIMIZER_TOP_N_WINDOW_ELIMINATION:
-        case MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION:
-        case MetricsType::OPTIMIZER_DUPLICATE_GROUPS:
-        case MetricsType::OPTIMIZER_REORDER_FILTER:
-        case MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN:
-        case MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN:
-        case MetricsType::OPTIMIZER_EXTENSION:
-        case MetricsType::OPTIMIZER_MATERIALIZED_CTE:
-        case MetricsType::OPTIMIZER_SUM_REWRITER:
-        case MetricsType::OPTIMIZER_LATE_MATERIALIZATION:
-        case MetricsType::OPTIMIZER_CTE_INLINING:
-        case MetricsType::OPTIMIZER_COMMON_SUBPLAN:
-            return true;
-        default:
-            return false;
-    };
+profiler_settings_t MetricsUtils::GetPhaseTimingMetrics() {
+	return {
+		MetricsType::ALL_OPTIMIZERS,
+		MetricsType::CUMULATIVE_OPTIMIZER_TIMING,
+		MetricsType::PHYSICAL_PLANNER,
+		MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING,
+		MetricsType::PHYSICAL_PLANNER_CREATE_PLAN,
+		MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES,
+		MetricsType::PLANNER,
+		MetricsType::PLANNER_BINDING,
+	};
 }
 
 bool MetricsUtils::IsPhaseTimingMetric(MetricsType type) {
-    switch(type) {
-        case MetricsType::ALL_OPTIMIZERS:
-        case MetricsType::CUMULATIVE_OPTIMIZER_TIMING:
-        case MetricsType::PHYSICAL_PLANNER:
-        case MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING:
-        case MetricsType::PHYSICAL_PLANNER_CREATE_PLAN:
-        case MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES:
-        case MetricsType::PLANNER:
-        case MetricsType::PLANNER_BINDING:
-            return true;
-        default:
-            return false;
-    };
+	switch(type) {
+		case MetricsType::ALL_OPTIMIZERS:
+		case MetricsType::CUMULATIVE_OPTIMIZER_TIMING:
+		case MetricsType::PHYSICAL_PLANNER:
+		case MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING:
+		case MetricsType::PHYSICAL_PLANNER_CREATE_PLAN:
+		case MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES:
+		case MetricsType::PLANNER:
+		case MetricsType::PLANNER_BINDING:
+			return true;
+		default:
+			return false;
+	}
 }
 
-bool MetricsUtils::IsQueryGlobalMetric(MetricsType type) {
-    switch(type) {
-        case MetricsType::ATTACH_LOAD_STORAGE_LATENCY:
-        case MetricsType::ATTACH_REPLAY_WAL_LATENCY:
-        case MetricsType::BLOCKED_THREAD_TIME:
-        case MetricsType::CHECKPOINT_LATENCY:
-        case MetricsType::SYSTEM_PEAK_BUFFER_MEMORY:
-        case MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE:
-        case MetricsType::WAITING_TO_ATTACH_LATENCY:
-            return true;
-        default:
-            return false;
-    };
+profiler_settings_t MetricsUtils::GetRootScopeMetrics() {
+	return {
+		MetricsType::ATTACH_LOAD_STORAGE_LATENCY,
+		MetricsType::ATTACH_REPLAY_WAL_LATENCY,
+		MetricsType::BLOCKED_THREAD_TIME,
+		MetricsType::CHECKPOINT_LATENCY,
+		MetricsType::LATENCY,
+		MetricsType::QUERY_NAME,
+		MetricsType::ROWS_RETURNED,
+		MetricsType::TOTAL_BYTES_READ,
+		MetricsType::TOTAL_BYTES_WRITTEN,
+		MetricsType::WAITING_TO_ATTACH_LATENCY,
+	};
 }
 
-} // namespace duckdb
+bool MetricsUtils::IsRootScopeMetric(MetricsType type) {
+	switch(type) {
+		case MetricsType::ATTACH_LOAD_STORAGE_LATENCY:
+		case MetricsType::ATTACH_REPLAY_WAL_LATENCY:
+		case MetricsType::BLOCKED_THREAD_TIME:
+		case MetricsType::CHECKPOINT_LATENCY:
+		case MetricsType::LATENCY:
+		case MetricsType::QUERY_NAME:
+		case MetricsType::ROWS_RETURNED:
+		case MetricsType::TOTAL_BYTES_READ:
+		case MetricsType::TOTAL_BYTES_WRITTEN:
+		case MetricsType::WAITING_TO_ATTACH_LATENCY:
+			return true;
+		default:
+			return false;
+	}
+}
+
+}
diff --git a/src/common/enums/metric_type.json b/src/common/enums/metric_type.json
new file mode 100644
index 0000000000..9c41e923a9
--- /dev/null
+++ b/src/common/enums/metric_type.json
@@ -0,0 +1,240 @@
+[
+  {
+    "group": "default",
+    "description": "metrics that are collected by default",
+    "metrics": [
+      {
+        "name": "CPU_TIME",
+        "description": "CPU time spent on the query",
+        "type": "double",
+        "unit": "seconds",
+        "collection_method": "cumulative",
+        "child": "OPERATOR_TIMING"
+      },
+      {
+        "name": "CUMULATIVE_CARDINALITY",
+        "description": "Cumulative cardinality of the query",
+        "type": "uint64",
+        "unit": "absolute",
+        "collection_method": "cumulative",
+        "child": "OPERATOR_CARDINALITY"
+      },
+      {
+        "name": "CUMULATIVE_ROWS_SCANNED",
+        "description": "Cumulative number of rows scanned by the query",
+        "type": "uint64",
+        "unit": "absolute",
+        "collection_method": "cumulative",
+        "child": "OPERATOR_ROWS_SCANNED"
+      },
+      {
+        "name": "EXTRA_INFO",
+        "description": "Unique operator metrics",
+        "type": "map"
+      },
+      {
+        "name": "LATENCY",
+        "description": "The total elapsed query execution time",
+        "type": "double",
+        "unit": "seconds",
+        "query_root": true,
+        "collection_method": "timer"
+      },
+      {
+        "name": "QUERY_NAME",
+        "description": "The query string",
+        "type": "string",
+        "query_root": true
+      },
+      {
+        "name": "RESULT_SET_SIZE",
+        "description": "The size of the result",
+        "type": "uint64",
+        "unit": "bytes",
+        "collection_method": "child",
+        "child": "RESULT_SET_SIZE"
+      },
+      {
+        "name": "ROWS_RETURNED",
+        "description": "The number of rows returned by the query",
+        "type": "uint64",
+        "unit": "absolute",
+        "query_root": true,
+        "collection_method": "child",
+        "child": "OPERATOR_CARDINALITY"
+      }
+    ]
+  },
+  {
+    "group": "execution",
+    "description": "metrics that are collected during query execution",
+    "metrics": [
+      {
+        "name": "BLOCKED_THREAD_TIME",
+        "description": "Time spent waiting for a thread to become available",
+        "type": "double",
+        "unit": "seconds",
+        "query_root": true
+      },
+      {
+        "name": "SYSTEM_PEAK_BUFFER_MEMORY",
+        "description": "Peak memory usage of the system",
+        "type": "uint64",
+        "unit": "bytes"
+      },
+      {
+        "name": "SYSTEM_PEAK_TEMP_DIR_SIZE",
+        "description": "Peak size of the temporary directory",
+        "type": "uint64",
+        "unit": "bytes"
+      }
+    ]
+  },
+  {
+    "group": "file",
+    "description": "metrics that are collected during file operations",
+    "metrics": [
+      {
+        "name": "ATTACH_LOAD_STORAGE_LATENCY",
+        "description": "Time spent loading a storage engine",
+        "type": "double",
+        "unit": "seconds",
+        "query_root": true,
+        "collection_method": "timer"
+      },
+      {
+        "name": "ATTACH_REPLAY_WAL_LATENCY",
+        "description": "Time spent replaying the WAL",
+        "type": "double",
+        "unit": "seconds",
+        "query_root": true,
+        "collection_method": "timer"
+      },
+      {
+        "name": "CHECKPOINT_LATENCY",
+        "description": "Time spent performing a checkpoint",
+        "type": "double",
+        "unit": "seconds",
+        "query_root": true,
+        "collection_method": "timer"
+      },
+      {
+        "name": "TOTAL_BYTES_READ",
+        "description": "Total number of bytes read from disk",
+        "type": "uint64",
+        "unit": "bytes",
+        "query_root": true,
+        "collection_method": "query_metric"
+      },
+      {
+        "name": "TOTAL_BYTES_WRITTEN",
+        "description": "Total number of bytes written to disk",
+        "type": "uint64",
+        "unit": "bytes",
+        "query_root": true,
+        "collection_method": "query_metric"
+      },
+      {
+        "name": "WAITING_TO_ATTACH_LATENCY",
+        "description": "Time spent waiting for a storage engine to attach",
+        "type": "double",
+        "unit": "seconds",
+        "query_root": true,
+        "collection_method": "timer"
+      }
+    ]
+  },
+  {
+    "group": "phase_timing",
+    "description": "",
+    "metrics": [
+      {
+        "name": "ALL_OPTIMIZERS",
+        "description": "Enables all optimizers"
+      },
+      {
+        "name": "CUMULATIVE_OPTIMIZER_TIMING",
+        "description": "Time spent in all optimizers",
+        "type": "double",
+        "unit": "milliseconds",
+        "collection_method": "cumulative_operators"
+      },
+      {
+        "name": "PHYSICAL_PLANNER",
+        "description": "The time spent generating the physical plan",
+        "type": "double",
+        "unit": "milliseconds"
+      },
+      {
+        "name": "PHYSICAL_PLANNER_COLUMN_BINDING",
+        "description": "The time spent binding the columns in the logical plan to physical columns",
+        "type": "double",
+        "unit": "milliseconds"
+      },
+      {
+        "name": "PHYSICAL_PLANNER_CREATE_PLAN",
+        "description": "The time spent creating the physical plan",
+        "type": "double",
+        "unit": "milliseconds"
+      },
+      {
+        "name": "PHYSICAL_PLANNER_RESOLVE_TYPES",
+        "description": "The time spent resolving the types in the logical plan to physical types",
+        "type": "double",
+        "unit": "milliseconds"
+      },
+      {
+        "name": "PLANNER",
+        "description": "The time to generate the logical plan from the parsed SQL nodes.",
+        "type": "double",
+        "unit": "milliseconds"
+      },
+      {
+        "name": "PLANNER_BINDING",
+        "description": "The time taken to bind the logical plan.",
+        "type": "double",
+        "unit": "milliseconds"
+      }
+    ]
+  },
+  {
+    "group": "operator",
+    "description": "metrics that are collected for each operator",
+    "metrics": [
+      {
+        "name": "OPERATOR_CARDINALITY",
+        "description": "Cardinality of the operator",
+        "type": "uint64",
+        "unit": "absolute"
+      },
+      {
+        "name": "OPERATOR_NAME",
+        "description": "Name of the operator",
+        "type": "string"
+      },
+      {
+        "name": "OPERATOR_ROWS_SCANNED",
+        "description": "Number of rows scanned by the operator",
+        "type": "uint64",
+        "unit": "absolute"
+      },
+      {
+        "name": "OPERATOR_TIMING",
+        "description": "Time spent in the operator",
+        "type": "double",
+        "unit": "seconds"
+      },
+      {
+        "name": "OPERATOR_TYPE",
+        "description": "Type of the operator",
+        "type": "string"
+      }
+    ]
+  },
+  {
+    "group": "optimizer",
+    "description": "metrics that are collected for each optimizer",
+    "generated": true,
+    "metrics": []
+  }
+]
\ No newline at end of file
diff --git a/src/include/duckdb/common/enum_util.hpp b/src/include/duckdb/common/enum_util.hpp
index 9854e49f43..b4b814c0c1 100644
--- a/src/include/duckdb/common/enum_util.hpp
+++ b/src/include/duckdb/common/enum_util.hpp
@@ -258,6 +258,8 @@ enum class MergeActionType : uint8_t;
 
 enum class MetaPipelineType : uint8_t;
 
+enum class MetricGroup : uint8_t;
+
 enum class MetricsType : uint8_t;
 
 enum class MultiFileColumnMappingMode : uint8_t;
@@ -792,6 +794,9 @@ const char* EnumUtil::ToChars<MergeActionType>(MergeActionType value);
 template<>
 const char* EnumUtil::ToChars<MetaPipelineType>(MetaPipelineType value);
 
+template<>
+const char* EnumUtil::ToChars<MetricGroup>(MetricGroup value);
+
 template<>
 const char* EnumUtil::ToChars<MetricsType>(MetricsType value);
 
@@ -1423,6 +1428,9 @@ MergeActionType EnumUtil::FromString<MergeActionType>(const char *value);
 template<>
 MetaPipelineType EnumUtil::FromString<MetaPipelineType>(const char *value);
 
+template<>
+MetricGroup EnumUtil::FromString<MetricGroup>(const char *value);
+
 template<>
 MetricsType EnumUtil::FromString<MetricsType>(const char *value);
 
diff --git a/src/include/duckdb/common/enums/metric_type.hpp b/src/include/duckdb/common/enums/metric_type.hpp
index 110c9d53f0..f06c413bfe 100644
--- a/src/include/duckdb/common/enums/metric_type.hpp
+++ b/src/include/duckdb/common/enums/metric_type.hpp
@@ -1,8 +1,7 @@
 //-------------------------------------------------------------------------
 //                         DuckDB
 //
-//
-// duckdb/common/enums/metrics_type.hpp
+// duckdb/common/enums/metric_type.hpp
 // 
 // This file is automatically generated by scripts/generate_metric_enums.py
 // Do not edit this file manually, your changes will be overwritten
@@ -12,80 +11,89 @@
 
 #include "duckdb/common/types/value.hpp"
 #include "duckdb/common/unordered_set.hpp"
-#include "duckdb/common/unordered_map.hpp"
 #include "duckdb/common/constants.hpp"
-#include "duckdb/common/enum_util.hpp"
 #include "duckdb/common/enums/optimizer_type.hpp"
 
 namespace duckdb {
 
+enum class MetricGroup : uint8_t {
+	ALL,
+	DEFAULT,
+	EXECUTION,
+	FILE,
+	OPERATOR,
+	OPTIMIZER,
+	PHASE_TIMING,
+	INVALID,
+};
+
 enum class MetricsType : uint8_t {
-    ATTACH_LOAD_STORAGE_LATENCY,
-    ATTACH_REPLAY_WAL_LATENCY,
-    BLOCKED_THREAD_TIME,
-    CHECKPOINT_LATENCY,
-    CPU_TIME,
-    CUMULATIVE_CARDINALITY,
-    CUMULATIVE_ROWS_SCANNED,
-    EXTRA_INFO,
-    LATENCY,
-    OPERATOR_CARDINALITY,
-    OPERATOR_NAME,
-    OPERATOR_ROWS_SCANNED,
-    OPERATOR_TIMING,
-    OPERATOR_TYPE,
-    QUERY_NAME,
-    RESULT_SET_SIZE,
-    ROWS_RETURNED,
-    SYSTEM_PEAK_BUFFER_MEMORY,
-    SYSTEM_PEAK_TEMP_DIR_SIZE,
-    TOTAL_BYTES_READ,
-    TOTAL_BYTES_WRITTEN,
-    WAITING_TO_ATTACH_LATENCY,
-    ALL_OPTIMIZERS,
-    CUMULATIVE_OPTIMIZER_TIMING,
-    PHYSICAL_PLANNER,
-    PHYSICAL_PLANNER_COLUMN_BINDING,
-    PHYSICAL_PLANNER_CREATE_PLAN,
-    PHYSICAL_PLANNER_RESOLVE_TYPES,
-    PLANNER,
-    PLANNER_BINDING,
-    OPTIMIZER_EXPRESSION_REWRITER,
-    OPTIMIZER_FILTER_PULLUP,
-    OPTIMIZER_FILTER_PUSHDOWN,
-    OPTIMIZER_EMPTY_RESULT_PULLUP,
-    OPTIMIZER_CTE_FILTER_PUSHER,
-    OPTIMIZER_REGEX_RANGE,
-    OPTIMIZER_IN_CLAUSE,
-    OPTIMIZER_JOIN_ORDER,
-    OPTIMIZER_DELIMINATOR,
-    OPTIMIZER_UNNEST_REWRITER,
-    OPTIMIZER_UNUSED_COLUMNS,
-    OPTIMIZER_STATISTICS_PROPAGATION,
-    OPTIMIZER_COMMON_SUBEXPRESSIONS,
-    OPTIMIZER_COMMON_AGGREGATE,
-    OPTIMIZER_COLUMN_LIFETIME,
-    OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
-    OPTIMIZER_LIMIT_PUSHDOWN,
-    OPTIMIZER_TOP_N,
-    OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
-    OPTIMIZER_COMPRESSED_MATERIALIZATION,
-    OPTIMIZER_DUPLICATE_GROUPS,
-    OPTIMIZER_REORDER_FILTER,
-    OPTIMIZER_SAMPLING_PUSHDOWN,
-    OPTIMIZER_JOIN_FILTER_PUSHDOWN,
-    OPTIMIZER_EXTENSION,
-    OPTIMIZER_MATERIALIZED_CTE,
-    OPTIMIZER_SUM_REWRITER,
-    OPTIMIZER_LATE_MATERIALIZATION,
-    OPTIMIZER_CTE_INLINING,
-    OPTIMIZER_COMMON_SUBPLAN,
+	ALL_OPTIMIZERS,
+	ATTACH_LOAD_STORAGE_LATENCY,
+	ATTACH_REPLAY_WAL_LATENCY,
+	BLOCKED_THREAD_TIME,
+	CHECKPOINT_LATENCY,
+	CPU_TIME,
+	CUMULATIVE_CARDINALITY,
+	CUMULATIVE_OPTIMIZER_TIMING,
+	CUMULATIVE_ROWS_SCANNED,
+	EXTRA_INFO,
+	LATENCY,
+	OPERATOR_CARDINALITY,
+	OPERATOR_NAME,
+	OPERATOR_ROWS_SCANNED,
+	OPERATOR_TIMING,
+	OPERATOR_TYPE,
+	OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
+	OPTIMIZER_COLUMN_LIFETIME,
+	OPTIMIZER_COMMON_AGGREGATE,
+	OPTIMIZER_COMMON_SUBEXPRESSIONS,
+	OPTIMIZER_COMMON_SUBPLAN,
+	OPTIMIZER_COMPRESSED_MATERIALIZATION,
+	OPTIMIZER_CTE_FILTER_PUSHER,
+	OPTIMIZER_CTE_INLINING,
+	OPTIMIZER_DELIMINATOR,
+	OPTIMIZER_DUPLICATE_GROUPS,
+	OPTIMIZER_EMPTY_RESULT_PULLUP,
+	OPTIMIZER_EXPRESSION_REWRITER,
+	OPTIMIZER_EXTENSION,
+	OPTIMIZER_FILTER_PULLUP,
+	OPTIMIZER_FILTER_PUSHDOWN,
+	OPTIMIZER_IN_CLAUSE,
+	OPTIMIZER_JOIN_FILTER_PUSHDOWN,
+	OPTIMIZER_JOIN_ORDER,
+	OPTIMIZER_LATE_MATERIALIZATION,
+	OPTIMIZER_LIMIT_PUSHDOWN,
+	OPTIMIZER_MATERIALIZED_CTE,
+	OPTIMIZER_REGEX_RANGE,
+	OPTIMIZER_REORDER_FILTER,
+	OPTIMIZER_SAMPLING_PUSHDOWN,
+	OPTIMIZER_STATISTICS_PROPAGATION,
+	OPTIMIZER_SUM_REWRITER,
+	OPTIMIZER_TOP_N,
+	OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
+	OPTIMIZER_UNNEST_REWRITER,
+	OPTIMIZER_UNUSED_COLUMNS,
+	PHYSICAL_PLANNER,
+	PHYSICAL_PLANNER_COLUMN_BINDING,
+	PHYSICAL_PLANNER_CREATE_PLAN,
+	PHYSICAL_PLANNER_RESOLVE_TYPES,
+	PLANNER,
+	PLANNER_BINDING,
+	QUERY_NAME,
+	RESULT_SET_SIZE,
+	ROWS_RETURNED,
+	SYSTEM_PEAK_BUFFER_MEMORY,
+	SYSTEM_PEAK_TEMP_DIR_SIZE,
+	TOTAL_BYTES_READ,
+	TOTAL_BYTES_WRITTEN,
+	WAITING_TO_ATTACH_LATENCY,
 };
 
 struct MetricsTypeHashFunction {
-	uint64_t operator()(const MetricsType &index) const {
-		return std::hash<uint8_t>()(static_cast<uint8_t>(index));
-	}
+    uint64_t operator()(const MetricsType &index) const {
+        return std::hash<uint8_t>()(static_cast<uint8_t>(index));
+    }
 };
 
 typedef unordered_set<MetricsType, MetricsTypeHashFunction> profiler_settings_t;
@@ -93,15 +101,39 @@ typedef unordered_map<MetricsType, Value, MetricsTypeHashFunction> profiler_metr
 
 class MetricsUtils {
 public:
-    static profiler_settings_t GetOptimizerMetrics();
-    static profiler_settings_t GetPhaseTimingMetrics();
 
-    static MetricsType GetOptimizerMetricByType(OptimizerType type);
-    static OptimizerType GetOptimizerTypeByMetric(MetricsType type);
+	// All metrics
+	static profiler_settings_t GetAllMetrics();
+	static profiler_settings_t GetMetricsByGroupType(MetricGroup type);
 
-    static bool IsOptimizerMetric(MetricsType type);
-    static bool IsPhaseTimingMetric(MetricsType type);
-    static bool IsQueryGlobalMetric(MetricsType type);
-};
+	// Default metrics
+	static profiler_settings_t GetDefaultMetrics();
+	static bool IsDefaultMetric(MetricsType type);
+
+	// Execution metrics
+	static profiler_settings_t GetExecutionMetrics();
+	static bool IsExecutionMetric(MetricsType type);
 
+	// File metrics
+	static profiler_settings_t GetFileMetrics();
+	static bool IsFileMetric(MetricsType type);
+
+	// Operator metrics
+	static profiler_settings_t GetOperatorMetrics();
+	static bool IsOperatorMetric(MetricsType type);
+
+	// Optimizer metrics
+	static profiler_settings_t GetOptimizerMetrics();
+	static bool IsOptimizerMetric(MetricsType type);
+	static MetricsType GetOptimizerMetricByType(OptimizerType type);
+	static OptimizerType GetOptimizerTypeByMetric(MetricsType type);
+
+	// PhaseTiming metrics
+	static profiler_settings_t GetPhaseTimingMetrics();
+	static bool IsPhaseTimingMetric(MetricsType type);
+
+	// RootScope metrics
+	static profiler_settings_t GetRootScopeMetrics();
+	static bool IsRootScopeMetric(MetricsType type);
+};
 } // namespace duckdb
diff --git a/src/include/duckdb/main/client_config.hpp b/src/include/duckdb/main/client_config.hpp
index 284e63ce95..2485ffdf49 100644
--- a/src/include/duckdb/main/client_config.hpp
+++ b/src/include/duckdb/main/client_config.hpp
@@ -40,7 +40,7 @@ struct ClientConfig {
 	string profiler_save_location;
 	//! The custom settings for the profiler
 	//! (empty = use the default settings)
-	profiler_settings_t profiler_settings = ProfilingInfo::DefaultSettings();
+	profiler_settings_t profiler_settings = MetricsUtils::GetDefaultMetrics();
 
 	//! Allows suppressing profiler output, even if enabled. We turn on the profiler on all test runs but don't want
 	//! to output anything
diff --git a/src/include/duckdb/main/profiling_info.hpp b/src/include/duckdb/main/profiling_info.hpp
index e54a13618f..71925b5e79 100644
--- a/src/include/duckdb/main/profiling_info.hpp
+++ b/src/include/duckdb/main/profiling_info.hpp
@@ -39,11 +39,6 @@ public:
 	ProfilingInfo(ProfilingInfo &) = default;
 	ProfilingInfo &operator=(ProfilingInfo const &) = default;
 
-public:
-	static profiler_settings_t DefaultSettings();
-	static profiler_settings_t RootScopeSettings();
-	static profiler_settings_t OperatorScopeSettings();
-
 public:
 	void ResetMetrics();
 	//! Returns true, if the query profiler must collect this metric.
diff --git a/src/include/duckdb/main/profiling_utils.hpp b/src/include/duckdb/main/profiling_utils.hpp
new file mode 100644
index 0000000000..41c3e50328
--- /dev/null
+++ b/src/include/duckdb/main/profiling_utils.hpp
@@ -0,0 +1,42 @@
+//-------------------------------------------------------------------------
+//                         DuckDB
+//
+// duckdb/main/profiling_utils.hpp
+// 
+// This file is automatically generated by scripts/generate_metric_enums.py
+// Do not edit this file manually, your changes will be overwritten
+//-------------------------------------------------------------------------
+
+#pragma once
+
+#include "duckdb/common/enums/metric_type.hpp"
+#include "duckdb/main/query_profiler.hpp"
+#include "duckdb/main/profiling_node.hpp"
+
+namespace duckdb_yyjson {
+struct yyjson_mut_doc;
+struct yyjson_mut_val;
+} // namespace duckdb_yyjson
+
+namespace duckdb {
+
+class ProfilingUtils {
+public:
+	static void SetMetricToDefault(profiler_metrics_t &metrics, const MetricsType &type);
+	static void MetricToJson(duckdb_yyjson::yyjson_mut_doc *doc, duckdb_yyjson::yyjson_mut_val *dest, const char *key_ptr,  profiler_metrics_t &metrics, const MetricsType &type);
+	static void CollectMetrics(const MetricsType &type, QueryMetrics &query_metrics, Value &metric, ProfilingNode &node, ProfilingInfo &child_info);
+
+private:
+	static string OperatorToString(const Value &val);
+
+	template <class METRIC_TYPE>
+	static void AggregateMetric(ProfilingNode &node, MetricsType aggregated_metric, MetricsType child_metric, const std::function<METRIC_TYPE(const METRIC_TYPE &, const METRIC_TYPE &)> &update_fun);
+
+	template <class METRIC_TYPE>
+	static void GetCumulativeMetric(ProfilingNode &node, MetricsType cumulative_metric, MetricsType child_metric);
+
+	static Value GetCumulativeOptimizers(ProfilingNode &node);
+
+};
+
+}
diff --git a/src/main/CMakeLists.txt b/src/main/CMakeLists.txt
index 3095587f47..dd68824b44 100644
--- a/src/main/CMakeLists.txt
+++ b/src/main/CMakeLists.txt
@@ -42,6 +42,7 @@ add_library_unity(
   prepared_statement.cpp
   prepared_statement_data.cpp
   profiling_info.cpp
+  profiling_utils.cpp
   relation.cpp
   query_profiler.cpp
   query_result.cpp
diff --git a/src/main/profiling_info.cpp b/src/main/profiling_info.cpp
index 6e60b9d25b..7aa2b54866 100644
--- a/src/main/profiling_info.cpp
+++ b/src/main/profiling_info.cpp
@@ -1,7 +1,7 @@
 #include "duckdb/main/profiling_info.hpp"
 
 #include "duckdb/common/enum_util.hpp"
-#include "duckdb/main/query_profiler.hpp"
+#include "duckdb/main/profiling_utils.hpp"
 
 #include "yyjson.hpp"
 
@@ -23,12 +23,12 @@ ProfilingInfo::ProfilingInfo(const profiler_settings_t &n_settings, const idx_t
 
 	// Reduce.
 	if (depth == 0) {
-		auto op_metrics = OperatorScopeSettings();
+		auto op_metrics = MetricsUtils::GetOperatorMetrics();
 		for (const auto metric : op_metrics) {
 			settings.erase(metric);
 		}
 	} else {
-		auto root_metrics = RootScopeSettings();
+		auto root_metrics = MetricsUtils::GetRootScopeMetrics();
 		for (const auto metric : root_metrics) {
 			settings.erase(metric);
 		}
@@ -36,49 +36,6 @@ ProfilingInfo::ProfilingInfo(const profiler_settings_t &n_settings, const idx_t
 	ResetMetrics();
 }
 
-profiler_settings_t ProfilingInfo::DefaultSettings() {
-	return {MetricsType::ATTACH_LOAD_STORAGE_LATENCY,
-	        MetricsType::ATTACH_REPLAY_WAL_LATENCY,
-	        MetricsType::BLOCKED_THREAD_TIME,
-	        MetricsType::CHECKPOINT_LATENCY,
-	        MetricsType::CPU_TIME,
-	        MetricsType::CUMULATIVE_CARDINALITY,
-	        MetricsType::CUMULATIVE_ROWS_SCANNED,
-	        MetricsType::EXTRA_INFO,
-	        MetricsType::LATENCY,
-	        MetricsType::OPERATOR_CARDINALITY,
-	        MetricsType::OPERATOR_NAME,
-	        MetricsType::OPERATOR_ROWS_SCANNED,
-	        MetricsType::OPERATOR_TIMING,
-	        MetricsType::OPERATOR_TYPE,
-	        MetricsType::RESULT_SET_SIZE,
-	        MetricsType::ROWS_RETURNED,
-	        MetricsType::SYSTEM_PEAK_BUFFER_MEMORY,
-	        MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE,
-	        MetricsType::TOTAL_BYTES_READ,
-	        MetricsType::TOTAL_BYTES_WRITTEN,
-	        MetricsType::WAITING_TO_ATTACH_LATENCY,
-	        MetricsType::QUERY_NAME};
-}
-
-profiler_settings_t ProfilingInfo::RootScopeSettings() {
-	return {MetricsType::ATTACH_LOAD_STORAGE_LATENCY,
-	        MetricsType::ATTACH_REPLAY_WAL_LATENCY,
-	        MetricsType::BLOCKED_THREAD_TIME,
-	        MetricsType::CHECKPOINT_LATENCY,
-	        MetricsType::LATENCY,
-	        MetricsType::ROWS_RETURNED,
-	        MetricsType::TOTAL_BYTES_READ,
-	        MetricsType::TOTAL_BYTES_WRITTEN,
-	        MetricsType::WAITING_TO_ATTACH_LATENCY,
-	        MetricsType::QUERY_NAME};
-}
-
-profiler_settings_t ProfilingInfo::OperatorScopeSettings() {
-	return {MetricsType::OPERATOR_CARDINALITY, MetricsType::OPERATOR_ROWS_SCANNED, MetricsType::OPERATOR_TIMING,
-	        MetricsType::OPERATOR_NAME, MetricsType::OPERATOR_TYPE};
-}
-
 void ProfilingInfo::ResetMetrics() {
 	metrics.clear();
 	for (auto &metric : expanded_settings) {
@@ -87,44 +44,7 @@ void ProfilingInfo::ResetMetrics() {
 			continue;
 		}
 
-		switch (metric) {
-		case MetricsType::QUERY_NAME:
-			metrics[metric] = Value::CreateValue("");
-			break;
-		case MetricsType::LATENCY:
-		case MetricsType::BLOCKED_THREAD_TIME:
-		case MetricsType::CPU_TIME:
-		case MetricsType::OPERATOR_TIMING:
-		case MetricsType::WAITING_TO_ATTACH_LATENCY:
-		case MetricsType::ATTACH_LOAD_STORAGE_LATENCY:
-		case MetricsType::ATTACH_REPLAY_WAL_LATENCY:
-		case MetricsType::CHECKPOINT_LATENCY:
-			metrics[metric] = Value::CreateValue(0.0);
-			break;
-		case MetricsType::OPERATOR_NAME:
-			metrics[metric] = Value::CreateValue("");
-			break;
-		case MetricsType::OPERATOR_TYPE:
-			metrics[metric] = Value::CreateValue<uint8_t>(0);
-			break;
-		case MetricsType::ROWS_RETURNED:
-		case MetricsType::RESULT_SET_SIZE:
-		case MetricsType::CUMULATIVE_CARDINALITY:
-		case MetricsType::OPERATOR_CARDINALITY:
-		case MetricsType::CUMULATIVE_ROWS_SCANNED:
-		case MetricsType::OPERATOR_ROWS_SCANNED:
-		case MetricsType::SYSTEM_PEAK_BUFFER_MEMORY:
-		case MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE:
-		case MetricsType::TOTAL_BYTES_READ:
-		case MetricsType::TOTAL_BYTES_WRITTEN:
-			metrics[metric] = Value::CreateValue<uint64_t>(0);
-			break;
-		case MetricsType::EXTRA_INFO:
-			metrics[metric] = Value::MAP(InsertionOrderPreservingMap<string>());
-			break;
-		default:
-			throw InternalException("MetricsType" + EnumUtil::ToString(metric) + "not implemented");
-		}
+		ProfilingUtils::SetMetricToDefault(metrics, metric);
 	}
 }
 
@@ -217,42 +137,7 @@ void ProfilingInfo::WriteMetricsToJSON(yyjson_mut_doc *doc, yyjson_mut_val *dest
 			continue;
 		}
 
-		switch (metric) {
-		case MetricsType::QUERY_NAME:
-		case MetricsType::OPERATOR_NAME:
-			yyjson_mut_obj_add_strcpy(doc, dest, key_ptr, metrics[metric].GetValue<string>().c_str());
-			break;
-		case MetricsType::LATENCY:
-		case MetricsType::BLOCKED_THREAD_TIME:
-		case MetricsType::CPU_TIME:
-		case MetricsType::OPERATOR_TIMING:
-		case MetricsType::WAITING_TO_ATTACH_LATENCY:
-		case MetricsType::ATTACH_LOAD_STORAGE_LATENCY:
-		case MetricsType::ATTACH_REPLAY_WAL_LATENCY:
-		case MetricsType::CHECKPOINT_LATENCY: {
-			yyjson_mut_obj_add_real(doc, dest, key_ptr, metrics[metric].GetValue<double>());
-			break;
-		}
-		case MetricsType::OPERATOR_TYPE: {
-			yyjson_mut_obj_add_strcpy(doc, dest, key_ptr, GetMetricAsString(metric).c_str());
-			break;
-		}
-		case MetricsType::ROWS_RETURNED:
-		case MetricsType::RESULT_SET_SIZE:
-		case MetricsType::CUMULATIVE_CARDINALITY:
-		case MetricsType::OPERATOR_CARDINALITY:
-		case MetricsType::CUMULATIVE_ROWS_SCANNED:
-		case MetricsType::OPERATOR_ROWS_SCANNED:
-		case MetricsType::SYSTEM_PEAK_BUFFER_MEMORY:
-		case MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE:
-		case MetricsType::TOTAL_BYTES_READ:
-		case MetricsType::TOTAL_BYTES_WRITTEN: {
-			yyjson_mut_obj_add_uint(doc, dest, key_ptr, metrics[metric].GetValue<uint64_t>());
-			break;
-		}
-		default:
-			throw NotImplementedException("MetricsType %s not implemented", EnumUtil::ToString(metric));
-		}
+		ProfilingUtils::MetricToJson(doc, dest, key_ptr, metrics, metric);
 	}
 }
 
diff --git a/src/main/profiling_utils.cpp b/src/main/profiling_utils.cpp
new file mode 100644
index 0000000000..b414a6b040
--- /dev/null
+++ b/src/main/profiling_utils.cpp
@@ -0,0 +1,192 @@
+// This file is automatically generated by scripts/generate_metric_enums.py
+// Do not edit this file manually, your changes will be overwritten
+
+#include "duckdb/main/profiling_utils.hpp"
+#include "duckdb/common/enum_util.hpp"
+#include "duckdb/main/profiling_node.hpp"
+#include "duckdb/main/query_profiler.hpp"
+
+#include "yyjson.hpp"
+
+using namespace duckdb_yyjson; // NOLINT
+
+namespace duckdb {
+
+string ProfilingUtils::OperatorToString(const Value &val) {
+    const auto type = static_cast<PhysicalOperatorType>(val.GetValue<uint8_t>());
+    return EnumUtil::ToString(type);
+}
+
+template <class METRIC_TYPE>
+void ProfilingUtils::AggregateMetric(ProfilingNode &node, MetricsType aggregated_metric, MetricsType child_metric, const std::function<METRIC_TYPE(const METRIC_TYPE &, const METRIC_TYPE &)> &update_fun) {
+	auto &info = node.GetProfilingInfo();
+	info.metrics[aggregated_metric] = info.metrics[child_metric];
+
+	for (idx_t i = 0; i < node.GetChildCount(); i++) {
+		auto child = node.GetChild(i);
+		AggregateMetric<METRIC_TYPE>(*child, aggregated_metric, child_metric, update_fun);
+
+		auto &child_info = child->GetProfilingInfo();
+		auto value = child_info.GetMetricValue<METRIC_TYPE>(aggregated_metric);
+		info.MetricUpdate<METRIC_TYPE>(aggregated_metric, value, update_fun);
+	}
+}
+
+template <class METRIC_TYPE>
+void ProfilingUtils::GetCumulativeMetric(ProfilingNode &node, MetricsType cumulative_metric, MetricsType child_metric) {
+	AggregateMetric<METRIC_TYPE>(
+	    node, cumulative_metric, child_metric,
+	    [](const METRIC_TYPE &old_value, const METRIC_TYPE &new_value) { return old_value + new_value; });
+}
+
+Value ProfilingUtils::GetCumulativeOptimizers(ProfilingNode &node) {
+	auto &metrics = node.GetProfilingInfo().metrics;
+	double count = 0;
+	for (auto &metric : metrics) {
+		if (MetricsUtils::IsOptimizerMetric(metric.first)) {
+			count += metric.second.GetValue<double>();
+		}
+	}
+	return Value::CreateValue(count);
+}
+
+void ProfilingUtils::SetMetricToDefault(profiler_metrics_t &metrics, const MetricsType &type) {
+	switch(type) {
+		case MetricsType::ALL_OPTIMIZERS:
+		case MetricsType::ATTACH_LOAD_STORAGE_LATENCY:
+		case MetricsType::ATTACH_REPLAY_WAL_LATENCY:
+		case MetricsType::BLOCKED_THREAD_TIME:
+		case MetricsType::CHECKPOINT_LATENCY:
+		case MetricsType::CPU_TIME:
+		case MetricsType::CUMULATIVE_OPTIMIZER_TIMING:
+		case MetricsType::LATENCY:
+		case MetricsType::OPERATOR_TIMING:
+		case MetricsType::PHYSICAL_PLANNER:
+		case MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING:
+		case MetricsType::PHYSICAL_PLANNER_CREATE_PLAN:
+		case MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES:
+		case MetricsType::PLANNER:
+		case MetricsType::PLANNER_BINDING:
+		case MetricsType::WAITING_TO_ATTACH_LATENCY:
+			metrics[type] = Value::CreateValue(0.0);
+			break;
+		case MetricsType::CUMULATIVE_CARDINALITY:
+		case MetricsType::CUMULATIVE_ROWS_SCANNED:
+		case MetricsType::OPERATOR_CARDINALITY:
+		case MetricsType::OPERATOR_ROWS_SCANNED:
+		case MetricsType::RESULT_SET_SIZE:
+		case MetricsType::ROWS_RETURNED:
+		case MetricsType::SYSTEM_PEAK_BUFFER_MEMORY:
+		case MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE:
+		case MetricsType::TOTAL_BYTES_READ:
+		case MetricsType::TOTAL_BYTES_WRITTEN:
+			metrics[type] = Value::CreateValue<uint64_t>(0);
+			break;
+		case MetricsType::EXTRA_INFO:
+			metrics[type] = Value::MAP(InsertionOrderPreservingMap<string>());
+			break;
+		case MetricsType::OPERATOR_NAME:
+		case MetricsType::QUERY_NAME:
+			metrics[type] = Value::CreateValue("");
+			break;
+		case MetricsType::OPERATOR_TYPE:
+			metrics[type] = Value::CreateValue<uint8_t>(0);
+			break;
+		default:
+			throw InternalException("Unknown metric type %s", EnumUtil::ToString(type));
+	}
+}
+
+void ProfilingUtils::MetricToJson(duckdb_yyjson::yyjson_mut_doc *doc, duckdb_yyjson::yyjson_mut_val *dest, const char *key_ptr,  profiler_metrics_t &metrics, const MetricsType &type) {
+	switch(type) {
+		case MetricsType::ALL_OPTIMIZERS:
+		case MetricsType::ATTACH_LOAD_STORAGE_LATENCY:
+		case MetricsType::ATTACH_REPLAY_WAL_LATENCY:
+		case MetricsType::BLOCKED_THREAD_TIME:
+		case MetricsType::CHECKPOINT_LATENCY:
+		case MetricsType::CPU_TIME:
+		case MetricsType::CUMULATIVE_OPTIMIZER_TIMING:
+		case MetricsType::LATENCY:
+		case MetricsType::OPERATOR_TIMING:
+		case MetricsType::PHYSICAL_PLANNER:
+		case MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING:
+		case MetricsType::PHYSICAL_PLANNER_CREATE_PLAN:
+		case MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES:
+		case MetricsType::PLANNER:
+		case MetricsType::PLANNER_BINDING:
+		case MetricsType::WAITING_TO_ATTACH_LATENCY:
+			yyjson_mut_obj_add_real(doc, dest, key_ptr, metrics[type].GetValue<double>());
+			break;
+		case MetricsType::CUMULATIVE_CARDINALITY:
+		case MetricsType::CUMULATIVE_ROWS_SCANNED:
+		case MetricsType::OPERATOR_CARDINALITY:
+		case MetricsType::OPERATOR_ROWS_SCANNED:
+		case MetricsType::RESULT_SET_SIZE:
+		case MetricsType::ROWS_RETURNED:
+		case MetricsType::SYSTEM_PEAK_BUFFER_MEMORY:
+		case MetricsType::SYSTEM_PEAK_TEMP_DIR_SIZE:
+		case MetricsType::TOTAL_BYTES_READ:
+		case MetricsType::TOTAL_BYTES_WRITTEN:
+			yyjson_mut_obj_add_uint(doc, dest, key_ptr, metrics[type].GetValue<uint64_t>());
+			break;
+		case MetricsType::EXTRA_INFO:
+			break;
+		case MetricsType::OPERATOR_NAME:
+		case MetricsType::QUERY_NAME:
+			yyjson_mut_obj_add_strcpy(doc, dest, key_ptr, metrics[type].GetValue<string>().c_str());
+			break;
+		case MetricsType::OPERATOR_TYPE:
+			yyjson_mut_obj_add_strcpy(doc, dest, key_ptr, OperatorToString(metrics[type]).c_str());
+			break;
+		default:
+			throw InternalException("Unknown metric type %s", EnumUtil::ToString(type));
+	}
+}
+
+void ProfilingUtils::CollectMetrics(const MetricsType &type, QueryMetrics &query_metrics, Value &metric, ProfilingNode &node, ProfilingInfo &child_info) {
+	switch(type) {
+		case MetricsType::CPU_TIME:
+			GetCumulativeMetric<double>(node, MetricsType::CPU_TIME, MetricsType::OPERATOR_TIMING);
+			break;
+		case MetricsType::CUMULATIVE_CARDINALITY:
+			GetCumulativeMetric<uint64_t>(node, MetricsType::CUMULATIVE_CARDINALITY, MetricsType::OPERATOR_CARDINALITY);
+			break;
+		case MetricsType::CUMULATIVE_ROWS_SCANNED:
+			GetCumulativeMetric<uint64_t>(node, MetricsType::CUMULATIVE_ROWS_SCANNED, MetricsType::OPERATOR_ROWS_SCANNED);
+			break;
+		case MetricsType::ATTACH_LOAD_STORAGE_LATENCY:
+			metric = query_metrics.attach_load_storage_latency.Elapsed();
+			break;
+		case MetricsType::ATTACH_REPLAY_WAL_LATENCY:
+			metric = query_metrics.attach_replay_wal_latency.Elapsed();
+			break;
+		case MetricsType::CHECKPOINT_LATENCY:
+			metric = query_metrics.checkpoint_latency.Elapsed();
+			break;
+		case MetricsType::LATENCY:
+			metric = query_metrics.latency.Elapsed();
+			break;
+		case MetricsType::WAITING_TO_ATTACH_LATENCY:
+			metric = query_metrics.waiting_to_attach_latency.Elapsed();
+			break;
+		case MetricsType::RESULT_SET_SIZE:
+			metric = child_info.metrics[MetricsType::RESULT_SET_SIZE];
+			break;
+		case MetricsType::ROWS_RETURNED:
+			metric = child_info.metrics[MetricsType::OPERATOR_CARDINALITY];
+			break;
+		case MetricsType::TOTAL_BYTES_READ:
+			metric = Value::UBIGINT(query_metrics.total_bytes_read);
+			break;
+		case MetricsType::TOTAL_BYTES_WRITTEN:
+			metric = Value::UBIGINT(query_metrics.total_bytes_written);
+			break;
+		case MetricsType::CUMULATIVE_OPTIMIZER_TIMING:
+			metric = GetCumulativeOptimizers(node);
+			break;
+		default:
+			return;
+	}
+}
+
+}
diff --git a/src/main/query_profiler.cpp b/src/main/query_profiler.cpp
index b4f15a8e68..2c7df10396 100644
--- a/src/main/query_profiler.cpp
+++ b/src/main/query_profiler.cpp
@@ -13,6 +13,7 @@
 #include "duckdb/main/client_config.hpp"
 #include "duckdb/main/client_context.hpp"
 #include "duckdb/main/client_data.hpp"
+#include "duckdb/main/profiling_utils.hpp"
 #include "duckdb/planner/expression/bound_function_expression.hpp"
 #include "duckdb/storage/buffer/buffer_pool.hpp"
 #include "yyjson.hpp"
@@ -191,40 +192,6 @@ void QueryProfiler::StartExplainAnalyze() {
 	is_explain_analyze = true;
 }
 
-template <class METRIC_TYPE>
-static void AggregateMetric(ProfilingNode &node, MetricsType aggregated_metric, MetricsType child_metric,
-                            const std::function<METRIC_TYPE(const METRIC_TYPE &, const METRIC_TYPE &)> &update_fun) {
-	auto &info = node.GetProfilingInfo();
-	info.metrics[aggregated_metric] = info.metrics[child_metric];
-
-	for (idx_t i = 0; i < node.GetChildCount(); i++) {
-		auto child = node.GetChild(i);
-		AggregateMetric<METRIC_TYPE>(*child, aggregated_metric, child_metric, update_fun);
-
-		auto &child_info = child->GetProfilingInfo();
-		auto value = child_info.GetMetricValue<METRIC_TYPE>(aggregated_metric);
-		info.MetricUpdate<METRIC_TYPE>(aggregated_metric, value, update_fun);
-	}
-}
-
-template <class METRIC_TYPE>
-static void GetCumulativeMetric(ProfilingNode &node, MetricsType cumulative_metric, MetricsType child_metric) {
-	AggregateMetric<METRIC_TYPE>(
-	    node, cumulative_metric, child_metric,
-	    [](const METRIC_TYPE &old_value, const METRIC_TYPE &new_value) { return old_value + new_value; });
-}
-
-Value GetCumulativeOptimizers(ProfilingNode &node) {
-	auto &metrics = node.GetProfilingInfo().metrics;
-	double count = 0;
-	for (auto &metric : metrics) {
-		if (MetricsUtils::IsOptimizerMetric(metric.first)) {
-			count += metric.second.GetValue<double>();
-		}
-	}
-	return Value::CreateValue(count);
-}
-
 void QueryProfiler::EndQuery() {
 	unique_lock<std::mutex> guard(lock);
 	if (!IsEnabled() || !running) {
@@ -250,55 +217,16 @@ void QueryProfiler::EndQuery() {
 			auto &child_info = root->children[0]->GetProfilingInfo();
 			info.metrics[MetricsType::QUERY_NAME] = query_metrics.query;
 
-			auto &settings = info.expanded_settings;
+			const auto &settings = info.expanded_settings;
 			for (const auto &global_info_entry : query_metrics.query_global_info.metrics) {
 				info.metrics[global_info_entry.first] = global_info_entry.second;
 			}
-			if (info.Enabled(settings, MetricsType::LATENCY)) {
-				info.metrics[MetricsType::LATENCY] = query_metrics.latency.Elapsed();
-			}
-			if (info.Enabled(settings, MetricsType::TOTAL_BYTES_READ)) {
-				info.metrics[MetricsType::TOTAL_BYTES_READ] = Value::UBIGINT(query_metrics.total_bytes_read);
-			}
-			if (info.Enabled(settings, MetricsType::TOTAL_BYTES_WRITTEN)) {
-				info.metrics[MetricsType::TOTAL_BYTES_WRITTEN] = Value::UBIGINT(query_metrics.total_bytes_written);
-			}
-			if (info.Enabled(settings, MetricsType::ROWS_RETURNED)) {
-				info.metrics[MetricsType::ROWS_RETURNED] = child_info.metrics[MetricsType::OPERATOR_CARDINALITY];
-			}
-			if (info.Enabled(settings, MetricsType::CPU_TIME)) {
-				GetCumulativeMetric<double>(*root, MetricsType::CPU_TIME, MetricsType::OPERATOR_TIMING);
-			}
-			if (info.Enabled(settings, MetricsType::CUMULATIVE_CARDINALITY)) {
-				GetCumulativeMetric<idx_t>(*root, MetricsType::CUMULATIVE_CARDINALITY,
-				                           MetricsType::OPERATOR_CARDINALITY);
-			}
-			if (info.Enabled(settings, MetricsType::CUMULATIVE_ROWS_SCANNED)) {
-				GetCumulativeMetric<idx_t>(*root, MetricsType::CUMULATIVE_ROWS_SCANNED,
-				                           MetricsType::OPERATOR_ROWS_SCANNED);
-			}
-			if (info.Enabled(settings, MetricsType::RESULT_SET_SIZE)) {
-				info.metrics[MetricsType::RESULT_SET_SIZE] = child_info.metrics[MetricsType::RESULT_SET_SIZE];
-			}
-			if (info.Enabled(settings, MetricsType::WAITING_TO_ATTACH_LATENCY)) {
-				info.metrics[MetricsType::WAITING_TO_ATTACH_LATENCY] =
-				    query_metrics.waiting_to_attach_latency.Elapsed();
-			}
-			if (info.Enabled(settings, MetricsType::ATTACH_LOAD_STORAGE_LATENCY)) {
-				info.metrics[MetricsType::ATTACH_LOAD_STORAGE_LATENCY] =
-				    query_metrics.attach_load_storage_latency.Elapsed();
-			}
-			if (info.Enabled(settings, MetricsType::ATTACH_REPLAY_WAL_LATENCY)) {
-				info.metrics[MetricsType::ATTACH_REPLAY_WAL_LATENCY] =
-				    query_metrics.attach_replay_wal_latency.Elapsed();
-			}
-			if (info.Enabled(settings, MetricsType::CHECKPOINT_LATENCY)) {
-				info.metrics[MetricsType::CHECKPOINT_LATENCY] = query_metrics.checkpoint_latency.Elapsed();
-			}
 
 			MoveOptimizerPhasesToRoot();
-			if (info.Enabled(settings, MetricsType::CUMULATIVE_OPTIMIZER_TIMING)) {
-				info.metrics.at(MetricsType::CUMULATIVE_OPTIMIZER_TIMING) = GetCumulativeOptimizers(*root);
+			for (auto &metric : info.metrics) {
+				if (info.Enabled(settings, metric.first)) {
+					ProfilingUtils::CollectMetrics(metric.first, query_metrics, metric.second, *root, child_info);
+				}
 			}
 		}
 
@@ -464,7 +392,7 @@ OperatorProfiler::OperatorProfiler(ClientContext &context) : context(context) {
 	}
 
 	// Reduce.
-	auto root_metrics = ProfilingInfo::RootScopeSettings();
+	auto root_metrics = MetricsUtils::GetRootScopeMetrics();
 	for (const auto metric : root_metrics) {
 		settings.erase(metric);
 	}
@@ -909,7 +837,7 @@ profiler_settings_t EraseQueryRootSettings(profiler_settings_t settings) {
 
 	for (auto &setting : settings) {
 		if (MetricsUtils::IsOptimizerMetric(setting) || MetricsUtils::IsPhaseTimingMetric(setting) ||
-		    MetricsUtils::IsQueryGlobalMetric(setting)) {
+		    MetricsUtils::IsRootScopeMetric(setting)) {
 			phase_timing_settings_to_erase.insert(setting);
 		}
 	}
diff --git a/src/main/settings/custom_settings.cpp b/src/main/settings/custom_settings.cpp
index 0f83968b5f..ad1a031209 100644
--- a/src/main/settings/custom_settings.cpp
+++ b/src/main/settings/custom_settings.cpp
@@ -336,22 +336,39 @@ bool IsEnabledOptimizer(MetricsType metric, const set<OptimizerType> &disabled_o
 	return false;
 }
 
-static profiler_settings_t FillTreeNodeSettings(unordered_map<string, string> &json,
+static profiler_settings_t FillTreeNodeSettings(unordered_map<string, string> &input,
                                                 const set<OptimizerType> &disabled_optimizers) {
 	profiler_settings_t metrics;
 
 	string invalid_settings;
-	for (auto &entry : json) {
+	for (auto &entry : input) {
 		MetricsType setting;
+		MetricGroup group = MetricGroup::INVALID;
 		try {
 			setting = EnumUtil::FromString<MetricsType>(StringUtil::Upper(entry.first));
 		} catch (std::exception &ex) {
-			if (!invalid_settings.empty()) {
-				invalid_settings += ", ";
+			try {
+				group = EnumUtil::FromString<MetricGroup>(StringUtil::Upper(entry.first));
+			} catch (std::exception &ex) {
+				if (!invalid_settings.empty()) {
+					invalid_settings += ", ";
+				}
+				invalid_settings += entry.first;
+				continue;
+			}
+		}
+		if (group != MetricGroup::INVALID) {
+			if (entry.second == "true") {
+				auto group_metrics = MetricsUtils::GetMetricsByGroupType(group);
+				for (auto &metric : group_metrics) {
+					if (!MetricsUtils::IsOptimizerMetric(metric) || IsEnabledOptimizer(metric, disabled_optimizers)) {
+						metrics.insert(metric);
+					}
+				}
 			}
-			invalid_settings += entry.first;
 			continue;
 		}
+
 		if (StringUtil::Lower(entry.second) == "true" &&
 		    (!MetricsUtils::IsOptimizerMetric(setting) || IsEnabledOptimizer(setting, disabled_optimizers))) {
 			metrics.insert(setting);
@@ -379,9 +396,9 @@ void CustomProfilingSettingsSetting::SetLocal(ClientContext &context, const Valu
 	auto &config = ClientConfig::GetConfig(context);
 
 	// parse the file content
-	unordered_map<string, string> json;
+	unordered_map<string, string> input_json;
 	try {
-		json = StringUtil::ParseJSONMap(input.ToString())->Flatten();
+		input_json = StringUtil::ParseJSONMap(input.ToString())->Flatten();
 	} catch (std::exception &ex) {
 		throw IOException("Could not parse the custom profiler settings file due to incorrect JSON: \"%s\".  Make sure "
 		                  "all the keys and values start with a quote. ",
@@ -392,7 +409,7 @@ void CustomProfilingSettingsSetting::SetLocal(ClientContext &context, const Valu
 	auto &db_config = DBConfig::GetConfig(context);
 	auto &disabled_optimizers = db_config.options.disabled_optimizers;
 
-	auto settings = FillTreeNodeSettings(json, disabled_optimizers);
+	auto settings = FillTreeNodeSettings(input_json, disabled_optimizers);
 	AddOptimizerMetrics(settings, disabled_optimizers);
 	config.profiler_settings = settings;
 }
@@ -400,7 +417,7 @@ void CustomProfilingSettingsSetting::SetLocal(ClientContext &context, const Valu
 void CustomProfilingSettingsSetting::ResetLocal(ClientContext &context) {
 	auto &config = ClientConfig::GetConfig(context);
 	config.enable_profiler = ClientConfig().enable_profiler;
-	config.profiler_settings = ProfilingInfo::DefaultSettings();
+	config.profiler_settings = MetricsUtils::GetDefaultMetrics();
 }
 
 Value CustomProfilingSettingsSetting::GetSetting(const ClientContext &context) {
@@ -1268,6 +1285,12 @@ void ProfilingModeSetting::SetLocal(ClientContext &context, const Value &input)
 		for (auto &setting : phase_timing_settings) {
 			config.profiler_settings.insert(setting);
 		}
+	} else if (parameter == "all") {
+		config.enable_profiler = true;
+		auto all_metrics = MetricsUtils::GetAllMetrics();
+		for (auto &metric : all_metrics) {
+			config.profiler_settings.insert(metric);
+		}
 	} else {
 		throw ParserException("Unrecognized profiling mode \"%s\", supported formats: [standard, detailed]", parameter);
 	}
diff --git a/test/sql/pragma/profiling/test_all_profiling_settings.test b/test/sql/pragma/profiling/test_all_profiling_settings.test
new file mode 100644
index 0000000000..22697c9082
--- /dev/null
+++ b/test/sql/pragma/profiling/test_all_profiling_settings.test
@@ -0,0 +1,98 @@
+# name: test/sql/pragma/profiling/test_all_profiling_settings.test
+# description: Test all settings profiling settings.
+# group: [profiling]
+
+# This file is automatically generated by scripts/generate_metric_enums.py
+# Do not edit this file manually, your changes will be overwritten
+
+require json
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SET profiling_mode='all';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"ALL_OPTIMIZERS": "true"
+"ATTACH_LOAD_STORAGE_LATENCY": "true"
+"ATTACH_REPLAY_WAL_LATENCY": "true"
+"BLOCKED_THREAD_TIME": "true"
+"CHECKPOINT_LATENCY": "true"
+"CPU_TIME": "true"
+"CUMULATIVE_CARDINALITY": "true"
+"CUMULATIVE_OPTIMIZER_TIMING": "true"
+"CUMULATIVE_ROWS_SCANNED": "true"
+"EXTRA_INFO": "true"
+"LATENCY": "true"
+"OPERATOR_CARDINALITY": "true"
+"OPERATOR_NAME": "true"
+"OPERATOR_ROWS_SCANNED": "true"
+"OPERATOR_TIMING": "true"
+"OPERATOR_TYPE": "true"
+"OPTIMIZER_BUILD_SIDE_PROBE_SIDE": "true"
+"OPTIMIZER_COLUMN_LIFETIME": "true"
+"OPTIMIZER_COMMON_AGGREGATE": "true"
+"OPTIMIZER_COMMON_SUBEXPRESSIONS": "true"
+"OPTIMIZER_COMMON_SUBPLAN": "true"
+"OPTIMIZER_COMPRESSED_MATERIALIZATION": "true"
+"OPTIMIZER_CTE_FILTER_PUSHER": "true"
+"OPTIMIZER_CTE_INLINING": "true"
+"OPTIMIZER_DELIMINATOR": "true"
+"OPTIMIZER_DUPLICATE_GROUPS": "true"
+"OPTIMIZER_EMPTY_RESULT_PULLUP": "true"
+"OPTIMIZER_EXPRESSION_REWRITER": "true"
+"OPTIMIZER_EXTENSION": "true"
+"OPTIMIZER_FILTER_PULLUP": "true"
+"OPTIMIZER_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_IN_CLAUSE": "true"
+"OPTIMIZER_JOIN_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_JOIN_ORDER": "true"
+"OPTIMIZER_LATE_MATERIALIZATION": "true"
+"OPTIMIZER_LIMIT_PUSHDOWN": "true"
+"OPTIMIZER_MATERIALIZED_CTE": "true"
+"OPTIMIZER_REGEX_RANGE": "true"
+"OPTIMIZER_REORDER_FILTER": "true"
+"OPTIMIZER_SAMPLING_PUSHDOWN": "true"
+"OPTIMIZER_STATISTICS_PROPAGATION": "true"
+"OPTIMIZER_SUM_REWRITER": "true"
+"OPTIMIZER_TOP_N": "true"
+"OPTIMIZER_TOP_N_WINDOW_ELIMINATION": "true"
+"OPTIMIZER_UNNEST_REWRITER": "true"
+"OPTIMIZER_UNUSED_COLUMNS": "true"
+"PHYSICAL_PLANNER": "true"
+"PHYSICAL_PLANNER_COLUMN_BINDING": "true"
+"PHYSICAL_PLANNER_CREATE_PLAN": "true"
+"PHYSICAL_PLANNER_RESOLVE_TYPES": "true"
+"PLANNER": "true"
+"PLANNER_BINDING": "true"
+"QUERY_NAME": "true"
+"RESULT_SET_SIZE": "true"
+"ROWS_RETURNED": "true"
+"SYSTEM_PEAK_BUFFER_MEMORY": "true"
+"SYSTEM_PEAK_TEMP_DIR_SIZE": "true"
+"TOTAL_BYTES_READ": "true"
+"TOTAL_BYTES_WRITTEN": "true"
+"WAITING_TO_ATTACH_LATENCY": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT cpu_time, extra_info, rows_returned, latency FROM metrics_output;
+
diff --git a/test/sql/pragma/profiling/test_custom_profiling_memory_and_temp_dir.test_slow b/test/sql/pragma/profiling/test_custom_profiling_memory_and_temp_dir.test_slow
index 3d786b26c1..862c277560 100644
--- a/test/sql/pragma/profiling/test_custom_profiling_memory_and_temp_dir.test_slow
+++ b/test/sql/pragma/profiling/test_custom_profiling_memory_and_temp_dir.test_slow
@@ -10,6 +10,9 @@ PRAGMA enable_verification;
 statement ok
 PRAGMA enable_profiling = 'json';
 
+statement ok
+PRAGMA custom_profiling_settings='{"SYSTEM_PEAK_BUFFER_MEMORY": "true", "SYSTEM_PEAK_TEMP_DIR_SIZE": "true"}';
+
 statement ok
 PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
 
diff --git a/test/sql/pragma/profiling/test_custom_profiling_optimizer.test b/test/sql/pragma/profiling/test_custom_profiling_optimizer_settings.test
similarity index 90%
rename from test/sql/pragma/profiling/test_custom_profiling_optimizer.test
rename to test/sql/pragma/profiling/test_custom_profiling_optimizer_settings.test
index bbf753c222..7f50cb3807 100644
--- a/test/sql/pragma/profiling/test_custom_profiling_optimizer.test
+++ b/test/sql/pragma/profiling/test_custom_profiling_optimizer_settings.test
@@ -1,4 +1,4 @@
-# name: test/sql/pragma/profiling/test_custom_profiling_optimizer.test
+# name: test/sql/pragma/profiling/test_custom_profiling_optimizer_settings.test
 # description: Test custom optimizer profiling settings.
 # group: [profiling]
 
@@ -7,15 +7,15 @@
 
 require json
 
-statement ok
-PRAGMA enable_verification;
-
 statement ok
 PRAGMA enable_profiling = 'json';
 
 statement ok
 PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
 
+statement ok
+SET profiling_mode='standard';
+
 statement ok
 PRAGMA custom_profiling_settings='{"ALL_OPTIMIZERS": "true"}';
 
@@ -169,28 +169,14 @@ SELECT unnest(res) FROM (
     string_split(setting, ', ') AS res
 ) ORDER BY ALL;
 ----
-"ATTACH_LOAD_STORAGE_LATENCY": "true"
-"ATTACH_REPLAY_WAL_LATENCY": "true"
-"BLOCKED_THREAD_TIME": "true"
-"CHECKPOINT_LATENCY": "true"
 "CPU_TIME": "true"
 "CUMULATIVE_CARDINALITY": "true"
 "CUMULATIVE_ROWS_SCANNED": "true"
 "EXTRA_INFO": "true"
 "LATENCY": "true"
-"OPERATOR_CARDINALITY": "true"
-"OPERATOR_NAME": "true"
-"OPERATOR_ROWS_SCANNED": "true"
-"OPERATOR_TIMING": "true"
-"OPERATOR_TYPE": "true"
 "QUERY_NAME": "true"
 "RESULT_SET_SIZE": "true"
 "ROWS_RETURNED": "true"
-"SYSTEM_PEAK_BUFFER_MEMORY": "true"
-"SYSTEM_PEAK_TEMP_DIR_SIZE": "true"
-"TOTAL_BYTES_READ": "true"
-"TOTAL_BYTES_WRITTEN": "true"
-"WAITING_TO_ATTACH_LATENCY": "true"
 
 statement ok
 CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
diff --git a/test/sql/pragma/profiling/test_custom_profiling_using_groups.test b/test/sql/pragma/profiling/test_custom_profiling_using_groups.test
new file mode 100644
index 0000000000..bd7a074d1a
--- /dev/null
+++ b/test/sql/pragma/profiling/test_custom_profiling_using_groups.test
@@ -0,0 +1,791 @@
+# name: test/sql/pragma/profiling/test_custom_profiling_using_groups.test
+# description: Test default profiling settings using groups.
+# group: [profiling]
+
+# This file is automatically generated by scripts/generate_metric_enums.py
+# Do not edit this file manually, your changes will be overwritten
+
+require json
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+PRAGMA custom_profiling_settings='{"ALL": "true"}';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"ALL_OPTIMIZERS": "true"
+"ATTACH_LOAD_STORAGE_LATENCY": "true"
+"ATTACH_REPLAY_WAL_LATENCY": "true"
+"BLOCKED_THREAD_TIME": "true"
+"CHECKPOINT_LATENCY": "true"
+"CPU_TIME": "true"
+"CUMULATIVE_CARDINALITY": "true"
+"CUMULATIVE_OPTIMIZER_TIMING": "true"
+"CUMULATIVE_ROWS_SCANNED": "true"
+"EXTRA_INFO": "true"
+"LATENCY": "true"
+"OPERATOR_CARDINALITY": "true"
+"OPERATOR_NAME": "true"
+"OPERATOR_ROWS_SCANNED": "true"
+"OPERATOR_TIMING": "true"
+"OPERATOR_TYPE": "true"
+"OPTIMIZER_BUILD_SIDE_PROBE_SIDE": "true"
+"OPTIMIZER_COLUMN_LIFETIME": "true"
+"OPTIMIZER_COMMON_AGGREGATE": "true"
+"OPTIMIZER_COMMON_SUBEXPRESSIONS": "true"
+"OPTIMIZER_COMMON_SUBPLAN": "true"
+"OPTIMIZER_COMPRESSED_MATERIALIZATION": "true"
+"OPTIMIZER_CTE_FILTER_PUSHER": "true"
+"OPTIMIZER_CTE_INLINING": "true"
+"OPTIMIZER_DELIMINATOR": "true"
+"OPTIMIZER_DUPLICATE_GROUPS": "true"
+"OPTIMIZER_EMPTY_RESULT_PULLUP": "true"
+"OPTIMIZER_EXPRESSION_REWRITER": "true"
+"OPTIMIZER_EXTENSION": "true"
+"OPTIMIZER_FILTER_PULLUP": "true"
+"OPTIMIZER_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_IN_CLAUSE": "true"
+"OPTIMIZER_JOIN_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_JOIN_ORDER": "true"
+"OPTIMIZER_LATE_MATERIALIZATION": "true"
+"OPTIMIZER_LIMIT_PUSHDOWN": "true"
+"OPTIMIZER_MATERIALIZED_CTE": "true"
+"OPTIMIZER_REGEX_RANGE": "true"
+"OPTIMIZER_REORDER_FILTER": "true"
+"OPTIMIZER_SAMPLING_PUSHDOWN": "true"
+"OPTIMIZER_STATISTICS_PROPAGATION": "true"
+"OPTIMIZER_SUM_REWRITER": "true"
+"OPTIMIZER_TOP_N": "true"
+"OPTIMIZER_TOP_N_WINDOW_ELIMINATION": "true"
+"OPTIMIZER_UNNEST_REWRITER": "true"
+"OPTIMIZER_UNUSED_COLUMNS": "true"
+"PHYSICAL_PLANNER": "true"
+"PHYSICAL_PLANNER_COLUMN_BINDING": "true"
+"PHYSICAL_PLANNER_CREATE_PLAN": "true"
+"PHYSICAL_PLANNER_RESOLVE_TYPES": "true"
+"PLANNER": "true"
+"PLANNER_BINDING": "true"
+"QUERY_NAME": "true"
+"RESULT_SET_SIZE": "true"
+"ROWS_RETURNED": "true"
+"SYSTEM_PEAK_BUFFER_MEMORY": "true"
+"SYSTEM_PEAK_TEMP_DIR_SIZE": "true"
+"TOTAL_BYTES_READ": "true"
+"TOTAL_BYTES_WRITTEN": "true"
+"WAITING_TO_ATTACH_LATENCY": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT ALL_OPTIMIZERS,
+	ATTACH_LOAD_STORAGE_LATENCY,
+	ATTACH_REPLAY_WAL_LATENCY,
+	BLOCKED_THREAD_TIME,
+	CHECKPOINT_LATENCY,
+	CPU_TIME,
+	CUMULATIVE_CARDINALITY,
+	CUMULATIVE_OPTIMIZER_TIMING,
+	CUMULATIVE_ROWS_SCANNED,
+	EXTRA_INFO,
+	LATENCY,
+	OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
+	OPTIMIZER_COLUMN_LIFETIME,
+	OPTIMIZER_COMMON_AGGREGATE,
+	OPTIMIZER_COMMON_SUBEXPRESSIONS,
+	OPTIMIZER_COMMON_SUBPLAN,
+	OPTIMIZER_COMPRESSED_MATERIALIZATION,
+	OPTIMIZER_CTE_FILTER_PUSHER,
+	OPTIMIZER_CTE_INLINING,
+	OPTIMIZER_DELIMINATOR,
+	OPTIMIZER_DUPLICATE_GROUPS,
+	OPTIMIZER_EMPTY_RESULT_PULLUP,
+	OPTIMIZER_EXPRESSION_REWRITER,
+	OPTIMIZER_EXTENSION,
+	OPTIMIZER_FILTER_PULLUP,
+	OPTIMIZER_FILTER_PUSHDOWN,
+	OPTIMIZER_IN_CLAUSE,
+	OPTIMIZER_JOIN_FILTER_PUSHDOWN,
+	OPTIMIZER_JOIN_ORDER,
+	OPTIMIZER_LATE_MATERIALIZATION,
+	OPTIMIZER_LIMIT_PUSHDOWN,
+	OPTIMIZER_MATERIALIZED_CTE,
+	OPTIMIZER_REGEX_RANGE,
+	OPTIMIZER_REORDER_FILTER,
+	OPTIMIZER_SAMPLING_PUSHDOWN,
+	OPTIMIZER_STATISTICS_PROPAGATION,
+	OPTIMIZER_SUM_REWRITER,
+	OPTIMIZER_TOP_N,
+	OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
+	OPTIMIZER_UNNEST_REWRITER,
+	OPTIMIZER_UNUSED_COLUMNS,
+	PHYSICAL_PLANNER,
+	PHYSICAL_PLANNER_COLUMN_BINDING,
+	PHYSICAL_PLANNER_CREATE_PLAN,
+	PHYSICAL_PLANNER_RESOLVE_TYPES,
+	PLANNER,
+	PLANNER_BINDING,
+	QUERY_NAME,
+	RESULT_SET_SIZE,
+	ROWS_RETURNED,
+	SYSTEM_PEAK_BUFFER_MEMORY,
+	SYSTEM_PEAK_TEMP_DIR_SIZE,
+	TOTAL_BYTES_READ,
+	TOTAL_BYTES_WRITTEN,
+	WAITING_TO_ATTACH_LATENCY
+FROM metrics_output;
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+PRAGMA custom_profiling_settings='{"DEFAULT": "true"}';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"CPU_TIME": "true"
+"CUMULATIVE_CARDINALITY": "true"
+"CUMULATIVE_ROWS_SCANNED": "true"
+"EXTRA_INFO": "true"
+"LATENCY": "true"
+"QUERY_NAME": "true"
+"RESULT_SET_SIZE": "true"
+"ROWS_RETURNED": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT CPU_TIME,
+	CUMULATIVE_CARDINALITY,
+	CUMULATIVE_ROWS_SCANNED,
+	EXTRA_INFO,
+	LATENCY,
+	QUERY_NAME,
+	RESULT_SET_SIZE,
+	ROWS_RETURNED
+FROM metrics_output;
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+PRAGMA custom_profiling_settings='{"EXECUTION": "true"}';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"BLOCKED_THREAD_TIME": "true"
+"SYSTEM_PEAK_BUFFER_MEMORY": "true"
+"SYSTEM_PEAK_TEMP_DIR_SIZE": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT BLOCKED_THREAD_TIME,
+	SYSTEM_PEAK_BUFFER_MEMORY,
+	SYSTEM_PEAK_TEMP_DIR_SIZE
+FROM metrics_output;
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+PRAGMA custom_profiling_settings='{"FILE": "true"}';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"ATTACH_LOAD_STORAGE_LATENCY": "true"
+"ATTACH_REPLAY_WAL_LATENCY": "true"
+"CHECKPOINT_LATENCY": "true"
+"TOTAL_BYTES_READ": "true"
+"TOTAL_BYTES_WRITTEN": "true"
+"WAITING_TO_ATTACH_LATENCY": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT ATTACH_LOAD_STORAGE_LATENCY,
+	ATTACH_REPLAY_WAL_LATENCY,
+	CHECKPOINT_LATENCY,
+	TOTAL_BYTES_READ,
+	TOTAL_BYTES_WRITTEN,
+	WAITING_TO_ATTACH_LATENCY
+FROM metrics_output;
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+PRAGMA custom_profiling_settings='{"OPERATOR": "true"}';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"OPERATOR_CARDINALITY": "true"
+"OPERATOR_NAME": "true"
+"OPERATOR_ROWS_SCANNED": "true"
+"OPERATOR_TIMING": "true"
+"OPERATOR_TYPE": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT OPERATOR_CARDINALITY,
+	OPERATOR_NAME,
+	OPERATOR_ROWS_SCANNED,
+	OPERATOR_TIMING,
+	OPERATOR_TYPE
+FROM (
+	SELECT unnest(children, max_depth := 2)
+	FROM metrics_output
+)
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+PRAGMA custom_profiling_settings='{"OPTIMIZER": "true"}';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"OPTIMIZER_BUILD_SIDE_PROBE_SIDE": "true"
+"OPTIMIZER_COLUMN_LIFETIME": "true"
+"OPTIMIZER_COMMON_AGGREGATE": "true"
+"OPTIMIZER_COMMON_SUBEXPRESSIONS": "true"
+"OPTIMIZER_COMMON_SUBPLAN": "true"
+"OPTIMIZER_COMPRESSED_MATERIALIZATION": "true"
+"OPTIMIZER_CTE_FILTER_PUSHER": "true"
+"OPTIMIZER_CTE_INLINING": "true"
+"OPTIMIZER_DELIMINATOR": "true"
+"OPTIMIZER_DUPLICATE_GROUPS": "true"
+"OPTIMIZER_EMPTY_RESULT_PULLUP": "true"
+"OPTIMIZER_EXPRESSION_REWRITER": "true"
+"OPTIMIZER_EXTENSION": "true"
+"OPTIMIZER_FILTER_PULLUP": "true"
+"OPTIMIZER_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_IN_CLAUSE": "true"
+"OPTIMIZER_JOIN_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_JOIN_ORDER": "true"
+"OPTIMIZER_LATE_MATERIALIZATION": "true"
+"OPTIMIZER_LIMIT_PUSHDOWN": "true"
+"OPTIMIZER_MATERIALIZED_CTE": "true"
+"OPTIMIZER_REGEX_RANGE": "true"
+"OPTIMIZER_REORDER_FILTER": "true"
+"OPTIMIZER_SAMPLING_PUSHDOWN": "true"
+"OPTIMIZER_STATISTICS_PROPAGATION": "true"
+"OPTIMIZER_SUM_REWRITER": "true"
+"OPTIMIZER_TOP_N": "true"
+"OPTIMIZER_TOP_N_WINDOW_ELIMINATION": "true"
+"OPTIMIZER_UNNEST_REWRITER": "true"
+"OPTIMIZER_UNUSED_COLUMNS": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
+	OPTIMIZER_COLUMN_LIFETIME,
+	OPTIMIZER_COMMON_AGGREGATE,
+	OPTIMIZER_COMMON_SUBEXPRESSIONS,
+	OPTIMIZER_COMMON_SUBPLAN,
+	OPTIMIZER_COMPRESSED_MATERIALIZATION,
+	OPTIMIZER_CTE_FILTER_PUSHER,
+	OPTIMIZER_CTE_INLINING,
+	OPTIMIZER_DELIMINATOR,
+	OPTIMIZER_DUPLICATE_GROUPS,
+	OPTIMIZER_EMPTY_RESULT_PULLUP,
+	OPTIMIZER_EXPRESSION_REWRITER,
+	OPTIMIZER_EXTENSION,
+	OPTIMIZER_FILTER_PULLUP,
+	OPTIMIZER_FILTER_PUSHDOWN,
+	OPTIMIZER_IN_CLAUSE,
+	OPTIMIZER_JOIN_FILTER_PUSHDOWN,
+	OPTIMIZER_JOIN_ORDER,
+	OPTIMIZER_LATE_MATERIALIZATION,
+	OPTIMIZER_LIMIT_PUSHDOWN,
+	OPTIMIZER_MATERIALIZED_CTE,
+	OPTIMIZER_REGEX_RANGE,
+	OPTIMIZER_REORDER_FILTER,
+	OPTIMIZER_SAMPLING_PUSHDOWN,
+	OPTIMIZER_STATISTICS_PROPAGATION,
+	OPTIMIZER_SUM_REWRITER,
+	OPTIMIZER_TOP_N,
+	OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
+	OPTIMIZER_UNNEST_REWRITER,
+	OPTIMIZER_UNUSED_COLUMNS
+FROM metrics_output;
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+PRAGMA custom_profiling_settings='{"PHASE_TIMING": "true"}';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"ALL_OPTIMIZERS": "true"
+"CUMULATIVE_OPTIMIZER_TIMING": "true"
+"OPTIMIZER_BUILD_SIDE_PROBE_SIDE": "true"
+"OPTIMIZER_COLUMN_LIFETIME": "true"
+"OPTIMIZER_COMMON_AGGREGATE": "true"
+"OPTIMIZER_COMMON_SUBEXPRESSIONS": "true"
+"OPTIMIZER_COMMON_SUBPLAN": "true"
+"OPTIMIZER_COMPRESSED_MATERIALIZATION": "true"
+"OPTIMIZER_CTE_FILTER_PUSHER": "true"
+"OPTIMIZER_CTE_INLINING": "true"
+"OPTIMIZER_DELIMINATOR": "true"
+"OPTIMIZER_DUPLICATE_GROUPS": "true"
+"OPTIMIZER_EMPTY_RESULT_PULLUP": "true"
+"OPTIMIZER_EXPRESSION_REWRITER": "true"
+"OPTIMIZER_EXTENSION": "true"
+"OPTIMIZER_FILTER_PULLUP": "true"
+"OPTIMIZER_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_IN_CLAUSE": "true"
+"OPTIMIZER_JOIN_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_JOIN_ORDER": "true"
+"OPTIMIZER_LATE_MATERIALIZATION": "true"
+"OPTIMIZER_LIMIT_PUSHDOWN": "true"
+"OPTIMIZER_MATERIALIZED_CTE": "true"
+"OPTIMIZER_REGEX_RANGE": "true"
+"OPTIMIZER_REORDER_FILTER": "true"
+"OPTIMIZER_SAMPLING_PUSHDOWN": "true"
+"OPTIMIZER_STATISTICS_PROPAGATION": "true"
+"OPTIMIZER_SUM_REWRITER": "true"
+"OPTIMIZER_TOP_N": "true"
+"OPTIMIZER_TOP_N_WINDOW_ELIMINATION": "true"
+"OPTIMIZER_UNNEST_REWRITER": "true"
+"OPTIMIZER_UNUSED_COLUMNS": "true"
+"PHYSICAL_PLANNER": "true"
+"PHYSICAL_PLANNER_COLUMN_BINDING": "true"
+"PHYSICAL_PLANNER_CREATE_PLAN": "true"
+"PHYSICAL_PLANNER_RESOLVE_TYPES": "true"
+"PLANNER": "true"
+"PLANNER_BINDING": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT ALL_OPTIMIZERS,
+	CUMULATIVE_OPTIMIZER_TIMING,
+	OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
+	OPTIMIZER_COLUMN_LIFETIME,
+	OPTIMIZER_COMMON_AGGREGATE,
+	OPTIMIZER_COMMON_SUBEXPRESSIONS,
+	OPTIMIZER_COMMON_SUBPLAN,
+	OPTIMIZER_COMPRESSED_MATERIALIZATION,
+	OPTIMIZER_CTE_FILTER_PUSHER,
+	OPTIMIZER_CTE_INLINING,
+	OPTIMIZER_DELIMINATOR,
+	OPTIMIZER_DUPLICATE_GROUPS,
+	OPTIMIZER_EMPTY_RESULT_PULLUP,
+	OPTIMIZER_EXPRESSION_REWRITER,
+	OPTIMIZER_EXTENSION,
+	OPTIMIZER_FILTER_PULLUP,
+	OPTIMIZER_FILTER_PUSHDOWN,
+	OPTIMIZER_IN_CLAUSE,
+	OPTIMIZER_JOIN_FILTER_PUSHDOWN,
+	OPTIMIZER_JOIN_ORDER,
+	OPTIMIZER_LATE_MATERIALIZATION,
+	OPTIMIZER_LIMIT_PUSHDOWN,
+	OPTIMIZER_MATERIALIZED_CTE,
+	OPTIMIZER_REGEX_RANGE,
+	OPTIMIZER_REORDER_FILTER,
+	OPTIMIZER_SAMPLING_PUSHDOWN,
+	OPTIMIZER_STATISTICS_PROPAGATION,
+	OPTIMIZER_SUM_REWRITER,
+	OPTIMIZER_TOP_N,
+	OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
+	OPTIMIZER_UNNEST_REWRITER,
+	OPTIMIZER_UNUSED_COLUMNS,
+	PHYSICAL_PLANNER,
+	PHYSICAL_PLANNER_COLUMN_BINDING,
+	PHYSICAL_PLANNER_CREATE_PLAN,
+	PHYSICAL_PLANNER_RESOLVE_TYPES,
+	PLANNER,
+	PLANNER_BINDING
+FROM metrics_output;
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+PRAGMA custom_profiling_settings='{"DEFAULT": "true", "FILE": "true"}';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"ATTACH_LOAD_STORAGE_LATENCY": "true"
+"ATTACH_REPLAY_WAL_LATENCY": "true"
+"CHECKPOINT_LATENCY": "true"
+"CPU_TIME": "true"
+"CUMULATIVE_CARDINALITY": "true"
+"CUMULATIVE_ROWS_SCANNED": "true"
+"EXTRA_INFO": "true"
+"LATENCY": "true"
+"QUERY_NAME": "true"
+"RESULT_SET_SIZE": "true"
+"ROWS_RETURNED": "true"
+"TOTAL_BYTES_READ": "true"
+"TOTAL_BYTES_WRITTEN": "true"
+"WAITING_TO_ATTACH_LATENCY": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT ATTACH_LOAD_STORAGE_LATENCY,
+	ATTACH_REPLAY_WAL_LATENCY,
+	CHECKPOINT_LATENCY,
+	CPU_TIME,
+	CUMULATIVE_CARDINALITY,
+	CUMULATIVE_ROWS_SCANNED,
+	EXTRA_INFO,
+	LATENCY,
+	QUERY_NAME,
+	RESULT_SET_SIZE,
+	ROWS_RETURNED,
+	TOTAL_BYTES_READ,
+	TOTAL_BYTES_WRITTEN,
+	WAITING_TO_ATTACH_LATENCY
+FROM metrics_output;
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+PRAGMA custom_profiling_settings='{"FILE": "true", "OPTIMIZER": "true"}';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"ATTACH_LOAD_STORAGE_LATENCY": "true"
+"ATTACH_REPLAY_WAL_LATENCY": "true"
+"CHECKPOINT_LATENCY": "true"
+"OPTIMIZER_BUILD_SIDE_PROBE_SIDE": "true"
+"OPTIMIZER_COLUMN_LIFETIME": "true"
+"OPTIMIZER_COMMON_AGGREGATE": "true"
+"OPTIMIZER_COMMON_SUBEXPRESSIONS": "true"
+"OPTIMIZER_COMMON_SUBPLAN": "true"
+"OPTIMIZER_COMPRESSED_MATERIALIZATION": "true"
+"OPTIMIZER_CTE_FILTER_PUSHER": "true"
+"OPTIMIZER_CTE_INLINING": "true"
+"OPTIMIZER_DELIMINATOR": "true"
+"OPTIMIZER_DUPLICATE_GROUPS": "true"
+"OPTIMIZER_EMPTY_RESULT_PULLUP": "true"
+"OPTIMIZER_EXPRESSION_REWRITER": "true"
+"OPTIMIZER_EXTENSION": "true"
+"OPTIMIZER_FILTER_PULLUP": "true"
+"OPTIMIZER_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_IN_CLAUSE": "true"
+"OPTIMIZER_JOIN_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_JOIN_ORDER": "true"
+"OPTIMIZER_LATE_MATERIALIZATION": "true"
+"OPTIMIZER_LIMIT_PUSHDOWN": "true"
+"OPTIMIZER_MATERIALIZED_CTE": "true"
+"OPTIMIZER_REGEX_RANGE": "true"
+"OPTIMIZER_REORDER_FILTER": "true"
+"OPTIMIZER_SAMPLING_PUSHDOWN": "true"
+"OPTIMIZER_STATISTICS_PROPAGATION": "true"
+"OPTIMIZER_SUM_REWRITER": "true"
+"OPTIMIZER_TOP_N": "true"
+"OPTIMIZER_TOP_N_WINDOW_ELIMINATION": "true"
+"OPTIMIZER_UNNEST_REWRITER": "true"
+"OPTIMIZER_UNUSED_COLUMNS": "true"
+"TOTAL_BYTES_READ": "true"
+"TOTAL_BYTES_WRITTEN": "true"
+"WAITING_TO_ATTACH_LATENCY": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT ATTACH_LOAD_STORAGE_LATENCY,
+	ATTACH_REPLAY_WAL_LATENCY,
+	CHECKPOINT_LATENCY,
+	OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
+	OPTIMIZER_COLUMN_LIFETIME,
+	OPTIMIZER_COMMON_AGGREGATE,
+	OPTIMIZER_COMMON_SUBEXPRESSIONS,
+	OPTIMIZER_COMMON_SUBPLAN,
+	OPTIMIZER_COMPRESSED_MATERIALIZATION,
+	OPTIMIZER_CTE_FILTER_PUSHER,
+	OPTIMIZER_CTE_INLINING,
+	OPTIMIZER_DELIMINATOR,
+	OPTIMIZER_DUPLICATE_GROUPS,
+	OPTIMIZER_EMPTY_RESULT_PULLUP,
+	OPTIMIZER_EXPRESSION_REWRITER,
+	OPTIMIZER_EXTENSION,
+	OPTIMIZER_FILTER_PULLUP,
+	OPTIMIZER_FILTER_PUSHDOWN,
+	OPTIMIZER_IN_CLAUSE,
+	OPTIMIZER_JOIN_FILTER_PUSHDOWN,
+	OPTIMIZER_JOIN_ORDER,
+	OPTIMIZER_LATE_MATERIALIZATION,
+	OPTIMIZER_LIMIT_PUSHDOWN,
+	OPTIMIZER_MATERIALIZED_CTE,
+	OPTIMIZER_REGEX_RANGE,
+	OPTIMIZER_REORDER_FILTER,
+	OPTIMIZER_SAMPLING_PUSHDOWN,
+	OPTIMIZER_STATISTICS_PROPAGATION,
+	OPTIMIZER_SUM_REWRITER,
+	OPTIMIZER_TOP_N,
+	OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
+	OPTIMIZER_UNNEST_REWRITER,
+	OPTIMIZER_UNUSED_COLUMNS,
+	TOTAL_BYTES_READ,
+	TOTAL_BYTES_WRITTEN,
+	WAITING_TO_ATTACH_LATENCY
+FROM metrics_output;
+
+statement ok
+PRAGMA enable_profiling = 'json';
+
+statement ok
+PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
+
+statement ok
+PRAGMA custom_profiling_settings='{"PHASE_TIMING": "true", "EXECUTION": "true", "FILE": "true"}';
+
+statement ok
+SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
+
+statement ok
+PRAGMA disable_profiling;
+
+query I
+SELECT unnest(res) FROM (
+    SELECT current_setting('custom_profiling_settings') AS raw_setting,
+    raw_setting.trim('{}') AS setting,
+    string_split(setting, ', ') AS res
+) ORDER BY ALL;
+----
+"ALL_OPTIMIZERS": "true"
+"ATTACH_LOAD_STORAGE_LATENCY": "true"
+"ATTACH_REPLAY_WAL_LATENCY": "true"
+"BLOCKED_THREAD_TIME": "true"
+"CHECKPOINT_LATENCY": "true"
+"CUMULATIVE_OPTIMIZER_TIMING": "true"
+"OPTIMIZER_BUILD_SIDE_PROBE_SIDE": "true"
+"OPTIMIZER_COLUMN_LIFETIME": "true"
+"OPTIMIZER_COMMON_AGGREGATE": "true"
+"OPTIMIZER_COMMON_SUBEXPRESSIONS": "true"
+"OPTIMIZER_COMMON_SUBPLAN": "true"
+"OPTIMIZER_COMPRESSED_MATERIALIZATION": "true"
+"OPTIMIZER_CTE_FILTER_PUSHER": "true"
+"OPTIMIZER_CTE_INLINING": "true"
+"OPTIMIZER_DELIMINATOR": "true"
+"OPTIMIZER_DUPLICATE_GROUPS": "true"
+"OPTIMIZER_EMPTY_RESULT_PULLUP": "true"
+"OPTIMIZER_EXPRESSION_REWRITER": "true"
+"OPTIMIZER_EXTENSION": "true"
+"OPTIMIZER_FILTER_PULLUP": "true"
+"OPTIMIZER_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_IN_CLAUSE": "true"
+"OPTIMIZER_JOIN_FILTER_PUSHDOWN": "true"
+"OPTIMIZER_JOIN_ORDER": "true"
+"OPTIMIZER_LATE_MATERIALIZATION": "true"
+"OPTIMIZER_LIMIT_PUSHDOWN": "true"
+"OPTIMIZER_MATERIALIZED_CTE": "true"
+"OPTIMIZER_REGEX_RANGE": "true"
+"OPTIMIZER_REORDER_FILTER": "true"
+"OPTIMIZER_SAMPLING_PUSHDOWN": "true"
+"OPTIMIZER_STATISTICS_PROPAGATION": "true"
+"OPTIMIZER_SUM_REWRITER": "true"
+"OPTIMIZER_TOP_N": "true"
+"OPTIMIZER_TOP_N_WINDOW_ELIMINATION": "true"
+"OPTIMIZER_UNNEST_REWRITER": "true"
+"OPTIMIZER_UNUSED_COLUMNS": "true"
+"PHYSICAL_PLANNER": "true"
+"PHYSICAL_PLANNER_COLUMN_BINDING": "true"
+"PHYSICAL_PLANNER_CREATE_PLAN": "true"
+"PHYSICAL_PLANNER_RESOLVE_TYPES": "true"
+"PLANNER": "true"
+"PLANNER_BINDING": "true"
+"SYSTEM_PEAK_BUFFER_MEMORY": "true"
+"SYSTEM_PEAK_TEMP_DIR_SIZE": "true"
+"TOTAL_BYTES_READ": "true"
+"TOTAL_BYTES_WRITTEN": "true"
+"WAITING_TO_ATTACH_LATENCY": "true"
+
+statement ok
+CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
+
+statement ok
+SELECT ALL_OPTIMIZERS,
+	ATTACH_LOAD_STORAGE_LATENCY,
+	ATTACH_REPLAY_WAL_LATENCY,
+	BLOCKED_THREAD_TIME,
+	CHECKPOINT_LATENCY,
+	CUMULATIVE_OPTIMIZER_TIMING,
+	OPTIMIZER_BUILD_SIDE_PROBE_SIDE,
+	OPTIMIZER_COLUMN_LIFETIME,
+	OPTIMIZER_COMMON_AGGREGATE,
+	OPTIMIZER_COMMON_SUBEXPRESSIONS,
+	OPTIMIZER_COMMON_SUBPLAN,
+	OPTIMIZER_COMPRESSED_MATERIALIZATION,
+	OPTIMIZER_CTE_FILTER_PUSHER,
+	OPTIMIZER_CTE_INLINING,
+	OPTIMIZER_DELIMINATOR,
+	OPTIMIZER_DUPLICATE_GROUPS,
+	OPTIMIZER_EMPTY_RESULT_PULLUP,
+	OPTIMIZER_EXPRESSION_REWRITER,
+	OPTIMIZER_EXTENSION,
+	OPTIMIZER_FILTER_PULLUP,
+	OPTIMIZER_FILTER_PUSHDOWN,
+	OPTIMIZER_IN_CLAUSE,
+	OPTIMIZER_JOIN_FILTER_PUSHDOWN,
+	OPTIMIZER_JOIN_ORDER,
+	OPTIMIZER_LATE_MATERIALIZATION,
+	OPTIMIZER_LIMIT_PUSHDOWN,
+	OPTIMIZER_MATERIALIZED_CTE,
+	OPTIMIZER_REGEX_RANGE,
+	OPTIMIZER_REORDER_FILTER,
+	OPTIMIZER_SAMPLING_PUSHDOWN,
+	OPTIMIZER_STATISTICS_PROPAGATION,
+	OPTIMIZER_SUM_REWRITER,
+	OPTIMIZER_TOP_N,
+	OPTIMIZER_TOP_N_WINDOW_ELIMINATION,
+	OPTIMIZER_UNNEST_REWRITER,
+	OPTIMIZER_UNUSED_COLUMNS,
+	PHYSICAL_PLANNER,
+	PHYSICAL_PLANNER_COLUMN_BINDING,
+	PHYSICAL_PLANNER_CREATE_PLAN,
+	PHYSICAL_PLANNER_RESOLVE_TYPES,
+	PLANNER,
+	PLANNER_BINDING,
+	SYSTEM_PEAK_BUFFER_MEMORY,
+	SYSTEM_PEAK_TEMP_DIR_SIZE,
+	TOTAL_BYTES_READ,
+	TOTAL_BYTES_WRITTEN,
+	WAITING_TO_ATTACH_LATENCY
+FROM metrics_output;
+
diff --git a/test/sql/pragma/profiling/test_default_profiling_settings.test b/test/sql/pragma/profiling/test_default_profiling_settings.test
index 70105c4c78..6c507c915c 100644
--- a/test/sql/pragma/profiling/test_default_profiling_settings.test
+++ b/test/sql/pragma/profiling/test_default_profiling_settings.test
@@ -7,15 +7,15 @@
 
 require json
 
-statement ok
-PRAGMA enable_verification;
-
 statement ok
 PRAGMA enable_profiling = 'json';
 
 statement ok
 PRAGMA profiling_output = '__TEST_DIR__/profiling_output.json';
 
+statement ok
+SET profiling_mode='standard';
+
 statement ok
 SELECT unnest(['Maia', 'Thijs', 'Mark', 'Hannes', 'Tom', 'Max', 'Carlo', 'Sam', 'Tania']) AS names ORDER BY random();
 
@@ -29,28 +29,14 @@ SELECT unnest(res) FROM (
     string_split(setting, ', ') AS res
 ) ORDER BY ALL;
 ----
-"ATTACH_LOAD_STORAGE_LATENCY": "true"
-"ATTACH_REPLAY_WAL_LATENCY": "true"
-"BLOCKED_THREAD_TIME": "true"
-"CHECKPOINT_LATENCY": "true"
 "CPU_TIME": "true"
 "CUMULATIVE_CARDINALITY": "true"
 "CUMULATIVE_ROWS_SCANNED": "true"
 "EXTRA_INFO": "true"
 "LATENCY": "true"
-"OPERATOR_CARDINALITY": "true"
-"OPERATOR_NAME": "true"
-"OPERATOR_ROWS_SCANNED": "true"
-"OPERATOR_TIMING": "true"
-"OPERATOR_TYPE": "true"
 "QUERY_NAME": "true"
 "RESULT_SET_SIZE": "true"
 "ROWS_RETURNED": "true"
-"SYSTEM_PEAK_BUFFER_MEMORY": "true"
-"SYSTEM_PEAK_TEMP_DIR_SIZE": "true"
-"TOTAL_BYTES_READ": "true"
-"TOTAL_BYTES_WRITTEN": "true"
-"WAITING_TO_ATTACH_LATENCY": "true"
 
 statement ok
 CREATE OR REPLACE TABLE metrics_output AS SELECT * FROM '__TEST_DIR__/profiling_output.json';
diff --git a/test/sql/settings/setting_profiling_mode.test b/test/sql/settings/setting_profiling_mode.test
index 72890ef6fb..b5888b5040 100644
--- a/test/sql/settings/setting_profiling_mode.test
+++ b/test/sql/settings/setting_profiling_mode.test
@@ -8,7 +8,10 @@ SET profiling_mode='standard';
 statement ok
 SET profiling_mode='detailed';
 
+statement ok
+SET profiling_mode='all';
+
 statement error
 SET profiling_mode='unknown';
 ----
-<REGEX>:.*Parser Error.*Unrecognized profiling mode.*
\ No newline at end of file
+<REGEX>:.*Parser Error.*Unrecognized profiling mode.*
